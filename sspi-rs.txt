--- File: .github/CODEOWNERS ---
# File auto-generated and managed by Devops
/.github/ @devolutions/devops @devolutions/architecture-maintainers
/.github/dependabot.yml @devolutions/security-managers


--- File: .github/dependabot.yml ---
version: 2
updates:
  - package-ecosystem: "cargo"
    directories:
      - "/"
      - "/fuzz/"
    schedule:
      interval: "weekly"
    assignees:
      - "CBenoit"
    open-pull-requests-limit: 3
    groups:
      crypto:
        patterns:
          - "md-5"
          - "md5"
          - "md4"
          - "sha1"
          - "sha2"
          - "sha3"
          - "pkcs*"
          - "x509-cert"
          - "hmac"
          - "der"
          - "crypto-mac"
          - "*tls*"
          - "*rand*"
          - "picky*"
      windows:
        patterns:
          - "windows*"
          - "winapi"
      patch:
        dependency-type: "production"
        update-types:
          - "patch"
      dev:
        dependency-type: "development"


--- File: .github/workflows/build-native.yml ---
name: Build Native

on:
  workflow_call:

jobs:
  preflight:
    name: Preflight
    runs-on: ubuntu-latest
    outputs:
      project-version: ${{ steps.get-version.outputs.project-version }}
      package-version: ${{ steps.get-version.outputs.package-version }}

    steps:
      - name: Checkout ${{ github.repository }}
        uses: actions/checkout@v4

      - name: Get version
        id: get-version
        shell: pwsh
        run: |
          $CsprojXml = [Xml] (Get-Content .\ffi\dotnet\Devolutions.Sspi\Devolutions.Sspi.csproj)
          $ProjectVersion = $CsprojXml.Project.PropertyGroup.Version | Select-Object -First 1
          $PackageVersion = $ProjectVersion -Replace "^(\d+)\.(\d+)\.(\d+).(\d+)$", "`$1.`$2.`$3"
          echo "project-version=$ProjectVersion" >> $Env:GITHUB_OUTPUT
          echo "package-version=$PackageVersion" >> $Env:GITHUB_OUTPUT

  build-native:
    name: Native build
    runs-on: ${{ matrix.runner }}
    needs: preflight
    strategy:
      fail-fast: false
      matrix:
        os: [ win, osx, linux, ios, android ]
        arch: [ x86, x64, arm, arm64 ]
        build: [ debug, release ]
        include:
          - os: win
            runner: windows-2022
          - os: osx
            runner: macos-14
          - os: linux
            runner: ubuntu-22.04
          - os: ios
            runner: macos-14
          - os: android
            runner: ubuntu-22.04
        exclude:
          - arch: arm
            os: win
          - arch: arm
            os: osx
          - arch: arm
            os: linux
          - arch: arm
            os: ios
          - arch: x86
            os: win
          - arch: x86
            os: osx
          - arch: x86
            os: linux
          - arch: x86
            os: ios

    steps:
      - name: Checkout ${{ github.repository }}
        uses: actions/checkout@v4

      - name: Configure Android NDK
        uses: Devolutions/actions-public/cargo-android-ndk@v1
        if: matrix.os == 'android'
        with:
          android_api_level: "21"

      - name: Install dependencies for rustls
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          choco install ninja nasm

          # We need to add the NASM binary folder to the PATH manually.
          # We don’t need to do that for ninja.
          Write-Output "PATH=$Env:PATH;$Env:ProgramFiles\NASM" >> $Env:GITHUB_ENV

          # libclang / LLVM is a requirement for AWS LC.
          # https://aws.github.io/aws-lc-rs/requirements/windows.html#libclang--llvm
          $VSINSTALLDIR = $(vswhere.exe -latest -requires Microsoft.VisualStudio.Component.VC.Llvm.Clang -property installationPath)
          Write-Output "LIBCLANG_PATH=$VSINSTALLDIR\VC\Tools\Llvm\x64\bin" >> $Env:GITHUB_ENV

          # Install Visual Studio Developer PowerShell Module for cmdlets such as Enter-VsDevShell
          Install-Module VsDevShell -Force

      - name: Install dependencies
        if: matrix.os == 'ios'
        run: cargo install --force --locked bindgen-cli

      - name: Setup build environment
        shell: pwsh
        run: |
          if ('${{ matrix.os }}' -Eq 'osx') {
            echo "MACOSX_DEPLOYMENT_TARGET=10.10" | Out-File -FilePath $Env:GITHUB_ENV -Encoding utf8 -Append
          } elseif ('${{ matrix.os }}' -Eq 'ios') {
            echo "IPHONEOS_DEPLOYMENT_TARGET=12.1" | Out-File -FilePath $Env:GITHUB_ENV -Encoding utf8 -Append
          }

      - name: Setup LLVM
        uses: Devolutions/actions-public/setup-llvm@v1
        if: matrix.os == 'linux'
        with:
          version: "18.1.8"

      - name: Setup CBake
        uses: Devolutions/actions-public/setup-cbake@v1
        if: matrix.os == 'linux'
        with:
          sysroots: |
            - ubuntu-20.04-amd64
            - ubuntu-20.04-arm64
          cargo_env_scripts: true

      - name: Build sspi (${{matrix.os}}-${{matrix.arch}}) (${{matrix.build}})
        shell: pwsh
        run: |
          Set-PSDebug -Trace 1

          $BuildType = '${{matrix.build}}'
          $DotNetOs = '${{matrix.os}}'
          $DotNetArch = '${{matrix.arch}}'
          $DotNetRid = '${{matrix.os}}-${{matrix.arch}}'
          $RustArch = @{'x64'='x86_64';'arm64'='aarch64';
            'x86'='i686';'arm'='armv7'}[$DotNetArch]
          $AppleArch = @{'x64'='x86_64';'arm64'='arm64';
            'x86'='i386';'arm'='arm'}[$DotNetArch]
          $MsvcArch = @{'x64'='x64';'arm64'='arm64'}[$DotNetArch]
          $RustPlatform = @{'win'='pc-windows-msvc';
            'osx'='apple-darwin';'ios'='apple-ios';
            'linux'='unknown-linux-gnu';'android'='linux-android'}[$DotNetOs]
          $LibPrefix = @{'win'='';'osx'='lib';'ios'='lib';
            'linux'='lib';'android'='lib'}[$DotNetOs]
          $LibSuffix = @{'win'='.dll';'osx'='.dylib';'ios'='.dylib';
            'linux'='.so';'android'='.so'}[$DotNetOs]
          $RustTarget = "$RustArch-$RustPlatform"

          if (($DotNetOs -eq 'android') -and ($DotNetArch -eq 'arm')) {
            $RustTarget = "armv7-linux-androideabi"
          }

          if ($DotNetOs -eq 'osx') {
            Set-Item "Env:CFLAGS_${RustArch}-apple-darwin" "-arch $AppleArch"
          }

          rustup target add $RustTarget

          if ($DotNetOs -eq 'win') {
            Enter-VsDevShell $MsvcArch
            $Env:RUSTFLAGS="-C target-feature=+crt-static"
          }

          $ProjectVersion = '${{ needs.preflight.outputs.project-version }}'
          $PackageVersion = '${{ needs.preflight.outputs.package-version }}'

          $CargoToml = Get-Content .\ffi\Cargo.toml
          $CargoToml = $CargoToml | ForEach-Object {
            if ($_.StartsWith("version =")) { "version = `"$PackageVersion`"" } else { $_ }
          }
          Set-Content -Path .\ffi\Cargo.toml -Value $CargoToml

          $CargoArgs = @('build', '-vvv', '-p', 'sspi-ffi', '--target', $RustTarget)

          if (-Not ($BuildType -Eq 'debug')) {
            $CargoArgs += @('--release')
          }

          if ($DotNetOs -Eq 'win') {
            $CargoArgs += @('--features', 'tsssp')
          }

          # No pregenerated Android bindings are provided for aws-lc-sys at this time.
          # See: https://github.com/aws/aws-lc-rs/tree/main/aws-lc-sys#pregenerated-bindings-availability
          # For simplicity, we’re using the ring crypto backend.
          if ($DotNetOs -Eq 'android') {
            $CargoArgs += @('--no-default-features', '--features', 'scard,ring')
          }

          if ($DotNetOs -eq 'linux') {
            $LinuxArch = @{'x64'='amd64';'arm64'='arm64'}[$DotNetArch]
            $Env:SYSROOT_NAME = "ubuntu-20.04-$LinuxArch"
            . "$HOME/.cargo/cbake/${RustTarget}-enter.ps1"
            $Env:AWS_LC_SYS_CMAKE_BUILDER="true"
          }

          $CargoCmd = $(@('cargo') + $CargoArgs) -Join ' '
          Write-Host $CargoCmd
          & cargo $CargoArgs | Out-Host
        
          $OutputLibraryName = "${LibPrefix}sspi$LibSuffix"
          $RenamedLibraryName = "${LibPrefix}DevolutionsSspi$LibSuffix"

          $OutputLibrary = Join-Path "target" $RustTarget $BuildType $OutputLibraryName
          $OutputPath = Join-Path "dependencies" "runtimes" $DotNetRid "native"

          New-Item -ItemType Directory -Path $OutputPath | Out-Null
          Copy-Item $OutputLibrary $(Join-Path $OutputPath $RenamedLibraryName)

      - name: Upload native components
        uses: actions/upload-artifact@v4
        with:
          name: sspi-${{matrix.os}}-${{matrix.arch}}-${{matrix.build}}
          path: dependencies/runtimes/${{matrix.os}}-${{matrix.arch}}

  build-universal:
    name: Universal Build
    runs-on: ubuntu-24.04
    needs: [preflight, build-native]
    strategy:
      fail-fast: false
      matrix:
        os: [ osx, ios ]
        build: [ debug, release ]

    steps:
      - name: Checkout ${{ github.repository }}
        uses: actions/checkout@v4

      - name: Setup CCTools
        uses: Devolutions/actions-public/setup-cctools@v1

      - name: Download native components
        uses: actions/download-artifact@v4
        with:
          path: dependencies/runtimes

      - name: Lipo (${{matrix.build}})
        shell: pwsh
        run: |
          Set-Location "dependencies/runtimes"
          # No RID for universal binaries, see: https://github.com/dotnet/runtime/issues/53156
          $OutputPath = Join-Path "${{ matrix.os }}-universal" "native"
          New-Item -ItemType Directory -Path $OutputPath | Out-Null
          $Libraries = Get-ChildItem -Recurse -Path "sspi-${{ matrix.os }}-*-${{ matrix.build }}" -Filter "*.dylib" | Foreach-Object { $_.FullName } | Select -Unique
          $LipoCmd = $(@('lipo', '-create', '-output', (Join-Path -Path $OutputPath -ChildPath "libDevolutionsSspi.dylib")) + $Libraries) -Join ' '
          Write-Host $LipoCmd
          Invoke-Expression $LipoCmd

      - name: Framework (${{matrix.build}})
        shell: pwsh
        if: ${{ matrix.os == 'ios' }}
        run: |
          $Version = '${{ needs.preflight.outputs.project-version }}'
          $ShortVersion = '${{ needs.preflight.outputs.package-version }}'
          $BundleName = "libDevolutionsSspi"
          $RuntimesDir = Join-Path "dependencies" "runtimes" "ios-universal" "native"
          $FrameworkDir = Join-Path "$RuntimesDir" "$BundleName.framework"
          New-Item -Path $FrameworkDir -ItemType "directory" -Force
          $FrameworkExecutable = Join-Path $FrameworkDir $BundleName
          Copy-Item -Path (Join-Path "$RuntimesDir" "$BundleName.dylib") -Destination $FrameworkExecutable -Force

          $RPathCmd = $(@('install_name_tool', '-id', "@rpath/$BundleName.framework/$BundleName", "$FrameworkExecutable")) -Join ' '
          Write-Host $RPathCmd
          Invoke-Expression $RPathCmd

          [xml] $InfoPlistXml = Get-Content "Info.plist"
          Select-Xml -xml $InfoPlistXml -XPath "/plist/dict/key[. = 'CFBundleIdentifier']/following-sibling::string[1]" |
          %{ 	
          $_.Node.InnerXml = "com.devolutions.sspi"
          }
          Select-Xml -xml $InfoPlistXml -XPath "/plist/dict/key[. = 'CFBundleExecutable']/following-sibling::string[1]" |
          %{ 	
          $_.Node.InnerXml = $BundleName
          }
          Select-Xml -xml $InfoPlistXml -XPath "/plist/dict/key[. = 'CFBundleVersion']/following-sibling::string[1]" |
          %{ 	
          $_.Node.InnerXml = $Version
          }
          Select-Xml -xml $InfoPlistXml -XPath "/plist/dict/key[. = 'CFBundleShortVersionString']/following-sibling::string[1]" |
          %{ 	
          $_.Node.InnerXml = $ShortVersion
          }

          # Write the plist *without* a BOM
          $Encoding = New-Object System.Text.UTF8Encoding($false)
          $Writer = New-Object System.IO.StreamWriter((Join-Path $FrameworkDir "Info.plist"), $false, $Encoding)
          $InfoPlistXml.Save($Writer)
          $Writer.Close()

          # .NET XML document inserts two square brackets at the end of the DOCTYPE tag
          # It's perfectly valid XML, but we're dealing with plists here and dyld will not be able to read the file
          ((Get-Content -Path (Join-Path $FrameworkDir "Info.plist") -Raw) -Replace 'PropertyList-1.0.dtd"\[\]', 'PropertyList-1.0.dtd"') | Set-Content -Path (Join-Path $FrameworkDir "Info.plist")

      - name: Upload native components
        uses: actions/upload-artifact@v4
        with:
          name: sspi-${{ matrix.os }}-universal-${{ matrix.build }}
          path: dependencies/runtimes/${{ matrix.os }}-universal


--- File: .github/workflows/ci.yml ---
name: CI

on:
  push:
    branches:
      - master
  pull_request:
    types: [ opened, synchronize, reopened ]
  workflow_dispatch:

jobs:
  formatting:
    name: Check formatting
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Check formatting
        shell: pwsh
        run: |
          Write-Host "Check formatting"
          cargo fmt --all -- --check
          if ($LastExitCode -eq 1) {   
            throw "Bad formatting, please run 'cargo +stable fmt --all'"
          }

  lints:
    name: Lints [${{ matrix.os }}]
    runs-on: ${{ matrix.runner }}
    needs: formatting
    strategy:
      fail-fast: true
      matrix:
        os: [ win, osx, linux ]
        include:
          - os: win
            runner: windows-2022
            additional-args: --features tsssp
          - os: osx
            runner: macos-14
          - os: linux
            runner: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      # Compiling the ffi module is enough to lint the whole sspi workspace
      - name: Check clippy
        env:
          AWS_LC_SYS_NO_ASM: true
        run: cargo clippy --manifest-path ffi/Cargo.toml ${{ matrix.additional-args }} -- -D warnings -D clippy::print_stdout

  tests:
    name: Tests [${{ matrix.os }}] [${{ matrix.crate-name }}]
    runs-on: ${{ matrix.runner }}
    needs: formatting
    env:
      SSPI_RS_IS_RUNNING_TESTS: true
    strategy:
      fail-fast: true
      matrix:
        os: [ win, osx, linux ]
        manifest: [ Cargo.toml, ffi/Cargo.toml ]
        include:
          - manifest: Cargo.toml
            crate-name: sspi
          - manifest: ffi/Cargo.toml
            crate-name: sspi-ffi

          - os: win
            runner: windows-2022
          - os: osx
            runner: macos-14
          - os: linux
            runner: ubuntu-latest

          - os: win
            manifest: Cargo.toml
            additional-args: --features network_client,dns_resolver,scard,tsssp
          - os: osx
            manifest: Cargo.toml
            additional-args: --features network_client,scard
          - os: linux
            manifest: Cargo.toml
            additional-args: --features network_client,dns_resolver,scard

          - os: win
            manifest: ffi/Cargo.toml
            additional-args: --features tsssp

    steps:
      - uses: actions/checkout@v4

      - name: Test
        env:
          AWS_LC_SYS_NO_ASM: true
        run: cargo test --manifest-path ${{ matrix.manifest }} ${{ matrix.additional-args }}

  miri:
    name: Miri FFI tests
    runs-on: ubuntu-latest
    needs: formatting
    env:
      SSPI_RS_IS_RUNNING_TESTS: true

    steps:
      - uses: actions/checkout@v4

      - name: Install nightly toolchain and Miri
        run: |
          rustup toolchain install nightly --component miri
          rustup override set nightly

      - name: Test
        run: cargo miri test --manifest-path ffi/Cargo.toml --no-default-features --features ring

  wasm:
    name: WASM target
    runs-on: ubuntu-latest
    needs: formatting

    steps:
      - uses: actions/checkout@v4

      - name: Prepare runner
        run: sudo apt-get install wabt

      - name: Check
        shell: pwsh
        run: ./tools/wasm-testcompile/check.ps1

  build-native:
    name: Build native
    needs: formatting
    uses: ./.github/workflows/build-native.yml

  success:
    name: Success
    runs-on: ubuntu-latest
    if: ${{ always() }}
    needs:
      - formatting
      - lints
      - tests
      - miri
      - wasm
      - build-native

    steps:
      - name: CI succeeded
        id: succeeded
        if: ${{ !contains(needs.*.result, 'failure') }}
        run: exit 0

      - name: CI failed
        if: ${{ steps.succeeded.outcome == 'skipped' }}
        run: exit 1


--- File: .github/workflows/nuget.yml ---
name: Publish NuGet package

on:
  workflow_dispatch:
    inputs:
      dry-run:
        description: 'Dry run'
        required: true
        type: boolean
        default: true
  schedule:
    - cron: '21 3 * * 1' # 3:21 AM UTC every Monday

jobs:
  preflight:
    name: Preflight
    runs-on: ubuntu-latest
    outputs:
      dry-run: ${{ steps.get-dry-run.outputs.dry-run }}

    steps:
      - name: Get dry run
        id: get-dry-run
        shell: pwsh
        run: |
          Set-PSDebug -Trace 1

          $IsDryRun = '${{ github.event.inputs.dry-run }}' -Eq 'true' -Or '${{ github.event_name }}' -Eq 'schedule'

          if ($IsDryRun) {
            echo "dry-run=true" >> $Env:GITHUB_OUTPUT
          } else {
            echo "dry-run=false" >> $Env:GITHUB_OUTPUT
          }

  build-native:
    uses: ./.github/workflows/build-native.yml

  build-managed:
    name: Managed build
    runs-on: windows-2022
    needs: [build-native]

    steps:
      - name: Check out ${{ github.repository }}
        uses: actions/checkout@v4

      - name: Prepare dependencies
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Path "dependencies/runtimes" | Out-Null

      - name: Download native components
        uses: actions/download-artifact@v4
        with:
          path: dependencies/runtimes

      - name: Rename dependencies
        shell: pwsh
        run: |
          Set-PSDebug -Trace 1

          Set-Location "dependencies/runtimes"

          $(Get-Item ".\sspi-*-release") | ForEach-Object { Rename-Item $_ $_.Name.Replace("-release", "") }
          $(Get-Item ".\sspi-*") | ForEach-Object { Rename-Item $_ $_.Name.Replace("sspi-", "") }
          Get-ChildItem * -Recurse

      - name: Build sspi (managed)
        shell: pwsh
        run: |
          dotnet build .\ffi\dotnet\Devolutions.Sspi.sln -o package

      - name: Upload managed components
        uses: actions/upload-artifact@v4
        with:
          name: sspi-nupkg
          path: package/*.nupkg

  publish:
    name: Publish NuGet package
    runs-on: ubuntu-latest
    environment: nuget-publish
    if: needs.preflight.outputs.dry-run == 'false'
    needs:
      - preflight
      - build-managed

    steps:
      - name: Download NuGet package artifact
        uses: actions/download-artifact@v4
        with:
          name: sspi-nupkg
          path: package

      - name: Publish to nuget.org
        shell: pwsh
        run: |
          Set-PSDebug -Trace 1

          $Files = Get-ChildItem -Recurse package/*.nupkg
    
          foreach ($File in $Files) {
            $PushCmd = @(
              'dotnet', 
              'nuget', 
              'push', 
              "$File",
              '--api-key',
              '${{ secrets.NUGET_API_KEY }}',
              '--source',
              'https://api.nuget.org/v3/index.json',
              '--skip-duplicate'
            )

            Write-Host "Publishing $($File.Name)..."
            $PushCmd = $PushCmd -Join ' '
            Invoke-Expression $PushCmd
          }

  notify:
    name: Notify failure
    runs-on: ubuntu-latest
    if: ${{ always() && contains(needs.*.result, 'failure') && github.event_name == 'schedule' }}
    needs:
      - preflight
      - build-native
      - build-managed
    env:
      SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_ARCHITECTURE }}
      SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK
    steps:
      - name: Send slack notification
        id: slack
        uses: slackapi/slack-github-action@v1.26.0
        with:
          payload: |
            {
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*${{ github.repository }}* :fire::fire::fire::fire::fire: \n The scheduled build for *${{ github.repository }}* is <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|broken>"
                  }
                }
              ]
            }

--- File: .github/workflows/release-crates.yml ---
name: Release crates

permissions:
  pull-requests: write
  contents: write

on:
  workflow_dispatch:
  push:
    branches:
      - master

jobs:
  # Create a PR with the new versions and changelog, preparing the next release.
  open-pr:
    name: Open release PR
    runs-on: ubuntu-latest
    environment: cratesio-publish

    concurrency:
      group: release-plz-${{ github.ref }}
      cancel-in-progress: false

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 512

      - name: Run release-plz
        id: release-plz
        uses: Devolutions/actions-public/release-plz@v1
        with:
          command: release-pr
          git-name: Devolutions Bot
          git-email: bot@devolutions.net
          github-token: ${{ secrets.DEVOLUTIONSBOT_WRITE_TOKEN }}

  # Release unpublished packages.
  release:
    name: Release crates
    runs-on: ubuntu-latest
    environment: cratesio-publish

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 512

      - name: Run release-plz
        uses: Devolutions/actions-public/release-plz@v1
        with:
          command: release
          registry-token: ${{ secrets.CRATES_IO_TOKEN }}


--- File: .gitignore ---
## Ignore Visual Studio temporary files, build results, and
## files generated by popular Visual Studio add-ons.
##
## Get latest from https://github.com/github/gitignore/blob/main/VisualStudio.gitignore

# User-specific files
*.rsuser
*.suo
*.user
*.userosscache
*.sln.docstates

# User-specific files (MonoDevelop/Xamarin Studio)
*.userprefs

# Mono auto generated files
mono_crash.*

# Build results
[Dd]ebug/
[Dd]ebugPublic/
[Rr]elease/
[Rr]eleases/
x64/
x86/
[Ww][Ii][Nn]32/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
bld/
[Bb]in/
[Oo]bj/
[Ll]og/
[Ll]ogs/

# Visual Studio 2015/2017 cache/options directory
.vs/
# Uncomment if you have tasks that create the project's static files in wwwroot
#wwwroot/

# Visual Studio 2017 auto generated files
Generated\ Files/

# MSTest test Results
[Tt]est[Rr]esult*/
[Bb]uild[Ll]og.*

# NUnit
*.VisualState.xml
TestResult.xml
nunit-*.xml

# Build Results of an ATL Project
[Dd]ebugPS/
[Rr]eleasePS/
dlldata.c

# Benchmark Results
BenchmarkDotNet.Artifacts/

# .NET Core
project.lock.json
project.fragment.lock.json
artifacts/

# ASP.NET Scaffolding
ScaffoldingReadMe.txt

# StyleCop
StyleCopReport.xml

# Files built by Visual Studio
*_i.c
*_p.c
*_h.h
*.ilk
*.meta
*.obj
*.iobj
*.pch
*.pdb
*.ipdb
*.pgc
*.pgd
*.rsp
*.sbr
*.tlb
*.tli
*.tlh
*.tmp
*.tmp_proj
*_wpftmp.csproj
*.log
*.tlog
*.vspscc
*.vssscc
.builds
*.pidb
*.svclog
*.scc

# Chutzpah Test files
_Chutzpah*

# Visual C++ cache files
ipch/
*.aps
*.ncb
*.opendb
*.opensdf
*.sdf
*.cachefile
*.VC.db
*.VC.VC.opendb

# Visual Studio profiler
*.psess
*.vsp
*.vspx
*.sap

# Visual Studio Trace Files
*.e2e

# TFS 2012 Local Workspace
$tf/

# Guidance Automation Toolkit
*.gpState

# ReSharper is a .NET coding add-in
_ReSharper*/
*.[Rr]e[Ss]harper
*.DotSettings.user

# TeamCity is a build add-in
_TeamCity*

# DotCover is a Code Coverage Tool
*.dotCover

# AxoCover is a Code Coverage Tool
.axoCover/*
!.axoCover/settings.json

# Coverlet is a free, cross platform Code Coverage Tool
coverage*.json
coverage*.xml
coverage*.info

# Visual Studio code coverage results
*.coverage
*.coveragexml

# NCrunch
_NCrunch_*
.*crunch*.local.xml
nCrunchTemp_*

# MightyMoose
*.mm.*
AutoTest.Net/

# Web workbench (sass)
.sass-cache/

# Installshield output folder
[Ee]xpress/

# DocProject is a documentation generator add-in
DocProject/buildhelp/
DocProject/Help/*.HxT
DocProject/Help/*.HxC
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/Html2
DocProject/Help/html

# Click-Once directory
publish/

# Publish Web Output
*.[Pp]ublish.xml
*.azurePubxml
# Note: Comment the next line if you want to checkin your web deploy settings,
# but database connection strings (with potential passwords) will be unencrypted
*.pubxml
*.publishproj

# Microsoft Azure Web App publish settings. Comment the next line if you want to
# checkin your Azure Web App publish settings, but sensitive information contained
# in these scripts will be unencrypted
PublishScripts/

# NuGet Packages
*.nupkg
# NuGet Symbol Packages
*.snupkg
# The packages folder can be ignored because of Package Restore
**/[Pp]ackages/*
# except build/, which is used as an MSBuild target.
!**/[Pp]ackages/build/
# Uncomment if necessary however generally it will be regenerated when needed
#!**/[Pp]ackages/repositories.config
# NuGet v3's project.json files produces more ignorable files
*.nuget.props
*.nuget.targets

# Microsoft Azure Build Output
csx/
*.build.csdef

# Microsoft Azure Emulator
ecf/
rcf/

# Windows Store app package directories and files
AppPackages/
BundleArtifacts/
Package.StoreAssociation.xml
_pkginfo.txt
*.appx
*.appxbundle
*.appxupload

# Visual Studio cache files
# files ending in .cache can be ignored
*.[Cc]ache
# but keep track of directories ending in .cache
!?*.[Cc]ache/

# Others
ClientBin/
~$*
*~
*.dbmdl
*.dbproj.schemaview
*.jfm
*.pfx
*.publishsettings
orleans.codegen.cs

# Including strong name files can present a security risk
# (https://github.com/github/gitignore/pull/2483#issue-259490424)
#*.snk

# Since there are multiple workflows, uncomment next line to ignore bower_components
# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)
#bower_components/

# RIA/Silverlight projects
Generated_Code/

# Backup & report files from converting an old project file
# to a newer Visual Studio version. Backup files are not needed,
# because we have git ;-)
_UpgradeReport_Files/
Backup*/
UpgradeLog*.XML
UpgradeLog*.htm
ServiceFabricBackup/
*.rptproj.bak

# SQL Server files
*.mdf
*.ldf
*.ndf

# Business Intelligence projects
*.rdl.data
*.bim.layout
*.bim_*.settings
*.rptproj.rsuser
*- [Bb]ackup.rdl
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl

# Microsoft Fakes
FakesAssemblies/

# GhostDoc plugin setting file
*.GhostDoc.xml

# Node.js Tools for Visual Studio
.ntvs_analysis.dat
node_modules/

# Visual Studio 6 build log
*.plg

# Visual Studio 6 workspace options file
*.opt

# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)
*.vbw

# Visual Studio 6 auto-generated project file (contains which files were open etc.)
*.vbp

# Visual Studio 6 workspace and project file (working project files containing files to include in project)
*.dsw
*.dsp

# Visual Studio 6 technical files
*.ncb
*.aps

# Visual Studio LightSwitch build output
**/*.HTMLClient/GeneratedArtifacts
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
_Pvt_Extensions

# Paket dependency manager
.paket/paket.exe
paket-files/

# FAKE - F# Make
.fake/

# CodeRush personal settings
.cr/personal

# Python Tools for Visual Studio (PTVS)
__pycache__/
*.pyc

# Cake - Uncomment if you are using it
# tools/**
# !tools/packages.config

# Tabs Studio
*.tss

# Telerik's JustMock configuration file
*.jmconfig

# BizTalk build output
*.btp.cs
*.btm.cs
*.odx.cs
*.xsd.cs

# OpenCover UI analysis results
OpenCover/

# Azure Stream Analytics local run output
ASALocalRun/

# MSBuild Binary and Structured Log
*.binlog

# NVidia Nsight GPU debugger configuration file
*.nvuser

# MFractors (Xamarin productivity tool) working folder
.mfractor/

# Local History for Visual Studio
.localhistory/

# Visual Studio History (VSHistory) files
.vshistory/

# BeatPulse healthcheck temp database
healthchecksdb

# Backup folder for Package Reference Convert tool in Visual Studio 2017
MigrationBackup/

# Ionide (cross platform F# VS Code tools) working folder
.ionide/

# Fody - auto-generated XML schema
FodyWeavers.xsd

# VS Code files for those working on multiple tools
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
*.code-workspace

# Local History for Visual Studio Code
.history/

# Windows Installer files from build outputs
*.cab
*.msi
*.msix
*.msm
*.msp

# JetBrains Rider
*.sln.iml

Properties/

target
**/*.rs.bk
.idea/
.DS_Store

--- File: CHANGELOG.md ---
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).


## [[0.16.1](https://github.com/Devolutions/sspi-rs/compare/sspi-v0.16.0...sspi-v0.16.1)] - 2025-08-19

### <!-- 1 -->Features

- Add method to set the channel bindings for a session (#479) ([0c0e225fe7](https://github.com/Devolutions/sspi-rs/commit/0c0e225fe7d7ddffc18ad0176deba207edaf3524)) 

  Setting and sending the CBs is described in Sec. 3.1.5.2.1 of the NTLM spec, admittedly in a slightly confusing way, which may seem to suggest that the bindings are somehow part of the CHALLENGE message, but they are not: knowledge of CBs is strictly local to the client, therefore the client should send them in AUTHENTICATE.

## [[0.16.0](https://github.com/Devolutions/sspi-rs/compare/sspi-v0.15.14...sspi-v0.16.0)] - 2025-07-07

### <!-- 1 -->Features

- Server-side Kerberos implementation (#440) ([943a297edd](https://github.com/Devolutions/sspi-rs/commit/943a297eddad91bf6dfa02bdb53b422453df0ed9)) 

### <!-- 4 -->Bug Fixes

- Server-side Kerberos fixes (#457) ([27ce28dad5](https://github.com/Devolutions/sspi-rs/commit/27ce28dad5aa490d094b4ea1db5a315ea1478264)) 

- Kerberos server MIC token generation and validation (#464) ([12fbd706a8](https://github.com/Devolutions/sspi-rs/commit/12fbd706a8e807b4e4ea9b6bb39f4bace60afd9a)) 

- Kerberos server WRAP token generation and validation (#463) ([4bbe4071c8](https://github.com/Devolutions/sspi-rs/commit/4bbe4071c80172ee2c85552ef1060a65394a45c0)) 

## [[0.15.14](https://github.com/Devolutions/sspi-rs/compare/sspi-v0.15.13...sspi-v0.15.14)] - 2025-07-01

### <!-- 7 -->Build

- Update picky-krb to 0.11 (#460) ([5157bee02b](https://github.com/Devolutions/sspi-rs/commit/5157bee02b0383571c726801bda15f0dd9dc7934)) 



## [[0.15.13](https://github.com/Devolutions/sspi-rs/compare/sspi-v0.15.12...sspi-v0.15.13)] - 2025-06-23

### <!-- 7 -->Build

- Bump windows-sys from 0.59.0 to 0.60.2 in the windows group across 1 directory (#455) ([5744c8b4b3](https://github.com/Devolutions/sspi-rs/commit/5744c8b4b3aa5a47a2a25e9375434333de769002)) 

## [[0.15.12](https://github.com/Devolutions/sspi-rs/compare/sspi-v0.15.11...sspi-v0.15.12)] - 2025-06-20

### <!-- 4 -->Bug Fixes

- Invalid Kerberos token DER encoding (#453) ([0ec3e687dd](https://github.com/Devolutions/sspi-rs/commit/0ec3e687dd28ff95910c79b4781d538cbffb9a80)) 

  The default behavior of serializing a KrbMessage<T> was accidentally changed.

## [[0.15.11](https://github.com/Devolutions/sspi-rs/compare/sspi-v0.15.10...sspi-v0.15.11)] - 2025-06-11

### <!-- 4 -->Bug Fixes

- Negotiate attempts KDC detection even when Kerberos is disabled (#447) ([c56132c3f8](https://github.com/Devolutions/sspi-rs/commit/c56132c3f8d3b7e957e64577109158511ee3f4b8)) 

## [[0.15.10](https://github.com/Devolutions/sspi-rs/compare/sspi-v0.15.9...sspi-v0.15.10)] - 2025-06-10

### <!-- 7 -->Build

- Update picky-krb to 0.10 (#448) ([b8b983d7ae](https://github.com/Devolutions/sspi-rs/commit/b8b983d7aecb8e1c84037d157c2b932668e069b1)) 

## [[0.15.9](https://github.com/Devolutions/sspi-rs/compare/sspi-v0.15.8...sspi-v0.15.9)] - 2025-06-05

### <!-- 7 -->Build

- Bump windows-registry from 0.4.0 to 0.5.2 in the windows group across 1 directory (#444) ([9a349f7bdc](https://github.com/Devolutions/sspi-rs/commit/9a349f7bdcfe33658af27420af3dd38a88d773ab)) 

## [[0.15.8](https://github.com/Devolutions/sspi-rs/compare/sspi-v0.15.7...sspi-v0.15.8)] - 2025-06-05

### Build

- Migrate from `winreg` to `windows-registry` crate (#441) ([8631235c8a](https://github.com/Devolutions/sspi-rs/commit/8631235c8a3f93e6f4573142101a25210adb49a5)) 



## [[0.15.7](https://github.com/Devolutions/sspi-rs/compare/sspi-v0.15.6...sspi-v0.15.7)] - 2025-05-29

### <!-- 4 -->Bug Fixes

- Do not log at info-level return values (#438) ([68d02e410d](https://github.com/Devolutions/sspi-rs/commit/68d02e410dadf0278ed2a109117c71c43920ea4f)) 

## [[0.15.6](https://github.com/Devolutions/sspi-rs/compare/sspi-v0.15.5...sspi-v0.15.6)] - 2025-05-27

### <!-- 4 -->Bug Fixes

- Lower info-level logs to debug-level (#436) ([665cb1e1dc](https://github.com/Devolutions/sspi-rs/commit/665cb1e1dc148683779e65f66d1408ddaa911bea)) 

## [[0.15.5](https://github.com/Devolutions/sspi-rs/compare/sspi-v0.15.4...sspi-v0.15.5)] - 2025-04-25

### <!-- 1 -->Features

- Add `query_context_session_key` (#417) ([862657a57c](https://github.com/Devolutions/sspi-rs/commit/862657a57c781e348ef5ccafe540511b19148b44)) 

  This addition is an implementation for the SSP API
  `QueryContextAttributesEx(SECPKG_ATTR_SESSION_KEY)`. It is required for
  protocols such as SMB, and adding it to the `Sspi` trait, enables access
  to it across all the SSP packages implemented.
  
  This adds the option for using Kerberos and Negotiate session keys.

## [[0.15.4](https://github.com/Devolutions/sspi-rs/compare/sspi-v0.15.3...sspi-v0.15.4)] - 2025-03-24

### <!-- 7 -->Build

- Update dependencies

## [[0.15.3](https://github.com/Devolutions/sspi-rs/compare/sspi-v0.15.2...sspi-v0.15.3)] - 2025-03-12

### <!-- 4 -->Bug Fixes

- Set correct seq number in MIC token (#390) ([69f03c2933](https://github.com/Devolutions/sspi-rs/commit/69f03c2933c1da106b64a565a757666cd4d94bde)) 

  Fixes Kerberos LDAP auth.
  The problem was in the invalid sequence number in MIC token.

- NTLM RPC auth (#395) ([34d896c9ce](https://github.com/Devolutions/sspi-rs/commit/34d896c9cee7e0b3e0d5ee3c5002c781d9fc8fbf)) 

## [[0.15.2](https://github.com/Devolutions/sspi-rs/compare/sspi-v0.15.1...sspi-v0.15.2)] - 2025-02-27

### <!-- 1 -->Features

- Support `SECBUFFER_READONLY_WITH_CHECKSUM` flag (#357) ([397fd9502d](https://github.com/Devolutions/sspi-rs/commit/397fd9502dc315e4e8e7c4700b6e789c5e7b44c3)) 

- Add `USE_DCE_STYLE` flag support (#358) ([0f78bccaea](https://github.com/Devolutions/sspi-rs/commit/0f78bccaea7ac5620f83de68d3559f212262c789)) 

### <!-- 4 -->Bug Fixes

- Kerberos authentication and encryption for RPC and RDP (#372) ([442dfc1382](https://github.com/Devolutions/sspi-rs/commit/442dfc1382033f6f81bb4cd021cca7318cce224e)) 

## [[0.15.1](https://github.com/Devolutions/sspi-rs/compare/sspi-v0.15.0...sspi-v0.15.1)] - 2025-02-04

### <!-- 1 -->Features

- Add `make_signature` and `verify_signature` to `Sspi` trait (#343) ([040188a34d](https://github.com/Devolutions/sspi-rs/commit/040188a34d5d7b8607825b25a4eb78c25c6b57cc)) 

### <!-- 4 -->Bug Fixes

- Store session key when using server-side NTLM implementation (#354) ([41d1ca7fed](https://github.com/Devolutions/sspi-rs/commit/41d1ca7fed623759dcc9ff6f28c7558ecfa6fcbd)) 


--- File: Cargo.lock ---
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "addr2line"
version = "0.24.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dfbe277e56a376000877090da837660b4427aad530e3028d44e0bffe4f89a1c1"
dependencies = [
 "gimli",
]

[[package]]
name = "adler2"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "320119579fcad9c21884f5c4861d16174d0e06250625266f50fe6898340abefa"

[[package]]
name = "aead"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d122413f284cf2d62fb1b7db97e02edb8cda96d769b16e443a4f6195e35662b0"
dependencies = [
 "crypto-common 0.1.6",
 "generic-array",
]

[[package]]
name = "aes"
version = "0.8.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b169f7a6d4742236a0a00c541b845991d0ac43e546831af1249753ab4c3aa3a0"
dependencies = [
 "cfg-if",
 "cipher",
 "cpufeatures",
]

[[package]]
name = "aes-gcm"
version = "0.10.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "831010a0f742e1209b3bcea8fab6a8e149051ba6099432c8cb2cc117dec3ead1"
dependencies = [
 "aead",
 "aes",
 "cipher",
 "ctr",
 "ghash",
 "subtle",
]

[[package]]
name = "aes-kw"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "69fa2b352dcefb5f7f3a5fb840e02665d311d878955380515e4fd50095dd3d8c"
dependencies = [
 "aes",
]

[[package]]
name = "aho-corasick"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e60d3430d3a69478ad0993f19238d2df97c507009a52b3c10addcd7f6bcb916"
dependencies = [
 "memchr",
]

[[package]]
name = "anyhow"
version = "1.0.99"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b0674a1ddeecb70197781e945de4b3b8ffb61fa939a5597bcf48503737663100"

[[package]]
name = "arbitrary"
version = "1.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c3d036a3c4ab069c7b410a2ce876bd74808d2d0888a82667669f8e783a898bf1"
dependencies = [
 "derive_arbitrary",
]

[[package]]
name = "async-dnssd"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3d49ffe175ab45bbfd74b548313d9d7cdfff27161a94b007b52eeeb5f9aaa15e"
dependencies = [
 "bitflags 1.3.2",
 "futures-channel",
 "futures-core",
 "futures-executor",
 "futures-util",
 "libc",
 "log",
 "pin-utils",
 "pkg-config",
 "tokio",
 "winapi",
]

[[package]]
name = "async-recursion"
version = "1.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b43422f69d8ff38f95f1b2bb76517c91589a924d1559a0e935d7c8ce0274c11"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "async-trait"
version = "0.1.89"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9035ad2d096bed7955a320ee7e2230574d28fd3c3a0f186cbea1ff3c7eed5dbb"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "atomic-polyfill"
version = "1.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8cf2bce30dfe09ef0bfaef228b9d414faaf7e563035494d7fe092dba54b300f4"
dependencies = [
 "critical-section",
]

[[package]]
name = "atomic-waker"
version = "1.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1505bd5d3d116872e7271a6d4e16d81d0c8570876c8de68093a09ac269d8aac0"

[[package]]
name = "autocfg"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c08606f8c3cbf4ce6ec8e28fb0014a2c086708fe954eaa885384a6165172e7e8"

[[package]]
name = "aws-lc-rs"
version = "1.13.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c953fe1ba023e6b7730c0d4b031d06f267f23a46167dcbd40316644b10a17ba"
dependencies = [
 "aws-lc-sys",
 "zeroize",
]

[[package]]
name = "aws-lc-sys"
version = "0.30.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dbfd150b5dbdb988bcc8fb1fe787eb6b7ee6180ca24da683b61ea5405f3d43ff"
dependencies = [
 "bindgen",
 "cc",
 "cmake",
 "dunce",
 "fs_extra",
]

[[package]]
name = "backtrace"
version = "0.3.75"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6806a6321ec58106fea15becdad98371e28d92ccbc7c8f1b3b6dd724fe8f1002"
dependencies = [
 "addr2line",
 "cfg-if",
 "libc",
 "miniz_oxide",
 "object",
 "rustc-demangle",
 "windows-targets 0.52.6",
]

[[package]]
name = "base16ct"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4c7f02d4ea65f2c1853089ffd8d2787bdbc63de2f0d29dedbcf8ccdfa0ccd4cf"

[[package]]
name = "base64"
version = "0.22.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b3254f16251a8381aa12e40e3c4d2f0199f8c6508fbecb9d91f575e0fbb8c6"

[[package]]
name = "base64ct"
version = "1.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "55248b47b0caf0546f7988906588779981c43bb1bc9d0c44087278f80cdb44ba"

[[package]]
name = "bindgen"
version = "0.69.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "271383c67ccabffb7381723dea0672a673f292304fcb45c01cc648c7a8d58088"
dependencies = [
 "bitflags 2.9.3",
 "cexpr",
 "clang-sys",
 "itertools",
 "lazy_static",
 "lazycell",
 "log",
 "prettyplease",
 "proc-macro2",
 "quote",
 "regex",
 "rustc-hash 1.1.0",
 "shlex",
 "syn",
 "which",
]

[[package]]
name = "bit-set"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "08807e080ed7f9d5433fa9b275196cfc35414f66a0c79d864dc51a0d825231a3"
dependencies = [
 "bit-vec",
]

[[package]]
name = "bit-vec"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e764a1d40d510daf35e07be9eb06e75770908c27d411ee6c92109c9840eaaf7"

[[package]]
name = "bitflags"
version = "1.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"

[[package]]
name = "bitflags"
version = "2.9.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34efbcccd345379ca2868b2b2c9d3782e9cc58ba87bc7d79d5b53d9c9ae6f25d"
dependencies = [
 "arbitrary",
]

[[package]]
name = "block-buffer"
version = "0.10.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71"
dependencies = [
 "generic-array",
]

[[package]]
name = "block-buffer"
version = "0.11.0-rc.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a229bfd78e4827c91b9b95784f69492c1b77c1ab75a45a8a037b139215086f94"
dependencies = [
 "hybrid-array",
]

[[package]]
name = "block-padding"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a8894febbff9f758034a5b8e12d87918f56dfc64a8e1fe757d65e29041538d93"
dependencies = [
 "generic-array",
]

[[package]]
name = "bumpalo"
version = "3.19.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"

[[package]]
name = "byteorder"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b"

[[package]]
name = "bytes"
version = "1.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d71b6127be86fdcfddb610f7182ac57211d4b18a3e9c82eb2d17662f2227ad6a"

[[package]]
name = "cbc"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "26b52a9543ae338f279b96b0b9fed9c8093744685043739079ce85cd58f289a6"
dependencies = [
 "cipher",
]

[[package]]
name = "cc"
version = "1.2.34"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42bc4aea80032b7bf409b0bc7ccad88853858911b7713a8062fdc0623867bedc"
dependencies = [
 "jobserver",
 "libc",
 "shlex",
]

[[package]]
name = "cexpr"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6fac387a98bb7c37292057cffc56d62ecb629900026402633ae9160df93a8766"
dependencies = [
 "nom",
]

[[package]]
name = "cfg-if"
version = "1.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2fd1289c04a9ea8cb22300a459a72a385d7c73d3259e2ed7dcb2af674838cfa9"

[[package]]
name = "cfg_aliases"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "613afe47fcd5fac7ccf1db93babcb082c5994d996f20b8b159f2ad1658eb5724"

[[package]]
name = "cipher"
version = "0.4.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "773f3b9af64447d2ce9850330c473515014aa235e6a783b02db81ff39e4a3dad"
dependencies = [
 "crypto-common 0.1.6",
 "inout",
]

[[package]]
name = "clang-sys"
version = "1.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b023947811758c97c59bf9d1c188fd619ad4718dcaa767947df1cadb14f39f4"
dependencies = [
 "glob",
 "libc",
 "libloading",
]

[[package]]
name = "cmake"
version = "0.1.54"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e7caa3f9de89ddbe2c607f4101924c5abec803763ae9534e4f4d7d8f84aa81f0"
dependencies = [
 "cc",
]

[[package]]
name = "concat-kdf"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2d72c1252426a83be2092dd5884a5f6e3b8e7180f6891b6263d2c21b92ec8816"
dependencies = [
 "digest 0.10.7",
]

[[package]]
name = "console_error_panic_hook"
version = "0.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a06aeb73f470f66dcdbf7223caeebb85984942f22f1adb2a088cf9668146bbbc"
dependencies = [
 "cfg-if",
 "wasm-bindgen",
]

[[package]]
name = "const-oid"
version = "0.9.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c2459377285ad874054d797f3ccebf984978aa39129f6eafde5cdc8315b612f8"

[[package]]
name = "const-oid"
version = "0.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0dabb6555f92fb9ee4140454eb5dcd14c7960e1225c6d1a6cc361f032947713e"

[[package]]
name = "core-foundation"
version = "0.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b2a6cd9ae233e7f62ba4e9353e81a88df7fc8a5987b8d445b4d90c879bd156f6"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "core-foundation-sys"
version = "0.8.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"

[[package]]
name = "cpufeatures"
version = "0.2.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "59ed5838eebb26a2bb2e58f6d5b5316989ae9d08bab10e0e6d103e656d1b0280"
dependencies = [
 "libc",
]

[[package]]
name = "crc32fast"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9481c1c90cbf2ac953f07c8d4a58aa3945c425b7185c9154d67a65e4230da511"
dependencies = [
 "cfg-if",
]

[[package]]
name = "critical-section"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "790eea4361631c5e7d22598ecd5723ff611904e3344ce8720784c93e3d83d40b"

[[package]]
name = "crypto"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bf1e6e5492f8f0830c37f301f6349e0dac8b2466e4fe89eef90e9eef906cd046"
dependencies = [
 "crypto-common 0.1.6",
]

[[package]]
name = "crypto-bigint"
version = "0.5.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0dc92fb57ca44df6db8059111ab3af99a63d5d0f8375d9972e319a379c6bab76"
dependencies = [
 "generic-array",
 "rand_core 0.6.4",
 "subtle",
 "zeroize",
]

[[package]]
name = "crypto-common"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3"
dependencies = [
 "generic-array",
 "rand_core 0.6.4",
 "typenum",
]

[[package]]
name = "crypto-common"
version = "0.2.0-rc.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8a23fa214dea9efd4dacee5a5614646b30216ae0f05d4bb51bafb50e9da1c5be"
dependencies = [
 "hybrid-array",
]

[[package]]
name = "crypto-mac"
version = "0.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "25fab6889090c8133f3deb8f73ba3c65a7f456f66436fc012a1b1e272b1e103e"
dependencies = [
 "generic-array",
 "subtle",
]

[[package]]
name = "ctr"
version = "0.9.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0369ee1ad671834580515889b80f2ea915f23b8be8d0daa4bbaf2ac5c7590835"
dependencies = [
 "cipher",
]

[[package]]
name = "curve25519-dalek"
version = "4.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "97fb8b7c4503de7d6ae7b42ab72a5a59857b4c937ec27a3d4539dba95b5ab2be"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "curve25519-dalek-derive",
 "digest 0.10.7",
 "fiat-crypto",
 "rustc_version",
 "subtle",
 "zeroize",
]

[[package]]
name = "curve25519-dalek-derive"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f46882e17999c6cc590af592290432be3bce0428cb0d5f8b6715e4dc7b383eb3"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "data-encoding"
version = "2.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2a2330da5de22e8a3cb63252ce2abb30116bf5265e89c0e01bc17015ce30a476"

[[package]]
name = "der"
version = "0.7.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e7c1832837b905bbfb5101e07cc24c8deddf52f93225eee6ead5f4d63d53ddcb"
dependencies = [
 "const-oid 0.9.6",
 "pem-rfc7468",
 "zeroize",
]

[[package]]
name = "deranged"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c9e6a11ca8224451684bc0d7d5a7adbf8f2fd6887261a1cfc3c0432f9d4068e"
dependencies = [
 "powerfmt",
]

[[package]]
name = "derive_arbitrary"
version = "1.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e567bd82dcff979e4b03460c307b3cdc9e96fde3d73bed1496d2bc75d9dd62a"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "des"
version = "0.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ffdd80ce8ce993de27e9f063a444a4d53ce8e8db4c1f00cc03af5ad5a9867a1e"
dependencies = [
 "cipher",
]

[[package]]
name = "diff"
version = "0.1.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56254986775e3233ffa9c4d7d3faaf6d36a2c09d30b20687e9f88bc8bafc16c8"

[[package]]
name = "digest"
version = "0.10.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292"
dependencies = [
 "block-buffer 0.10.4",
 "const-oid 0.9.6",
 "crypto-common 0.1.6",
 "subtle",
]

[[package]]
name = "digest"
version = "0.11.0-rc.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "460dd7f37e4950526b54a5a6b1f41b6c8e763c58eb9a8fc8fc05ba5c2f44ca7b"
dependencies = [
 "block-buffer 0.11.0-rc.4",
 "const-oid 0.10.1",
 "crypto-common 0.2.0-rc.3",
 "subtle",
]

[[package]]
name = "displaydoc"
version = "0.2.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "97369cbbc041bc366949bc74d34658d6cda5621039731c6310521892a3a20ae0"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "dpapi"
version = "0.2.0"
dependencies = [
 "aes-gcm",
 "aes-kw",
 "bitflags 2.9.3",
 "byteorder",
 "concat-kdf",
 "digest 0.11.0-rc.0",
 "dpapi-core",
 "dpapi-pdu",
 "dpapi-transport",
 "elliptic-curve",
 "hmac 0.12.1",
 "hmac 0.13.0-rc.0",
 "kbkdf",
 "num-bigint-dig",
 "num-derive",
 "num-traits",
 "p256",
 "p384",
 "p521",
 "paste",
 "picky-asn1",
 "picky-asn1-der",
 "picky-asn1-x509",
 "picky-krb",
 "rand 0.8.5",
 "regex",
 "sha1 0.10.6",
 "sha1 0.11.0-rc.0",
 "sha2 0.10.9",
 "sha2 0.11.0-rc.0",
 "sspi",
 "thiserror 2.0.16",
 "tracing",
 "typenum",
 "url",
 "uuid",
 "whoami",
]

[[package]]
name = "dpapi-core"
version = "0.1.0"
dependencies = [
 "ironrdp-core",
 "uuid",
]

[[package]]
name = "dpapi-fuzzing"
version = "0.0.0"
dependencies = [
 "arbitrary",
 "dpapi-core",
 "dpapi-pdu",
 "pretty_assertions",
]

[[package]]
name = "dpapi-native-transport"
version = "0.1.0"
dependencies = [
 "dpapi-transport",
 "futures-util",
 "tokio",
 "tokio-tungstenite",
 "tracing",
 "transport",
 "url",
 "uuid",
]

[[package]]
name = "dpapi-pdu"
version = "0.1.0"
dependencies = [
 "arbitrary",
 "bitflags 2.9.3",
 "dpapi-core",
 "num-bigint-dig",
 "num-derive",
 "num-traits",
 "paste",
 "thiserror 2.0.16",
 "uuid",
]

[[package]]
name = "dpapi-transport"
version = "0.1.0"
dependencies = [
 "thiserror 2.0.16",
 "url",
 "uuid",
]

[[package]]
name = "dpapi-web"
version = "0.0.0"
dependencies = [
 "anyhow",
 "console_error_panic_hook",
 "dpapi",
 "dpapi-transport",
 "futures-util",
 "getrandom 0.2.16",
 "getrandom 0.3.3",
 "gloo-net",
 "gloo-timers",
 "js-sys",
 "reqwest",
 "rustls-pki-types",
 "sspi",
 "time",
 "tracing",
 "tracing-subscriber",
 "tracing-web",
 "url",
 "uuid",
 "wasm-bindgen",
 "wasm-bindgen-futures",
]

[[package]]
name = "dunce"
version = "1.0.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "92773504d58c093f6de2459af4af33faa518c13451eb8f2b5698ed3d36e7c813"

[[package]]
name = "ecdsa"
version = "0.16.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ee27f32b5c5292967d2d4a9d7f1e0b0aed2c15daded5a60300e4abb9d8020bca"
dependencies = [
 "der",
 "digest 0.10.7",
 "elliptic-curve",
 "rfc6979",
 "signature",
 "spki",
]

[[package]]
name = "ed25519"
version = "2.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "115531babc129696a58c64a4fef0a8bf9e9698629fb97e9e40767d235cfbcd53"
dependencies = [
 "pkcs8",
 "signature",
]

[[package]]
name = "ed25519-dalek"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "70e796c081cee67dc755e1a36a0a172b897fab85fc3f6bc48307991f64e4eca9"
dependencies = [
 "curve25519-dalek",
 "ed25519",
 "rand_core 0.6.4",
 "serde",
 "sha2 0.10.9",
 "subtle",
 "zeroize",
]

[[package]]
name = "either"
version = "1.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "48c757948c5ede0e46177b7add2e67155f70e33c07fea8284df6576da70b3719"

[[package]]
name = "elliptic-curve"
version = "0.13.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b5e6043086bf7973472e0c7dff2142ea0b680d30e18d9cc40f267efbf222bd47"
dependencies = [
 "base16ct",
 "crypto-bigint",
 "digest 0.10.7",
 "ff",
 "generic-array",
 "group",
 "hkdf",
 "pem-rfc7468",
 "pkcs8",
 "rand_core 0.6.4",
 "sec1",
 "subtle",
 "zeroize",
]

[[package]]
name = "enum-as-inner"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a1e6a265c649f3f5979b601d26f1d05ada116434c87741c9493cb56218f76cbc"
dependencies = [
 "heck",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "errno"
version = "0.3.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "778e2ac28f6c47af28e4907f13ffd1e1ddbd400980a9abd7c8df189bf578a5ad"
dependencies = [
 "libc",
 "windows-sys 0.60.2",
]

[[package]]
name = "fastrand"
version = "2.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "37909eebbb50d72f9059c3b6d82c0463f2ff062c9e95845c43a6c9c0355411be"

[[package]]
name = "ff"
version = "0.13.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c0b50bfb653653f9ca9095b427bed08ab8d75a137839d9ad64eb11810d5b6393"
dependencies = [
 "rand_core 0.6.4",
 "subtle",
]

[[package]]
name = "ffi-types"
version = "0.0.0"

[[package]]
name = "fiat-crypto"
version = "0.2.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "28dea519a9695b9977216879a3ebfddf92f1c08c05d984f8996aecd6ecdc811d"

[[package]]
name = "flate2"
version = "1.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a3d7db9596fecd151c5f638c0ee5d5bd487b6e0ea232e5dc96d5250f6f94b1d"
dependencies = [
 "crc32fast",
 "libz-sys",
 "miniz_oxide",
]

[[package]]
name = "fnv"
version = "1.0.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1"

[[package]]
name = "form_urlencoded"
version = "1.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cb4cb245038516f5f85277875cdaa4f7d2c9a0fa0468de06ed190163b1581fcf"
dependencies = [
 "percent-encoding",
]

[[package]]
name = "fs_extra"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42703706b716c37f96a77aea830392ad231f44c9e9a67872fa5548707e11b11c"

[[package]]
name = "futures"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "65bc07b1a8bc7c85c5f2e110c476c7389b4554ba72af57d8445ea63a576b0876"
dependencies = [
 "futures-channel",
 "futures-core",
 "futures-executor",
 "futures-io",
 "futures-sink",
 "futures-task",
 "futures-util",
]

[[package]]
name = "futures-channel"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2dff15bf788c671c1934e366d07e30c1814a8ef514e1af724a602e8a2fbe1b10"
dependencies = [
 "futures-core",
 "futures-sink",
]

[[package]]
name = "futures-core"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "05f29059c0c2090612e8d742178b0580d2dc940c837851ad723096f87af6663e"

[[package]]
name = "futures-executor"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e28d1d997f585e54aebc3f97d39e72338912123a67330d723fdbb564d646c9f"
dependencies = [
 "futures-core",
 "futures-task",
 "futures-util",
]

[[package]]
name = "futures-io"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9e5c1b78ca4aae1ac06c48a526a655760685149f0d465d21f37abfe57ce075c6"

[[package]]
name = "futures-macro"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "162ee34ebcb7c64a8abebc059ce0fee27c2262618d7b60ed8faf72fef13c3650"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "futures-sink"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e575fab7d1e0dcb8d0c7bcf9a63ee213816ab51902e6d244a95819acacf1d4f7"

[[package]]
name = "futures-task"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f90f7dce0722e95104fcb095585910c0977252f286e354b5e3bd38902cd99988"

[[package]]
name = "futures-util"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9fa08315bb612088cc391249efdc3bc77536f16c91f6cf495e6fbe85b20a4a81"
dependencies = [
 "futures-channel",
 "futures-core",
 "futures-io",
 "futures-macro",
 "futures-sink",
 "futures-task",
 "memchr",
 "pin-project-lite",
 "pin-utils",
 "slab",
]

[[package]]
name = "generic-array"
version = "0.14.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a"
dependencies = [
 "typenum",
 "version_check",
 "zeroize",
]

[[package]]
name = "getrandom"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "335ff9f135e4384c8150d6f27c6daed433577f86b4750418338c01a1a2528592"
dependencies = [
 "cfg-if",
 "js-sys",
 "libc",
 "wasi 0.11.1+wasi-snapshot-preview1",
 "wasm-bindgen",
]

[[package]]
name = "getrandom"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "26145e563e54f2cadc477553f1ec5ee650b00862f0a58bcd12cbdc5f0ea2d2f4"
dependencies = [
 "cfg-if",
 "js-sys",
 "libc",
 "r-efi",
 "wasi 0.14.2+wasi-0.2.4",
 "wasm-bindgen",
]

[[package]]
name = "ghash"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f0d8a4362ccb29cb0b265253fb0a2728f592895ee6854fd9bc13f2ffda266ff1"
dependencies = [
 "opaque-debug",
 "polyval",
]

[[package]]
name = "gimli"
version = "0.31.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "07e28edb80900c19c28f1072f2e8aeca7fa06b23cd4169cefe1af5aa3260783f"

[[package]]
name = "glob"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0cc23270f6e1808e30a928bdc84dea0b9b4136a8bc82338574f23baf47bbd280"

[[package]]
name = "gloo-net"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c06f627b1a58ca3d42b45d6104bf1e1a03799df472df00988b6ba21accc10580"
dependencies = [
 "futures-channel",
 "futures-core",
 "futures-io",
 "futures-sink",
 "gloo-utils",
 "http",
 "js-sys",
 "pin-project",
 "thiserror 1.0.69",
 "wasm-bindgen",
 "wasm-bindgen-futures",
 "web-sys",
]

[[package]]
name = "gloo-timers"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbb143cf96099802033e0d4f4963b19fd2e0b728bcf076cd9cf7f6634f092994"
dependencies = [
 "futures-channel",
 "futures-core",
 "js-sys",
 "wasm-bindgen",
]

[[package]]
name = "gloo-utils"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b5555354113b18c547c1d3a98fbf7fb32a9ff4f6fa112ce823a21641a0ba3aa"
dependencies = [
 "js-sys",
 "wasm-bindgen",
 "web-sys",
]

[[package]]
name = "group"
version = "0.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f0f9ef7462f7c099f518d754361858f86d8a07af53ba9af0fe635bbccb151a63"
dependencies = [
 "ff",
 "rand_core 0.6.4",
 "subtle",
]

[[package]]
name = "hash32"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b0c35f58762feb77d74ebe43bdbc3210f09be9fe6742234d573bacc26ed92b67"
dependencies = [
 "byteorder",
]

[[package]]
name = "heapless"
version = "0.7.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cdc6457c0eb62c71aac4bc17216026d8410337c4126773b9c5daba343f17964f"
dependencies = [
 "atomic-polyfill",
 "hash32",
 "rustc_version",
 "spin",
 "stable_deref_trait",
]

[[package]]
name = "heck"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2304e00983f87ffb38b55b444b5e3b60a884b5d30c0fca7d82fe33449bbe55ea"

[[package]]
name = "hex"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70"

[[package]]
name = "hickory-proto"
version = "0.24.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "92652067c9ce6f66ce53cc38d1169daa36e6e7eb7dd3b63b5103bd9d97117248"
dependencies = [
 "async-trait",
 "cfg-if",
 "data-encoding",
 "enum-as-inner",
 "futures-channel",
 "futures-io",
 "futures-util",
 "idna",
 "ipnet",
 "once_cell",
 "rand 0.8.5",
 "thiserror 1.0.69",
 "tinyvec",
 "tokio",
 "tracing",
 "url",
]

[[package]]
name = "hickory-resolver"
version = "0.24.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cbb117a1ca520e111743ab2f6688eddee69db4e0ea242545a604dce8a66fd22e"
dependencies = [
 "cfg-if",
 "futures-util",
 "hickory-proto",
 "ipconfig",
 "lru-cache",
 "once_cell",
 "parking_lot",
 "rand 0.8.5",
 "resolv-conf",
 "smallvec",
 "thiserror 1.0.69",
 "tokio",
 "tracing",
]

[[package]]
name = "hkdf"
version = "0.12.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7b5f8eb2ad728638ea2c7d47a21db23b7b58a72ed6a38256b8a1849f15fbbdf7"
dependencies = [
 "hmac 0.12.1",
]

[[package]]
name = "hmac"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c49c37c09c17a53d937dfbb742eb3a961d65a994e6bcdcf37e7399d0cc8ab5e"
dependencies = [
 "digest 0.10.7",
]

[[package]]
name = "hmac"
version = "0.13.0-rc.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8dc6a2fcc35ab09136c6df2cdf9ca49790701420a3a6b5db0987dddbabc79b21"
dependencies = [
 "digest 0.11.0-rc.0",
]

[[package]]
name = "home"
version = "0.5.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589533453244b0995c858700322199b2becb13b627df2851f64a2775d024abcf"
dependencies = [
 "windows-sys 0.59.0",
]

[[package]]
name = "http"
version = "1.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f4a85d31aea989eead29a3aaf9e1115a180df8282431156e533de47660892565"
dependencies = [
 "bytes",
 "fnv",
 "itoa",
]

[[package]]
name = "http-body"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1efedce1fb8e6913f23e0c92de8e62cd5b772a67e7b3946df930a62566c93184"
dependencies = [
 "bytes",
 "http",
]

[[package]]
name = "http-body-util"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b021d93e26becf5dc7e1b75b1bed1fd93124b374ceb73f43d4d4eafec896a64a"
dependencies = [
 "bytes",
 "futures-core",
 "http",
 "http-body",
 "pin-project-lite",
]

[[package]]
name = "httparse"
version = "1.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6dbf3de79e51f3d586ab4cb9d5c3e2c14aa28ed23d180cf89b4df0454a69cc87"

[[package]]
name = "hybrid-array"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "891d15931895091dea5c47afa5b3c9a01ba634b311919fd4d41388fa0e3d76af"
dependencies = [
 "typenum",
]

[[package]]
name = "hyper"
version = "1.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eb3aa54a13a0dfe7fbe3a59e0c76093041720fdc77b110cc0fc260fafb4dc51e"
dependencies = [
 "atomic-waker",
 "bytes",
 "futures-channel",
 "futures-core",
 "http",
 "http-body",
 "httparse",
 "itoa",
 "pin-project-lite",
 "pin-utils",
 "smallvec",
 "tokio",
 "want",
]

[[package]]
name = "hyper-rustls"
version = "0.27.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3c93eb611681b207e1fe55d5a71ecf91572ec8a6705cdb6857f7d8d5242cf58"
dependencies = [
 "http",
 "hyper",
 "hyper-util",
 "rustls",
 "rustls-native-certs",
 "rustls-pki-types",
 "tokio",
 "tokio-rustls",
 "tower-service",
 "webpki-roots",
]

[[package]]
name = "hyper-util"
version = "0.1.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8d9b05277c7e8da2c93a568989bb6207bef0112e8d17df7a6eda4a3cf143bc5e"
dependencies = [
 "base64",
 "bytes",
 "futures-channel",
 "futures-core",
 "futures-util",
 "http",
 "http-body",
 "hyper",
 "ipnet",
 "libc",
 "percent-encoding",
 "pin-project-lite",
 "socket2 0.6.0",
 "tokio",
 "tower-service",
 "tracing",
]

[[package]]
name = "icu_collections"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "200072f5d0e3614556f94a9930d5dc3e0662a652823904c3a75dc3b0af7fee47"
dependencies = [
 "displaydoc",
 "potential_utf",
 "yoke",
 "zerofrom",
 "zerovec",
]

[[package]]
name = "icu_locale_core"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0cde2700ccaed3872079a65fb1a78f6c0a36c91570f28755dda67bc8f7d9f00a"
dependencies = [
 "displaydoc",
 "litemap",
 "tinystr",
 "writeable",
 "zerovec",
]

[[package]]
name = "icu_normalizer"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "436880e8e18df4d7bbc06d58432329d6458cc84531f7ac5f024e93deadb37979"
dependencies = [
 "displaydoc",
 "icu_collections",
 "icu_normalizer_data",
 "icu_properties",
 "icu_provider",
 "smallvec",
 "zerovec",
]

[[package]]
name = "icu_normalizer_data"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "00210d6893afc98edb752b664b8890f0ef174c8adbb8d0be9710fa66fbbf72d3"

[[package]]
name = "icu_properties"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "016c619c1eeb94efb86809b015c58f479963de65bdb6253345c1a1276f22e32b"
dependencies = [
 "displaydoc",
 "icu_collections",
 "icu_locale_core",
 "icu_properties_data",
 "icu_provider",
 "potential_utf",
 "zerotrie",
 "zerovec",
]

[[package]]
name = "icu_properties_data"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "298459143998310acd25ffe6810ed544932242d3f07083eee1084d83a71bd632"

[[package]]
name = "icu_provider"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "03c80da27b5f4187909049ee2d72f276f0d9f99a42c306bd0131ecfe04d8e5af"
dependencies = [
 "displaydoc",
 "icu_locale_core",
 "stable_deref_trait",
 "tinystr",
 "writeable",
 "yoke",
 "zerofrom",
 "zerotrie",
 "zerovec",
]

[[package]]
name = "idna"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b0875f23caa03898994f6ddc501886a45c7d3d62d04d2d90788d47be1b1e4de"
dependencies = [
 "idna_adapter",
 "smallvec",
 "utf8_iter",
]

[[package]]
name = "idna_adapter"
version = "1.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3acae9609540aa318d1bc588455225fb2085b9ed0c4f6bd0d9d5bcd86f1a0344"
dependencies = [
 "icu_normalizer",
 "icu_properties",
]

[[package]]
name = "inout"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "879f10e63c20629ecabbb64a8010319738c66a5cd0c29b02d63d272b03751d01"
dependencies = [
 "block-padding",
 "generic-array",
]

[[package]]
name = "io-uring"
version = "0.7.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "046fa2d4d00aea763528b4950358d0ead425372445dc8ff86312b3c69ff7727b"
dependencies = [
 "bitflags 2.9.3",
 "cfg-if",
 "libc",
]

[[package]]
name = "ipconfig"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b58db92f96b720de98181bbbe63c831e87005ab460c1bf306eb2622b4707997f"
dependencies = [
 "socket2 0.5.10",
 "widestring",
 "windows-sys 0.48.0",
 "winreg",
]

[[package]]
name = "ipnet"
version = "2.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "469fb0b9cefa57e3ef31275ee7cacb78f2fdca44e4765491884a2b119d4eb130"

[[package]]
name = "iri-string"
version = "0.7.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dbc5ebe9c3a1a7a5127f920a418f7585e9e758e911d0466ed004f393b0e380b2"
dependencies = [
 "memchr",
 "serde",
]

[[package]]
name = "ironrdp-core"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b2db60a59716a84d09040d29c9e75e81545842510fccb0934c09b28e78b46680"
dependencies = [
 "ironrdp-error",
]

[[package]]
name = "ironrdp-error"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a9d7794e854eef2f13fdf79c8502bcc567a75a15fd0522885f37739386a4cef"

[[package]]
name = "iso7816"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cd3c7e91da489667bb054f9cd2f1c60cc2ac4478a899f403d11dbc62189215b0"
dependencies = [
 "heapless",
]

[[package]]
name = "iso7816-tlv"
version = "0.4.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7660d28d24a831d690228a275d544654a30f3b167a8e491cf31af5fe5058b546"
dependencies = [
 "untrusted",
]

[[package]]
name = "itertools"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba291022dbbd398a455acf126c1e341954079855bc60dfdda641363bd6922569"
dependencies = [
 "either",
]

[[package]]
name = "itoa"
version = "1.0.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a5f13b858c8d314ee3e8f639011f7ccefe71f97f96e50151fb991f267928e2c"

[[package]]
name = "jobserver"
version = "0.1.34"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9afb3de4395d6b3e67a780b6de64b51c978ecf11cb9a462c66be7d4ca9039d33"
dependencies = [
 "getrandom 0.3.3",
 "libc",
]

[[package]]
name = "js-sys"
version = "0.3.77"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1cfaf33c695fc6e08064efbc1f72ec937429614f25eef83af942d0e227c3a28f"
dependencies = [
 "once_cell",
 "wasm-bindgen",
]

[[package]]
name = "kbkdf"
version = "0.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b758ac9cc629a963ae38718148729d65d4e401f0e516862fa7820f6b76666aa0"
dependencies = [
 "digest 0.11.0-rc.0",
]

[[package]]
name = "keccak"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ecc2af9a1119c51f12a14607e783cb977bde58bc069ff0c3da1095e635d70654"
dependencies = [
 "cpufeatures",
]

[[package]]
name = "lazy_static"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
dependencies = [
 "spin",
]

[[package]]
name = "lazycell"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "830d08ce1d1d941e6b30645f1a0eb5643013d835ce3779a5fc208261dbe10f55"

[[package]]
name = "libc"
version = "0.2.175"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6a82ae493e598baaea5209805c49bbf2ea7de956d50d7da0da1164f9c6d28543"

[[package]]
name = "libloading"
version = "0.8.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "07033963ba89ebaf1584d767badaa2e8fcec21aedea6b8c0346d487d49c28667"
dependencies = [
 "cfg-if",
 "windows-targets 0.53.3",
]

[[package]]
name = "libm"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f9fbbcab51052fe104eb5e5d351cf728d30a5be1fe14d9be8a3b097481fb97de"

[[package]]
name = "libredox"
version = "0.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "391290121bad3d37fbddad76d8f5d1c1c314cfc646d143d7e07a3086ddff0ce3"
dependencies = [
 "bitflags 2.9.3",
 "libc",
 "redox_syscall",
]

[[package]]
name = "libz-sys"
version = "1.1.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b70e7a7df205e92a1a4cd9aaae7898dac0aa555503cc0a649494d0d60e7651d"
dependencies = [
 "cc",
 "pkg-config",
 "vcpkg",
]

[[package]]
name = "linked-hash-map"
version = "0.5.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0717cef1bc8b636c6e1c1bbdefc09e6322da8a9321966e8928ef80d20f7f770f"

[[package]]
name = "linux-raw-sys"
version = "0.4.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d26c52dbd32dccf2d10cac7725f8eae5296885fb5703b261f7d0a0739ec807ab"

[[package]]
name = "linux-raw-sys"
version = "0.9.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cd945864f07fe9f5371a27ad7b52a172b4b499999f1d97574c9fa68373937e12"

[[package]]
name = "litemap"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "241eaef5fd12c88705a01fc1066c48c4b36e0dd4377dcdc7ec3942cea7a69956"

[[package]]
name = "lock_api"
version = "0.4.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96936507f153605bddfcda068dd804796c84324ed2510809e5b2a624c81da765"
dependencies = [
 "autocfg",
 "scopeguard",
]

[[package]]
name = "log"
version = "0.4.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "13dc2df351e3202783a1fe0d44375f7295ffb4049267b0f3018346dc122a1d94"

[[package]]
name = "lru-cache"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "31e24f1ad8321ca0e8a1e0ac13f23cb668e6f5466c2c57319f6a5cf1cc8e3b1c"
dependencies = [
 "linked-hash-map",
]

[[package]]
name = "lru-slab"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "112b39cec0b298b6c1999fee3e31427f74f676e4cb9879ed1a121b43661a4154"

[[package]]
name = "matchers"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8263075bb86c5a1b1427b5ae862e8889656f126e9f77c484496e8b47cf5c5558"
dependencies = [
 "regex-automata 0.1.10",
]

[[package]]
name = "md-5"
version = "0.10.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d89e7ee0cfbedfc4da3340218492196241d89eefb6dab27de5df917a6d2e78cf"
dependencies = [
 "cfg-if",
 "digest 0.10.7",
]

[[package]]
name = "md4"
version = "0.10.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7da5ac363534dce5fabf69949225e174fbf111a498bf0ff794c8ea1fba9f3dda"
dependencies = [
 "digest 0.10.7",
]

[[package]]
name = "memchr"
version = "2.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a282da65faaf38286cf3be983213fcf1d2e2a58700e808f83f4ea9a4804bc0"

[[package]]
name = "minimal-lexical"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a"

[[package]]
name = "miniz_oxide"
version = "0.8.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fa76a2c86f704bdb222d66965fb3d63269ce38518b83cb0575fca855ebb6316"
dependencies = [
 "adler2",
]

[[package]]
name = "mio"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78bed444cc8a2160f01cbcf811ef18cac863ad68ae8ca62092e8db51d51c761c"
dependencies = [
 "libc",
 "wasi 0.11.1+wasi-snapshot-preview1",
 "windows-sys 0.59.0",
]

[[package]]
name = "nom"
version = "7.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d273983c5a657a70a3e8f2a01329822f3b8c8172b73826411a55751e404a0a4a"
dependencies = [
 "memchr",
 "minimal-lexical",
]

[[package]]
name = "nu-ansi-term"
version = "0.46.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77a8165726e8236064dbb45459242600304b42a5ea24ee2948e18e023bf7ba84"
dependencies = [
 "overload",
 "winapi",
]

[[package]]
name = "num-bigint-dig"
version = "0.8.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc84195820f291c7697304f3cbdadd1cb7199c0efc917ff5eafd71225c136151"
dependencies = [
 "arbitrary",
 "byteorder",
 "lazy_static",
 "libm",
 "num-integer",
 "num-iter",
 "num-traits",
 "rand 0.8.5",
 "serde",
 "smallvec",
 "zeroize",
]

[[package]]
name = "num-conv"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "51d515d32fb182ee37cda2ccdcb92950d6a3c2893aa280e540671c2cd0f3b1d9"

[[package]]
name = "num-derive"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed3955f1a9c7c0c15e092f9c887db08b1fc683305fdf6eb6684f22555355e202"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "num-integer"
version = "0.1.46"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7969661fd2958a5cb096e56c8e1ad0444ac2bbcd0061bd28660485a44879858f"
dependencies = [
 "num-traits",
]

[[package]]
name = "num-iter"
version = "0.1.45"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1429034a0490724d0075ebb2bc9e875d6503c3cf69e235a8941aa757d83ef5bf"
dependencies = [
 "autocfg",
 "num-integer",
 "num-traits",
]

[[package]]
name = "num-traits"
version = "0.2.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
dependencies = [
 "autocfg",
 "libm",
]

[[package]]
name = "num_threads"
version = "0.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c7398b9c8b70908f6371f47ed36737907c87c52af34c268fed0bf0ceb92ead9"
dependencies = [
 "libc",
]

[[package]]
name = "object"
version = "0.36.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "62948e14d923ea95ea2c7c86c71013138b66525b86bdc08d2dcc262bdb497b87"
dependencies = [
 "memchr",
]

[[package]]
name = "oid"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c19903c598813dba001b53beeae59bb77ad4892c5c1b9b3500ce4293a0d06c2"
dependencies = [
 "serde",
]

[[package]]
name = "once_cell"
version = "1.21.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"

[[package]]
name = "opaque-debug"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c08d65885ee38876c4f86fa503fb49d7b507c2b62552df7c70b2fce627e06381"

[[package]]
name = "openssl-probe"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d05e27ee213611ffe7d6348b942e8f942b37114c00cc03cec254295a4a17852e"

[[package]]
name = "overload"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b15813163c1d831bf4a13c3610c05c0d03b39feb07f7e09fa234dac9b15aaf39"

[[package]]
name = "p256"
version = "0.13.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c9863ad85fa8f4460f9c48cb909d38a0d689dba1f6f6988a5e3e0d31071bcd4b"
dependencies = [
 "ecdsa",
 "elliptic-curve",
 "primeorder",
 "sha2 0.10.9",
]

[[package]]
name = "p384"
version = "0.13.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fe42f1670a52a47d448f14b6a5c61dd78fce51856e68edaa38f7ae3a46b8d6b6"
dependencies = [
 "ecdsa",
 "elliptic-curve",
 "primeorder",
 "sha2 0.10.9",
]

[[package]]
name = "p521"
version = "0.13.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fc9e2161f1f215afdfce23677034ae137bbd45016a880c2eb3ba8eb95f085b2"
dependencies = [
 "base16ct",
 "ecdsa",
 "elliptic-curve",
 "primeorder",
 "rand_core 0.6.4",
 "sha2 0.10.9",
]

[[package]]
name = "parking_lot"
version = "0.12.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "70d58bf43669b5795d1576d0641cfb6fbb2057bf629506267a92807158584a13"
dependencies = [
 "lock_api",
 "parking_lot_core",
]

[[package]]
name = "parking_lot_core"
version = "0.9.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bc838d2a56b5b1a6c25f55575dfc605fabb63bb2365f6c2353ef9159aa69e4a5"
dependencies = [
 "cfg-if",
 "libc",
 "redox_syscall",
 "smallvec",
 "windows-targets 0.52.6",
]

[[package]]
name = "paste"
version = "1.0.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "57c0d7b74b563b49d38dae00a0c37d4d6de9b432382b2892f0574ddcae73fd0a"

[[package]]
name = "pbkdf2"
version = "0.12.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f8ed6a7761f76e3b9f92dfb0a60a6a6477c61024b775147ff0973a02653abaf2"
dependencies = [
 "digest 0.10.7",
 "hmac 0.12.1",
 "sha1 0.10.6",
]

[[package]]
name = "pem-rfc7468"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "88b39c9bfcfc231068454382784bb460aae594343fb030d46e9f50a645418412"
dependencies = [
 "base64ct",
]

[[package]]
name = "percent-encoding"
version = "2.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b4f627cb1b25917193a259e49bdad08f671f8d9708acfd5fe0a8c1455d87220"

[[package]]
name = "picky"
version = "7.0.0-rc.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "33807ce79d4b14a8918e968a8606e5142ddc6aec933acef79de0bd769cae5fb1"
dependencies = [
 "base64",
 "digest 0.10.7",
 "ed25519-dalek",
 "hex",
 "md-5",
 "num-bigint-dig",
 "p256",
 "p384",
 "p521",
 "picky-asn1",
 "picky-asn1-der",
 "picky-asn1-x509",
 "rand 0.8.5",
 "rand_core 0.6.4",
 "rsa",
 "serde",
 "sha1 0.10.6",
 "sha2 0.10.9",
 "sha3",
 "thiserror 1.0.69",
 "x25519-dalek",
 "zeroize",
]

[[package]]
name = "picky-asn1"
version = "0.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2ff038f9360b934342fb3c0a1d6e82c438a2624b51c3c6e3e6d7cf252b6f3ee3"
dependencies = [
 "oid",
 "serde",
 "serde_bytes",
 "time",
 "zeroize",
]

[[package]]
name = "picky-asn1-der"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9dccb53c26f70c082e008818f524bd45d057069517b047bd0c0ee062d6d7d7f2"
dependencies = [
 "picky-asn1",
 "serde",
 "serde_bytes",
]

[[package]]
name = "picky-asn1-x509"
version = "0.14.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d493f73cf052073ca1fe38666f74c2396987aa6ea660e77dd624cc6c8f60389e"
dependencies = [
 "base64",
 "num-bigint-dig",
 "oid",
 "picky-asn1",
 "picky-asn1-der",
 "serde",
 "widestring",
 "zeroize",
]

[[package]]
name = "picky-krb"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e78a55491723b0a10bc2c02709a8d92d74ef674fe1b569cb4a08bac3d105487"
dependencies = [
 "aes",
 "byteorder",
 "cbc",
 "crypto",
 "des",
 "hmac 0.12.1",
 "num-bigint-dig",
 "oid",
 "pbkdf2",
 "picky-asn1",
 "picky-asn1-der",
 "picky-asn1-x509",
 "rand 0.8.5",
 "serde",
 "sha1 0.10.6",
 "thiserror 1.0.69",
 "uuid",
]

[[package]]
name = "pin-project"
version = "1.1.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "677f1add503faace112b9f1373e43e9e054bfdd22ff1a63c1bc485eaec6a6a8a"
dependencies = [
 "pin-project-internal",
]

[[package]]
name = "pin-project-internal"
version = "1.1.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6e918e4ff8c4549eb882f14b3a4bc8c8bc93de829416eacf579f1207a8fbf861"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "pin-project-lite"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b3cff922bd51709b605d9ead9aa71031d81447142d828eb4a6eba76fe619f9b"

[[package]]
name = "pin-utils"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b870d8c151b6f2fb93e84a13146138f05d02ed11c7e7c54f8826aaaf7c9f184"

[[package]]
name = "pkcs1"
version = "0.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c8ffb9f10fa047879315e6625af03c164b16962a5368d724ed16323b68ace47f"
dependencies = [
 "der",
 "pkcs8",
 "spki",
]

[[package]]
name = "pkcs8"
version = "0.10.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f950b2377845cebe5cf8b5165cb3cc1a5e0fa5cfa3e1f7f55707d8fd82e0a7b7"
dependencies = [
 "der",
 "spki",
]

[[package]]
name = "pkg-config"
version = "0.3.32"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7edddbd0b52d732b21ad9a5fab5c704c14cd949e5e9a1ec5929a24fded1b904c"

[[package]]
name = "polyval"
version = "0.6.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9d1fe60d06143b2430aa532c94cfe9e29783047f06c0d7fd359a9a51b729fa25"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "opaque-debug",
 "universal-hash",
]

[[package]]
name = "portpicker"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "be97d76faf1bfab666e1375477b23fde79eccf0276e9b63b92a39d676a889ba9"
dependencies = [
 "rand 0.8.5",
]

[[package]]
name = "potential_utf"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e5a7c30837279ca13e7c867e9e40053bc68740f988cb07f7ca6df43cc734b585"
dependencies = [
 "zerovec",
]

[[package]]
name = "powerfmt"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "439ee305def115ba05938db6eb1644ff94165c5ab5e9420d1c1bcedbba909391"

[[package]]
name = "ppv-lite86"
version = "0.2.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85eae3c4ed2f50dcfe72643da4befc30deadb458a9b590d720cde2f2b1e97da9"
dependencies = [
 "zerocopy",
]

[[package]]
name = "pretty_assertions"
version = "1.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3ae130e2f271fbc2ac3a40fb1d07180839cdbbe443c7a27e1e3c13c5cac0116d"
dependencies = [
 "diff",
 "yansi",
]

[[package]]
name = "prettyplease"
version = "0.2.37"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "479ca8adacdd7ce8f1fb39ce9ecccbfe93a3f1344b3d0d97f20bc0196208f62b"
dependencies = [
 "proc-macro2",
 "syn",
]

[[package]]
name = "primeorder"
version = "0.13.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "353e1ca18966c16d9deb1c69278edbc5f194139612772bd9537af60ac231e1e6"
dependencies = [
 "elliptic-curve",
]

[[package]]
name = "proc-macro2"
version = "1.0.101"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "89ae43fd86e4158d6db51ad8e2b80f313af9cc74f5c0e03ccb87de09998732de"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "proptest"
version = "1.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6fcdab19deb5195a31cf7726a210015ff1496ba1464fd42cb4f537b8b01b471f"
dependencies = [
 "bit-set",
 "bit-vec",
 "bitflags 2.9.3",
 "lazy_static",
 "num-traits",
 "rand 0.9.2",
 "rand_chacha 0.9.0",
 "rand_xorshift",
 "regex-syntax 0.8.6",
 "rusty-fork",
 "tempfile",
 "unarray",
]

[[package]]
name = "quick-error"
version = "1.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a1d01941d82fa2ab50be1e79e6714289dd7cde78eba4c074bc5a4374f650dfe0"

[[package]]
name = "quinn"
version = "0.11.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "626214629cda6781b6dc1d316ba307189c85ba657213ce642d9c77670f8202c8"
dependencies = [
 "bytes",
 "cfg_aliases",
 "pin-project-lite",
 "quinn-proto",
 "quinn-udp",
 "rustc-hash 2.1.1",
 "rustls",
 "socket2 0.5.10",
 "thiserror 2.0.16",
 "tokio",
 "tracing",
 "web-time",
]

[[package]]
name = "quinn-proto"
version = "0.11.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49df843a9161c85bb8aae55f101bc0bac8bcafd637a620d9122fd7e0b2f7422e"
dependencies = [
 "bytes",
 "getrandom 0.3.3",
 "lru-slab",
 "rand 0.9.2",
 "ring",
 "rustc-hash 2.1.1",
 "rustls",
 "rustls-pki-types",
 "slab",
 "thiserror 2.0.16",
 "tinyvec",
 "tracing",
 "web-time",
]

[[package]]
name = "quinn-udp"
version = "0.5.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fcebb1209ee276352ef14ff8732e24cc2b02bbac986cd74a4c81bcb2f9881970"
dependencies = [
 "cfg_aliases",
 "libc",
 "once_cell",
 "socket2 0.5.10",
 "tracing",
 "windows-sys 0.59.0",
]

[[package]]
name = "quote"
version = "1.0.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1885c039570dc00dcb4ff087a89e185fd56bae234ddc7f056a945bf36467248d"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "r-efi"
version = "5.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "69cdb34c158ceb288df11e18b4bd39de994f6657d83847bdffdbd7f346754b0f"

[[package]]
name = "rand"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
dependencies = [
 "libc",
 "rand_chacha 0.3.1",
 "rand_core 0.6.4",
]

[[package]]
name = "rand"
version = "0.9.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6db2770f06117d490610c7488547d543617b21bfa07796d7a12f6f1bd53850d1"
dependencies = [
 "rand_chacha 0.9.0",
 "rand_core 0.9.3",
]

[[package]]
name = "rand_chacha"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88"
dependencies = [
 "ppv-lite86",
 "rand_core 0.6.4",
]

[[package]]
name = "rand_chacha"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3022b5f1df60f26e1ffddd6c66e8aa15de382ae63b3a0c1bfc0e4d3e3f325cb"
dependencies = [
 "ppv-lite86",
 "rand_core 0.9.3",
]

[[package]]
name = "rand_core"
version = "0.6.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"
dependencies = [
 "getrandom 0.2.16",
]

[[package]]
name = "rand_core"
version = "0.9.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "99d9a13982dcf210057a8a78572b2217b667c3beacbf3a0d8b454f6f82837d38"
dependencies = [
 "getrandom 0.3.3",
]

[[package]]
name = "rand_xorshift"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "513962919efc330f829edb2535844d1b912b0fbe2ca165d613e4e8788bb05a5a"
dependencies = [
 "rand_core 0.9.3",
]

[[package]]
name = "redox_syscall"
version = "0.5.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5407465600fb0548f1442edf71dd20683c6ed326200ace4b1ef0763521bb3b77"
dependencies = [
 "bitflags 2.9.3",
]

[[package]]
name = "regex"
version = "1.11.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "23d7fd106d8c02486a8d64e778353d1cffe08ce79ac2e82f540c86d0facf6912"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-automata 0.4.10",
 "regex-syntax 0.8.6",
]

[[package]]
name = "regex-automata"
version = "0.1.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c230d73fb8d8c1b9c0b3135c5142a8acee3a0558fb8db5cf1cb65f8d7862132"
dependencies = [
 "regex-syntax 0.6.29",
]

[[package]]
name = "regex-automata"
version = "0.4.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6b9458fa0bfeeac22b5ca447c63aaf45f28439a709ccd244698632f9aa6394d6"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax 0.8.6",
]

[[package]]
name = "regex-syntax"
version = "0.6.29"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f162c6dd7b008981e4d40210aca20b4bd0f9b60ca9271061b07f78537722f2e1"

[[package]]
name = "regex-syntax"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"

[[package]]
name = "reqwest"
version = "0.12.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d429f34c8092b2d42c7c93cec323bb4adeb7c67698f70839adec842ec10c7ceb"
dependencies = [
 "base64",
 "bytes",
 "futures-channel",
 "futures-core",
 "futures-util",
 "http",
 "http-body",
 "http-body-util",
 "hyper",
 "hyper-rustls",
 "hyper-util",
 "js-sys",
 "log",
 "percent-encoding",
 "pin-project-lite",
 "quinn",
 "rustls",
 "rustls-native-certs",
 "rustls-pki-types",
 "serde",
 "serde_json",
 "serde_urlencoded",
 "sync_wrapper",
 "tokio",
 "tokio-rustls",
 "tower",
 "tower-http",
 "tower-service",
 "url",
 "wasm-bindgen",
 "wasm-bindgen-futures",
 "web-sys",
 "webpki-roots",
]

[[package]]
name = "resolv-conf"
version = "0.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "95325155c684b1c89f7765e30bc1c42e4a6da51ca513615660cb8a62ef9a88e3"

[[package]]
name = "rfc6979"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f8dd2a808d456c4a54e300a23e9f5a67e122c3024119acbfd73e3bf664491cb2"
dependencies = [
 "hmac 0.12.1",
 "subtle",
]

[[package]]
name = "ring"
version = "0.17.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a4689e6c2294d81e88dc6261c768b63bc4fcdb852be6d1352498b114f61383b7"
dependencies = [
 "cc",
 "cfg-if",
 "getrandom 0.2.16",
 "libc",
 "untrusted",
 "windows-sys 0.52.0",
]

[[package]]
name = "rsa"
version = "0.9.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78928ac1ed176a5ca1d17e578a1825f3d81ca54cf41053a592584b020cfd691b"
dependencies = [
 "const-oid 0.9.6",
 "digest 0.10.7",
 "num-bigint-dig",
 "num-integer",
 "num-traits",
 "pkcs1",
 "pkcs8",
 "rand_core 0.6.4",
 "sha1 0.10.6",
 "signature",
 "spki",
 "subtle",
 "zeroize",
]

[[package]]
name = "rustc-demangle"
version = "0.1.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56f7d92ca342cea22a06f2121d944b4fd82af56988c270852495420f961d4ace"

[[package]]
name = "rustc-hash"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2"

[[package]]
name = "rustc-hash"
version = "2.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "357703d41365b4b27c590e3ed91eabb1b663f07c4c084095e60cbed4362dff0d"

[[package]]
name = "rustc_version"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cfcb3a22ef46e85b45de6ee7e79d063319ebb6594faafcf1c225ea92ab6e9b92"
dependencies = [
 "semver",
]

[[package]]
name = "rustix"
version = "0.38.44"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fdb5bc1ae2baa591800df16c9ca78619bf65c0488b41b96ccec5d11220d8c154"
dependencies = [
 "bitflags 2.9.3",
 "errno",
 "libc",
 "linux-raw-sys 0.4.15",
 "windows-sys 0.59.0",
]

[[package]]
name = "rustix"
version = "1.0.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "11181fbabf243db407ef8df94a6ce0b2f9a733bd8be4ad02b4eda9602296cac8"
dependencies = [
 "bitflags 2.9.3",
 "errno",
 "libc",
 "linux-raw-sys 0.9.4",
 "windows-sys 0.60.2",
]

[[package]]
name = "rustls"
version = "0.23.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c0ebcbd2f03de0fc1122ad9bb24b127a5a6cd51d72604a3f3c50ac459762b6cc"
dependencies = [
 "aws-lc-rs",
 "log",
 "once_cell",
 "ring",
 "rustls-pki-types",
 "rustls-webpki",
 "subtle",
 "zeroize",
]

[[package]]
name = "rustls-native-certs"
version = "0.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7fcff2dd52b58a8d98a70243663a0d234c4e2b79235637849d15913394a247d3"
dependencies = [
 "openssl-probe",
 "rustls-pki-types",
 "schannel",
 "security-framework",
]

[[package]]
name = "rustls-pki-types"
version = "1.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "229a4a4c221013e7e1f1a043678c5cc39fe5171437c88fb47151a21e6f5b5c79"
dependencies = [
 "web-time",
 "zeroize",
]

[[package]]
name = "rustls-webpki"
version = "0.103.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0a17884ae0c1b773f1ccd2bd4a8c72f16da897310a98b0e84bf349ad5ead92fc"
dependencies = [
 "aws-lc-rs",
 "ring",
 "rustls-pki-types",
 "untrusted",
]

[[package]]
name = "rustversion"
version = "1.0.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"

[[package]]
name = "rusty-fork"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cb3dcc6e454c328bb824492db107ab7c0ae8fcffe4ad210136ef014458c1bc4f"
dependencies = [
 "fnv",
 "quick-error",
 "tempfile",
 "wait-timeout",
]

[[package]]
name = "ryu"
version = "1.0.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "28d3b2b1366ec20994f1fd18c3c594f05c5dd4bc44d8bb0c1c632c8d6829481f"

[[package]]
name = "schannel"
version = "0.1.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1f29ebaa345f945cec9fbbc532eb307f0fdad8161f281b6369539c8d84876b3d"
dependencies = [
 "windows-sys 0.59.0",
]

[[package]]
name = "scopeguard"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"

[[package]]
name = "sec1"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3e97a565f76233a6003f9f5c54be1d9c5bdfa3eccfb189469f11ec4901c47dc"
dependencies = [
 "base16ct",
 "der",
 "generic-array",
 "pkcs8",
 "subtle",
 "zeroize",
]

[[package]]
name = "security-framework"
version = "3.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "80fb1d92c5028aa318b4b8bd7302a5bfcf48be96a37fc6fc790f806b0004ee0c"
dependencies = [
 "bitflags 2.9.3",
 "core-foundation",
 "core-foundation-sys",
 "libc",
 "security-framework-sys",
]

[[package]]
name = "security-framework-sys"
version = "2.14.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49db231d56a190491cb4aeda9527f1ad45345af50b0851622a7adb8c03b01c32"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "semver"
version = "1.0.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56e6fa9c48d24d85fb3de5ad847117517440f6beceb7798af16b4a87d616b8d0"

[[package]]
name = "serde"
version = "1.0.219"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5f0e2c6ed6606019b4e29e69dbaba95b11854410e5347d525002456dbbb786b6"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_bytes"
version = "0.11.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8437fd221bde2d4ca316d61b90e337e9e702b3820b87d63caa9ba6c02bd06d96"
dependencies = [
 "serde",
]

[[package]]
name = "serde_derive"
version = "1.0.219"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b0276cf7f2c73365f7157c8123c21cd9a50fbbd844757af28ca1f5925fc2a00"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "serde_json"
version = "1.0.143"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d401abef1d108fbd9cbaebc3e46611f4b1021f714a0597a71f41ee463f5f4a5a"
dependencies = [
 "itoa",
 "memchr",
 "ryu",
 "serde",
]

[[package]]
name = "serde_urlencoded"
version = "0.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3491c14715ca2294c4d6a88f15e84739788c1d030eed8c110436aafdaa2f3fd"
dependencies = [
 "form_urlencoded",
 "itoa",
 "ryu",
 "serde",
]

[[package]]
name = "sha1"
version = "0.10.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3bf829a2d51ab4a5ddf1352d8470c140cadc8301b2ae1789db023f01cedd6ba"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest 0.10.7",
]

[[package]]
name = "sha1"
version = "0.11.0-rc.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6f9318facddf9ac32a33527066936837e189b3f23ced6edc1603720ead5e2b3d"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest 0.11.0-rc.0",
]

[[package]]
name = "sha2"
version = "0.10.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a7507d819769d01a365ab707794a4084392c824f54a7a6a7862f8c3d0892b283"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest 0.10.7",
]

[[package]]
name = "sha2"
version = "0.11.0-rc.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "aa1d2e6b3cc4e43a8258a9a3b17aa5dfd2cc5186c7024bba8a64aa65b2c71a59"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest 0.11.0-rc.0",
]

[[package]]
name = "sha3"
version = "0.10.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75872d278a8f37ef87fa0ddbda7802605cb18344497949862c0d4dcb291eba60"
dependencies = [
 "digest 0.10.7",
 "keccak",
]

[[package]]
name = "sharded-slab"
version = "0.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f40ca3c46823713e0d4209592e8d6e826aa57e928f09752619fc696c499637f6"
dependencies = [
 "lazy_static",
]

[[package]]
name = "shlex"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"

[[package]]
name = "signature"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77549399552de45a898a580c1b41d445bf730df867cc44e6c0233bbc4b8329de"
dependencies = [
 "digest 0.10.7",
 "rand_core 0.6.4",
]

[[package]]
name = "slab"
version = "0.4.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a2ae44ef20feb57a68b23d846850f861394c2e02dc425a50098ae8c90267589"

[[package]]
name = "smallvec"
version = "1.15.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "67b1b7a3b5fe4f1376887184045fcf45c69e92af734b7aaddc05fb777b6fbd03"
dependencies = [
 "arbitrary",
]

[[package]]
name = "socket2"
version = "0.5.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e22376abed350d73dd1cd119b57ffccad95b4e585a7cda43e286245ce23c0678"
dependencies = [
 "libc",
 "windows-sys 0.52.0",
]

[[package]]
name = "socket2"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "233504af464074f9d066d7b5416c5f9b894a5862a6506e306f7b816cdd6f1807"
dependencies = [
 "libc",
 "windows-sys 0.59.0",
]

[[package]]
name = "spin"
version = "0.9.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6980e8d7511241f8acf4aebddbb1ff938df5eebe98691418c4468d0b72a96a67"
dependencies = [
 "lock_api",
]

[[package]]
name = "spki"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d91ed6c858b01f942cd56b37a94b3e0a1798290327d1236e4d9cf4eaca44d29d"
dependencies = [
 "base64ct",
 "der",
]

[[package]]
name = "sspi"
version = "0.16.1"
dependencies = [
 "async-dnssd",
 "async-recursion",
 "base64",
 "bitflags 2.9.3",
 "byteorder",
 "cfg-if",
 "crypto-mac",
 "futures",
 "hickory-resolver",
 "hmac 0.12.1",
 "lazy_static",
 "md-5",
 "md4",
 "num-bigint-dig",
 "num-derive",
 "num-traits",
 "oid",
 "picky",
 "picky-asn1",
 "picky-asn1-der",
 "picky-asn1-x509",
 "picky-krb",
 "portpicker",
 "proptest",
 "rand 0.8.5",
 "reqwest",
 "rsa",
 "rustls",
 "rustls-native-certs",
 "serde",
 "serde_derive",
 "sha1 0.10.6",
 "sha2 0.10.9",
 "static_assertions",
 "time",
 "tokio",
 "tracing",
 "tracing-subscriber",
 "url",
 "uuid",
 "whoami",
 "windows",
 "windows-registry",
 "windows-sys 0.60.2",
 "winscard",
 "zeroize",
]

[[package]]
name = "sspi-ffi"
version = "0.0.0"
dependencies = [
 "bitflags 2.9.3",
 "cfg-if",
 "dpapi",
 "dpapi-native-transport",
 "dpapi-transport",
 "ffi-types",
 "libc",
 "num-traits",
 "picky",
 "picky-asn1-der",
 "picky-asn1-x509",
 "sspi",
 "symbol-rename-macro",
 "tokio",
 "tracing",
 "tracing-subscriber",
 "url",
 "uuid",
 "whoami",
 "windows-sys 0.60.2",
 "winscard",
]

[[package]]
name = "stable_deref_trait"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a8f112729512f8e442d81f95a8a7ddf2b7c6b8a1a6f509a95864142b30cab2d3"

[[package]]
name = "static_assertions"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a2eb9349b6444b326872e140eb1cf5e7c522154d69e7a0ffb0fb81c06b37543f"

[[package]]
name = "subtle"
version = "2.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "13c2bddecc57b384dee18652358fb23172facb8a2c51ccc10d74c157bdea3292"

[[package]]
name = "symbol-rename-macro"
version = "0.0.0"

[[package]]
name = "syn"
version = "2.0.106"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ede7c438028d4436d71104916910f5bb611972c5cfd7f89b8300a8186e6fada6"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "sync_wrapper"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0bf256ce5efdfa370213c1dabab5935a12e49f2c58d15e9eac2870d3b4f27263"
dependencies = [
 "futures-core",
]

[[package]]
name = "synstructure"
version = "0.13.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "728a70f3dbaf5bab7f0c4b1ac8d7ae5ea60a4b5549c8a5914361c99147a709d2"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "tempfile"
version = "3.21.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "15b61f8f20e3a6f7e0649d825294eaf317edce30f82cf6026e7e4cb9222a7d1e"
dependencies = [
 "fastrand",
 "getrandom 0.3.3",
 "once_cell",
 "rustix 1.0.8",
 "windows-sys 0.60.2",
]

[[package]]
name = "thiserror"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6aaf5339b578ea85b50e080feb250a3e8ae8cfcdff9a461c9ec2904bc923f52"
dependencies = [
 "thiserror-impl 1.0.69",
]

[[package]]
name = "thiserror"
version = "2.0.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3467d614147380f2e4e374161426ff399c91084acd2363eaf549172b3d5e60c0"
dependencies = [
 "thiserror-impl 2.0.16",
]

[[package]]
name = "thiserror-impl"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4fee6c4efc90059e10f81e6d42c60a18f76588c3d74cb83a0b242a2b6c7504c1"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "thiserror-impl"
version = "2.0.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c5e1be1c48b9172ee610da68fd9cd2770e7a4056cb3fc98710ee6906f0c7960"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "thread_local"
version = "1.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f60246a4944f24f6e018aa17cdeffb7818b76356965d03b07d6a9886e8962185"
dependencies = [
 "cfg-if",
]

[[package]]
name = "time"
version = "0.3.41"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8a7619e19bc266e0f9c5e6686659d394bc57973859340060a69221e57dbc0c40"
dependencies = [
 "deranged",
 "itoa",
 "js-sys",
 "libc",
 "num-conv",
 "num_threads",
 "powerfmt",
 "serde",
 "time-core",
 "time-macros",
]

[[package]]
name = "time-core"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c9e9a38711f559d9e3ce1cdb06dd7c5b8ea546bc90052da6d06bb76da74bb07c"

[[package]]
name = "time-macros"
version = "0.2.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3526739392ec93fd8b359c8e98514cb3e8e021beb4e5f597b00a0221f8ed8a49"
dependencies = [
 "num-conv",
 "time-core",
]

[[package]]
name = "tinystr"
version = "0.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5d4f6d1145dcb577acf783d4e601bc1d76a13337bb54e6233add580b07344c8b"
dependencies = [
 "displaydoc",
 "zerovec",
]

[[package]]
name = "tinyvec"
version = "1.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bfa5fdc3bce6191a1dbc8c02d5c8bffcf557bafa17c124c5264a458f1b0613fa"
dependencies = [
 "tinyvec_macros",
]

[[package]]
name = "tinyvec_macros"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20"

[[package]]
name = "tokio"
version = "1.47.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "89e49afdadebb872d3145a5638b59eb0691ea23e46ca484037cfab3b76b95038"
dependencies = [
 "backtrace",
 "bytes",
 "io-uring",
 "libc",
 "mio",
 "pin-project-lite",
 "slab",
 "socket2 0.6.0",
 "tokio-macros",
 "windows-sys 0.59.0",
]

[[package]]
name = "tokio-macros"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6e06d43f1345a3bcd39f6a56dbb7dcab2ba47e68e8ac134855e7e2bdbaf8cab8"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "tokio-rustls"
version = "0.26.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e727b36a1a0e8b74c376ac2211e40c2c8af09fb4013c60d910495810f008e9b"
dependencies = [
 "rustls",
 "tokio",
]

[[package]]
name = "tokio-tungstenite"
version = "0.27.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "489a59b6730eda1b0171fcfda8b121f4bee2b35cba8645ca35c5f7ba3eb736c1"
dependencies = [
 "futures-util",
 "log",
 "rustls",
 "rustls-native-certs",
 "rustls-pki-types",
 "tokio",
 "tokio-rustls",
 "tungstenite",
]

[[package]]
name = "tower"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d039ad9159c98b70ecfd540b2573b97f7f52c3e8d9f8ad57a24b916a536975f9"
dependencies = [
 "futures-core",
 "futures-util",
 "pin-project-lite",
 "sync_wrapper",
 "tokio",
 "tower-layer",
 "tower-service",
]

[[package]]
name = "tower-http"
version = "0.6.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "adc82fd73de2a9722ac5da747f12383d2bfdb93591ee6c58486e0097890f05f2"
dependencies = [
 "bitflags 2.9.3",
 "bytes",
 "futures-util",
 "http",
 "http-body",
 "iri-string",
 "pin-project-lite",
 "tower",
 "tower-layer",
 "tower-service",
]

[[package]]
name = "tower-layer"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "121c2a6cda46980bb0fcd1647ffaf6cd3fc79a013de288782836f6df9c48780e"

[[package]]
name = "tower-service"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8df9b6e13f2d32c91b9bd719c00d1958837bc7dec474d94952798cc8e69eeec3"

[[package]]
name = "tracing"
version = "0.1.41"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "784e0ac535deb450455cbfa28a6f0df145ea1bb7ae51b821cf5e7927fdcfbdd0"
dependencies = [
 "pin-project-lite",
 "tracing-attributes",
 "tracing-core",
]

[[package]]
name = "tracing-attributes"
version = "0.1.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "81383ab64e72a7a8b8e13130c49e3dab29def6d0c7d76a03087b3cf71c5c6903"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "tracing-core"
version = "0.1.34"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b9d12581f227e93f094d3af2ae690a574abb8a2b9b7a96e7cfe9647b2b617678"
dependencies = [
 "once_cell",
 "valuable",
]

[[package]]
name = "tracing-log"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ee855f1f400bd0e5c02d150ae5de3840039a3f54b025156404e34c23c03f47c3"
dependencies = [
 "log",
 "once_cell",
 "tracing-core",
]

[[package]]
name = "tracing-subscriber"
version = "0.3.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e8189decb5ac0fa7bc8b96b7cb9b2701d60d48805aca84a238004d665fcc4008"
dependencies = [
 "matchers",
 "nu-ansi-term",
 "once_cell",
 "regex",
 "sharded-slab",
 "smallvec",
 "thread_local",
 "time",
 "tracing",
 "tracing-core",
 "tracing-log",
]

[[package]]
name = "tracing-web"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b9e6a141feebd51f8d91ebfd785af50fca223c570b86852166caa3b141defe7c"
dependencies = [
 "js-sys",
 "tracing-core",
 "tracing-subscriber",
 "wasm-bindgen",
 "web-sys",
]

[[package]]
name = "transport"
version = "0.0.0"
source = "git+https://github.com/Devolutions/devolutions-gateway.git?rev=4fd9c22#4fd9c222c55d97e7f7d2d541257298890b3e47b5"
dependencies = [
 "futures-core",
 "futures-sink",
 "futures-util",
 "parking_lot",
 "pin-project-lite",
 "tokio",
 "tracing",
]

[[package]]
name = "try-lock"
version = "0.2.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e421abadd41a4225275504ea4d6566923418b7f05506fbc9c0fe86ba7396114b"

[[package]]
name = "tungstenite"
version = "0.27.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eadc29d668c91fcc564941132e17b28a7ceb2f3ebf0b9dae3e03fd7a6748eb0d"
dependencies = [
 "bytes",
 "data-encoding",
 "http",
 "httparse",
 "log",
 "rand 0.9.2",
 "rustls",
 "rustls-pki-types",
 "sha1 0.10.6",
 "thiserror 2.0.16",
 "utf-8",
]

[[package]]
name = "typenum"
version = "1.18.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1dccffe3ce07af9386bfd29e80c0ab1a8205a2fc34e4bcd40364df902cfa8f3f"

[[package]]
name = "unarray"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eaea85b334db583fe3274d12b4cd1880032beab409c0d774be044d4480ab9a94"

[[package]]
name = "unicode-ident"
version = "1.0.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a5f39404a5da50712a4c1eecf25e90dd62b613502b7e925fd4e4d19b5c96512"

[[package]]
name = "universal-hash"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fc1de2c688dc15305988b563c3854064043356019f97a4b46276fe734c4f07ea"
dependencies = [
 "crypto-common 0.1.6",
 "subtle",
]

[[package]]
name = "untrusted"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8ecb6da28b8a351d773b68d5825ac39017e680750f980f3a1a85cd8dd28a47c1"

[[package]]
name = "url"
version = "2.5.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "08bc136a29a3d1758e07a9cca267be308aeebf5cfd5a10f3f67ab2097683ef5b"
dependencies = [
 "form_urlencoded",
 "idna",
 "percent-encoding",
 "serde",
]

[[package]]
name = "utf-8"
version = "0.7.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09cc8ee72d2a9becf2f2febe0205bbed8fc6615b7cb429ad062dc7b7ddd036a9"

[[package]]
name = "utf8_iter"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6c140620e7ffbb22c2dee59cafe6084a59b5ffc27a8859a5f0d494b5d52b6be"

[[package]]
name = "uuid"
version = "1.18.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f33196643e165781c20a5ead5582283a7dacbb87855d867fbc2df3f81eddc1be"
dependencies = [
 "arbitrary",
 "getrandom 0.3.3",
 "js-sys",
 "serde",
 "wasm-bindgen",
]

[[package]]
name = "valuable"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba73ea9cf16a25df0c8caa16c51acb937d5712a8429db78a3ee29d5dcacd3a65"

[[package]]
name = "vcpkg"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "accd4ea62f7bb7a82fe23066fb0957d48ef677f6eeb8215f372f52e48bb32426"

[[package]]
name = "version_check"
version = "0.9.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a"

[[package]]
name = "wait-timeout"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09ac3b126d3914f9849036f826e054cbabdc8519970b8998ddaf3b5bd3c65f11"
dependencies = [
 "libc",
]

[[package]]
name = "want"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bfa7760aed19e106de2c7c0b581b509f2f25d3dacaf737cb82ac61bc6d760b0e"
dependencies = [
 "try-lock",
]

[[package]]
name = "wasi"
version = "0.11.1+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ccf3ec651a847eb01de73ccad15eb7d99f80485de043efb2f370cd654f4ea44b"

[[package]]
name = "wasi"
version = "0.14.2+wasi-0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9683f9a5a998d873c0d21fcbe3c083009670149a8fab228644b8bd36b2c48cb3"
dependencies = [
 "wit-bindgen-rt",
]

[[package]]
name = "wasite"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b8dad83b4f25e74f184f64c43b150b91efe7647395b42289f38e50566d82855b"

[[package]]
name = "wasm-bindgen"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1edc8929d7499fc4e8f0be2262a241556cfc54a0bea223790e71446f2aab1ef5"
dependencies = [
 "cfg-if",
 "once_cell",
 "rustversion",
 "wasm-bindgen-macro",
]

[[package]]
name = "wasm-bindgen-backend"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2f0a0651a5c2bc21487bde11ee802ccaf4c51935d0d3d42a6101f98161700bc6"
dependencies = [
 "bumpalo",
 "log",
 "proc-macro2",
 "quote",
 "syn",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-futures"
version = "0.4.50"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "555d470ec0bc3bb57890405e5d4322cc9ea83cebb085523ced7be4144dac1e61"
dependencies = [
 "cfg-if",
 "js-sys",
 "once_cell",
 "wasm-bindgen",
 "web-sys",
]

[[package]]
name = "wasm-bindgen-macro"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7fe63fc6d09ed3792bd0897b314f53de8e16568c2b3f7982f468c0bf9bd0b407"
dependencies = [
 "quote",
 "wasm-bindgen-macro-support",
]

[[package]]
name = "wasm-bindgen-macro-support"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8ae87ea40c9f689fc23f209965b6fb8a99ad69aeeb0231408be24920604395de"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
 "wasm-bindgen-backend",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-shared"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1a05d73b933a847d6cccdda8f838a22ff101ad9bf93e33684f39c1f5f0eece3d"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "web-sys"
version = "0.3.77"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "33b6dd2ef9186f1f2072e409e99cd22a975331a6b3591b12c764e0e55c60d5d2"
dependencies = [
 "js-sys",
 "wasm-bindgen",
]

[[package]]
name = "web-time"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a6580f308b1fad9207618087a65c04e7a10bc77e02c8e84e9b00dd4b12fa0bb"
dependencies = [
 "js-sys",
 "wasm-bindgen",
]

[[package]]
name = "webpki-roots"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7e8983c3ab33d6fb807cfcdad2491c4ea8cbc8ed839181c7dfd9c67c83e261b2"
dependencies = [
 "rustls-pki-types",
]

[[package]]
name = "which"
version = "4.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87ba24419a2078cd2b0f2ede2691b6c66d8e47836da3b6db8265ebad47afbfc7"
dependencies = [
 "either",
 "home",
 "once_cell",
 "rustix 0.38.44",
]

[[package]]
name = "whoami"
version = "1.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5d4a4db5077702ca3015d3d02d74974948aba2ad9e12ab7df718ee64ccd7e97d"
dependencies = [
 "libredox",
 "wasite",
 "web-sys",
]

[[package]]
name = "widestring"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dd7cf3379ca1aac9eea11fba24fd7e315d621f8dfe35c8d7d2be8b793726e07d"

[[package]]
name = "winapi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
dependencies = [
 "winapi-i686-pc-windows-gnu",
 "winapi-x86_64-pc-windows-gnu",
]

[[package]]
name = "winapi-i686-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"

[[package]]
name = "winapi-x86_64-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"

[[package]]
name = "windows"
version = "0.61.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9babd3a767a4c1aef6900409f85f5d53ce2544ccdfaa86dad48c91782c6d6893"
dependencies = [
 "windows-collections",
 "windows-core",
 "windows-future",
 "windows-link",
 "windows-numerics",
]

[[package]]
name = "windows-collections"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3beeceb5e5cfd9eb1d76b381630e82c4241ccd0d27f1a39ed41b2760b255c5e8"
dependencies = [
 "windows-core",
]

[[package]]
name = "windows-core"
version = "0.61.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c0fdd3ddb90610c7638aa2b3a3ab2904fb9e5cdbecc643ddb3647212781c4ae3"
dependencies = [
 "windows-implement",
 "windows-interface",
 "windows-link",
 "windows-result",
 "windows-strings",
]

[[package]]
name = "windows-future"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fc6a41e98427b19fe4b73c550f060b59fa592d7d686537eebf9385621bfbad8e"
dependencies = [
 "windows-core",
 "windows-link",
 "windows-threading",
]

[[package]]
name = "windows-implement"
version = "0.60.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "windows-interface"
version = "0.59.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "windows-link"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e6ad25900d524eaabdbbb96d20b4311e1e7ae1699af4fb28c17ae66c80d798a"

[[package]]
name = "windows-numerics"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9150af68066c4c5c07ddc0ce30421554771e528bde427614c61038bc2c92c2b1"
dependencies = [
 "windows-core",
 "windows-link",
]

[[package]]
name = "windows-registry"
version = "0.5.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b8a9ed28765efc97bbc954883f4e6796c33a06546ebafacbabee9696967499e"
dependencies = [
 "windows-link",
 "windows-result",
 "windows-strings",
]

[[package]]
name = "windows-result"
version = "0.3.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56f42bd332cc6c8eac5af113fc0c1fd6a8fd2aa08a0119358686e5160d0586c6"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows-strings"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56e6c93f3a0c3b36176cb1327a4958a0353d5d166c2a35cb268ace15e91d3b57"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows-sys"
version = "0.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "677d2418bec65e3338edb076e806bc1ec15693c5d0104683f2efe857f61056a9"
dependencies = [
 "windows-targets 0.48.5",
]

[[package]]
name = "windows-sys"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d"
dependencies = [
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-sys"
version = "0.59.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b"
dependencies = [
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-sys"
version = "0.60.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f2f500e4d28234f72040990ec9d39e3a6b950f9f22d3dba18416c35882612bcb"
dependencies = [
 "windows-targets 0.53.3",
]

[[package]]
name = "windows-targets"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9a2fa6e2155d7247be68c096456083145c183cbbbc2764150dda45a87197940c"
dependencies = [
 "windows_aarch64_gnullvm 0.48.5",
 "windows_aarch64_msvc 0.48.5",
 "windows_i686_gnu 0.48.5",
 "windows_i686_msvc 0.48.5",
 "windows_x86_64_gnu 0.48.5",
 "windows_x86_64_gnullvm 0.48.5",
 "windows_x86_64_msvc 0.48.5",
]

[[package]]
name = "windows-targets"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
dependencies = [
 "windows_aarch64_gnullvm 0.52.6",
 "windows_aarch64_msvc 0.52.6",
 "windows_i686_gnu 0.52.6",
 "windows_i686_gnullvm 0.52.6",
 "windows_i686_msvc 0.52.6",
 "windows_x86_64_gnu 0.52.6",
 "windows_x86_64_gnullvm 0.52.6",
 "windows_x86_64_msvc 0.52.6",
]

[[package]]
name = "windows-targets"
version = "0.53.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d5fe6031c4041849d7c496a8ded650796e7b6ecc19df1a431c1a363342e5dc91"
dependencies = [
 "windows-link",
 "windows_aarch64_gnullvm 0.53.0",
 "windows_aarch64_msvc 0.53.0",
 "windows_i686_gnu 0.53.0",
 "windows_i686_gnullvm 0.53.0",
 "windows_i686_msvc 0.53.0",
 "windows_x86_64_gnu 0.53.0",
 "windows_x86_64_gnullvm 0.53.0",
 "windows_x86_64_msvc 0.53.0",
]

[[package]]
name = "windows-threading"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b66463ad2e0ea3bbf808b7f1d371311c80e115c0b71d60efc142cafbcfb057a6"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2b38e32f0abccf9987a4e3079dfb67dcd799fb61361e53e2882c3cbaf0d905d8"

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "86b8d5f90ddd19cb4a147a5fa63ca848db3df085e25fee3cc10b39b6eebae764"

[[package]]
name = "windows_aarch64_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc35310971f3b2dbbf3f0690a219f40e2d9afcf64f9ab7cc1be722937c26b4bc"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"

[[package]]
name = "windows_aarch64_msvc"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c7651a1f62a11b8cbd5e0d42526e55f2c99886c77e007179efff86c2b137e66c"

[[package]]
name = "windows_i686_gnu"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a75915e7def60c94dcef72200b9a8e58e5091744960da64ec734a6c6e9b3743e"

[[package]]
name = "windows_i686_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"

[[package]]
name = "windows_i686_gnu"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c1dc67659d35f387f5f6c479dc4e28f1d4bb90ddd1a5d3da2e5d97b42d6272c3"

[[package]]
name = "windows_i686_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"

[[package]]
name = "windows_i686_gnullvm"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ce6ccbdedbf6d6354471319e781c0dfef054c81fbc7cf83f338a4296c0cae11"

[[package]]
name = "windows_i686_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f55c233f70c4b27f66c523580f78f1004e8b5a8b659e05a4eb49d4166cca406"

[[package]]
name = "windows_i686_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"

[[package]]
name = "windows_i686_msvc"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "581fee95406bb13382d2f65cd4a908ca7b1e4c2f1917f143ba16efe98a589b5d"

[[package]]
name = "windows_x86_64_gnu"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "53d40abd2583d23e4718fddf1ebec84dbff8381c07cae67ff7768bbf19c6718e"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"

[[package]]
name = "windows_x86_64_gnu"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2e55b5ac9ea33f2fc1716d1742db15574fd6fc8dadc51caab1c16a3d3b4190ba"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b7b52767868a23d5bab768e390dc5f5c55825b6d30b86c844ff2dc7414044cc"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0a6e035dd0599267ce1ee132e51c27dd29437f63325753051e71dd9e42406c57"

[[package]]
name = "windows_x86_64_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed94fce61571a4006852b7389a063ab983c02eb1bb37b47f8272ce92d06d9538"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"

[[package]]
name = "windows_x86_64_msvc"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "271414315aff87387382ec3d271b52d7ae78726f5d44ac98b4f4030c91880486"

[[package]]
name = "winreg"
version = "0.50.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "524e57b2c537c0f9b1e69f1965311ec12182b4122e45035b1508cd24d2adadb1"
dependencies = [
 "cfg-if",
 "windows-sys 0.48.0",
]

[[package]]
name = "winscard"
version = "0.2.2"
dependencies = [
 "base64",
 "bitflags 2.9.3",
 "flate2",
 "iso7816",
 "iso7816-tlv",
 "num-derive",
 "num-traits",
 "picky",
 "picky-asn1-der",
 "picky-asn1-x509",
 "proptest",
 "rand 0.8.5",
 "rand_core 0.6.4",
 "rsa",
 "sha1 0.10.6",
 "time",
 "tracing",
 "uuid",
]

[[package]]
name = "wit-bindgen-rt"
version = "0.39.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6f42320e61fe2cfd34354ecb597f86f413484a798ba44a8ca1165c58d42da6c1"
dependencies = [
 "bitflags 2.9.3",
]

[[package]]
name = "writeable"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ea2f10b9bb0928dfb1b42b65e1f9e36f7f54dbdf08457afefb38afcdec4fa2bb"

[[package]]
name = "x25519-dalek"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c7e468321c81fb07fa7f4c636c3972b9100f0346e5b6a9f2bd0603a52f7ed277"
dependencies = [
 "curve25519-dalek",
 "rand_core 0.6.4",
 "serde",
 "zeroize",
]

[[package]]
name = "yansi"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cfe53a6657fd280eaa890a3bc59152892ffa3e30101319d168b781ed6529b049"

[[package]]
name = "yoke"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5f41bb01b8226ef4bfd589436a297c53d118f65921786300e427be8d487695cc"
dependencies = [
 "serde",
 "stable_deref_trait",
 "yoke-derive",
 "zerofrom",
]

[[package]]
name = "yoke-derive"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38da3c9736e16c5d3c8c597a9aaa5d1fa565d0532ae05e27c24aa62fb32c0ab6"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
 "synstructure",
]

[[package]]
name = "zerocopy"
version = "0.8.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1039dd0d3c310cf05de012d8a39ff557cb0d23087fd44cad61df08fc31907a2f"
dependencies = [
 "zerocopy-derive",
]

[[package]]
name = "zerocopy-derive"
version = "0.8.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ecf5b4cc5364572d7f4c329661bcc82724222973f2cab6f050a4e5c22f75181"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "zerofrom"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "50cc42e0333e05660c3587f3bf9d0478688e15d870fab3346451ce7f8c9fbea5"
dependencies = [
 "zerofrom-derive",
]

[[package]]
name = "zerofrom-derive"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d71e5d6e06ab090c67b5e44993ec16b72dcbaabc526db883a360057678b48502"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
 "synstructure",
]

[[package]]
name = "zeroize"
version = "1.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ced3678a2879b30306d323f4542626697a464a97c0a07c9aebf7ebca65cd4dde"
dependencies = [
 "zeroize_derive",
]

[[package]]
name = "zeroize_derive"
version = "1.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ce36e65b0d2999d2aafac989fb249189a141aee1f53c612c1f37d72631959f69"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "zerotrie"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "36f0bbd478583f79edad978b407914f61b2972f5af6fa089686016be8f9af595"
dependencies = [
 "displaydoc",
 "yoke",
 "zerofrom",
]

[[package]]
name = "zerovec"
version = "0.11.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e7aa2bd55086f1ab526693ecbe444205da57e25f4489879da80635a46d90e73b"
dependencies = [
 "yoke",
 "zerofrom",
 "zerovec-derive",
]

[[package]]
name = "zerovec-derive"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b96237efa0c878c64bd89c436f661be4e46b2f3eff1ebb976f7ef2321d2f58f"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]


--- File: Cargo.toml ---
[package]
name = "sspi"
version = "0.16.1"
edition = "2021"
readme = "README.md"
license = "MIT OR Apache-2.0"
homepage = "https://github.com/devolutions/sspi-rs"
repository = "https://github.com/devolutions/sspi-rs"
authors = ["Devolutions Inc. <infos@devolutions.net>"]
description = "A Rust implementation of the Security Support Provider Interface (SSPI) API"
keywords = ["ntlm", "auth", "sspi", "windows", "kerberos"]

[workspace]
resolver = "2"
members = [
  "ffi",
  "ffi/symbol-rename-macro",
  "crates/winscard",
  "crates/ffi-types",
  "crates/dpapi",
  "crates/dpapi-core",
  "crates/dpapi-pdu",
  "crates/dpapi-transport",
  "crates/dpapi-native-transport",
  "crates/dpapi-fuzzing",
  "crates/dpapi-web",
]
exclude = [
  "tools/wasm-testcompile",
  "tools/dpapi-cli-client",
]

[workspace.lints.rust]
unexpected_cfgs = { level = "warn", check-cfg = ['cfg(fuzzing)'] }

[workspace.dependencies]
uuid = { version = "1.18", default-features = false }
tracing = { version = "0.1",  default-features = false }
bitflags = "2.9"
rand = "0.8"
cfg-if = "1"
time = { version = "0.3", default-features = false }
sha1 = { version = "0.10", default-features = false }
sha2 = "0.10"
num-derive = "0.4"
num-traits = { version = "0.2", default-features = false }

picky = { version = "7.0.0-rc.15", default-features = false }
picky-asn1 = "0.10"
picky-asn1-der = "0.5"
picky-asn1-x509 = "0.14"
picky-krb = "0.11"

tokio = "1.47"
ffi-types = { path = "crates/ffi-types" }
winscard = { version = "0.2", path = "crates/winscard" }

dpapi = { version = "0.2.0", path = "crates/dpapi" }
dpapi-core = { version = "0.1.0", path = "crates/dpapi-core" }
dpapi-pdu = { version = "0.1.0", path = "crates/dpapi-pdu" }
dpapi-transport = { version = "0.1.0", path = "crates/dpapi-transport" }
dpapi-native-transport = { version = "0.1.0", path = "crates/dpapi-native-transport" }

rsa = { version = "0.9.7", default-features = false }
windows-sys = "0.60"
base64 = "0.22"
whoami = "1.6"
tracing-subscriber = "0.3"
proptest = "1.6"
serde = "1"
byteorder = "1.5"
num-bigint-dig = { version = "0.8", default-features = false }
hmac = "0.12"

[features]
default = ["aws-lc-rs"]

# Enable reqwest for HTTP requests.
network_client = ["dep:reqwest", "dep:portpicker", "dep:rustls-native-certs", "__rustls-used"]
# KDC discovery by querying DNS records.
dns_resolver = ["dep:hickory-resolver", "dep:tokio"]
# TSSSP should be used only on Windows as a native CredSSP replacement.
tsssp = ["dep:rustls", "__rustls-used"]
# Turns on Kerberos smart card login (available only on Windows and users WinSCard API).
scard = ["dep:winscard"]
# Use AWS LC as TLS cryptography provider.
aws-lc-rs = ["rustls?/aws-lc-rs", "__install-crypto-provider"]
# Use ring as TLS cryptography provider.
ring = ["rustls?/ring", "reqwest?/rustls-tls-native-roots", "__install-crypto-provider"]

# Internal (PRIVATE!) features. Do not rely on these whatsoever. They may disappear at anytime.

__test-data = []
__rustls-used = ["dep:rustls"]
__install-crypto-provider = []

[dependencies]
bitflags.workspace = true
rand.workspace = true
cfg-if.workspace = true
time = { workspace = true, features = ["std"] }
picky.workspace = true
sha1.workspace = true
sha2.workspace = true
num-derive.workspace = true
num-traits = { workspace = true, default-features = true }
picky-asn1-der.workspace = true
picky-asn1-x509 = { workspace = true, features = ["pkcs7"] }
uuid = { workspace = true, features = ["v4"], default-features = true }
# `rt-multi-thread` feature is required for `tokio::task::block_in_place` function.
tokio = { workspace = true, optional = true, features = ["time", "rt", "rt-multi-thread"] }
winscard = { workspace = true, optional = true }
rsa = { workspace = true, features = ["sha1"] }
tracing = { workspace = true, default-features = true }
serde.workspace = true
picky-krb = "0.11"
picky-asn1 = { workspace = true, features = ["time_conversion"] }
byteorder.workspace = true
num-bigint-dig.workspace = true
hmac.workspace = true
url = "2.5"

md-5 = "0.10"
md4 = "0.10"
crypto-mac = "0.11"
lazy_static = "1.5"
serde_derive = "1"
oid = "0.2"

reqwest = { version = "0.12", optional = true, default-features = false, features = ["blocking", "rustls-tls-no-provider"] }
hickory-resolver = { version = "0.24", optional = true }
portpicker = { version = "0.1", optional = true }
rustls = { version = "0.23", optional = true, default-features = false, features = ["logging", "std", "tls12"] }
rustls-native-certs = { version = "0.8", optional = true }
zeroize = { version = "1.8", features = ["zeroize_derive"] }
async-recursion = "1.1"

[target.'cfg(windows)'.dependencies]
windows-registry = "0.5"
windows = { version = "0.61", features = [ "Win32_Foundation", "Win32_NetworkManagement_Dns"] }
windows-sys = { workspace = true, features = ["Win32_Security_Cryptography", "Win32_Foundation"] }

[target.'cfg(target_arch = "wasm32")'.dependencies]
uuid = { workspace = true, features = ["js"]}

[target.'cfg(any(target_os = "macos", target_os = "ios"))'.dependencies]
async-dnssd = "0.5"
futures = "0.3"
tokio = { workspace = true, features = ["time", "rt", "rt-multi-thread"] }

[dev-dependencies]
base64.workspace = true
static_assertions = "1"
whoami.workspace = true
picky = { workspace = true, features = ["x509"] }
tracing-subscriber = { workspace = true, features = ["env-filter"] }
proptest.workspace = true
cfg-if.workspace = true

[lints]
workspace = true

[[example]]
name = "kerberos"
required-features = ["network_client"]


--- File: Info.plist ---
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>English</string>
	<key>CFBundleExecutable</key>
	<string></string>
	<key>CFBundleIconFile</key>
	<string></string>
	<key>CFBundleIdentifier</key>
	<string></string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundlePackageType</key>
	<string>FMWK</string>
	<key>CFBundleSignature</key>
	<string>????</string>
	<key>CFBundleVersion</key>
	<string></string>
	<key>CFBundleShortVersionString</key>
	<string>1.0.0.0</string>
	<key>CSResourcesFileMapped</key>
	<true/>
	<key>MinimumOSVersion</key>
	<string>12.1</string>
</dict>
</plist>


--- File: LICENSE-APACHE ---

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.


--- File: LICENSE-MIT ---
Permission is hereby granted, free of charge, to any
person obtaining a copy of this software and associated
documentation files (the "Software"), to deal in the
Software without restriction, including without
limitation the rights to use, copy, modify, merge,
publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software
is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice
shall be included in all copies or substantial portions
of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF
ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.


--- File: README.md ---
# sspi-rs

**sspi-rs** is a Rust implementation of [Security Support Provider Interface (SSPI)](https://docs.microsoft.com/en-us/windows/win32/rpc/security-support-provider-interface-sspi-). It ships with platform-independent implementations of [Security Support Providers (SSP)](https://docs.microsoft.com/en-us/windows/win32/rpc/security-support-providers-ssps-), and is able to utilize native Microsoft libraries when ran under Windows.

The purpose of sspi-rs is to clean the original interface from cluttering and provide users with Rust-friendly SSPs for execution under *nix or any other platform that is able to compile Rust.

## Overview

The sspi-rs works in accordance with the MSDN documentation. At the moment, [NT LAN Manager (NTLM)](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/b38c36ed-2804-4868-a9ff-8dd3182128e4) is implemented and available for platform independent execution. It is also possible to create your own SSPs by implementing the [`SspiImpl`]() trait. More on that in the [Documentation](target/doc/sspi/index.html).

###### Ease of use

Some SSPI functions tend to be cumbersome, that's why sspi-rs allows to use SSPI in a convenient way by utilizing builders. Examples are available in the [examples](examples), [example section](#example), and [Documentation](target/doc/sspi/index.html).

## Documentation

Documentation will give you a comprehensive overlook of the crate. For the example of a simple use case, visit the [examples](examples) folder.

## Example

The usage of the SSPs is as simple as creating an instance of the security provider and calling its functions.

Here is an example of acquiring a credentials handle and a timestamp of their validity:
```rust
use sspi::{CredentialUse, Ntlm, Sspi, Username, builders::EmptyInitializeSecurityContext, SecurityBuffer, ClientRequestFlags, DataRepresentation, BufferType, SspiImpl};

fn main() {
    let account_name = "example_user";
    let computer_name = "example_computer";
    let mut ntlm = Ntlm::new();
    let username = Username::new(&account_name, Some(&computer_name)).unwrap();
    let identity = sspi::AuthIdentity {
        username,
        password: String::from("example_password").into(),
    };

    let mut acq_cred_result = ntlm
        .acquire_credentials_handle()
        .with_credential_use(CredentialUse::Outbound)
        .with_auth_data(&identity)
        .execute()
        .unwrap();

    let mut output_buffer = vec![SecurityBuffer::new(Vec::new(), BufferType::Token)];
    // first time calling initialize_security_context, the input buffer should be empty
    let mut input_buffer = vec![SecurityBuffer::new(Vec::new(), BufferType::Token)];

    // create a builder for the first call to initialize_security_context
    // the target should start with the protocol name, e.g. "HTTP/example.com" or "LDAP/example.com"
    let mut builder = EmptyInitializeSecurityContext::<<Ntlm as SspiImpl>::CredentialsHandle>::new()
        .with_credentials_handle(&mut acq_cred_result.credentials_handle)
        .with_context_requirements(ClientRequestFlags::CONFIDENTIALITY | ClientRequestFlags::ALLOCATE_MEMORY)
        .with_target_data_representation(DataRepresentation::Native)
        .with_target_name("LDAP/example.com")
        .with_input(&mut input_buffer)
        .with_output(&mut output_buffer);

    // call initialize_security_context
    // Note: the initialize_security_context_impl returns a generator, for NTLM, 
    // this generator will never yield as NTLM requires no network communication to a third party
    // but negotiate and kerberos do require network communication, so the generator is used to
    // allow the caller to provide the network information through the generator.resume() method
    // take a look at the examples/kerberos.rs for more information
    let _result = ntlm
        .initialize_security_context_impl(&mut builder)
        .resolve_to_result()
        .unwrap();
    // ... exchange your token in output buffer with the server and repeat the process until either server is satisfied or an error is thrown
}

```

Example of acquiring an SSP provided by Windows:
```Rust
let mut negotiate = SecurityPackage::from_package_type(
    SecurityPackageType::Other(String::from("Negotiate"))
);
```

## Projects using sspi-rs

* [Devolutions Gateway](https://github.com/Devolutions/devolutions-gateway)
* [IronRDP](https://github.com/Devolutions/IronRDP)
* [Python SSPI Library](https://github.com/jborean93/sspilib)
* [NetExec](https://github.com/Pennyw0rth/NetExec)
* [LDAP client library](https://github.com/kanidm/ldap3/blob/master/proto/examples/sasltest/main.rs)
* [Remote Desktop Manager](https://devolutions.net/remote-desktop-manager/)

(Feel free to open a PR if you know about other projects!)

## License

Licensed under either of:

 * [Apache License, Version 2.0](http://www.apache.org/licenses/LICENSE-2.0)
 * [MIT license](http://opensource.org/licenses/MIT)

at your option.

### Contribution

Unless you explicitly state otherwise, any contribution intentionally submitted
for inclusion in the work by you, as defined in the Apache-2.0 license, shall be
dual licensed as above, without any additional terms or conditions.


--- File: cliff.toml ---
# Configuration file for git-cliff

[changelog]
trim = false

header = """
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

"""

# https://tera.netlify.app/docs/#introduction
body = """
{% if version -%}
  ## [[{{ version | trim_start_matches(pat="v") }}]{%- if release_link -%}({{ release_link }}){% endif %}] - {{ timestamp | date(format="%Y-%m-%d") }}
{%- else -%}
  ## [Unreleased]
{%- endif %}

{% for group, commits in commits | group_by(attribute="group") -%}

### {{ group | upper_first }}

{%- for commit in commits %}

{%- set message = commit.message | upper_first %}

{%- if commit.breaking %}
  {%- set breaking = "[**breaking**] " %}
{%- else %}
  {%- set breaking = "" %}
{%- endif %}

{%- set short_sha = commit.id | truncate(length=10, end="") %}
{%- set commit_url = "https://github.com/Devolutions/sspi-rs/commit/" ~ commit.id %}
{%- set commit_link = "[" ~ short_sha ~ "](" ~ commit_url ~ ")" %}

- {{ breaking }}{{ message }} ({{ commit_link }}) \
  {% if commit.body %}\n\n  {{ commit.body | replace(from="\n", to="\n  ") }}{% endif %}
{%- endfor %}

{% endfor -%}
"""

footer = ""

[git]
conventional_commits = true
filter_unconventional = false
filter_commits = false
date_order = false
protect_breaking_commits = true
sort_commits = "oldest"

commit_preprocessors = [
  # Replace issue number with the link
  { pattern = '\((\w+\s)?#([0-9]+)\)', replace = "([#${2}](https://github.com/Devolutions/sspi-rs/issues/${2}))"},
  # Replace commit sha1 with the link
  { pattern = '([a-f0-9]{10})([a-f0-9]{30})', replace = "[${0}](https://github.com/Devolutions/sspi-rs/commit/${1}${2})" }
]

# regex for parsing and grouping commits
# <!-- <NUMBER> --> is a trick to control the section order: https://github.com/orhun/git-cliff/issues/9#issuecomment-914521594
commit_parsers = [
  { message = "^chore", skip = true },
  { message = "^style", skip = true },
  { message = "^refactor", skip = true },
  { message = "^test", skip = true },
  { message = "^ci", skip = true },
  { message = "^chore\\(release\\): prepare for", skip = true },
  { footer = "^[Cc]hangelog: ?ignore", skip = true },

  { message = "(?i)security", group = "<!-- 0 -->Security" },
  { body = "(?i)security", group = "<!-- 0 -->Security" },
  { footer = "^[Ss]ecurity: ?yes", group = "<!-- 0 -->Security" },

  { message = "^feat", group = "<!-- 1 -->Features" },

  { message = "^revert", group = "<!-- 3 -->Revert" },
  { message = "^fix", group = "<!-- 4 -->Bug Fixes" },
  { message = "^perf", group = "<!-- 5 -->Performance" },
  { message = "^doc", group = "<!-- 6 -->Documentation" },
  { message = "^build", group = "<!-- 7 -->Build" },

  { message = "(?i)improve", group = "<!-- 2 -->Improvements" },
  { message = "(?i)adjust", group = "<!-- 2 -->Improvements" },
  { message = "(?i)change", group = "<!-- 2 -->Improvements" },

  { message = ".*", group = "<!-- 99 -->Please Sort" },
]


--- File: crates/dpapi-core/Cargo.toml ---
[package]
name = "dpapi-core"
version = "0.1.0"
edition = "2024"
publish = false # not ready yet

[features]
std = []
alloc = []

[dependencies]
uuid.workspace = true
ironrdp-core = { version = "0.1", features = ["alloc"] }

[lints]
workspace = true


--- File: crates/dpapi-core/README.md ---
# DPAPI core

DPAPI core traits and types.

--- File: crates/dpapi-core/src/decode.rs ---
use ironrdp_core::{DecodeError, DecodeResult, InvalidFieldErr, ReadCursor, ensure_size};
use uuid::Uuid;

use crate::NeedsContext;

/// Decodes [Uuid] from provided source [ReadCursor].
pub fn decode_uuid(src: &mut ReadCursor<'_>) -> DecodeResult<Uuid> {
    ensure_size!(in: src, size: Uuid::FIXED_PART_SIZE);

    Uuid::from_slice_le(src.read_slice(Uuid::FIXED_PART_SIZE))
        .map_err(|err| DecodeError::invalid_field("", "uuid", "invalid data").with_source(err))
}

/// PDU that can be decoded from a binary input and provided context.
pub trait DecodeWithContextOwned: Sized + NeedsContext {
    /// Decodes PDU from a [`ReadCursor`] with provided context.
    fn decode_with_context_owned(src: &mut ReadCursor<'_>, ctx: Self::Context<'_>) -> DecodeResult<Self>;
}

/// Fixed size of the structure.
pub trait FixedPartSize {
    /// Size of the fixed part of frame.
    const FIXED_PART_SIZE: usize;
}

impl FixedPartSize for Uuid {
    const FIXED_PART_SIZE: usize = 16;
}

/// Finds the precise byte count required to decode the frame from a possibly partial input.
/// Incorrectly reading too few or too many bytes will lead to program malfunctions.
pub trait FindLength: FixedPartSize {
    /// Try to find the length of this frame given the first bytes.
    fn find_frame_length(bytes: &[u8]) -> DecodeResult<Option<usize>>;
}


--- File: crates/dpapi-core/src/encode.rs ---
use ironrdp_core::{Encode, EncodeResult, WriteCursor, ensure_size};
use uuid::Uuid;

use crate::FixedPartSize;

/// Encodes [Uuid] in-place using the provided [WriteCursor].
pub fn encode_uuid(uuid: Uuid, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
    ensure_size!(in: dst, size: Uuid::FIXED_PART_SIZE);

    dst.write_slice(&uuid.to_bytes_le());

    Ok(())
}

/// Encodes sequence of elements in-place using the provided [WriteCursor].
pub fn encode_seq<T: Encode>(data: &[T], dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
    for item in data.iter() {
        item.encode(dst)?;
    }

    Ok(())
}

/// Computes the size in bytes for the sequence of elements.
pub fn size_seq<T: Encode>(data: &[T]) -> usize {
    data.iter().map(|item| item.size()).sum()
}

#[cfg(feature = "alloc")]
mod encode_vec {
    use alloc::vec::Vec;

    use ironrdp_core::{Encode, EncodeResult, WriteBuf, encode_buf};

    /// Extension trait which allows to encode PDU into [Vec].
    pub trait EncodeVec {
        /// Encodes this PDU into a [Vec] allocating a memory on fly.
        fn encode_vec(&self) -> EncodeResult<Vec<u8>>;
    }

    impl<T: Encode> EncodeVec for T {
        fn encode_vec(&self) -> EncodeResult<Vec<u8>> {
            let mut buf = WriteBuf::new();
            encode_buf(self, &mut buf)?;

            Ok(buf.into_inner())
        }
    }
}

#[cfg(feature = "alloc")]
pub use encode_vec::*;


--- File: crates/dpapi-core/src/lib.rs ---
#![doc = include_str!("../README.md")]
#![cfg_attr(not(feature = "std"), no_std)]
#![warn(clippy::std_instead_of_alloc)]
#![warn(clippy::std_instead_of_core)]
#![warn(missing_docs)]

#[cfg(feature = "alloc")]
extern crate alloc;

mod decode;
mod encode;
mod marker;
mod padding;
/// Helper functions for working with C and UTF-16c strings.
#[cfg(feature = "alloc")]
pub mod str;

pub use decode::{DecodeWithContextOwned, FindLength, FixedPartSize, decode_uuid};
#[cfg(feature = "alloc")]
pub use encode::EncodeVec;
pub use encode::{encode_seq, encode_uuid, size_seq};
pub use ironrdp_core::{
    DecodeError, DecodeOwned, DecodeResult, Encode, EncodeError, EncodeResult, InvalidFieldErr, OtherErr, ReadCursor,
    UnsupportedValueErr, WriteBuf, WriteCursor, cast_int, cast_length, decode_owned, encode_buf, ensure_size,
};
pub use marker::{NeedsContext, StaticName};
pub use padding::{compute_padding, read_padding, write_padding};


--- File: crates/dpapi-core/src/marker.rs ---
/// Bound used by other traits when a context struct is required.
pub trait NeedsContext {
    /// Required context.
    type Context<'ctx>;
}

/// Represents named PDU.
pub trait StaticName {
    /// Static name of the PDU.
    const NAME: &'static str;
}


--- File: crates/dpapi-core/src/padding.rs ---
use ironrdp_core::{DecodeResult, EncodeResult, ReadCursor, WriteCursor, ensure_size};

/// Write padding bytes into [WriteCursor].
pub fn write_padding(mut padding_len: usize, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
    ensure_size!(ctx: "Padding", in: dst, size: padding_len);

    loop {
        match padding_len {
            0 => break,
            1 => {
                dst.write_u8(0);
                padding_len -= 1;
            }
            2..=3 => {
                dst.write_u16(0);
                padding_len -= 2;
            }
            4..=7 => {
                dst.write_u32(0);
                padding_len -= 4;
            }
            _ => {
                dst.write_u64(0);
                padding_len -= 8;
            }
        }
    }

    Ok(())
}

/// Reads padding bytes from the provided [ReadCursor].
pub fn read_padding(padding_len: usize, src: &mut ReadCursor<'_>) -> DecodeResult<()> {
    ensure_size!(ctx: "Padding", in: src, size: padding_len);

    src.advance(padding_len);

    Ok(())
}

/// Computes a padding length for the given alignment and data length.
pub fn compute_padding(alignment: usize, len: usize) -> usize {
    (alignment - (len % alignment)) % alignment
}


--- File: crates/dpapi-core/src/str.rs ---
use alloc::string::String;
use alloc::vec::Vec;

use ironrdp_core::{DecodeError, DecodeResult, InvalidFieldErr, ReadCursor, WriteCursor, ensure_size};

/// Decodes a UTF-16–encoded byte slice into a [String].
///
/// The input `data` slice should has the size multiple of two (`data.len() % 2 == 0`).
/// Otherwise, the function will return an error.
///
/// *Note*: this function does not expect a NULL-char at the end of the byte slice.
pub fn from_utf16_le(data: &[u8]) -> DecodeResult<String> {
    if data.len() % 2 != 0 {
        return Err(DecodeError::invalid_field(
            "",
            "UTF-16 data",
            "byte slice should has the size multiple of two",
        ));
    }

    String::from_utf16(
        &data
            .chunks(2)
            .map(|c| u16::from_le_bytes(c.try_into().unwrap()))
            .collect::<Vec<u16>>(),
    )
    .map_err(|err| DecodeError::invalid_field("", "UTF-16 data", "is not valid UTF-16").with_source(err))
}

/// Encodes str into a UTF-16 encoded byte array.
///
/// *Note*: this function automatically appends a NULL-char.
///
/// # Panics
///
/// Panics when cursor's internal buffer doesn't have enough space.
pub fn encode_utf16_le(data: &str, dst: &mut WriteCursor) {
    data.encode_utf16()
        .chain(core::iter::once(0))
        .for_each(|v| dst.write_u16(v));
}

/// Calculates the size in bytes of the UTF16 encoded representation of
/// the string slice.
///
/// *Note*: this function automatically counts a NULL-char.
pub fn str_utf16_len(data: &str) -> usize {
    data.encode_utf16().chain(core::iter::once(0)).count() * 2
}

/// Reads UTF-16 C-str from [ReadCursor].
pub fn read_c_str_utf16_le(len: usize, src: &mut ReadCursor<'_>) -> DecodeResult<String> {
    if len < 2 {
        return Err(DecodeError::invalid_field(
            "",
            "C UTF-16 str",
            "expected at least 2 bytes",
        ));
    }

    ensure_size!(ctx: "UTF16-le C str", in: src, size: len);
    let buf = src.read_slice(len - 2 /* UTF16 null terminator */);

    // Read UTF16 null terminator.
    src.read_u16();

    from_utf16_le(buf)
}


--- File: crates/dpapi-fuzzing/Cargo.toml ---
[package]
name = "dpapi-fuzzing"
version = "0.0.0"
edition = "2021"
publish = false

[dependencies]
dpapi-pdu = { workspace = true, features = ["arbitrary"] }
dpapi-core = { workspace = true, features = [] }
arbitrary = { version = "1", features = ["derive"] }
pretty_assertions = "1.4"

[lints]
workspace = true


--- File: crates/dpapi-fuzzing/src/generator.rs ---
use dpapi_core::{encode_buf, DecodeOwned, DecodeResult, EncodeResult, ReadCursor, StaticName, WriteBuf};
use dpapi_pdu::gkdi::{EcdhKey, FfcdhKey, FfcdhParameters, GetKey, GroupKeyEnvelope, KdfParameters, KeyIdentifier};
use dpapi_pdu::rpc::{
    AlterContext, AlterContextResponse, Bind, BindAck, BindNak, Command, ContextElement, ContextResult, EptMap,
    EptMapResult, Fault, Floor, Pdu, PduHeader, Response, SecurityTrailer, SyntaxId, VerificationTrailer,
};

macro_rules! wrapper {
    (pub enum $name:ident ; structs $( $msg_ty:ident, )+ ) => {
        #[derive(Debug, PartialEq, arbitrary::Arbitrary)]
        pub enum $name {
            $( $msg_ty($msg_ty), )+
        }

        impl $name {
            pub fn encode(&self, dst: &mut WriteBuf) -> EncodeResult<&'static str> {
                match self {
                    $(
                        $name::$msg_ty(msg) => {
                            encode_buf(msg, dst)?;

                            Ok($msg_ty::NAME)
                        },
                    )+
                }
            }

            pub fn decode(name: &str, src: &mut ReadCursor<'_>) -> DecodeResult<Self> {
                match name {
                    $(
                        $msg_ty::NAME => $msg_ty::decode_owned(src).map(Self::$msg_ty),
                    )+
                    _ => panic!("unexpected case"),
                }
            }
        }
    };
}

wrapper! {
    pub enum AnyStruct;
    structs
        // bind
        SyntaxId,
        ContextElement,
        ContextResult,
        Bind,
        BindAck,
        BindNak,
        AlterContext,
        AlterContextResponse,

        // epm
        Floor,
        EptMap,
        EptMapResult,

        // pdu
        PduHeader,
        SecurityTrailer,
        Fault,
        Pdu,

        // request
        Response,

        // verification
        Command,
        VerificationTrailer,

        // gkdi
        GetKey,
        KdfParameters,
        FfcdhParameters,
        FfcdhKey,
        EcdhKey,
        KeyIdentifier,
        GroupKeyEnvelope,
}


--- File: crates/dpapi-fuzzing/src/lib.rs ---
pub mod generator;
pub mod oracles;


--- File: crates/dpapi-fuzzing/src/oracles/decoding.rs ---
use dpapi_core::{DecodeOwned, DecodeWithContextOwned, Encode, ReadCursor};
use dpapi_pdu::gkdi::{EcdhKey, FfcdhKey, FfcdhParameters, GetKey, GroupKeyEnvelope, KdfParameters, KeyIdentifier};
use dpapi_pdu::rpc::{
    AlterContext, AlterContextResponse, Bind, BindAck, BindNak, Command, ContextElement, ContextResult, EptMap,
    EptMapResult, Fault, Floor, PacketFlags, Pdu, PduHeader, Request, Response, SecurityTrailer, SyntaxId,
    VerificationTrailer,
};

pub fn structure_decoding(data: &[u8]) {
    // bind
    decode::<SyntaxId>(data);
    decode::<ContextElement>(data);
    decode::<ContextResult>(data);
    decode::<Bind>(data);
    decode::<BindAck>(data);
    decode::<BindNak>(data);
    decode::<AlterContext>(data);
    decode::<AlterContextResponse>(data);

    // epm
    decode::<Floor>(data);
    decode::<EptMap>(data);
    decode::<EptMapResult>(data);

    // pdu
    decode::<PduHeader>(data);
    decode::<SecurityTrailer>(data);
    decode::<Fault>(data);
    decode::<Pdu>(data);

    // request
    decode::<Response>(data);

    // verification
    decode::<Command>(data);
    decode::<VerificationTrailer>(data);

    // gkdi
    decode::<GetKey>(data);
    decode::<KdfParameters>(data);
    decode::<FfcdhParameters>(data);
    decode::<FfcdhKey>(data);
    decode::<EcdhKey>(data);
    decode::<KeyIdentifier>(data);
    decode::<GroupKeyEnvelope>(data);

    decode_with_context::<PacketFlags, Request>(
        data,
        PacketFlags::PfcSupportHeaderSign | PacketFlags::PfcLastFrag | PacketFlags::PfcFirstFrag,
    );
    decode_with_context::<PacketFlags, Request>(
        data,
        PacketFlags::PfcSupportHeaderSign
            | PacketFlags::PfcLastFrag
            | PacketFlags::PfcFirstFrag
            | PacketFlags::PfcObjectUuid,
    );
}

fn decode<S>(data: &[u8])
where
    S: DecodeOwned + Encode,
{
    let mut reader = ReadCursor::new(data);

    let decoded = S::decode_owned(&mut reader);
    let bytes_read = reader.pos();

    if let Ok(decoded) = decoded {
        assert_eq!(decoded.size(), bytes_read);
    }
}

fn decode_with_context<'ctx, C, S>(data: &[u8], ctx: C)
where
    S: DecodeWithContextOwned<Context<'ctx> = C> + Encode,
{
    let mut reader = ReadCursor::new(data);

    let decoded = S::decode_with_context_owned(&mut reader, ctx);
    let bytes_read = reader.pos();

    if let Ok(decoded) = decoded {
        assert_eq!(decoded.size(), bytes_read);
    }
}


--- File: crates/dpapi-fuzzing/src/oracles/mod.rs ---
mod decoding;
mod round_trip;

pub use decoding::structure_decoding;
pub use round_trip::round_trip;


--- File: crates/dpapi-fuzzing/src/oracles/round_trip.rs ---
use dpapi_core::{ReadCursor, WriteBuf};

use crate::generator::AnyStruct;

pub fn round_trip(any: AnyStruct) {
    let mut buf = WriteBuf::new();

    if let Ok(name) = any.encode(&mut buf) {
        let round_tripped_struct =
            AnyStruct::decode(name, &mut ReadCursor::new(buf.filled())).expect("decode should not fail");
        pretty_assertions::assert_eq!(any, round_tripped_struct);
    }
}


--- File: crates/dpapi-native-transport/Cargo.toml ---
[package]
name = "dpapi-native-transport"
version = "0.1.0"
edition = "2021"
publish = false # not ready yet

[dependencies]
transport = { git = "https://github.com/Devolutions/devolutions-gateway.git", rev = "4fd9c22" }
tokio.workspace = true
tokio-tungstenite = { version = "0.27", default-features = false, features = ["connect", "rustls-tls-native-roots"] }
url = "2.5"
uuid = { workspace = true, features = ["v4"] }
tracing.workspace = true
dpapi-transport.workspace = true
futures-util = "0.3"

[lints]
workspace = true


--- File: crates/dpapi-native-transport/src/lib.rs ---
#[macro_use]
extern crate tracing;

use std::io::{Error, ErrorKind};
use std::net::SocketAddr;

use dpapi_transport::{ConnectOptions, Stream, Transport, DEFAULT_RPC_PORT};
use tokio::io::{AsyncRead, AsyncWrite};
use tokio::net::TcpStream;
use tokio_tungstenite::tungstenite;
use tokio_tungstenite::tungstenite::Bytes;
use url::Url;
use uuid::Uuid;

pub trait AsyncReadWrite: AsyncRead + AsyncWrite + Unpin {}

impl<T> AsyncReadWrite for T where T: AsyncRead + AsyncWrite + Unpin + 'static {}

pub type ErasedReadWrite = Box<dyn AsyncReadWrite>;

pub struct TokioStream<S> {
    stream: S,
}

impl<S> TokioStream<S> {
    pub fn new(stream: S) -> Self {
        Self { stream }
    }
}

impl<S> Stream for TokioStream<S>
where
    S: AsyncRead + AsyncWrite + Unpin,
{
    async fn read_vec(&mut self, length: usize) -> Result<Vec<u8>, Error> {
        let mut buf = vec![0; length];
        self.read_exact(&mut buf).await?;

        Ok(buf)
    }

    async fn read_exact(&mut self, mut buf: &mut [u8]) -> Result<(), Error> {
        use tokio::io::AsyncReadExt as _;

        while !buf.is_empty() {
            let bytes_read = Box::pin(async { self.stream.read(buf).await }).await?;
            buf = &mut buf[bytes_read..];

            if bytes_read == 0 {
                return Err(ErrorKind::UnexpectedEof.into());
            }
        }

        Ok(())
    }

    async fn write_all(&mut self, buf: &[u8]) -> Result<(), Error> {
        use tokio::io::AsyncWriteExt as _;

        Box::pin(async {
            self.stream.write_all(buf).await?;
            self.stream.flush().await?;

            Ok(())
        })
        .await
    }
}

pub struct NativeTransport;

impl NativeTransport {
    /// Connects to the RPC server via the Devolutions Gateway tunneled connection.
    #[instrument(err)]
    async fn ws_connect(
        mut proxy: Url,
        session_id: Uuid,
        session_token: &str,
    ) -> Result<TokioStream<ErasedReadWrite>, Error> {
        proxy.path_segments_mut().unwrap().extend([session_id.to_string()]);
        proxy.query_pairs_mut().append_pair("token", session_token);

        let (ws, _) = tokio_tungstenite::connect_async(proxy.as_str()).await.map_err(|err| {
            error!(?err, "Failed to establish WS connection.");
            Error::other(err)
        })?;

        {
            use futures_util::{future, SinkExt as _, StreamExt as _};

            let ws_compat = ws
                .filter_map(|item| {
                    future::ready(
                        item.map(|msg| match msg {
                            tungstenite::Message::Text(data) => {
                                Some(transport::WsReadMsg::Payload(data.as_bytes().to_vec()))
                            }
                            tungstenite::Message::Binary(data) => Some(transport::WsReadMsg::Payload(data.to_vec())),
                            tungstenite::Message::Ping(_) | tungstenite::Message::Pong(_) => None,
                            tungstenite::Message::Close(_) => Some(transport::WsReadMsg::Close),
                            tungstenite::Message::Frame(_) => {
                                unreachable!("raw frames are never returned when reading")
                            }
                        })
                        .transpose(),
                    )
                })
                .with(|item: Vec<u8>| {
                    future::ready(Ok::<_, tungstenite::Error>(tungstenite::Message::Binary(Bytes::from(
                        item,
                    ))))
                });

            Ok(TokioStream::new(
                Box::new(transport::WsStream::new(ws_compat)) as ErasedReadWrite
            ))
        }
    }
}

fn url_to_socket_addr(url: &Url) -> Result<SocketAddr, Error> {
    url.socket_addrs(|| Some(DEFAULT_RPC_PORT))?
        .first()
        .ok_or_else(|| {
            Error::new(
                ErrorKind::InvalidInput,
                "cannot convert destination URL to socket address",
            )
        })
        .copied()
}

impl Transport for NativeTransport {
    type Stream = TokioStream<ErasedReadWrite>;

    #[instrument(skip(connection_options), err)]
    async fn connect(connection_options: &ConnectOptions) -> Result<Self::Stream, Error> {
        match connection_options {
            ConnectOptions::Tcp(addr) => {
                let stream =
                    TokioStream::new(Box::new(TcpStream::connect(url_to_socket_addr(addr)?).await?) as ErasedReadWrite);
                Ok(stream)
            }
            ConnectOptions::WsTunnel {
                proxy,
                destination,
                get_session_token,
            } => {
                let session_id = Uuid::new_v4();
                let session_token = get_session_token(session_id, destination.clone()).await?;

                Self::ws_connect(proxy.clone(), session_id, session_token.as_ref()).await
            }
        }
    }
}


--- File: crates/dpapi-pdu/Cargo.toml ---
[package]
name = "dpapi-pdu"
version = "0.1.0"
edition = "2021"
publish = false # not ready yet

[features]
std = []
arbitrary = ["uuid/arbitrary", "num-bigint-dig/fuzz", "bitflags/arbitrary", "dep:arbitrary", "std"]

[dependencies]
dpapi-core = { workspace = true, features = ["alloc"] }
uuid.workspace = true
num-bigint-dig = { workspace = true, default-features = false }
bitflags.workspace = true
num-derive.workspace = true
num-traits = { workspace = true, default-features = true }

thiserror = { version = "2.0", default-features = false }
arbitrary = {  version = "1", optional = true, features = ["derive"] }

[dev-dependencies]
paste = "1.0"

[lints]
workspace = true


--- File: crates/dpapi-pdu/src/error.rs ---
use alloc::string::String;

use dpapi_core::{DecodeError, InvalidFieldErr};
use thiserror::Error;

#[derive(Debug, Error)]
pub enum Error {
    #[error("{0}")]
    FromUtf16(String),

    #[error("invalid {name} length: expected at least {expected} bytes but got {actual}")]
    InvalidLength {
        name: &'static str,
        expected: usize,
        actual: usize,
    },
}

impl From<Error> for DecodeError {
    fn from(err: Error) -> Self {
        match &err {
            Error::FromUtf16(_) => DecodeError::invalid_field("", "UTF-16 string", "invalid value"),
            Error::InvalidLength { .. } => DecodeError::invalid_field("", "length", "invalid value"),
        }
        .with_source(err)
    }
}

impl From<alloc::string::FromUtf16Error> for Error {
    fn from(err: alloc::string::FromUtf16Error) -> Self {
        use alloc::string::ToString;

        Self::FromUtf16(err.to_string())
    }
}

pub type Result<T> = core::result::Result<T, Error>;


--- File: crates/dpapi-pdu/src/gkdi.rs ---
use alloc::borrow::ToOwned;
use alloc::string::{String, ToString};
use alloc::vec;
use alloc::vec::Vec;
use core::{fmt, mem};

use dpapi_core::str::{encode_utf16_le, read_c_str_utf16_le, str_utf16_len};
use dpapi_core::{
    cast_int, cast_length, compute_padding, decode_uuid, encode_uuid, ensure_size, read_padding, write_padding,
    DecodeError, DecodeOwned, DecodeResult, Encode, EncodeError, EncodeResult, FixedPartSize, InvalidFieldErr,
    OtherErr, ReadCursor, StaticName, WriteCursor,
};
use num_bigint_dig::BigUint;
use thiserror::Error;
use uuid::Uuid;

use crate::Error;

pub const KDF_ALGORITHM_NAME: &str = "SP800_108_CTR_HMAC";

#[derive(Debug, Error)]
pub enum GkdiError {
    #[error("invalid hash algorithm name: {0}")]
    InvalidHashName(String),

    #[error("invalid {name} version: expected {expected} but got {actual}")]
    InvalidVersion {
        name: &'static str,
        expected: u32,
        actual: u32,
    },

    #[error("invalid {name} magic bytes")]
    InvalidMagic {
        name: &'static str,
        expected: &'static [u8],
        actual: Vec<u8>,
    },

    #[error("invalid elliptic curve id")]
    InvalidEllipticCurveId(Vec<u8>),
}

pub type GkdiResult<T> = core::result::Result<T, GkdiError>;

impl From<GkdiError> for DecodeError {
    fn from(err: GkdiError) -> Self {
        match &err {
            GkdiError::InvalidHashName(_) => {
                DecodeError::invalid_field("KdfParameters", "hash algorithm", "invalid value")
            }
            GkdiError::InvalidVersion { .. } => DecodeError::invalid_field("", "version", "invalid version"),
            GkdiError::InvalidEllipticCurveId(_) => {
                DecodeError::invalid_field("EcdhKey", "elliptic curve id", "invalid value")
            }
            GkdiError::InvalidMagic { .. } => DecodeError::invalid_field("", "magic", "invalid value"),
        }
        .with_source(err)
    }
}

/// GetKey RPC Request
///
/// This can be used to build the stub data for the GetKey RPC request.
/// The syntax for this function is defined in []`MS-GKDI 3.1.4.1 GetKey (Opnum 0)`](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gkdi/4cac87a3-521e-4918-a272-240f8fabed39)
#[derive(Debug, Clone, PartialEq, Eq)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
pub struct GetKey {
    /// The the security descriptor for which the group key is being requested.
    pub target_sd: Vec<u8>,
    /// This parameter represents the root key identifier of the requested key. It can be set to NULL.
    pub root_key_id: Option<Uuid>,
    /// This parameter represents the L0 index of the requested group key.
    /// It MUST be a signed 32-bit integer greater than or equal to -1.
    pub l0_key_id: i32,
    /// This parameter represents the L1 index of the requested group key.
    /// It MUST be a signed 32-bit integer between -1 and 31 (inclusive).
    pub l1_key_id: i32,
    /// This parameter represents the L2 index of the requested group key.
    /// It MUST be a 32-bit integer between -1 and 31 (inclusive).
    pub l2_key_id: i32,
}

impl GetKey {
    pub const OPNUM: u16 = 0;
}

impl StaticName for GetKey {
    const NAME: &'static str = "GetKey";
}

impl Encode for GetKey {
    fn encode(&self, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
        ensure_size!(in: dst, size: self.size());

        let target_sd_len = cast_length!("GetKey", "target_sd", self.target_sd.len())?;
        // cbTargetSD
        dst.write_u64(target_sd_len);
        // pbTargetSD - pointer header includes the length + padding
        dst.write_u64(target_sd_len);

        dst.write_slice(&self.target_sd);

        write_padding(compute_padding(8, self.target_sd.len()), dst)?;

        if let Some(root_key_id) = self.root_key_id.as_ref() {
            dst.write_slice(&[0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00]);
            encode_uuid(*root_key_id, dst)?;
        } else {
            dst.write_u64(0);
        };

        dst.write_i32(self.l0_key_id);
        dst.write_i32(self.l1_key_id);
        dst.write_i32(self.l2_key_id);

        Ok(())
    }

    fn name(&self) -> &'static str {
        Self::NAME
    }

    fn size(&self) -> usize {
        8 /* cbTargetSD */ + 8 /* pbTartetSD */ + self.target_sd.len() + compute_padding(8, self.target_sd.len())
        + if self.root_key_id.is_some() { 8 + Uuid::FIXED_PART_SIZE } else { 8 }
        + 4 /* l0 */ + 4 /* l1 */ + 4 /* l2 */
    }
}

impl DecodeOwned for GetKey {
    fn decode_owned(src: &mut ReadCursor<'_>) -> DecodeResult<Self> {
        ensure_size!(in: src, size: 8 /* target_sd_len */ + 8 /* offset */);

        let target_sd_len = { cast_int!("GetKey", "target_sd len", src.read_u64()) as DecodeResult<_> }?;
        let _offset = src.read_u64();

        ensure_size!(in: src, size: target_sd_len);
        let target_sd = src.read_slice(target_sd_len).to_vec();

        read_padding(compute_padding(8, target_sd_len), src)?;

        ensure_size!(in: src, size: 8);
        let root_key_id = if src.read_u64() != 0 {
            Some(decode_uuid(src)?)
        } else {
            None
        };

        ensure_size!(in: src, size: 4 * 3);
        let l0_key_id = src.read_i32();
        let l1_key_id = src.read_i32();
        let l2_key_id = src.read_i32();

        Ok(Self {
            target_sd,
            root_key_id,
            l0_key_id,
            l1_key_id,
            l2_key_id,
        })
    }
}

/// Supported hash algorithms.
///
/// It contains hash algorithms that are listed in the documentation:
/// https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gkdi/9946aeff-a914-45e9-b9e5-6cb5b4059187
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
pub enum HashAlg {
    Sha1,
    Sha256,
    Sha384,
    Sha512,
}

impl fmt::Display for HashAlg {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            HashAlg::Sha1 => write!(f, "SHA1"),
            HashAlg::Sha256 => write!(f, "SHA256"),
            HashAlg::Sha384 => write!(f, "SHA384"),
            HashAlg::Sha512 => write!(f, "SHA512"),
        }
    }
}

impl TryFrom<&str> for HashAlg {
    type Error = GkdiError;

    fn try_from(data: &str) -> GkdiResult<Self> {
        match data {
            "SHA1" => Ok(HashAlg::Sha1),
            "SHA256" => Ok(HashAlg::Sha256),
            "SHA384" => Ok(HashAlg::Sha384),
            "SHA512" => Ok(HashAlg::Sha512),
            _ => Err(GkdiError::InvalidHashName(data.to_owned())),
        }
    }
}

/// [KDF Parameters](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gkdi/9946aeff-a914-45e9-b9e5-6cb5b4059187)
///
/// The following specifies the format and field descriptions for the key derivation function (KDF) parameters structure.
#[derive(Debug, Clone, PartialEq, Eq)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
pub struct KdfParameters {
    pub hash_alg: HashAlg,
}

impl KdfParameters {
    // The following magic identifiers are specified in the Microsoft documentation:
    // https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gkdi/9946aeff-a914-45e9-b9e5-6cb5b4059187
    const MAGIC_IDENTIFIER_1: &[u8] = &[0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00];
    const MAGIC_IDENTIFIER_2: &[u8] = &[0x00, 0x00, 0x00, 0x00];
    const FIXED_PART_SIZE: usize =
        Self::MAGIC_IDENTIFIER_1.len() + 4 /* encoded_hash_alg len */ + Self::MAGIC_IDENTIFIER_2.len();
}

impl StaticName for KdfParameters {
    const NAME: &'static str = "KdfParameters";
}

impl Encode for KdfParameters {
    fn encode(&self, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
        ensure_size!(in: dst, size: self.size());

        let hash_alg = self.hash_alg.to_string();

        dst.write_slice(Self::MAGIC_IDENTIFIER_1);
        dst.write_u32(cast_int!("GetKey", "target_sd len", str_utf16_len(&hash_alg))?);
        dst.write_slice(Self::MAGIC_IDENTIFIER_2);
        encode_utf16_le(&hash_alg, dst);

        Ok(())
    }

    fn name(&self) -> &'static str {
        Self::NAME
    }

    fn size(&self) -> usize {
        let encoded_hash_alg_len = str_utf16_len(&self.hash_alg.to_string());

        Self::FIXED_PART_SIZE + encoded_hash_alg_len
    }
}

impl DecodeOwned for KdfParameters {
    fn decode_owned(src: &mut ReadCursor<'_>) -> DecodeResult<Self> {
        ensure_size!(in: src, size: Self::FIXED_PART_SIZE);

        let magic_identifier_1 = src.read_slice(Self::MAGIC_IDENTIFIER_1.len());

        if magic_identifier_1 != Self::MAGIC_IDENTIFIER_1 {
            Err(GkdiError::InvalidMagic {
                name: "KdfParameters::MAGIC_IDENTIFIER_1",
                expected: Self::MAGIC_IDENTIFIER_1,
                actual: magic_identifier_1.to_vec(),
            })?;
        }

        let hash_name_len = { cast_int!("KdfParameters", "hash name len", src.read_u32()) as DecodeResult<_> }?;

        let magic_identifier_2 = src.read_slice(Self::MAGIC_IDENTIFIER_2.len());

        if magic_identifier_2 != Self::MAGIC_IDENTIFIER_2 {
            Err(GkdiError::InvalidMagic {
                name: "KdfParameters::MAGIC_IDENTIFIER_1",
                expected: Self::MAGIC_IDENTIFIER_2,
                actual: magic_identifier_2.to_vec(),
            })?;
        }

        // The smallest possible hash algorithm name is "SHA1\0", 10 bytes long in UTF-16 encoding.
        if hash_name_len < 10 {
            Err(Error::InvalidLength {
                name: "KdfParameters hash id",
                expected: 10,
                actual: hash_name_len,
            })?;
        }

        Ok(Self {
            hash_alg: read_c_str_utf16_le(hash_name_len, src)?.as_str().try_into()?,
        })
    }
}

/// [FFC DH Parameters](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gkdi/e15ae269-ee21-446a-a480-de3ea243db5f)
///
/// This structure specifies field parameters for use in deriving finite field cryptography (FFC) Diffie-Hellman (DH)
/// ([SP800-56A](https://csrc.nist.gov/pubs/sp/800/56/a/r1/final) section 5.7.1) keys,
/// as specified in section [3.1.4.1.2](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gkdi/5d373568-dd68-499b-bd06-a3ce16ca7117).
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct FfcdhParameters {
    /// A 32-bit unsigned integer. This field MUST be the length, in bytes, of the public key.
    /// This field is encoded using little-endian format.
    pub key_length: u32,
    /// This is the large prime field order, and is a domain parameter for the FFC DH algorithm ([SP800-56A] section 5.7.1).
    /// It MUST be encoded in big-endian format. The length of this field, in bytes,
    /// MUST be equal to the value of the Key length field.
    pub field_order: BigUint,
    /// The generator of the subgroup, a domain parameter for the FFC DH algorithm ([SP800-56A] section 5.7.1).
    /// It MUST be encoded in big-endian format. The length of this field, in bytes,
    /// MUST be equal to the value of the Key length field.
    pub generator: BigUint,
}

impl FfcdhParameters {
    // The following magic value is defined in the Microsoft documentation:
    // https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gkdi/e15ae269-ee21-446a-a480-de3ea243db5f
    const MAGIC: &[u8] = &[0x44, 0x48, 0x50, 0x4d];
    const FIXED_PART_SIZE: usize = 4 /* structure length */ + Self::MAGIC.len() + 4 /* key length */;
}

fn pad_key_buffer(key_length: usize, buf: &mut Vec<u8>) -> EncodeResult<()> {
    if buf.len() > key_length {
        return Err(EncodeError::other("key", "key is bigger then specified key length"));
    }

    let mut key = vec![0; key_length];

    let start = key_length - buf.len();
    key[start..].copy_from_slice(buf);

    mem::swap(&mut key, buf);

    Ok(())
}

#[cfg(feature = "arbitrary")]
fn check_if_data_valid_for_big_uint(data: Vec<u32>) -> arbitrary::Result<Vec<u32>> {
    if data.is_empty() || data.last() == Some(&0) {
        Err(arbitrary::Error::IncorrectFormat)
    } else {
        Ok(data)
    }
}

#[cfg(feature = "arbitrary")]
impl arbitrary::Arbitrary<'_> for FfcdhParameters {
    fn arbitrary(u: &mut arbitrary::Unstructured<'_>) -> arbitrary::Result<Self> {
        let field_order = BigUint::new(check_if_data_valid_for_big_uint(u.arbitrary()?)?);
        let generator = BigUint::new(check_if_data_valid_for_big_uint(u.arbitrary()?)?);

        let bits = field_order.bits().max(generator.bits());

        Ok(Self {
            key_length: (bits as u32).div_ceil(8),
            field_order,
            generator,
        })
    }
}

impl StaticName for FfcdhParameters {
    const NAME: &'static str = "FfcdhParameters";
}

impl Encode for FfcdhParameters {
    fn encode(&self, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
        ensure_size!(in: dst, size: self.size());

        // Calculate total structure length and write it.
        //
        // Length (4 bytes):  A 32-bit unsigned integer. This field MUST be the length, in bytes, of the entire structure. This field is encoded using little-endian format:
        // https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gkdi/e15ae269-ee21-446a-a480-de3ea243db5f
        dst.write_u32(12 + self.key_length * 2);

        dst.write_slice(Self::MAGIC);
        dst.write_u32(self.key_length);

        let key_len: usize = cast_int!("FfcdhParameters", "key len", self.key_length)?;

        if key_len < self.field_order.bits().div_ceil(8) || key_len < self.generator.bits().div_ceil(8) {
            return Err(EncodeError::invalid_field("FfcdhParameters", "key_length", "too small"));
        }

        let mut field_order = self.field_order.to_bytes_be();
        pad_key_buffer(key_len, &mut field_order)?;
        dst.write_slice(&field_order);

        let mut generator = self.generator.to_bytes_be();
        pad_key_buffer(key_len, &mut generator)?;
        dst.write_slice(&generator);

        Ok(())
    }

    fn name(&self) -> &'static str {
        Self::NAME
    }

    fn size(&self) -> usize {
        Self::FIXED_PART_SIZE + usize::try_from(self.key_length).unwrap() * 2
    }
}

impl DecodeOwned for FfcdhParameters {
    fn decode_owned(src: &mut ReadCursor<'_>) -> DecodeResult<Self> {
        ensure_size!(in: src, size: Self::FIXED_PART_SIZE);

        let _total_len = src.read_u32();

        let magic = src.read_slice(Self::MAGIC.len());

        if magic != Self::MAGIC {
            Err(GkdiError::InvalidMagic {
                name: "FfcdhParameters",
                expected: Self::MAGIC,
                actual: magic.to_vec(),
            })?;
        }

        let key_length = src.read_u32();
        let key_len = { cast_int!("FfcdhParameters", "key len", key_length) as DecodeResult<_> }?;
        ensure_size!(in: src, size: key_len * 2);

        let field_order = BigUint::from_bytes_be(src.read_slice(key_len));
        let generator = BigUint::from_bytes_be(src.read_slice(key_len));

        Ok(Self {
            key_length,
            field_order,
            generator,
        })
    }
}

/// [FFC DH Key](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gkdi/f8770f01-036d-4bf6-a4cf-1bd0e3913404)
///
/// The following specifies the format and field descriptions for the FFC DH Key structure.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct FfcdhKey {
    /// A 32-bit unsigned integer. The value in this field MUST be equal to the length, in bytes,
    /// of the Public key field. This parameter is encoded using little-endian format.
    pub key_length: u32,
    /// This is the large prime field order, and is a domain parameter for the FFC DH algorithm ([SP800-56A](https://csrc.nist.gov/pubs/sp/800/56/a/r1/final) section 5.7.1).
    /// It MUST be encoded in big-endian format. The length of this field, in bytes,
    /// MUST be equal to the value in the Key length field.
    pub field_order: BigUint,
    /// The generator of the subgroup, a domain parameter for the FFC DH algorithm ([SP800-56A](https://csrc.nist.gov/pubs/sp/800/56/a/r1/final) section 5.7.1).
    /// It MUST be encoded in big-endian format. The length of this field, in bytes,
    /// MUST be equal to the value in the Key length field.
    pub generator: BigUint,
    /// The public key for the FFC DH algorithm ([SP800-56A](https://csrc.nist.gov/pubs/sp/800/56/a/r1/final) section 5.7.1).
    /// It MUST be encoded in big-endian format. The length of this field, in bytes,
    /// MUST be equal to the value of the Key length field.
    pub public_key: BigUint,
}

impl FfcdhKey {
    // The following magic value is defined in the Microsoft documentation:
    // https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gkdi/f8770f01-036d-4bf6-a4cf-1bd0e3913404
    const MAGIC: &[u8] = &[0x44, 0x48, 0x50, 0x42];
    const FIXED_PART_SIZE: usize = Self::MAGIC.len() + 4 /* key length */;
}

#[cfg(feature = "arbitrary")]
impl arbitrary::Arbitrary<'_> for FfcdhKey {
    fn arbitrary(u: &mut arbitrary::Unstructured<'_>) -> arbitrary::Result<Self> {
        let field_order = BigUint::new(check_if_data_valid_for_big_uint(u.arbitrary()?)?);
        let generator = BigUint::new(check_if_data_valid_for_big_uint(u.arbitrary()?)?);
        let public_key = BigUint::new(check_if_data_valid_for_big_uint(u.arbitrary()?)?);

        let bits = field_order.bits().max(generator.bits().max(public_key.bits()));

        Ok(Self {
            key_length: (bits as u32).div_ceil(8),
            field_order,
            generator,
            public_key,
        })
    }
}

impl StaticName for FfcdhKey {
    const NAME: &'static str = "FfcdhKey";
}

impl Encode for FfcdhKey {
    fn encode(&self, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
        ensure_size!(in: dst, size: self.size());

        dst.write_slice(Self::MAGIC);

        dst.write_u32(self.key_length);

        let key_len: usize = cast_int!("FfcdhKey", "key len", self.key_length)?;

        if key_len < self.field_order.bits().div_ceil(8)
            || key_len < self.generator.bits().div_ceil(8)
            || key_len < self.public_key.bits().div_ceil(8)
        {
            return Err(EncodeError::invalid_field("FfcdhKey", "key_length", "too small"));
        }

        let mut field_order = self.field_order.to_bytes_be();
        pad_key_buffer(key_len, &mut field_order)?;
        dst.write_slice(&field_order);

        let mut generator = self.generator.to_bytes_be();
        pad_key_buffer(key_len, &mut generator)?;
        dst.write_slice(&generator);

        let mut public_key = self.public_key.to_bytes_be();
        pad_key_buffer(key_len, &mut public_key)?;
        dst.write_slice(&public_key);

        Ok(())
    }

    fn name(&self) -> &'static str {
        Self::NAME
    }

    fn size(&self) -> usize {
        Self::FIXED_PART_SIZE + usize::try_from(self.key_length).unwrap() * 3
    }
}

impl DecodeOwned for FfcdhKey {
    fn decode_owned(src: &mut ReadCursor<'_>) -> DecodeResult<Self> {
        ensure_size!(in: src, size: Self::FIXED_PART_SIZE);

        let magic = src.read_slice(Self::MAGIC.len());

        if magic != FfcdhKey::MAGIC {
            Err(GkdiError::InvalidMagic {
                name: "FfcdhKey",
                expected: Self::MAGIC,
                actual: magic.to_vec(),
            })?;
        }

        let key_length = src.read_u32();
        let key_len = { cast_int!("FfcdhKey", "key len", key_length) as DecodeResult<_> }?;

        ensure_size!(in: src, size: key_len * 3);

        Ok(Self {
            key_length,
            field_order: BigUint::from_bytes_be(src.read_slice(key_len)),
            generator: BigUint::from_bytes_be(src.read_slice(key_len)),
            public_key: BigUint::from_bytes_be(src.read_slice(key_len)),
        })
    }
}

/// Supported elliptic curves.
///
/// It contains elliptic curves that are listed in the documentation:
/// https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gkdi/24876a37-9a92-4187-9052-222bb6f85d4a
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
pub enum EllipticCurve {
    P256,
    P384,
    P521,
}

impl From<EllipticCurve> for &[u8] {
    fn from(curve: EllipticCurve) -> Self {
        match curve {
            EllipticCurve::P256 => b"ECK1",
            EllipticCurve::P384 => b"ECK3",
            EllipticCurve::P521 => b"ECK5",
        }
    }
}

impl TryFrom<&[u8]> for EllipticCurve {
    type Error = GkdiError;

    fn try_from(value: &[u8]) -> GkdiResult<Self> {
        match value {
            b"ECK1" => Ok(EllipticCurve::P256),
            b"ECK3" => Ok(EllipticCurve::P384),
            b"ECK5" => Ok(EllipticCurve::P521),
            _ => Err(GkdiError::InvalidEllipticCurveId(value.to_vec())),
        }
    }
}

/// [ECDH Key](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gkdi/24876a37-9a92-4187-9052-222bb6f85d4a)
///
/// The following specifies the format and field descriptions for the Elliptic Curve Diffie-Hellman (ECDH) Key structure [RFC5114](https://www.rfc-editor.org/info/rfc5114).
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct EcdhKey {
    /// Represents the ECDH field parameters.
    pub curve: EllipticCurve,
    /// A 32-bit unsigned integer. This field MUST be the length, in bytes, of the public key.
    /// This field is encoded using little-endian format.
    pub key_length: u32,
    /// The x coordinate of the point P that represents the ECDH [RFC5114](https://www.rfc-editor.org/info/rfc5114) public key.
    /// It MUST be encoded in big-endian format. The length of this field, in bytes,
    /// MUST be equal to the value in the Key length field.
    pub x: BigUint,
    /// The y coordinate of the point P that represents the ECDH public key.
    /// It MUST be encoded in big-endian format. The length of this field, in bytes,
    /// MUST be equal to the value in the Key length field.
    pub y: BigUint,
}

impl EcdhKey {
    const FIXED_PART_SIZE: usize = 4 /* encoded_curve len */ + 4 /* key_length */;
}

#[cfg(feature = "arbitrary")]
impl arbitrary::Arbitrary<'_> for EcdhKey {
    fn arbitrary(u: &mut arbitrary::Unstructured<'_>) -> arbitrary::Result<Self> {
        let x = BigUint::new(check_if_data_valid_for_big_uint(u.arbitrary()?)?);
        let y = BigUint::new(check_if_data_valid_for_big_uint(u.arbitrary()?)?);

        let bits = x.bits().max(y.bits());

        Ok(Self {
            curve: u.arbitrary()?,
            key_length: (bits as u32).div_ceil(8),
            x,
            y,
        })
    }
}

impl StaticName for EcdhKey {
    const NAME: &'static str = "EcdhKey";
}

impl Encode for EcdhKey {
    fn encode(&self, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
        ensure_size!(in: dst, size: self.size());

        dst.write_slice(self.curve.into());

        dst.write_u32(self.key_length);

        let key_len: usize = cast_int!("EcdhKey", "key len", self.key_length)?;

        if key_len < self.x.bits().div_ceil(8) || key_len < self.y.bits().div_ceil(8) {
            return Err(EncodeError::invalid_field("EcdhKey", "key_length", "too small"));
        }

        let mut x = self.x.to_bytes_be();
        pad_key_buffer(key_len, &mut x)?;
        dst.write_slice(&x);

        let mut y = self.y.to_bytes_be();
        pad_key_buffer(key_len, &mut y)?;
        dst.write_slice(&y);

        Ok(())
    }

    fn name(&self) -> &'static str {
        Self::NAME
    }

    fn size(&self) -> usize {
        Self::FIXED_PART_SIZE + 2 * usize::try_from(self.key_length).unwrap()
    }
}

impl DecodeOwned for EcdhKey {
    fn decode_owned(src: &mut ReadCursor<'_>) -> DecodeResult<Self> {
        ensure_size!(in: src, size: Self::FIXED_PART_SIZE);

        let curve_id = src.read_slice(4);
        let curve = EllipticCurve::try_from(curve_id)?;

        let key_length = src.read_u32();
        let key_len = { cast_int!("EcdgKey", "key len", key_length) as DecodeResult<_> }?;

        ensure_size!(in: src, size: key_len * 2);

        Ok(Self {
            curve,
            key_length,
            x: BigUint::from_bytes_be(src.read_slice(key_len)),
            y: BigUint::from_bytes_be(src.read_slice(key_len)),
        })
    }
}

/// Key Identifier
///
/// This contains the key identifier info that can be used by MS-GKDI GetKey to retrieve the group key seed values.
/// This structure is not defined publicly by Microsoft but it closely matches the [GroupKeyEnvelope] structure.
#[derive(Debug, Clone, PartialEq, Eq, Default)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
pub struct KeyIdentifier {
    /// The version of the structure.
    pub version: u32,
    /// Flags describing the values inside the structure.
    pub flags: u32,

    /// The L0 index of the key.
    pub l0: i32,
    /// The L1 index of the key.
    pub l1: i32,
    /// The L2 index of the key.
    pub l2: i32,
    /// A GUID that identifies a root key.
    pub root_key_identifier: Uuid,

    /// Key info.
    pub key_info: Vec<u8>,
    /// The domain name of the server in DNS format.
    pub domain_name: String,
    /// The forest name of the server in DNS format.
    pub forest_name: String,
}

impl KeyIdentifier {
    pub const DEFAULT_VERSION: u32 = 1;
    // https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gkdi/192c061c-e740-4aa0-ab1d-6954fb3e58f7
    const MAGIC: [u8; 4] = [0x4b, 0x44, 0x53, 0x4b];
    const FIXED_PART_SIZE: usize = 4 /* version */ + Self::MAGIC.len() + 4 /* flags */ + 4 /* l0 */ + 4 /* l1 */ + 4 /* l2 */
        + Uuid::FIXED_PART_SIZE /* root_key_identifier */ + 4 /* key_info len */ + 4 /* domain_name len */
        + 4 /* forest_name len */;

    pub fn is_public_key(&self) -> bool {
        self.flags & 1 != 0
    }
}

impl StaticName for KeyIdentifier {
    const NAME: &'static str = "KeyIdentifier";
}

impl Encode for KeyIdentifier {
    fn encode(&self, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
        ensure_size!(in: dst, size: self.size());

        dst.write_u32(self.version);
        dst.write_slice(&Self::MAGIC);
        dst.write_u32(self.flags);

        dst.write_i32(self.l0);
        dst.write_i32(self.l1);
        dst.write_i32(self.l2);

        encode_uuid(self.root_key_identifier, dst)?;

        dst.write_u32(cast_length!("KeyIdentifier", "key len", self.key_info.len())?);
        dst.write_u32(cast_length!(
            "KeyIdentifier",
            "domain name len",
            str_utf16_len(&self.domain_name)
        )?);
        dst.write_u32(cast_length!(
            "KeyIdentifier",
            "forest name len",
            str_utf16_len(&self.forest_name)
        )?);

        dst.write_slice(&self.key_info);
        encode_utf16_le(&self.domain_name, dst);
        encode_utf16_le(&self.forest_name, dst);

        Ok(())
    }

    fn name(&self) -> &'static str {
        Self::NAME
    }

    fn size(&self) -> usize {
        Self::FIXED_PART_SIZE
            + self.key_info.len()
            + str_utf16_len(&self.domain_name)
            + str_utf16_len(&self.forest_name)
    }
}

impl DecodeOwned for KeyIdentifier {
    fn decode_owned(src: &mut ReadCursor<'_>) -> DecodeResult<Self> {
        ensure_size!(in: src, size: Self::FIXED_PART_SIZE);

        let version = src.read_u32();

        let magic = src.read_slice(Self::MAGIC.len());

        if magic != Self::MAGIC {
            Err(GkdiError::InvalidMagic {
                name: "KeyIdentifier",
                expected: Self::MAGIC.as_slice(),
                actual: magic.to_vec(),
            })?;
        }

        let flags = src.read_u32();

        let l0 = src.read_i32();
        let l1 = src.read_i32();
        let l2 = src.read_i32();
        let root_key_identifier = decode_uuid(src)?;

        let key_info_len = { cast_int!("KeyIdentifier", "key info len", src.read_u32()) as DecodeResult<_> }?;

        let domain_len = { cast_int!("KeyIdentifier", "domain name len", src.read_u32()) as DecodeResult<_> }?;
        if domain_len < 2 {
            Err(Error::InvalidLength {
                name: "KeyIdentifier domain name",
                expected: 2,
                actual: domain_len,
            })?;
        }

        let forest_len = { cast_int!("KeyIdentifier", "forest name len", src.read_u32()) as DecodeResult<_> }?;
        if forest_len < 2 {
            Err(Error::InvalidLength {
                name: "KeyIdentifier forest name",
                expected: 2,
                actual: forest_len,
            })?;
        }

        ensure_size!(in: src, size: key_info_len);
        let key_info = src.read_slice(key_info_len).to_vec();

        Ok(Self {
            version,
            flags,
            l0,
            l1,
            l2,
            root_key_identifier,
            key_info,
            domain_name: read_c_str_utf16_le(domain_len, src)?,
            forest_name: read_c_str_utf16_le(forest_len, src)?,
        })
    }
}

/// [Group Key Envelope](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gkdi/192c061c-e740-4aa0-ab1d-6954fb3e58f7)
///
/// The following specifies the format and field descriptions for the Group Key Envelope structure.
#[derive(Debug, Clone, PartialEq, Eq)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
pub struct GroupKeyEnvelope {
    /// A 32-bit unsigned integer. Bit 31 (LSB) MUST be set to 1 when this structure is being used to
    /// transport a public key, otherwise set to 0. Bit 30 MUST be set to 1 when the key being transported
    /// by this structure might be used for encryption and decryption, otherwise it should only be used for decryption.
    /// This field is encoded using little-endian format.
    pub flags: u32,
    /// This field MUST be the L0 index of the key being enveloped. This field is encoded using little-endian format.
    pub l0: i32,
    /// This field MUST be the L1 index of the key being enveloped, and therefore MUST be a number between 0 and 31, inclusive.
    /// This field is encoded using little-endian format.
    pub l1: i32,
    /// This field MUST be the L2 index of the key being enveloped, and therefore MUST be a number between 0 and 31, inclusive.
    /// This field is encoded using little-endian format.
    pub l2: i32,
    /// A GUID containing the root key identifier of the key being enveloped.
    pub root_key_identifier: Uuid,
    /// This field MUST be the ADM element KDF algorithm name associated with the ADM element root key,
    /// whose identifier is in the Root key identifier field.
    pub kdf_alg: String,
    /// This field MUST contain the KDF parameters associated with the ADM element root key,
    /// whose identifier is in the Root key identifier field.
    pub kdf_parameters: Vec<u8>,
    /// This field MUST be the ADM element Secret agreement algorithm name associated with the ADM element root key,
    /// whose identifier is in the Root key identifier field.
    pub secret_algorithm: String,
    /// This field MUST contain the ADM element Secret agreement algorithm associated with the ADM element root key,
    /// whose identifier is in the Root key identifier field.
    pub secret_parameters: Vec<u8>,
    /// A 32-bit unsigned integer. This field MUST be the private key length associated with the root key,
    /// whose identifier is in the Root key identifier field. This field is encoded using little-endian format.
    pub private_key_length: u32,
    /// A 32-bit unsigned integer. This field MUST be the public key length associated with the root key,
    /// whose identifier is in the Root key identifier field. This field is encoded using little-endian format.
    pub public_key_length: u32,
    /// This field MUST be the domain name of the server in DNS format.
    pub domain_name: String,
    /// This field MUST be the forest name of the server in DNS format.
    pub forest_name: String,
    /// An L1 seed key ADM element in binary form.
    pub l1_key: Vec<u8>,
    /// The L2 seed key ADM element or the group public key ADM element with group key identifier in binary form.
    pub l2_key: Vec<u8>,
}

impl GroupKeyEnvelope {
    // The following magic value is defined in the Microsoft documentation:
    // https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gkdi/192c061c-e740-4aa0-ab1d-6954fb3e58f7
    const MAGIC: &[u8] = &[0x4B, 0x44, 0x53, 0x4B];
    const VERSION: u32 = 1;
    const FIXED_PART_SIZE: usize = 4 /* version */ + Self::MAGIC.len() + 4 /* flags */ + 4 /* l0 */ + 4 /* l1 */ + 4 /* l2 */
        + Uuid::FIXED_PART_SIZE /* root_key_identifier */
        + 4 /* encoded_kdf_alg */
        + 4 /* kdf_parameters */
        + 4 /* encoded_secret_alg */
        + 4 /* secret_parameters */
        + 4 /* private_key_length */
        + 4 /* public_key_length */
        + 4 /* l1_key */
        + 4 /* l2_key */
        + 4 /* encoded_domain_name */
        + 4 /* encoded_forest_name */;

    pub fn is_public_key(&self) -> bool {
        self.flags & 1 != 0
    }
}

impl StaticName for GroupKeyEnvelope {
    const NAME: &'static str = "GroupKeyEnvelope";
}

impl Encode for GroupKeyEnvelope {
    fn encode(&self, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
        ensure_size!(in: dst, size: self.size());

        dst.write_u32(Self::VERSION);

        dst.write_slice(Self::MAGIC);
        dst.write_u32(self.flags);
        dst.write_i32(self.l0);
        dst.write_i32(self.l1);
        dst.write_i32(self.l2);
        encode_uuid(self.root_key_identifier, dst)?;

        let encoded_kdf_alg_len = str_utf16_len(&self.kdf_alg);
        let encoded_secret_alg_len = str_utf16_len(&self.secret_algorithm);
        let encoded_domain_name_len = str_utf16_len(&self.domain_name);
        let encoded_forest_name_len = str_utf16_len(&self.forest_name);

        dst.write_u32(cast_length!("GroupKeyEnvelope", "", encoded_kdf_alg_len)?);
        dst.write_u32(cast_length!("GroupKeyEnvelope", "", self.kdf_parameters.len())?);
        dst.write_u32(cast_length!("GroupKeyEnvelope", "", encoded_secret_alg_len)?);
        dst.write_u32(cast_length!("GroupKeyEnvelope", "", self.secret_parameters.len())?);
        dst.write_u32(self.private_key_length);
        dst.write_u32(self.public_key_length);
        dst.write_u32(cast_length!("GroupKeyEnvelope", "", self.l1_key.len())?);
        dst.write_u32(cast_length!("GroupKeyEnvelope", "", self.l2_key.len())?);
        dst.write_u32(cast_length!("GroupKeyEnvelope", "", encoded_domain_name_len)?);
        dst.write_u32(cast_length!("GroupKeyEnvelope", "", encoded_forest_name_len)?);

        encode_utf16_le(&self.kdf_alg, dst);
        dst.write_slice(&self.kdf_parameters);
        encode_utf16_le(&self.secret_algorithm, dst);
        dst.write_slice(&self.secret_parameters);
        encode_utf16_le(&self.domain_name, dst);
        encode_utf16_le(&self.forest_name, dst);
        dst.write_slice(&self.l1_key);
        dst.write_slice(&self.l2_key);

        Ok(())
    }

    fn name(&self) -> &'static str {
        Self::NAME
    }

    fn size(&self) -> usize {
        let encoded_kdf_alg_len = str_utf16_len(&self.kdf_alg);
        let encoded_secret_alg_len = str_utf16_len(&self.secret_algorithm);
        let encoded_domain_name_len = str_utf16_len(&self.domain_name);
        let encoded_forest_name_len = str_utf16_len(&self.forest_name);

        Self::FIXED_PART_SIZE
            + encoded_kdf_alg_len
            + self.kdf_parameters.len()
            + encoded_secret_alg_len
            + self.secret_parameters.len()
            + encoded_domain_name_len
            + encoded_forest_name_len
            + self.l1_key.len()
            + self.l2_key.len()
    }
}

impl DecodeOwned for GroupKeyEnvelope {
    fn decode_owned(src: &mut ReadCursor<'_>) -> DecodeResult<Self> {
        ensure_size!(in: src, size: Self::FIXED_PART_SIZE);

        let version = src.read_u32();

        if version != Self::VERSION {
            Err(GkdiError::InvalidVersion {
                name: "GroupKeyEnvelope",
                expected: Self::VERSION,
                actual: version,
            })?;
        }

        let magic = src.read_slice(Self::MAGIC.len());

        if magic != Self::MAGIC {
            Err(GkdiError::InvalidMagic {
                name: "GroupKeyEnvelope",
                expected: Self::MAGIC,
                actual: magic.to_vec(),
            })?;
        }

        let flags = src.read_u32();
        let l0 = src.read_i32();
        let l1 = src.read_i32();
        let l2 = src.read_i32();
        let root_key_identifier = decode_uuid(src)?;

        let kdf_alg_len = { cast_int!("GroupKeyEnvelope", "", src.read_u32()) as DecodeResult<_> }?;
        let kdf_parameters_len = { cast_int!("GroupKeyEnvelope", "", src.read_u32()) as DecodeResult<_> }?;
        let secret_alg_len = { cast_int!("GroupKeyEnvelope", "", src.read_u32()) as DecodeResult<_> }?;
        let secret_parameters_len = { cast_int!("GroupKeyEnvelope", "", src.read_u32()) as DecodeResult<_> }?;
        let private_key_length = src.read_u32();
        let public_key_length = src.read_u32();
        let l1_key_len = { cast_int!("GroupKeyEnvelope", "", src.read_u32()) as DecodeResult<_> }?;
        let l2_key_len = { cast_int!("GroupKeyEnvelope", "", src.read_u32()) as DecodeResult<_> }?;
        let domain_len = { cast_int!("GroupKeyEnvelope", "", src.read_u32()) as DecodeResult<_> }?;
        let forest_len = { cast_int!("GroupKeyEnvelope", "", src.read_u32()) as DecodeResult<_> }?;

        let kdf_alg = read_c_str_utf16_le(kdf_alg_len, src)?;

        ensure_size!(in: src, size: kdf_parameters_len);
        let kdf_parameters = src.read_slice(kdf_parameters_len).to_vec();

        let secret_algorithm = read_c_str_utf16_le(secret_alg_len, src)?;

        ensure_size!(in: src, size: secret_parameters_len);
        let secret_parameters = src.read_slice(secret_parameters_len).to_vec();

        let domain_name = read_c_str_utf16_le(domain_len, src)?;
        let forest_name = read_c_str_utf16_le(forest_len, src)?;

        ensure_size!(in: src, size: l1_key_len);
        let l1_key = src.read_slice(l1_key_len).to_vec();

        ensure_size!(in: src, size: l2_key_len);
        let l2_key = src.read_slice(l2_key_len).to_vec();

        Ok(Self {
            flags,
            l0,
            l1,
            l2,
            root_key_identifier,
            kdf_alg,
            kdf_parameters,
            secret_algorithm,
            secret_parameters,
            private_key_length,
            public_key_length,
            domain_name,
            forest_name,
            l1_key,
            l2_key,
        })
    }
}


--- File: crates/dpapi-pdu/src/lib.rs ---
#![cfg_attr(not(feature = "std"), no_std)]

extern crate alloc;

mod error;
pub mod gkdi;
pub mod rpc;
pub use error::{Error, Result};


--- File: crates/dpapi-pdu/src/rpc/bind.rs ---
use alloc::string::String;
use alloc::vec::Vec;

use dpapi_core::{
    cast_length, compute_padding, decode_uuid, encode_seq, encode_uuid, ensure_size, read_padding, size_seq,
    write_padding, DecodeError, DecodeOwned, DecodeResult, Encode, EncodeResult, FixedPartSize, InvalidFieldErr,
    ReadCursor, StaticName, WriteCursor,
};
use thiserror::Error;
use uuid::Uuid;

#[derive(Debug, Error)]
pub enum BindError {
    #[error("invalid context result code value: {0}")]
    InvalidContextResultCode(u16),
}

impl From<BindError> for DecodeError {
    fn from(err: BindError) -> Self {
        match &err {
            BindError::InvalidContextResultCode(_) => {
                DecodeError::invalid_field("ContextResult", "context result code", "invalid value")
            }
        }
        .with_source(err)
    }
}

pub type BindResult<T> = core::result::Result<T, BindError>;

/// [BindTimeFeatureNegotiationBitmask](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-rpce/cef529cc-77b5-4794-85dc-91e1467e80f0)
///
/// The bind time feature negotiation bitmask is an array of eight octets, each of which is interpreted as a bitmask.
/// **Bitmask**: Currently, only the two least significant bits in the first element of the array are defined.
///
/// ```C
/// typedef struct {
///    unsigned char Bitmask[8];
/// } BindTimeFeatureNegotiationBitmask;
/// ```
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u64)]
pub enum BindTimeFeatureNegotiationBitmask {
    None = 0x0,
    /// Client supports security context multiplexing, as specified in section [3.3.1.5.4](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-rpce/c8b3c80f-b2ba-4a78-bf36-dabba4278194).
    SecurityContextMultiplexingSupported = 0x01,
    /// Client supports keeping the connection open after sending the orphaned PDU, as specified in section [3.3.1.5.10](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-rpce/44d6f02e-55f3-4814-973e-cf0bc3287c44).
    KeepConnectionOnOrphanSupported = 0x02,
}

impl BindTimeFeatureNegotiationBitmask {
    pub fn as_u64(&self) -> u64 {
        *self as u64
    }
}

/// [RPC_SYNTAX_IDENTIFIER](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-rpcl/1831bd1c-738c-45dc-a2af-5d0b835af6f5)
///
/// This structure MUST contain a 0GUID and version information (MS-RPCE section 2.2.2.7). It is
/// identical to the RPC_SYNTAX_IDENTIFIER structure used in the LocToLoc interface in section 3.1.4.
/// This structure is used to represent the following:
/// * Identifier and version of an interface.
/// * Identifier and version of [transfer syntax](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-rpcl/55ec267c-87d9-4d97-a9d5-5681f5f283b8#gt_01216ea7-ac8a-4cc8-9d19-b901bc424c09) for an interface.
#[derive(Debug, Clone, PartialEq, Eq)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
pub struct SyntaxId {
    pub uuid: Uuid,
    pub version: u16,
    pub version_minor: u16,
}

impl StaticName for SyntaxId {
    const NAME: &'static str = "SyntaxId";
}

impl FixedPartSize for SyntaxId {
    const FIXED_PART_SIZE: usize = 16 /* uuid */ + 2 /* version */ + 2 /* version_minor */;
}

impl Encode for SyntaxId {
    fn encode(&self, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
        ensure_size!(in: dst, size: self.size());

        encode_uuid(self.uuid, dst)?;
        dst.write_u16(self.version);
        dst.write_u16(self.version_minor);

        Ok(())
    }

    fn name(&self) -> &'static str {
        Self::NAME
    }

    fn size(&self) -> usize {
        Self::FIXED_PART_SIZE
    }
}

impl DecodeOwned for SyntaxId {
    fn decode_owned(src: &mut ReadCursor) -> DecodeResult<Self> {
        ensure_size!(in: src, size: Self::FIXED_PART_SIZE);

        Ok(Self {
            uuid: decode_uuid(src)?,
            version: src.read_u16(),
            version_minor: src.read_u16(),
        })
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
pub struct ContextElement {
    pub context_id: u16,
    pub abstract_syntax: SyntaxId,
    pub transfer_syntaxes: Vec<SyntaxId>,
}

impl StaticName for ContextElement {
    const NAME: &'static str = "ContextElement";
}

impl FixedPartSize for ContextElement {
    const FIXED_PART_SIZE: usize = 2 /* context_id */ + 2 /* transfer_syntaxes length */ + SyntaxId::FIXED_PART_SIZE;
}

impl Encode for ContextElement {
    fn encode(&self, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
        ensure_size!(in: dst, size: self.size());

        dst.write_u16(self.context_id);
        dst.write_u16(cast_length!(
            "ContextElement",
            "transfer syntaxes count",
            self.transfer_syntaxes.len()
        )?);

        self.abstract_syntax.encode(dst)?;
        encode_seq(&self.transfer_syntaxes, dst)?;

        Ok(())
    }

    fn name(&self) -> &'static str {
        Self::NAME
    }

    fn size(&self) -> usize {
        Self::FIXED_PART_SIZE + size_seq(&self.transfer_syntaxes)
    }
}

impl DecodeOwned for ContextElement {
    fn decode_owned(src: &mut ReadCursor<'_>) -> DecodeResult<ContextElement> {
        ensure_size!(in: src, size: Self::FIXED_PART_SIZE);

        let context_id = src.read_u16();
        let transfer_syntaxes_count = usize::from(src.read_u16());
        let abstract_syntax = SyntaxId::decode_owned(src)?;

        let transfer_syntaxes = (0..transfer_syntaxes_count)
            .map(|_| SyntaxId::decode_owned(src))
            .collect::<DecodeResult<Vec<_>>>()?;

        Ok(Self {
            context_id,
            abstract_syntax,
            transfer_syntaxes,
        })
    }
}

/// [`p_cont_def_result_t` Enumerator](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-rpce/8df5c4d4-364d-468c-81fe-ec94c1b40917)
///
/// These extensions specify a new member, `negotiate_ack`, which is added to the `p_cont_def_result_t` enumeration
/// (specified in C706 section 12.6), with the numeric value of `3`.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
#[repr(u16)]
pub enum ContextResultCode {
    Acceptance = 0,
    UserRejection = 1,
    ProviderRejection = 2,
    NegotiateAck = 3, // MS-RPCE extension
}

impl ContextResultCode {
    pub fn as_u16(&self) -> u16 {
        *self as u16
    }
}

impl TryFrom<u16> for ContextResultCode {
    type Error = BindError;

    fn try_from(v: u16) -> BindResult<Self> {
        match v {
            0 => Ok(Self::Acceptance),
            1 => Ok(Self::UserRejection),
            2 => Ok(Self::ProviderRejection),
            3 => Ok(Self::NegotiateAck),
            v => Err(BindError::InvalidContextResultCode(v)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
pub struct ContextResult {
    pub result: ContextResultCode,
    pub reason: u16,
    pub syntax: Uuid,
    pub syntax_version: u32,
}

impl StaticName for ContextResult {
    const NAME: &'static str = "ContextResult";
}

impl FixedPartSize for ContextResult {
    const FIXED_PART_SIZE: usize = 2 /* result */ + 2 /* reason */ + 16 /* syntax */ + 4 /* syntax_version */;
}

impl Encode for ContextResult {
    fn encode(&self, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
        ensure_size!(in: dst, size: self.size());

        dst.write_u16(self.result.as_u16());
        dst.write_u16(self.reason);
        encode_uuid(self.syntax, dst)?;
        dst.write_u32(self.syntax_version);

        Ok(())
    }

    fn name(&self) -> &'static str {
        Self::NAME
    }

    fn size(&self) -> usize {
        Self::FIXED_PART_SIZE
    }
}

impl DecodeOwned for ContextResult {
    fn decode_owned(src: &mut ReadCursor<'_>) -> DecodeResult<Self> {
        ensure_size!(in: src, size: Self::FIXED_PART_SIZE);

        Ok(Self {
            result: src.read_u16().try_into()?,
            reason: src.read_u16(),
            syntax: decode_uuid(src)?,
            syntax_version: src.read_u32(),
        })
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
pub struct Bind {
    pub max_xmit_frag: u16,
    pub max_recv_frag: u16,
    pub assoc_group: u32,
    pub contexts: Vec<ContextElement>,
}

impl StaticName for Bind {
    const NAME: &'static str = "Bind";
}

impl FixedPartSize for Bind {
    const FIXED_PART_SIZE: usize = 2 /* max_xmit_frag */ + 2 /* max_recv_frag */ + 4 /* assoc_group */ + 4 /* contexts length */;
}

impl Encode for Bind {
    fn encode(&self, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
        ensure_size!(in: dst, size: self.size());

        dst.write_u16(self.max_xmit_frag);
        dst.write_u16(self.max_recv_frag);
        dst.write_u32(self.assoc_group);
        dst.write_u32(cast_length!("Bind", "contexts count", self.contexts.len())?);
        encode_seq(&self.contexts, dst)?;

        Ok(())
    }

    fn name(&self) -> &'static str {
        Self::NAME
    }

    fn size(&self) -> usize {
        Self::FIXED_PART_SIZE + size_seq(&self.contexts)
    }
}

impl DecodeOwned for Bind {
    fn decode_owned(src: &mut ReadCursor<'_>) -> DecodeResult<Self> {
        ensure_size!(in: src, size: Self::FIXED_PART_SIZE);

        let max_xmit_frag = src.read_u16();
        let max_recv_frag = src.read_u16();
        let assoc_group = src.read_u32();

        let contexts_count = src.read_u32();
        let contexts = (0..contexts_count)
            .map(|_| ContextElement::decode_owned(src))
            .collect::<DecodeResult<Vec<_>>>()?;

        Ok(Self {
            max_xmit_frag,
            max_recv_frag,
            assoc_group,
            contexts,
        })
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
pub struct BindAck {
    pub max_xmit_frag: u16,
    pub max_recv_frag: u16,
    pub assoc_group: u32,
    pub sec_addr: String,
    pub results: Vec<ContextResult>,
}

impl StaticName for BindAck {
    const NAME: &'static str = "BindAck";
}

impl FixedPartSize for BindAck {
    const FIXED_PART_SIZE: usize = 2 /* max_xmit_frag */ + 2 /* max_recv_frag */ + 4 /* assoc_group */ + 2 /* sec_addr lenght in bytes */;
}

impl Encode for BindAck {
    fn encode(&self, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
        ensure_size!(in: dst, size: self.size());

        dst.write_u16(self.max_xmit_frag);
        dst.write_u16(self.max_recv_frag);
        dst.write_u32(self.assoc_group);

        let sec_addr_len = if !self.sec_addr.is_empty() {
            let sec_addr_len = self.sec_addr.len() + 1 /* null-byte */;
            dst.write_u16(cast_length!("BindAck", "security address len", sec_addr_len)?);

            dst.write_slice(self.sec_addr.as_bytes());
            dst.write_u8(0);

            sec_addr_len
        } else {
            dst.write_u16(0);

            0
        } + 2 /* length in bytes */;

        write_padding(compute_padding(4, sec_addr_len), dst)?;

        dst.write_u32(cast_length!("BindAck", "results count", self.results.len())?);
        encode_seq(&self.results, dst)?;

        Ok(())
    }

    fn name(&self) -> &'static str {
        Self::NAME
    }

    fn size(&self) -> usize {
        let sec_addr_len = if !self.sec_addr.is_empty() { self.sec_addr.len() + 1 } else { 0 } + 2 /* sec_addr lenght in bytes */;

        2 /* max_xmit_frag */ + 2 /* max_recv_frag */ + 4 /* assoc_group */ + sec_addr_len + compute_padding(4, sec_addr_len) + 4 /* results length */ + size_seq(&self.results)
    }
}

impl DecodeOwned for BindAck {
    fn decode_owned(src: &mut ReadCursor<'_>) -> DecodeResult<Self> {
        ensure_size!(in: src, size: Self::FIXED_PART_SIZE);

        Ok(Self {
            max_xmit_frag: src.read_u16(),
            max_recv_frag: src.read_u16(),
            assoc_group: src.read_u32(),
            sec_addr: {
                let sec_addr_len = usize::from(src.read_u16());
                let sec_addr = if sec_addr_len > 0 {
                    ensure_size!(in: src, size: sec_addr_len);

                    let buf = src.read_slice(sec_addr_len - 1 /* null byte */).to_vec();
                    // Read null-terminator byte.
                    src.read_u8();

                    String::from_utf8(buf).map_err(|err| {
                        DecodeError::invalid_field("BindAck", "security address", "broken UTF-8").with_source(err)
                    })?
                } else {
                    String::new()
                };

                read_padding(compute_padding(4, sec_addr_len + 2), src)?;

                sec_addr
            },
            results: {
                ensure_size!(in: src, size: 4);
                let results_count = src.read_u32();

                (0..results_count)
                    .map(|_| ContextResult::decode_owned(src))
                    .collect::<DecodeResult<Vec<_>>>()?
            },
        })
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
pub struct Version(u8, u8);

impl StaticName for Version {
    const NAME: &'static str = "Version";
}

impl FixedPartSize for Version {
    const FIXED_PART_SIZE: usize = 2;
}

impl Encode for Version {
    fn encode(&self, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
        ensure_size!(in: dst, size: self.size());

        dst.write_u8(self.0);
        dst.write_u8(self.1);

        Ok(())
    }

    fn name(&self) -> &'static str {
        Self::NAME
    }

    fn size(&self) -> usize {
        Self::FIXED_PART_SIZE
    }
}

impl DecodeOwned for Version {
    fn decode_owned(src: &mut ReadCursor<'_>) -> DecodeResult<Self> {
        ensure_size!(in: src, size: Self::FIXED_PART_SIZE);

        Ok(Version(src.read_u8(), src.read_u8()))
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
pub struct BindNak {
    pub reason: u16,
    pub versions: Vec<Version>,
}

impl StaticName for BindNak {
    const NAME: &'static str = "BindNak";
}

impl FixedPartSize for BindNak {
    const FIXED_PART_SIZE: usize = 2 /* reason */ + 1 /* versions len */;
}

impl Encode for BindNak {
    fn encode(&self, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
        ensure_size!(in: dst, size: self.size());

        dst.write_u16(self.reason);

        dst.write_u8(cast_length!("BindNak", "versions count", self.versions.len())?);
        encode_seq(&self.versions, dst)?;

        let versions_buf_len = 1 /* len */ + size_seq(&self.versions);
        write_padding(compute_padding(4, versions_buf_len), dst)?;

        Ok(())
    }

    fn name(&self) -> &'static str {
        Self::NAME
    }

    fn size(&self) -> usize {
        let versions_size = size_seq(&self.versions);

        Self::FIXED_PART_SIZE + versions_size + compute_padding(4, versions_size + 1 /* versions len */)
    }
}

impl DecodeOwned for BindNak {
    fn decode_owned(src: &mut ReadCursor<'_>) -> DecodeResult<Self> {
        ensure_size!(in: src, size: Self::FIXED_PART_SIZE);

        Ok(Self {
            reason: src.read_u16(),
            versions: {
                let versions_count = usize::from(src.read_u8());
                let versions = (0..versions_count)
                    .map(|_| Version::decode_owned(src))
                    .collect::<DecodeResult<Vec<_>>>()?;

                let versions_buf_len = 1 /* len */ + size_seq(&versions);
                read_padding(compute_padding(4, versions_buf_len), src)?;

                versions
            },
        })
    }
}

// `AlterContext` has the same layout as `Bind`.
#[derive(Debug, Clone, PartialEq, Eq)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
pub struct AlterContext(pub Bind);

impl StaticName for AlterContext {
    const NAME: &'static str = "AlterContext";
}

impl FixedPartSize for AlterContext {
    const FIXED_PART_SIZE: usize = Bind::FIXED_PART_SIZE;
}

impl Encode for AlterContext {
    fn encode(&self, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
        ensure_size!(in: dst, size: self.size());

        self.0.encode(dst)
    }

    fn name(&self) -> &'static str {
        Self::NAME
    }

    fn size(&self) -> usize {
        self.0.size()
    }
}

impl DecodeOwned for AlterContext {
    fn decode_owned(src: &mut ReadCursor<'_>) -> DecodeResult<Self> {
        Ok(Self(Bind::decode_owned(src)?))
    }
}

// `AlterContextResponse` has the same layout as `BindAck`.
#[derive(Debug, Clone, PartialEq, Eq)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
pub struct AlterContextResponse(pub BindAck);

impl StaticName for AlterContextResponse {
    const NAME: &'static str = "AlterContextResponse";
}

impl FixedPartSize for AlterContextResponse {
    const FIXED_PART_SIZE: usize = BindAck::FIXED_PART_SIZE;
}

impl Encode for AlterContextResponse {
    fn encode(&self, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
        ensure_size!(in: dst, size: self.size());

        self.0.encode(dst)
    }

    fn name(&self) -> &'static str {
        Self::NAME
    }

    fn size(&self) -> usize {
        self.0.size()
    }
}

impl DecodeOwned for AlterContextResponse {
    fn decode_owned(src: &mut ReadCursor<'_>) -> DecodeResult<Self> {
        Ok(Self(BindAck::decode_owned(src)?))
    }
}


--- File: crates/dpapi-pdu/src/rpc/epm.rs ---
use alloc::vec::Vec;
use alloc::{format, vec};

use dpapi_core::{
    cast_int, cast_length, compute_padding, decode_uuid, encode_buf, encode_uuid, ensure_size, read_padding, size_seq,
    write_padding, DecodeError, DecodeOwned, DecodeResult, DecodeWithContextOwned, Encode, EncodeResult, FixedPartSize,
    InvalidFieldErr, NeedsContext, ReadCursor, StaticName, UnsupportedValueErr, WriteBuf, WriteCursor,
};
use num_derive::FromPrimitive;
use num_traits::FromPrimitive;
use thiserror::Error;
use uuid::{uuid, Uuid};

use crate::rpc::SyntaxId;

#[derive(Debug, Error)]
pub enum EpmError {
    #[error("invalid floor protocol: {0}")]
    InvalidFloorProtocol(u8),

    #[error("invalid floor value: {0}")]
    InvalidFloorValue(&'static str),

    #[error("unsupported floor protocol: {0:?}")]
    UnsupportedFloor(FloorProtocol),
}

impl From<EpmError> for DecodeError {
    fn from(err: EpmError) -> Self {
        match &err {
            EpmError::InvalidFloorProtocol(_) => DecodeError::invalid_field("Floor", "floor protocol", "invalid value"),
            EpmError::InvalidFloorValue(_) => DecodeError::invalid_field("Floor", "floor value", "invalid value"),
            EpmError::UnsupportedFloor(floor_protocol) => {
                DecodeError::unsupported_value("Floor", "floor", format!("{:?}", floor_protocol))
            }
        }
        .with_source(err)
    }
}

pub const EPM: SyntaxId = SyntaxId {
    uuid: uuid!("e1af8308-5d1f-11c9-91a4-08002b14a0fa"),
    version: 3,
    version_minor: 0,
};

#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive)]
#[repr(u8)]
pub enum FloorProtocol {
    Osi = 0x00,
    DnaSessionControl = 0x02,
    DnaSessionControlV3 = 0x03,
    DnaNspTransport = 0x04,
    Tp4 = 0x05,
    Clns = 0x06,
    Tcp = 0x07,
    Udp = 0x08,
    Ip = 0x09,
    RpcConnectionless = 0x0a,
    RpcConnectionOriented = 0x0b,
    UuidId = 0x0d,
    NamedPipes = 0x10,
    NetBios = 0x11,
    NetBeui = 0x12,
    NetWareSpx = 0x13,
    NetWareIpx = 0x14,
    AppleTalkStream = 0x16,
    AppleTalkDataram = 0x17,
    AppleTalk = 0x18,
    NetBios2 = 0x19,
    VinesSpp = 0x1a,
    VinesIpc = 0x1b,
    StreetTalk = 0x1c,
    UnixDomainSocket = 0x20,
    Null = 0x21,
    NetBios3 = 0x22,
}

impl FloorProtocol {
    pub fn as_u8(&self) -> u8 {
        *self as u8
    }
}

pub struct BaseFloor {
    pub protocol: FloorProtocol,
    pub lhs: Vec<u8>,
    pub rhs: Vec<u8>,
}

impl FixedPartSize for BaseFloor {
    const FIXED_PART_SIZE: usize = 2 /* lhs + protocol byte length */ + 1 /* protocol byte */;
}

impl BaseFloor {
    pub fn new(protocol: FloorProtocol, lhs: Vec<u8>, rhs: Vec<u8>) -> Self {
        Self { protocol, lhs, rhs }
    }
}

impl Encode for BaseFloor {
    fn encode(&self, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
        ensure_size!(in: dst, size: self.size());

        dst.write_u16(cast_length!(
            "Floor",
            "lhs + protocol byte len",
            self.lhs.len() + 1 /* protocol byte */
        )?);
        dst.write_u8(self.protocol.as_u8());
        dst.write_slice(&self.lhs);

        dst.write_u16(cast_length!("Floor", "rhs len", self.rhs.len())?);
        dst.write_slice(&self.rhs);

        Ok(())
    }

    fn name(&self) -> &'static str {
        "BaseFloor"
    }

    fn size(&self) -> usize {
        Self::FIXED_PART_SIZE + self.lhs.len() + 2 /* rhs len */ + self.rhs.len()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
pub struct TcpFloor {
    pub port: u16,
}

impl Encode for TcpFloor {
    fn encode(&self, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
        BaseFloor::new(FloorProtocol::Tcp, Vec::new(), self.port.to_be_bytes().to_vec()).encode(dst)
    }

    fn name(&self) -> &'static str {
        "TcpFloor"
    }

    fn size(&self) -> usize {
        BaseFloor::new(FloorProtocol::Tcp, Vec::new(), self.port.to_be_bytes().to_vec()).size()
    }
}

impl NeedsContext for TcpFloor {
    type Context<'ctx> = usize;
}

impl DecodeWithContextOwned for TcpFloor {
    fn decode_with_context_owned(src: &mut ReadCursor<'_>, ctx: Self::Context<'_>) -> DecodeResult<Self> {
        if ctx != 0 {
            return Err(DecodeError::invalid_field(
                "TcpFloor",
                "lhs len",
                "lhs len is greater then 0",
            ));
        }

        ensure_size!(in: src, size: 2 /* rhs len */);
        let rhs_len = usize::from(src.read_u16());

        ensure_size!(in: src, size: rhs_len);
        let rhs = src.read_slice(rhs_len).to_vec();

        if rhs.len() != 2 {
            Err(EpmError::InvalidFloorValue(
                "invalid TcpFloor rhs value length: expected exactly 2 bytes",
            ))?;
        }

        Ok(Self {
            port: u16::from_be_bytes(rhs.try_into().unwrap()),
        })
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
pub struct IpFloor {
    pub addr: u32,
}

impl NeedsContext for IpFloor {
    type Context<'ctx> = usize;
}

impl Encode for IpFloor {
    fn encode(&self, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
        BaseFloor::new(FloorProtocol::Ip, Vec::new(), self.addr.to_be_bytes().to_vec()).encode(dst)
    }

    fn name(&self) -> &'static str {
        "IpFloor"
    }

    fn size(&self) -> usize {
        BaseFloor::new(FloorProtocol::Ip, Vec::new(), self.addr.to_be_bytes().to_vec()).size()
    }
}

impl DecodeWithContextOwned for IpFloor {
    fn decode_with_context_owned(src: &mut ReadCursor<'_>, ctx: Self::Context<'_>) -> DecodeResult<Self> {
        if ctx != 0 {
            return Err(DecodeError::invalid_field(
                "IpFloor",
                "lhs len",
                "lhs len is greater then 0",
            ));
        }

        ensure_size!(in: src, size: 2 /* rhs len */);
        let rhs_len = usize::from(src.read_u16());

        ensure_size!(in: src, size: rhs_len);
        let rhs = src.read_slice(rhs_len).to_vec();

        if rhs.len() != 4 {
            Err(EpmError::InvalidFloorValue(
                "invalid IpFloor rhs value length: expected exactly 4 bytes",
            ))?;
        }

        Ok(Self {
            addr: u32::from_be_bytes(rhs.try_into().unwrap()),
        })
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
pub struct RpcConnectionOrientedFloor {
    pub version_minor: u16,
}

impl NeedsContext for RpcConnectionOrientedFloor {
    type Context<'ctx> = usize;
}

impl Encode for RpcConnectionOrientedFloor {
    fn encode(&self, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
        BaseFloor::new(
            FloorProtocol::RpcConnectionOriented,
            Vec::new(),
            self.version_minor.to_le_bytes().to_vec(),
        )
        .encode(dst)
    }

    fn name(&self) -> &'static str {
        "RpcConnectionOrientedFloor"
    }

    fn size(&self) -> usize {
        BaseFloor::new(
            FloorProtocol::RpcConnectionOriented,
            Vec::new(),
            self.version_minor.to_le_bytes().to_vec(),
        )
        .size()
    }
}

impl DecodeWithContextOwned for RpcConnectionOrientedFloor {
    fn decode_with_context_owned(src: &mut ReadCursor<'_>, ctx: Self::Context<'_>) -> DecodeResult<Self> {
        if ctx != 0 {
            return Err(DecodeError::invalid_field(
                "RpcConnectionOrientedFloor",
                "lhs len",
                "lhs len is greater then 0",
            ));
        }

        ensure_size!(in: src, size: 2 /* rhs len */);
        let rhs_len = usize::from(src.read_u16());

        if rhs_len != 2 {
            Err(EpmError::InvalidFloorValue(
                "invalid RpcConnectionOrientedFloor rhs value length: expected exactly 2 bytes",
            ))?;
        }

        ensure_size!(in: src, size: rhs_len);
        let rhs = src.read_slice(rhs_len).to_vec();

        Ok(Self {
            version_minor: u16::from_le_bytes(rhs.try_into().unwrap()),
        })
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
pub struct UuidFloor {
    pub uuid: Uuid,
    pub version: u16,
    pub version_minor: u16,
}

impl NeedsContext for UuidFloor {
    type Context<'ctx> = usize;
}

impl Encode for UuidFloor {
    fn encode(&self, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
        let mut lhs = self.uuid.to_bytes_le().to_vec();
        lhs.extend_from_slice(&self.version.to_le_bytes());

        BaseFloor::new(FloorProtocol::UuidId, lhs, self.version_minor.to_le_bytes().to_vec()).encode(dst)
    }

    fn name(&self) -> &'static str {
        "UuidFloor"
    }

    fn size(&self) -> usize {
        let mut lhs = self.uuid.to_bytes_le().to_vec();
        lhs.extend_from_slice(&self.version.to_le_bytes());

        BaseFloor::new(FloorProtocol::UuidId, lhs, self.version_minor.to_le_bytes().to_vec()).size()
    }
}

impl DecodeWithContextOwned for UuidFloor {
    fn decode_with_context_owned(src: &mut ReadCursor<'_>, ctx: Self::Context<'_>) -> DecodeResult<Self> {
        if ctx != Uuid::FIXED_PART_SIZE + 2
        /* versioh */
        {
            Err(EpmError::InvalidFloorValue(
                "invalid UuidFloor lhs value length: expected exactly 18 bytes",
            ))?;
        }

        ensure_size!(in: src, size: ctx);

        let lhs = src.read_slice(ctx);

        ensure_size!(in: src, size: 2);
        let rhs_len = usize::from(src.read_u16());

        if rhs_len != 2
        /* version minor */
        {
            Err(EpmError::InvalidFloorValue(
                "invalid UuidFloor rhs value length: expected exactly 2 bytes",
            ))?;
        }

        ensure_size!(in: src, size: rhs_len);
        let rhs = src.read_slice(rhs_len).to_vec();

        Ok(Self {
            uuid: decode_uuid(&mut ReadCursor::new(&lhs[0..Uuid::FIXED_PART_SIZE]))?,
            version: u16::from_le_bytes(lhs[Uuid::FIXED_PART_SIZE..].try_into().unwrap()),
            version_minor: u16::from_le_bytes(rhs.try_into().unwrap()),
        })
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
pub enum Floor {
    Tcp(TcpFloor),
    Ip(IpFloor),
    RpcConnectionOriented(RpcConnectionOrientedFloor),
    Uuid(UuidFloor),
}

impl StaticName for Floor {
    const NAME: &'static str = "Floor";
}

impl FixedPartSize for Floor {
    const FIXED_PART_SIZE: usize = 2 /* lhs + protocol byte length */ + 1 /* protocol byte */;
}

impl Encode for Floor {
    fn encode(&self, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
        match self {
            Floor::Tcp(tcp_floor) => tcp_floor.encode(dst),
            Floor::Ip(ip_floor) => ip_floor.encode(dst),
            Floor::RpcConnectionOriented(rpc_connection_oriented_floor) => rpc_connection_oriented_floor.encode(dst),
            Floor::Uuid(uuid_floor) => uuid_floor.encode(dst),
        }
    }

    fn name(&self) -> &'static str {
        Self::NAME
    }

    fn size(&self) -> usize {
        match self {
            Floor::Tcp(tcp_floor) => tcp_floor.size(),
            Floor::Ip(ip_floor) => ip_floor.size(),
            Floor::RpcConnectionOriented(rpc_connection_oriented_floor) => rpc_connection_oriented_floor.size(),
            Floor::Uuid(uuid_floor) => uuid_floor.size(),
        }
    }
}

impl DecodeOwned for Floor {
    fn decode_owned(src: &mut ReadCursor<'_>) -> DecodeResult<Self> {
        ensure_size!(in: src, size: Self::FIXED_PART_SIZE);

        let lhs_len = usize::from(src.read_u16().checked_sub(1).ok_or(DecodeError::invalid_field(
            "Floor",
            "lhs length",
            "lhs length is less then 1",
        ))?);

        let protocol_value = src.read_u8();
        let protocol = FloorProtocol::from_u8(protocol_value).ok_or(EpmError::InvalidFloorProtocol(protocol_value))?;

        Ok(match protocol {
            FloorProtocol::Tcp => Floor::Tcp(TcpFloor::decode_with_context_owned(src, lhs_len)?),
            FloorProtocol::Ip => Floor::Ip(IpFloor::decode_with_context_owned(src, lhs_len)?),
            FloorProtocol::RpcConnectionOriented => {
                Floor::RpcConnectionOriented(RpcConnectionOrientedFloor::decode_with_context_owned(src, lhs_len)?)
            }
            FloorProtocol::UuidId => Floor::Uuid(UuidFloor::decode_with_context_owned(src, lhs_len)?),
            protocol => Err(EpmError::UnsupportedFloor(protocol))?,
        })
    }
}

pub type Tower = Vec<Floor>;

pub fn build_tcpip_tower(service: SyntaxId, data_rep: SyntaxId, port: u16, addr: u32) -> Tower {
    vec![
        Floor::Uuid(UuidFloor {
            uuid: service.uuid,
            version: service.version,
            version_minor: service.version_minor,
        }),
        Floor::Uuid(UuidFloor {
            uuid: data_rep.uuid,
            version: data_rep.version,
            version_minor: data_rep.version_minor,
        }),
        Floor::RpcConnectionOriented(RpcConnectionOrientedFloor { version_minor: 0 }),
        Floor::Tcp(TcpFloor { port }),
        Floor::Ip(IpFloor { addr }),
    ]
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
pub struct EntryHandle(pub Option<(u32, Uuid)>);

impl StaticName for EntryHandle {
    const NAME: &'static str = "EntryHandle";
}

impl EntryHandle {
    const EMPTY_ENTRY_HANDLE: &[u8; 20] = &[0; 20];
}

impl FixedPartSize for EntryHandle {
    const FIXED_PART_SIZE: usize = Self::EMPTY_ENTRY_HANDLE.len();
}

impl Encode for EntryHandle {
    fn encode(&self, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
        ensure_size!(in: dst, size: self.size());

        if let Some(entry_handle) = self.0.as_ref() {
            dst.write_u32(entry_handle.0);
            encode_uuid(entry_handle.1, dst)?;
        } else {
            dst.write_slice(Self::EMPTY_ENTRY_HANDLE);
        }

        Ok(())
    }

    fn name(&self) -> &'static str {
        Self::NAME
    }

    fn size(&self) -> usize {
        Self::FIXED_PART_SIZE
    }
}

impl DecodeOwned for EntryHandle {
    fn decode_owned(src: &mut ReadCursor<'_>) -> DecodeResult<Self> {
        ensure_size!(in: src, size: Self::FIXED_PART_SIZE);

        let entry_handle_buf = src.read_slice(Self::FIXED_PART_SIZE);

        Ok(if entry_handle_buf != Self::EMPTY_ENTRY_HANDLE {
            Self(Some((
                u32::from_le_bytes(entry_handle_buf[0..4].try_into().unwrap()),
                decode_uuid(&mut ReadCursor::new(&entry_handle_buf[4..]))?,
            )))
        } else {
            Self(None)
        })
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
pub struct EptMap {
    pub obj: Option<Uuid>,
    pub tower: Tower,
    pub entry_handle: EntryHandle,
    pub max_towers: u32,
}

impl EptMap {
    pub const OPNUM: u16 = 3;
    const TOWER_REFERENT_ID_1: &[u8] = &[0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    const TOWER_REFERENT_ID_2: &[u8] = &[0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
}

impl StaticName for EptMap {
    const NAME: &'static str = "EptMap";
}

impl FixedPartSize for EptMap {
    const FIXED_PART_SIZE: usize = 8 /* obj with a referent id of 1 */ + Uuid::FIXED_PART_SIZE + 8 /* Tower referent id 2 */ + 8 /* encoded tower len */ + 4 /* encoded tower length */ + 2 /* floor length */;
}

impl Encode for EptMap {
    fn encode(&self, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
        ensure_size!(in: dst, size: self.size());

        // obj with a referent id of 1
        dst.write_slice(Self::TOWER_REFERENT_ID_1);

        if let Some(uuid) = self.obj {
            encode_uuid(uuid, dst)?;
        } else {
            dst.write_slice(&[0; 16]);
        }

        // Tower referent id 2
        dst.write_slice(Self::TOWER_REFERENT_ID_2);

        let mut encoded_tower = WriteBuf::new();
        encoded_tower.write_u16(cast_length!("EptMap", "towers count", self.tower.len())?);

        for floor in &self.tower {
            encode_buf(floor, &mut encoded_tower)?;
        }

        dst.write_u64(cast_length!("EptMap", "encoded tower", encoded_tower.filled_len())?);
        dst.write_u32(cast_length!("EptMap", "encoded tower", encoded_tower.filled_len())?);

        dst.write_slice(encoded_tower.filled());

        write_padding(compute_padding(8, encoded_tower.filled_len() + 4), dst)?;

        self.entry_handle.encode(dst)?;
        dst.write_u32(self.max_towers);

        Ok(())
    }

    fn name(&self) -> &'static str {
        Self::NAME
    }

    fn size(&self) -> usize {
        let encoded_tower_length = size_seq(&self.tower);
        let padding_len = compute_padding(
            8,
            encoded_tower_length + 2 /* tower amount */ + 4, /* encoded tower length */
        );

        Self::FIXED_PART_SIZE + encoded_tower_length + padding_len + self.entry_handle.size() + 4
        /* max_towers */
    }
}

impl DecodeOwned for EptMap {
    fn decode_owned(src: &mut ReadCursor<'_>) -> DecodeResult<Self> {
        ensure_size!(in: src, size: Self::FIXED_PART_SIZE);

        // obj with a referent id of 1
        src.read_u64();

        let obj = src.read_slice(Uuid::FIXED_PART_SIZE);

        let obj = if obj != [0; Uuid::FIXED_PART_SIZE] {
            Some(decode_uuid(&mut ReadCursor::new(obj))?)
        } else {
            None
        };

        // Tower referent id 2
        src.read_u64();

        let tower_length = { cast_length!("EptMap", "tower length", src.read_u64()) as DecodeResult<_> }?;
        if tower_length < 2
        /* floor length */
        {
            return Err(DecodeError::invalid_field(
                "EptMap",
                "tower length",
                "tower length is too small",
            ));
        }
        // encoded tower length
        src.read_u32();

        let tower_start = src.pos();

        let floor_length = usize::from(src.read_u16());

        let tower = (0..floor_length)
            .map(|_| Floor::decode_owned(src))
            .collect::<DecodeResult<Vec<Floor>>>()?;

        // invalid tower_length can lead to invalid padding and corrupted entry_handle and other fields.
        if src.pos() - tower_start != tower_length {
            return Err(DecodeError::invalid_field("EptMap", "tower length", "invalid value"));
        }

        let pad = compute_padding(8, {
            cast_length!(
                "RptMap",
                "towers count",
                tower_length + 4 /* encoded tower length */
            ) as DecodeResult<_>
        }?);
        read_padding(pad, src)?;

        let entry_handle = EntryHandle::decode_owned(src)?;
        ensure_size!(in: src, size: 4);
        let max_towers = src.read_u32();

        Ok(Self {
            obj,
            tower,
            entry_handle,
            max_towers,
        })
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
pub struct EptMapResult {
    pub entry_handle: EntryHandle,
    pub towers: Vec<Tower>,
    pub status: u32,
}

impl StaticName for EptMapResult {
    const NAME: &'static str = "EptMapResult";
}

impl FixedPartSize for EptMapResult {
    const FIXED_PART_SIZE: usize = EntryHandle::FIXED_PART_SIZE + 4 /* towers len */ + 8 /* towers len */ + 8 /* tower pointer offset */ + 8 /* towers len */;
}

impl Encode for EptMapResult {
    fn encode(&self, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
        ensure_size!(in: dst, size: self.size());

        self.entry_handle.encode(dst)?;

        dst.write_u32(cast_length!("EptMapResult", "towers count", self.towers.len())?);
        // max_tower_count
        dst.write_u64(cast_length!("EptMapResult", "max tower count", self.towers.len())?);

        // Tower pointer offset
        dst.write_u64(0);

        dst.write_u64(cast_length!("EptMapResult", "towers count", self.towers.len())?);

        for idx in 0..self.towers.len() {
            dst.write_u64(cast_length!("EptMapResult", "tower index", idx + 3)?);
        }

        for tower in &self.towers {
            let mut encoded_tower = WriteBuf::new();

            encoded_tower.write_u16(cast_length!("EptMapResult", "tower len", tower.len())?);

            for floor in tower {
                encode_buf(floor, &mut encoded_tower)?;
            }

            dst.write_u64(cast_length!(
                "EptMapResult",
                "encoded tower len",
                encoded_tower.filled_len()
            )?);
            dst.write_u32(cast_length!(
                "EptMapResult",
                "encoded tower len",
                encoded_tower.filled_len()
            )?);
            dst.write_slice(encoded_tower.filled());

            write_padding(compute_padding(4, encoded_tower.filled_len()), dst)?;
        }

        dst.write_u32(self.status);

        Ok(())
    }

    fn name(&self) -> &'static str {
        Self::NAME
    }

    fn size(&self) -> usize {
        Self::FIXED_PART_SIZE + self.towers.len() * 8 + self.towers.iter().map(|tower| {
            let encoded_tower_length = 2 /* tower len */ + size_seq(tower) + 8 /* encoded tower len */ + 4 /* encoded tower len */;
            let padding_len = compute_padding(4, encoded_tower_length);

            encoded_tower_length + padding_len
        }).sum::<usize>() + 4 /* status */
    }
}

impl DecodeOwned for EptMapResult {
    fn decode_owned(src: &mut ReadCursor<'_>) -> DecodeResult<Self> {
        ensure_size!(in: src, size: Self::FIXED_PART_SIZE);

        let entry_handle = EntryHandle::decode_owned(src)?;

        // num towers
        src.read_u32();
        // max tower count
        src.read_u64();
        // tower offset
        src.read_u64();

        let tower_count: usize = { cast_int!("EprMapResult", "tower count", src.read_u64()) as DecodeResult<_> }?;
        ensure_size!(in: src, size: tower_count.checked_mul(8).ok_or(DecodeError::invalid_field(
                "EptMapResult",
                "tower count",
                "tower count is too big",
            ))?
        );
        // Ignore referent ids
        for _ in 0..tower_count {
            src.read_u64();
        }

        let towers = (0..tower_count)
            .map(|_| {
                ensure_size!(in: src, size: 8 /* tower length */ + 4 + 2 /* floor length */);

                let tower_length = { cast_length!("EptMap", "tower length", src.read_u64()) as DecodeResult<_> }?;
                if tower_length < 2
                /* floor length */
                {
                    return Err(DecodeError::invalid_field(
                        "EptMap",
                        "tower length",
                        "tower length is too small",
                    ));
                }

                // encoded tower length
                src.read_u32();

                let tower_start = src.pos();
                let floor_length = src.read_u16();
                let tower = (0..floor_length)
                    .map(|_| Floor::decode_owned(src))
                    .collect::<DecodeResult<Vec<Floor>>>()?;

                // Invalid tower_length can lead to invalid padding and corrupted fields.
                if src.pos() - tower_start != tower_length {
                    return Err(DecodeError::invalid_field("EptMap", "tower length", "invalid value"));
                }

                read_padding(
                    compute_padding(4, {
                        cast_length!(
                            "EptMapResult",
                            "tower length",
                            tower_length.checked_add(4).ok_or(DecodeError::invalid_field(
                                "EptMapResult",
                                "tower length",
                                "tower length is too big",
                            ))?
                        ) as DecodeResult<_>
                    }?),
                    src,
                )?;

                Ok(tower)
            })
            .collect::<DecodeResult<Vec<Tower>>>()?;

        ensure_size!(in: src, size: 4);
        let status = src.read_u32();

        Ok(Self {
            entry_handle,
            towers,
            status,
        })
    }
}


--- File: crates/dpapi-pdu/src/rpc/mod.rs ---
mod bind;
mod epm;
mod pdu;
mod request;
mod verification;

pub use bind::{
    AlterContext, AlterContextResponse, Bind, BindAck, BindError, BindNak, BindTimeFeatureNegotiationBitmask,
    ContextElement, ContextResult, ContextResultCode, SyntaxId, Version,
};
pub use epm::{
    build_tcpip_tower, BaseFloor, EntryHandle, EpmError, EptMap, EptMapResult, Floor, FloorProtocol, IpFloor,
    RpcConnectionOrientedFloor, TcpFloor, Tower, UuidFloor, EPM,
};
pub use pdu::{
    AuthenticationLevel, CharacterRepr, DataRepr, Fault, FaultFlags, FloatingPointRepr, IntRepr, PacketFlags,
    PacketType, Pdu, PduData, PduError, PduHeader, SecurityProvider, SecurityTrailer,
};
pub use request::{Request, Response};
pub use verification::{
    Command, CommandBitmask, CommandError, CommandFlags, CommandHeader2, CommandPContext, CommandType,
    VerificationTrailer,
};


--- File: crates/dpapi-pdu/src/rpc/pdu.rs ---
use alloc::format;
use alloc::vec::Vec;

use dpapi_core::{
    compute_padding, ensure_size, read_padding, write_padding, DecodeError, DecodeOwned, DecodeResult,
    DecodeWithContextOwned, Encode, EncodeResult, FindLength, FixedPartSize, InvalidFieldErr, NeedsContext, OtherErr,
    ReadCursor, StaticName, UnsupportedValueErr, WriteCursor,
};
use num_derive::FromPrimitive;
use num_traits::FromPrimitive;
use thiserror::Error;

use crate::rpc::{AlterContext, AlterContextResponse, Bind, BindAck, BindNak, Request, Response};

#[derive(Error, Debug)]
pub enum PduError {
    #[error("invalid integer representation value: {0}")]
    InvalidIntRepr(u8),

    #[error("invalid character representation value: {0}")]
    InvalidCharacterRepr(u8),

    #[error("invalid floating point representation value: {0}")]
    InvalidFloatingPointRepr(u8),

    #[error("invalid packet type value: {0}")]
    InvalidPacketType(u8),

    #[error("invalid packet flags value: {0}")]
    InvalidPacketFlags(u8),

    #[error("invalid security provider value: {0}")]
    InvalidSecurityProvider(u8),

    #[error("invalid authentication level value: {0}")]
    InvalidAuthenticationLevel(u8),

    #[error("invalid fault flags value: {0}")]
    InvalidFaultFlags(u8),

    #[error("{0:?} PDU is not supported")]
    PduNotSupported(PacketType),

    #[error("invalid fragment (PDU) length: {0}")]
    InvalidFragLength(u16),

    #[error("RPC failed: {0}")]
    RpcFail(&'static str),
}

impl From<PduError> for DecodeError {
    fn from(err: PduError) -> Self {
        match &err {
            PduError::InvalidIntRepr(_) => DecodeError::invalid_field("PDU Header", "int repr", "invalid value"),
            PduError::InvalidCharacterRepr(_) => {
                DecodeError::invalid_field("PDU Header", "character repr", "invalid value")
            }
            PduError::InvalidFloatingPointRepr(_) => {
                DecodeError::invalid_field("PDU Header", "floating pint repr", "invalid value")
            }
            PduError::InvalidPacketType(_) => DecodeError::invalid_field("PDU Header", "packet type", "invalid value"),
            PduError::InvalidPacketFlags(_) => {
                DecodeError::invalid_field("PDU Header", "packet flags", "invalid value")
            }
            PduError::InvalidSecurityProvider(_) => {
                DecodeError::invalid_field("PDU Security Trailer", "security provider", "invalid value")
            }
            PduError::InvalidAuthenticationLevel(_) => {
                DecodeError::invalid_field("PDU Security Trailer", "authentication level", "invalid value")
            }
            PduError::InvalidFaultFlags(_) => DecodeError::invalid_field("Fault PDU", "fault flags", "invalid value"),
            PduError::PduNotSupported(packet_type) => {
                DecodeError::unsupported_value("", "PDU", format!("{:?}", packet_type))
            }
            PduError::InvalidFragLength(_) => DecodeError::invalid_field("PDU Header", "frag len", "instal value"),
            PduError::RpcFail(_) => DecodeError::other("RPC", "RPC failed"),
        }
        .with_source(err)
    }
}

pub type PduResult<T> = core::result::Result<T, PduError>;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Default, FromPrimitive)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
#[repr(u8)]
pub enum IntRepr {
    BigEndian = 0,
    #[default]
    LittleEndian = 1,
}

impl IntRepr {
    pub fn as_u8(&self) -> u8 {
        *self as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Default, FromPrimitive)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
#[repr(u8)]
pub enum CharacterRepr {
    #[default]
    Ascii = 0,
    Ebcdic = 1,
}

impl CharacterRepr {
    pub fn as_u8(&self) -> u8 {
        *self as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Default, FromPrimitive)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
#[repr(u8)]
pub enum FloatingPointRepr {
    #[default]
    Ieee = 0,
    Vax = 1,
    Cray = 2,
    Ibm = 3,
}

impl FloatingPointRepr {
    pub fn as_u8(&self) -> u8 {
        *self as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
#[repr(u8)]
pub enum PacketType {
    Request = 0,
    Ping = 1,
    Response = 2,
    Fault = 3,
    Working = 4,
    Nocall = 5,
    Reject = 6,
    Ack = 7,
    ClCancel = 8,
    Fack = 9,
    CancelAck = 10,
    Bind = 11,
    BindAck = 12,
    BindNak = 13,
    AlterContext = 14,
    AlterContextResponse = 15,
    Shutdown = 17,
    CoCancel = 18,
    Orphaned = 19,
}

impl PacketType {
    pub fn as_u8(&self) -> u8 {
        *self as u8
    }
}

bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Default)]
    #[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
    pub struct PacketFlags: u8 {
        const None = 0x00;
        const PfcFirstFrag = 0x01;
        const PfcLastFrag = 0x02;
        // PfcPendingCancel = 0x04,
        const PfcSupportHeaderSign = 0x04; // MS-RPCE extension used in Bind/AlterContext
        const PfcReserved1 = 0x08;
        const PfcConcMpx = 0x10;
        const PfcDidNotExecute = 0x20;
        const PfcMaybe = 0x40;
        const PfcObjectUuid = 0x80;
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Default)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
pub struct DataRepr {
    pub byte_order: IntRepr,
    pub character: CharacterRepr,
    pub floating_point: FloatingPointRepr,
}

impl StaticName for DataRepr {
    const NAME: &'static str = "DataRepr";
}

impl FixedPartSize for DataRepr {
    const FIXED_PART_SIZE: usize = 1 /* first octet */ + 1 /* floating point */ + 2 /* padding */;
}

impl Encode for DataRepr {
    fn encode(&self, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
        ensure_size!(in: dst, size: self.size());

        let first_octet = ((self.byte_order.as_u8()) << 4) | self.character.as_u8();
        dst.write_u8(first_octet);
        dst.write_u8(self.floating_point.as_u8());

        write_padding(compute_padding(4, 2), dst)?;

        Ok(())
    }

    fn name(&self) -> &'static str {
        Self::NAME
    }

    fn size(&self) -> usize {
        Self::FIXED_PART_SIZE
    }
}

impl DecodeOwned for DataRepr {
    fn decode_owned(src: &mut ReadCursor<'_>) -> DecodeResult<Self> {
        ensure_size!(in: src, size: Self::FIXED_PART_SIZE);

        let first_octet = src.read_u8();

        let integer_representation = (first_octet & 0b11110000) >> 4;
        let character_representation = first_octet & 0b00001111;
        let floating_representation = src.read_u8();

        let data_representation = Self {
            byte_order: IntRepr::from_u8(integer_representation)
                .ok_or(PduError::InvalidIntRepr(integer_representation))?,
            character: CharacterRepr::from_u8(character_representation)
                .ok_or(PduError::InvalidCharacterRepr(character_representation))?,
            floating_point: FloatingPointRepr::from_u8(floating_representation)
                .ok_or(PduError::InvalidFloatingPointRepr(floating_representation))?,
        };

        read_padding(compute_padding(4, 2), src)?;

        Ok(data_representation)
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
pub struct PduHeader {
    pub version: u8,
    pub version_minor: u8,
    pub packet_type: PacketType,
    pub packet_flags: PacketFlags,
    pub data_rep: DataRepr,
    pub frag_len: u16,
    pub auth_len: u16,
    pub call_id: u32,
}

impl StaticName for PduHeader {
    const NAME: &'static str = "PduHeader";
}

impl FixedPartSize for PduHeader {
    const FIXED_PART_SIZE: usize = 16;
}

impl Encode for PduHeader {
    fn encode(&self, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
        ensure_size!(in: dst, size: self.size());

        dst.write_u8(self.version);
        dst.write_u8(self.version_minor);
        dst.write_u8(self.packet_type.as_u8());
        dst.write_u8(self.packet_flags.bits());
        self.data_rep.encode(dst)?;
        dst.write_u16(self.frag_len);
        dst.write_u16(self.auth_len);
        dst.write_u32(self.call_id);

        Ok(())
    }

    fn name(&self) -> &'static str {
        Self::NAME
    }

    fn size(&self) -> usize {
        Self::FIXED_PART_SIZE
    }
}

impl DecodeOwned for PduHeader {
    fn decode_owned(src: &mut ReadCursor<'_>) -> DecodeResult<Self> {
        ensure_size!(in: src, size: Self::FIXED_PART_SIZE);

        Ok(Self {
            version: src.read_u8(),
            version_minor: src.read_u8(),
            packet_type: {
                let packet_type = src.read_u8();
                PacketType::from_u8(packet_type).ok_or(PduError::InvalidPacketType(packet_type))?
            },
            packet_flags: {
                let packet_flags = src.read_u8();
                PacketFlags::from_bits(packet_flags).ok_or(PduError::InvalidPacketFlags(packet_flags))?
            },
            data_rep: DataRepr::decode_owned(src)?,
            frag_len: src.read_u16(),
            auth_len: src.read_u16(),
            call_id: src.read_u32(),
        })
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
#[repr(u8)]
pub enum SecurityProvider {
    None = 0x00,
    GssNegotiate = 0x09,
    Winnt = 0x0a,
    GssSchannel = 0x0e,
    GssKerberos = 0x10,
    Netlogon = 0x44,
    Default = 0xff,
}

impl SecurityProvider {
    pub fn as_u8(&self) -> u8 {
        *self as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
#[repr(u8)]
pub enum AuthenticationLevel {
    Default = 0x00,
    None = 0x01,
    Connect = 0x02,
    Call = 0x03,
    Pkt = 0x04,
    PktIntegrity = 0x05,
    PktPrivacy = 0x06,
}

impl AuthenticationLevel {
    pub fn as_u8(&self) -> u8 {
        *self as u8
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
pub struct SecurityTrailer {
    pub security_type: SecurityProvider,
    pub level: AuthenticationLevel,
    pub pad_length: u8,
    pub context_id: u32,
    pub auth_value: Vec<u8>,
}

impl StaticName for SecurityTrailer {
    const NAME: &'static str = "SecurityTrailer";
}

impl FixedPartSize for SecurityTrailer {
    // `SecurityTrailer` size but without `auth_value`.
    const FIXED_PART_SIZE: usize = 8;
}

impl Encode for SecurityTrailer {
    fn encode(&self, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
        ensure_size!(in: dst, size: self.size());

        dst.write_u8(self.security_type.as_u8());
        dst.write_u8(self.level.as_u8());
        dst.write_u8(self.pad_length);
        dst.write_u8(0); // Auth-Rsrvd
        dst.write_u32(self.context_id);
        dst.write_slice(&self.auth_value);

        Ok(())
    }

    fn name(&self) -> &'static str {
        Self::NAME
    }

    fn size(&self) -> usize {
        Self::FIXED_PART_SIZE + self.auth_value.len()
    }
}

impl DecodeOwned for SecurityTrailer {
    fn decode_owned(src: &mut ReadCursor<'_>) -> DecodeResult<Self> {
        ensure_size!(in: src, size: Self::FIXED_PART_SIZE);

        let security_provider = src.read_u8();
        let authentication_level = src.read_u8();

        Ok(Self {
            security_type: SecurityProvider::from_u8(security_provider)
                .ok_or(PduError::InvalidSecurityProvider(security_provider))?,
            level: AuthenticationLevel::from_u8(authentication_level)
                .ok_or(PduError::InvalidAuthenticationLevel(authentication_level))?,
            pad_length: src.read_u8(),
            context_id: {
                // Skip Auth-Rsrvd.
                src.read_u8();

                src.read_u32()
            },
            auth_value: src.read_remaining().to_vec(),
        })
    }
}

bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Default)]
    #[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
    pub struct FaultFlags: u8 {
        const None = 0x00;
        const ExtendedErrorPresent = 0x01;
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
pub struct Fault {
    pub alloc_hint: u32,
    pub context_id: u16,
    pub cancel_count: u8,
    // Extension of MS-RPCE.
    pub flags: FaultFlags,
    pub status: u32,
    pub stub_data: Vec<u8>,
}

impl StaticName for Fault {
    const NAME: &'static str = "Fault PDU";
}

impl FixedPartSize for Fault {
    const FIXED_PART_SIZE: usize = 4 /* alloc_hint */ + 2 /* context_id */ + 1 /* cancel_count */ + 1 /* flags */ + 4 /* status */ + 4 /* padding */;
}

impl Encode for Fault {
    fn encode(&self, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
        ensure_size!(in: dst, size: self.size());

        dst.write_u32(self.alloc_hint);
        dst.write_u16(self.context_id);
        dst.write_u8(self.cancel_count);
        dst.write_u8(self.flags.bits());
        dst.write_u32(self.status);
        // alignment padding
        dst.write_u32(0);
        dst.write_slice(&self.stub_data);

        Ok(())
    }

    fn name(&self) -> &'static str {
        Self::NAME
    }

    fn size(&self) -> usize {
        Self::FIXED_PART_SIZE + self.stub_data.len()
    }
}

impl DecodeOwned for Fault {
    fn decode_owned(src: &mut ReadCursor<'_>) -> DecodeResult<Self> {
        ensure_size!(in: src, size: Self::FIXED_PART_SIZE);

        Ok(Self {
            alloc_hint: src.read_u32(),
            context_id: src.read_u16(),
            cancel_count: src.read_u8(),
            flags: {
                let fault_flags = src.read_u8();
                FaultFlags::from_bits(fault_flags).ok_or(PduError::InvalidFaultFlags(fault_flags))?
            },
            status: src.read_u32(),
            stub_data: {
                read_padding(
                    compute_padding(
                        8,
                        4 /* alloc_hint */ + 2 /* context_id */ + 1 /* cancel_count */ + 1 /* flags */ + 4, /* status */
                    ),
                    src,
                )?;

                src.read_remaining().to_vec()
            },
        })
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
pub enum PduData {
    Bind(Bind),
    BindAck(BindAck),
    BindNak(BindNak),
    AlterContext(AlterContext),
    AlterContextResponse(AlterContextResponse),
    Request(Request),
    Response(Response),
    Fault(Fault),
}

impl PduData {
    /// Returns [BindAck] extracted from the inner data.
    ///
    /// Returns an error if the inner data is not `BindAck` or `AlterContextResponse`.
    pub fn bind_ack(self) -> PduResult<BindAck> {
        match self {
            PduData::BindAck(bind_ack) => Ok(bind_ack),
            PduData::AlterContextResponse(alter_context) => Ok(alter_context.0),
            _ => Err(PduError::RpcFail("BindAcknowledge PDU is expected")),
        }
    }

    /// Checks if the [PduData] contains any error PDU inside. Returns an error if so.
    pub fn into_error(self) -> PduResult<Self> {
        if let PduData::Fault(_) = self {
            Err(PduError::RpcFail("got unexpected Fault PDU"))
        } else if let PduData::BindNak(_) = self {
            Err(PduError::RpcFail("got unexpected BindAcknowledge PDU"))
        } else {
            Ok(self)
        }
    }
}

impl StaticName for PduData {
    const NAME: &'static str = "PduData";
}

impl NeedsContext for PduData {
    type Context<'ctx> = &'ctx PduHeader;
}

impl DecodeWithContextOwned for PduData {
    fn decode_with_context_owned(src: &mut ReadCursor<'_>, pdu_header: Self::Context<'_>) -> DecodeResult<Self> {
        let security_trailer_len = if pdu_header.auth_len > 0 {
            SecurityTrailer::FIXED_PART_SIZE
        } else {
            0
        } + usize::from(pdu_header.auth_len);

        let data_len = usize::from(pdu_header.frag_len)
            .checked_sub(security_trailer_len + PduHeader::FIXED_PART_SIZE)
            .ok_or(
                DecodeError::invalid_field("PDU", "frag len", "frag len is too small")
                    .with_source(PduError::InvalidFragLength(pdu_header.frag_len)),
            )?;

        ensure_size!(in: src, size: data_len);
        let mut buf = ReadCursor::new(src.read_slice(data_len));

        let pdu_data = match pdu_header.packet_type {
            PacketType::Bind => PduData::Bind(Bind::decode_owned(&mut buf)?),
            PacketType::BindAck => PduData::BindAck(BindAck::decode_owned(&mut buf)?),
            PacketType::BindNak => PduData::BindNak(BindNak::decode_owned(&mut buf)?),
            PacketType::AlterContext => PduData::AlterContext(AlterContext::decode_owned(&mut buf)?),
            PacketType::AlterContextResponse => {
                PduData::AlterContextResponse(AlterContextResponse::decode_owned(&mut buf)?)
            }
            PacketType::Request => {
                PduData::Request(Request::decode_with_context_owned(&mut buf, pdu_header.packet_flags)?)
            }
            PacketType::Response => PduData::Response(Response::decode_owned(&mut buf)?),
            PacketType::Fault => PduData::Fault(Fault::decode_owned(&mut buf)?),
            packet_type => return Err(PduError::PduNotSupported(packet_type).into()),
        };

        Ok(pdu_data)
    }
}

impl Encode for PduData {
    fn encode(&self, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
        ensure_size!(in: dst, size: self.size());

        match self {
            PduData::Bind(bind) => bind.encode(dst),
            PduData::BindAck(bind_ack) => bind_ack.encode(dst),
            PduData::BindNak(bind_nak) => bind_nak.encode(dst),
            PduData::AlterContext(alter_context) => alter_context.encode(dst),
            PduData::AlterContextResponse(alter_context_response) => alter_context_response.encode(dst),
            PduData::Request(request) => request.encode(dst),
            PduData::Response(response) => response.encode(dst),
            PduData::Fault(fault) => fault.encode(dst),
        }
    }

    fn name(&self) -> &'static str {
        Self::NAME
    }

    fn size(&self) -> usize {
        match self {
            PduData::Bind(bind) => bind.size(),
            PduData::BindAck(bind_ack) => bind_ack.size(),
            PduData::BindNak(bind_nak) => bind_nak.size(),
            PduData::AlterContext(alter_context) => alter_context.size(),
            PduData::AlterContextResponse(alter_context_response) => alter_context_response.size(),
            PduData::Request(request) => request.size(),
            PduData::Response(response) => response.size(),
            PduData::Fault(fault) => fault.size(),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Pdu {
    pub header: PduHeader,
    pub data: PduData,
    pub security_trailer: Option<SecurityTrailer>,
}

impl Pdu {
    /// Tries to extract PDU Response from the inner data.
    ///
    /// Return an error if the PDU is any type then `Response`.
    pub fn try_into_response(self) -> PduResult<Response> {
        if let PduData::Response(response) = self.data {
            Ok(response)
        } else {
            Err(PduError::RpcFail("got unexpected PDU: expected Response PDU"))
        }
    }
}

#[cfg(feature = "arbitrary")]
impl arbitrary::Arbitrary<'_> for Pdu {
    fn arbitrary(u: &mut arbitrary::Unstructured<'_>) -> arbitrary::Result<Self> {
        let mut header = PduHeader::arbitrary(u)?;

        let data = match header.packet_type {
            PacketType::Bind => PduData::Bind(Bind::arbitrary(u)?),
            PacketType::BindAck => PduData::BindAck(BindAck::arbitrary(u)?),
            PacketType::BindNak => PduData::BindNak(BindNak::arbitrary(u)?),
            PacketType::AlterContext => PduData::AlterContext(AlterContext::arbitrary(u)?),
            PacketType::AlterContextResponse => PduData::AlterContextResponse(AlterContextResponse::arbitrary(u)?),
            PacketType::Request => {
                let mut request = Request::arbitrary(u)?;

                if header.packet_flags.contains(PacketFlags::PfcObjectUuid) {
                    if request.obj.is_none() {
                        request.obj = Some(u.arbitrary()?);
                    }
                } else if request.obj.is_some() {
                    request.obj = None;
                }

                PduData::Request(request)
            }
            PacketType::Response => PduData::Response(Response::arbitrary(u)?),
            PacketType::Fault => PduData::Fault(Fault::arbitrary(u)?),
            _ => return Err(arbitrary::Error::IncorrectFormat),
        };

        let encoded_len = data.size();

        let security_trailer = SecurityTrailer::arbitrary(u)?;

        let security_trailer = if security_trailer.auth_value.is_empty() {
            header.frag_len = u16::try_from(encoded_len + PduHeader::FIXED_PART_SIZE)
                .map_err(|_| arbitrary::Error::IncorrectFormat)?;
            header.auth_len = 0;

            None
        } else {
            header.auth_len = security_trailer
                .auth_value
                .len()
                .try_into()
                .map_err(|_| arbitrary::Error::IncorrectFormat)?;

            header.frag_len = u16::try_from(
                encoded_len
                    + usize::from(header.auth_len)
                    + PduHeader::FIXED_PART_SIZE
                    + SecurityTrailer::FIXED_PART_SIZE,
            )
            .map_err(|_| arbitrary::Error::IncorrectFormat)?;

            Some(security_trailer)
        };

        Ok(Self {
            header,
            data,
            security_trailer,
        })
    }
}

impl StaticName for Pdu {
    const NAME: &'static str = "PDU";
}

impl Encode for Pdu {
    fn encode(&self, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
        ensure_size!(in: dst, size: self.size());

        self.header.encode(dst)?;
        self.data.encode(dst)?;

        if let Some(security_trailer) = self.security_trailer.as_ref() {
            security_trailer.encode(dst)?;
        }

        Ok(())
    }

    fn name(&self) -> &'static str {
        Self::NAME
    }

    fn size(&self) -> usize {
        self.header.size()
            + self.data.size()
            + self
                .security_trailer
                .as_ref()
                .map(|security_trailer| security_trailer.size())
                .unwrap_or_default()
    }
}

impl DecodeOwned for Pdu {
    fn decode_owned(src: &mut ReadCursor<'_>) -> DecodeResult<Self> {
        let header = PduHeader::decode_owned(src)?;
        let data = PduData::decode_with_context_owned(src, &header)?;
        let security_trailer = if header.auth_len > 0 {
            Some(SecurityTrailer::decode_owned(src)?)
        } else {
            None
        };

        Ok(Self {
            header,
            data,
            security_trailer,
        })
    }
}

impl FixedPartSize for Pdu {
    const FIXED_PART_SIZE: usize = PduHeader::FIXED_PART_SIZE;
}

impl FindLength for Pdu {
    fn find_frame_length(bytes: &[u8]) -> DecodeResult<Option<usize>> {
        if bytes.len() < Self::FIXED_PART_SIZE {
            return Ok(None);
        }

        let pdu_header = PduHeader::decode_owned(&mut ReadCursor::new(&bytes[0..Self::FIXED_PART_SIZE]))?;

        Ok(Some(usize::from(pdu_header.frag_len)))
    }
}


--- File: crates/dpapi-pdu/src/rpc/request.rs ---
use alloc::vec::Vec;

use dpapi_core::{
    decode_uuid, encode_uuid, ensure_size, DecodeOwned, DecodeResult, DecodeWithContextOwned, Encode, EncodeResult,
    FixedPartSize, NeedsContext, ReadCursor, StaticName, WriteCursor,
};
use uuid::Uuid;

use crate::rpc::PacketFlags;

#[derive(Debug, Clone, PartialEq, Eq)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
pub struct Request {
    pub alloc_hint: u32,
    pub context_id: u16,
    pub opnum: u16,
    pub obj: Option<Uuid>,
    pub stub_data: Vec<u8>,
}

impl StaticName for Request {
    const NAME: &'static str = "Request";
}

impl FixedPartSize for Request {
    const FIXED_PART_SIZE: usize = 4 /* alloc_hint */ + 2 /* context_id */ + 2 /* opnum */;
}

impl Encode for Request {
    fn encode(&self, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
        ensure_size!(in: dst, size: self.size());

        dst.write_u32(self.alloc_hint);
        dst.write_u16(self.context_id);
        dst.write_u16(self.opnum);

        if let Some(obj) = self.obj.as_ref() {
            encode_uuid(*obj, dst)?;
        }

        dst.write_slice(&self.stub_data);

        Ok(())
    }

    fn name(&self) -> &'static str {
        Self::NAME
    }

    fn size(&self) -> usize {
        Self::FIXED_PART_SIZE
            + self.obj.as_ref().map(|_| Uuid::FIXED_PART_SIZE).unwrap_or_default()
            + self.stub_data.len()
    }
}

impl NeedsContext for Request {
    type Context<'ctx> = PacketFlags;
}

impl DecodeWithContextOwned for Request {
    fn decode_with_context_owned(src: &mut ReadCursor<'_>, flags: Self::Context<'_>) -> DecodeResult<Self> {
        ensure_size!(in: src, size: Self::FIXED_PART_SIZE);

        Ok(Self {
            alloc_hint: src.read_u32(),
            context_id: src.read_u16(),
            opnum: src.read_u16(),
            obj: if flags.contains(PacketFlags::PfcObjectUuid) {
                Some(decode_uuid(src)?)
            } else {
                None
            },
            stub_data: src.read_remaining().to_vec(),
        })
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
pub struct Response {
    pub alloc_hint: u32,
    pub context_id: u16,
    pub cancel_count: u8,
    pub stub_data: Vec<u8>,
}

impl StaticName for Response {
    const NAME: &'static str = "Response";
}

impl FixedPartSize for Response {
    const FIXED_PART_SIZE: usize = 4 /* alloc_hint */ + 2 /* context_id */ + 1 /* cancel_count */ + 1 /* reserved */;
}

impl Encode for Response {
    fn encode(&self, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
        ensure_size!(in: dst, size: self.size());

        dst.write_u32(self.alloc_hint);
        dst.write_u16(self.context_id);
        dst.write_u8(self.cancel_count);
        // Reserved.
        dst.write_u8(0);

        dst.write_slice(&self.stub_data);

        Ok(())
    }

    fn name(&self) -> &'static str {
        Self::NAME
    }

    fn size(&self) -> usize {
        Self::FIXED_PART_SIZE + self.stub_data.len()
    }
}

impl DecodeOwned for Response {
    fn decode_owned(src: &mut ReadCursor<'_>) -> DecodeResult<Self> {
        ensure_size!(in: src, size: Self::FIXED_PART_SIZE);

        Ok(Self {
            alloc_hint: src.read_u32(),
            context_id: src.read_u16(),
            cancel_count: {
                let cancel_count = src.read_u8();

                // Reserved
                src.read_u8();

                cancel_count
            },
            stub_data: src.read_remaining().to_vec(),
        })
    }
}


--- File: crates/dpapi-pdu/src/rpc/verification.rs ---
use alloc::vec::Vec;

use bitflags::bitflags;
use dpapi_core::{
    cast_length, encode_buf, encode_seq, ensure_size, size_seq, DecodeError, DecodeOwned, DecodeResult, Encode,
    EncodeResult, FixedPartSize, InvalidFieldErr, ReadCursor, StaticName, WriteBuf, WriteCursor,
};
use num_derive::FromPrimitive;
use num_traits::FromPrimitive;
use thiserror::Error;

use crate::rpc::{DataRepr, PacketType, SyntaxId};

#[derive(Debug, Error)]
pub enum CommandError {
    #[error("invalid RPC command type: {0}")]
    InvalidCommandType(u16),

    #[error("invalid RPC command flags: {0}")]
    InvalidCommandFlags(u16),

    #[error("invalid RPC bitmask command value length: expected exactly 4 bytes but got {0} bytes")]
    InvalidCommandBitmaskValueLength(usize),

    #[error("invalid packet RPC type value in RPC command: {0}")]
    InvalidPacketType(u8),

    #[error("invalid VerificationTrailer signature")]
    InvalidVerificationTrailerSignature { expected: &'static [u8], actual: Vec<u8> },
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, FromPrimitive)]
#[repr(u16)]
pub enum CommandType {
    Bitmask1 = 0x0001,
    Pcontext = 0x0002,
    Header2 = 0x0003,
}

impl CommandType {
    pub fn as_u16(self) -> u16 {
        self as u16
    }
}

bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Default)]
    #[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
    pub struct CommandFlags: u16 {
        const None = 0;
        const SecVtCommandEnd = 0x4000;
        const SecVtMustProcessCommand = 0x8000;
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
pub enum Command {
    Bitmask1(CommandBitmask),
    Pcontext(CommandPContext),
    Header2(CommandHeader2),
}

impl Command {
    pub fn set_flags(&mut self, flags: CommandFlags) {
        match self {
            Command::Bitmask1(command) => command.flags = flags,
            Command::Pcontext(command) => command.flags = flags,
            Command::Header2(command) => command.flags = flags,
        }
    }

    pub fn flags(&self) -> CommandFlags {
        match self {
            Command::Bitmask1(command) => command.flags,
            Command::Pcontext(command) => command.flags,
            Command::Header2(command) => command.flags,
        }
    }

    pub fn command_type(&self) -> CommandType {
        match self {
            Command::Bitmask1(_) => CommandType::Bitmask1,
            Command::Pcontext(_) => CommandType::Pcontext,
            Command::Header2(_) => CommandType::Header2,
        }
    }

    fn value_length(&self) -> usize {
        match self {
            Command::Bitmask1(command) => command.value_length(),
            Command::Pcontext(command) => command.value_length(),
            Command::Header2(command) => command.value_length(),
        }
    }
}

impl StaticName for Command {
    const NAME: &'static str = "Command";
}

impl FixedPartSize for Command {
    const FIXED_PART_SIZE: usize = 2 /* command_type + command_flags */ + 2 /* value length */;
}

impl Encode for Command {
    fn encode(&self, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
        ensure_size!(in: dst, size: self.size());

        dst.write_u16(self.command_type().as_u16() | self.flags().bits());

        match self {
            Command::Bitmask1(command) => command.encode_value(dst),
            Command::Pcontext(command) => command.encode_value(dst),
            Command::Header2(command) => command.encode_value(dst),
        }
    }

    fn name(&self) -> &'static str {
        Self::NAME
    }

    fn size(&self) -> usize {
        2 /* command_type + command_flags */ + self.value_length()
    }
}

impl DecodeOwned for Command {
    fn decode_owned(src: &mut ReadCursor<'_>) -> DecodeResult<Self> {
        ensure_size!(in: src, size: Self::FIXED_PART_SIZE);

        let cmd_field = src.read_u16();

        let command_type = cmd_field & 0x3fff;
        let command_flags = cmd_field & 0xc000;

        let command = CommandType::from_u16(command_type).ok_or(
            DecodeError::invalid_field("invalid Command", "command type", "invalid type")
                .with_source(CommandError::InvalidCommandType(command_type)),
        )?;
        let flags = CommandFlags::from_bits(command_flags).ok_or(
            DecodeError::invalid_field("Command", "command flags", "invalid flags")
                .with_source(CommandError::InvalidCommandFlags(command_flags)),
        )?;

        let value_len = usize::from(src.read_u16());

        ensure_size!(in: src, size: value_len);
        let value = src.read_slice(value_len);

        Ok(match command {
            CommandType::Bitmask1 => Self::Bitmask1(CommandBitmask::from_flags_and_value(flags, value)?),
            CommandType::Pcontext => Self::Pcontext(CommandPContext::from_flags_and_value(flags, value)?),
            CommandType::Header2 => Self::Header2(CommandHeader2::from_flags_and_value(flags, value)?),
        })
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
pub struct CommandBitmask {
    pub bits: u32,
    pub flags: CommandFlags,
}

impl CommandBitmask {
    fn value_length(&self) -> usize {
        4 /* bits */ + 2 /* value length */
    }

    fn from_flags_and_value(flags: CommandFlags, value: &[u8]) -> DecodeResult<Self> {
        if value.len() != 4 {
            Err(
                DecodeError::invalid_field("CommandBitmask", "value", "invalid value length")
                    .with_source(CommandError::InvalidCommandBitmaskValueLength(value.len())),
            )?;
        }

        let bits: [u8; 4] = value.try_into().expect("length is checked above");

        Ok(Self {
            flags,
            bits: u32::from_le_bytes(bits),
        })
    }

    fn encode_value(&self, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
        ensure_size!(in: dst, size: self.value_length());

        dst.write_u16(4);
        dst.write_slice(self.bits.to_le_bytes().as_slice());

        Ok(())
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
pub struct CommandPContext {
    pub flags: CommandFlags,
    pub interface_id: SyntaxId,
    pub transfer_syntax: SyntaxId,
}

impl CommandPContext {
    fn value_length(&self) -> usize {
        self.interface_id.size() + self.transfer_syntax.size() + 2 /* value length */
    }

    fn from_flags_and_value(flags: CommandFlags, value: &[u8]) -> DecodeResult<Self> {
        let mut src = ReadCursor::new(value);

        let interface_id = SyntaxId::decode_owned(&mut src)?;
        let transfer_syntax = SyntaxId::decode_owned(&mut src)?;

        if !src.is_empty() {
            Err(
                DecodeError::invalid_field("CommandPContext", "value", "invalid value length")
                    .with_source(CommandError::InvalidCommandBitmaskValueLength(value.len())),
            )?;
        }

        Ok(Self {
            flags,
            interface_id,
            transfer_syntax,
        })
    }

    fn encode_value(&self, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
        ensure_size!(in: dst, size: self.value_length());

        let mut buf = WriteBuf::new();

        encode_buf(&self.interface_id, &mut buf)?;
        encode_buf(&self.transfer_syntax, &mut buf)?;

        dst.write_u16(cast_length!(
            "CommandPContext",
            "encoded value length",
            buf.filled_len()
        )?);
        dst.write_slice(buf.filled());

        Ok(())
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
pub struct CommandHeader2 {
    pub flags: CommandFlags,
    pub packet_type: PacketType,
    pub data_rep: DataRepr,
    pub call_id: u32,
    pub context_id: u16,
    pub opnum: u16,
}

impl CommandHeader2 {
    fn value_length(&self) -> usize {
        Self::FIXED_PART_SIZE
    }

    fn from_flags_and_value(flags: CommandFlags, value: &[u8]) -> DecodeResult<Self> {
        let mut src = ReadCursor::new(value);
        ensure_size!(in: src, size: Self::FIXED_PART_SIZE - 2 /* value length is already read */);

        let command_header2 = Self {
            flags,
            packet_type: {
                let packet_type = src.read_u8();
                src.read_u8();
                src.read_u8();
                src.read_u8();

                PacketType::from_u8(packet_type).ok_or(
                    DecodeError::invalid_field("CommandHeader2", "packet type", "invalid value")
                        .with_source(CommandError::InvalidPacketType(packet_type)),
                )?
            },
            data_rep: DataRepr::decode_owned(&mut src)?,
            call_id: src.read_u32(),
            context_id: src.read_u16(),
            opnum: src.read_u16(),
        };

        if !src.is_empty() {
            Err(
                DecodeError::invalid_field("CommandHeader2", "value", "invalid value length")
                    .with_source(CommandError::InvalidCommandBitmaskValueLength(value.len())),
            )?;
        }

        Ok(command_header2)
    }

    fn encode_value(&self, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
        ensure_size!(in: dst, size: self.value_length());

        let mut buf = WriteBuf::new();

        buf.write_u8(self.packet_type.as_u8());
        // Reserved
        buf.write_slice(&[0, 0, 0]);
        encode_buf(&self.data_rep, &mut buf)?;

        buf.write_u32(self.call_id);
        buf.write_u16(self.context_id);
        buf.write_u16(self.opnum);

        dst.write_u16(cast_length!(
            "CommandHeader2",
            "encoded value length",
            buf.filled_len()
        )?);
        dst.write_slice(buf.filled());

        Ok(())
    }
}

impl FixedPartSize for CommandHeader2 {
    const FIXED_PART_SIZE: usize = 4 /* packet_type + reserved */ + DataRepr::FIXED_PART_SIZE + 4 /* call_id */ + 2 /* context_id */ + 2 /* opnum */ + 2 /* value length */;
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct VerificationTrailer {
    pub commands: Vec<Command>,
}

// We provide the custom Arbitrary trait implementation to ensure that the last command has `SecVtCommandEnd` flag turned on.
#[cfg(feature = "arbitrary")]
impl arbitrary::Arbitrary<'_> for VerificationTrailer {
    fn arbitrary(u: &mut arbitrary::Unstructured<'_>) -> arbitrary::Result<Self> {
        let mut commands = Vec::new();

        for _ in 0..u.arbitrary_len::<Command>()? {
            let command: Command = u.arbitrary()?;
            let flags = command.flags();

            commands.push(command);

            if flags.contains(CommandFlags::SecVtCommandEnd) {
                break;
            }
        }

        if let Some(command) = commands.last_mut() {
            let mut flags = command.flags();

            if !flags.contains(CommandFlags::SecVtCommandEnd) {
                flags.set(CommandFlags::SecVtCommandEnd, true);

                command.set_flags(flags);
            }
        }

        Ok(Self { commands })
    }
}

impl VerificationTrailer {
    const SIGNATURE: &[u8] = &[138, 227, 19, 113, 2, 244, 54, 113];
}

impl StaticName for VerificationTrailer {
    const NAME: &'static str = "VerificationTrailer";
}

impl FixedPartSize for VerificationTrailer {
    const FIXED_PART_SIZE: usize = Self::SIGNATURE.len();
}

impl Encode for VerificationTrailer {
    fn encode(&self, dst: &mut WriteCursor<'_>) -> EncodeResult<()> {
        ensure_size!(in: dst, size: self.size());

        dst.write_slice(Self::SIGNATURE);

        encode_seq(&self.commands, dst)?;

        Ok(())
    }

    fn name(&self) -> &'static str {
        Self::NAME
    }

    fn size(&self) -> usize {
        Self::SIGNATURE.len() + size_seq(&self.commands)
    }
}

impl DecodeOwned for VerificationTrailer {
    fn decode_owned(src: &mut ReadCursor<'_>) -> DecodeResult<Self> {
        ensure_size!(in: src, size: Self::FIXED_PART_SIZE);

        let signature = src.read_slice(VerificationTrailer::SIGNATURE.len());

        if signature != VerificationTrailer::SIGNATURE {
            Err(
                DecodeError::invalid_field("VerificationTrailer", "signature", "invalid data").with_source(
                    CommandError::InvalidVerificationTrailerSignature {
                        expected: VerificationTrailer::SIGNATURE,
                        actual: signature.to_vec(),
                    },
                ),
            )?;
        }

        let mut commands = Vec::new();
        while !src.is_empty() {
            let command = Command::decode_owned(src)?;
            let flags = command.flags();

            commands.push(command);

            if flags.contains(CommandFlags::SecVtCommandEnd) {
                break;
            }
        }

        Ok(Self { commands })
    }
}


--- File: crates/dpapi-pdu/tests/dpapi_pdu/gkdi.rs ---
use dpapi_pdu::gkdi::{
    EcdhKey, EllipticCurve, FfcdhKey, FfcdhParameters, GetKey, GroupKeyEnvelope, HashAlg, KdfParameters,
};
use num_bigint_dig::BigUint;
use uuid::uuid;

test_encoding_decoding! {
    get_key,
    GetKey,
    GetKey {
        target_sd: vec![1, 2, 3, 4],
        root_key_id: Some(uuid!("73294420-917f-416a-9ec3-86082afafb9e")),
        l0_key_id: -1,
        l1_key_id: 1,
        l2_key_id: 31,
    },
    [0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x44, 0x29, 0x73, 0x7f, 0x91, 0x6a, 0x41, 0x9e, 0xc3, 0x86, 0x08, 0x2a, 0xfa, 0xfb, 0x9e, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00]
}

test_encoding_decoding! {
    kdf_parameters,
    KdfParameters,
    KdfParameters {
        hash_alg: HashAlg::Sha512,
    },
    [0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x53, 0x00, 0x48, 0x00, 0x41, 0x00, 0x35, 0x00, 0x31, 0x00, 0x32, 0x00, 0x00, 0x00]
}

test_encoding_decoding! {
    ffcdh_parameters,
    FfcdhParameters,
    FfcdhParameters {
        key_length: 256,
        field_order: BigUint::from_bytes_be(&[135, 168, 230, 29, 180, 182, 102, 60, 255, 187, 209, 156, 101, 25, 89, 153, 140, 238, 246, 8, 102, 13, 208, 242, 93, 44, 238, 212, 67, 94, 59, 0, 224, 13, 248, 241, 214, 25, 87, 212, 250, 247, 223, 69, 97, 178, 170, 48, 22, 195, 217, 17, 52, 9, 111, 170, 59, 244, 41, 109, 131, 14, 154, 124, 32, 158, 12, 100, 151, 81, 122, 189, 90, 138, 157, 48, 107, 207, 103, 237, 145, 249, 230, 114, 91, 71, 88, 192, 34, 224, 177, 239, 66, 117, 191, 123, 108, 91, 252, 17, 212, 95, 144, 136, 185, 65, 245, 78, 177, 229, 155, 184, 188, 57, 160, 191, 18, 48, 127, 92, 79, 219, 112, 197, 129, 178, 63, 118, 182, 58, 202, 225, 202, 166, 183, 144, 45, 82, 82, 103, 53, 72, 138, 14, 241, 60, 109, 154, 81, 191, 164, 171, 58, 216, 52, 119, 150, 82, 77, 142, 246, 161, 103, 181, 164, 24, 37, 217, 103, 225, 68, 229, 20, 5, 100, 37, 28, 202, 203, 131, 230, 180, 134, 246, 179, 202, 63, 121, 113, 80, 96, 38, 192, 184, 87, 246, 137, 150, 40, 86, 222, 212, 1, 10, 189, 11, 230, 33, 195, 163, 150, 10, 84, 231, 16, 195, 117, 242, 99, 117, 215, 1, 65, 3, 164, 181, 67, 48, 193, 152, 175, 18, 97, 22, 210, 39, 110, 17, 113, 95, 105, 56, 119, 250, 215, 239, 9, 202, 219, 9, 74, 233, 30, 26, 21, 151]),
        generator: BigUint::from_bytes_be(&[63, 179, 44, 155, 115, 19, 77, 11, 46, 119, 80, 102, 96, 237, 189, 72, 76, 167, 177, 143, 33, 239, 32, 84, 7, 244, 121, 58, 26, 11, 161, 37, 16, 219, 193, 80, 119, 190, 70, 63, 255, 79, 237, 74, 172, 11, 181, 85, 190, 58, 108, 27, 12, 107, 71, 177, 188, 55, 115, 191, 126, 140, 111, 98, 144, 18, 40, 248, 194, 140, 187, 24, 165, 90, 227, 19, 65, 0, 10, 101, 1, 150, 249, 49, 199, 122, 87, 242, 221, 244, 99, 229, 233, 236, 20, 75, 119, 125, 230, 42, 170, 184, 168, 98, 138, 195, 118, 210, 130, 214, 237, 56, 100, 230, 121, 130, 66, 142, 188, 131, 29, 20, 52, 143, 111, 47, 145, 147, 181, 4, 90, 242, 118, 113, 100, 225, 223, 201, 103, 193, 251, 63, 46, 85, 164, 189, 27, 255, 232, 59, 156, 128, 208, 82, 185, 133, 209, 130, 234, 10, 219, 42, 59, 115, 19, 211, 254, 20, 200, 72, 75, 30, 5, 37, 136, 185, 183, 210, 187, 210, 223, 1, 97, 153, 236, 208, 110, 21, 87, 205, 9, 21, 179, 53, 59, 187, 100, 224, 236, 55, 127, 208, 40, 55, 13, 249, 43, 82, 199, 137, 20, 40, 205, 198, 126, 182, 24, 75, 82, 61, 29, 178, 70, 195, 47, 99, 7, 132, 144, 240, 14, 248, 214, 71, 209, 72, 212, 121, 84, 81, 94, 35, 39, 207, 239, 152, 197, 130, 102, 75, 76, 15, 108, 196, 22, 89]),
    },
    [12, 2, 0, 0, 68, 72, 80, 77, 0, 1, 0, 0, 135, 168, 230, 29, 180, 182, 102, 60, 255, 187, 209, 156, 101, 25, 89, 153, 140, 238, 246, 8, 102, 13, 208, 242, 93, 44, 238, 212, 67, 94, 59, 0, 224, 13, 248, 241, 214, 25, 87, 212, 250, 247, 223, 69, 97, 178, 170, 48, 22, 195, 217, 17, 52, 9, 111, 170, 59, 244, 41, 109, 131, 14, 154, 124, 32, 158, 12, 100, 151, 81, 122, 189, 90, 138, 157, 48, 107, 207, 103, 237, 145, 249, 230, 114, 91, 71, 88, 192, 34, 224, 177, 239, 66, 117, 191, 123, 108, 91, 252, 17, 212, 95, 144, 136, 185, 65, 245, 78, 177, 229, 155, 184, 188, 57, 160, 191, 18, 48, 127, 92, 79, 219, 112, 197, 129, 178, 63, 118, 182, 58, 202, 225, 202, 166, 183, 144, 45, 82, 82, 103, 53, 72, 138, 14, 241, 60, 109, 154, 81, 191, 164, 171, 58, 216, 52, 119, 150, 82, 77, 142, 246, 161, 103, 181, 164, 24, 37, 217, 103, 225, 68, 229, 20, 5, 100, 37, 28, 202, 203, 131, 230, 180, 134, 246, 179, 202, 63, 121, 113, 80, 96, 38, 192, 184, 87, 246, 137, 150, 40, 86, 222, 212, 1, 10, 189, 11, 230, 33, 195, 163, 150, 10, 84, 231, 16, 195, 117, 242, 99, 117, 215, 1, 65, 3, 164, 181, 67, 48, 193, 152, 175, 18, 97, 22, 210, 39, 110, 17, 113, 95, 105, 56, 119, 250, 215, 239, 9, 202, 219, 9, 74, 233, 30, 26, 21, 151, 63, 179, 44, 155, 115, 19, 77, 11, 46, 119, 80, 102, 96, 237, 189, 72, 76, 167, 177, 143, 33, 239, 32, 84, 7, 244, 121, 58, 26, 11, 161, 37, 16, 219, 193, 80, 119, 190, 70, 63, 255, 79, 237, 74, 172, 11, 181, 85, 190, 58, 108, 27, 12, 107, 71, 177, 188, 55, 115, 191, 126, 140, 111, 98, 144, 18, 40, 248, 194, 140, 187, 24, 165, 90, 227, 19, 65, 0, 10, 101, 1, 150, 249, 49, 199, 122, 87, 242, 221, 244, 99, 229, 233, 236, 20, 75, 119, 125, 230, 42, 170, 184, 168, 98, 138, 195, 118, 210, 130, 214, 237, 56, 100, 230, 121, 130, 66, 142, 188, 131, 29, 20, 52, 143, 111, 47, 145, 147, 181, 4, 90, 242, 118, 113, 100, 225, 223, 201, 103, 193, 251, 63, 46, 85, 164, 189, 27, 255, 232, 59, 156, 128, 208, 82, 185, 133, 209, 130, 234, 10, 219, 42, 59, 115, 19, 211, 254, 20, 200, 72, 75, 30, 5, 37, 136, 185, 183, 210, 187, 210, 223, 1, 97, 153, 236, 208, 110, 21, 87, 205, 9, 21, 179, 53, 59, 187, 100, 224, 236, 55, 127, 208, 40, 55, 13, 249, 43, 82, 199, 137, 20, 40, 205, 198, 126, 182, 24, 75, 82, 61, 29, 178, 70, 195, 47, 99, 7, 132, 144, 240, 14, 248, 214, 71, 209, 72, 212, 121, 84, 81, 94, 35, 39, 207, 239, 152, 197, 130, 102, 75, 76, 15, 108, 196, 22, 89]
}

test_encoding_decoding! {
    ffcdh_key,
    FfcdhKey,
    FfcdhKey {
        key_length: 256,
        field_order: BigUint::from_bytes_be(&[135, 168, 230, 29, 180, 182, 102, 60, 255, 187, 209, 156, 101, 25, 89, 153, 140, 238, 246, 8, 102, 13, 208, 242, 93, 44, 238, 212, 67, 94, 59, 0, 224, 13, 248, 241, 214, 25, 87, 212, 250, 247, 223, 69, 97, 178, 170, 48, 22, 195, 217, 17, 52, 9, 111, 170, 59, 244, 41, 109, 131, 14, 154, 124, 32, 158, 12, 100, 151, 81, 122, 189, 90, 138, 157, 48, 107, 207, 103, 237, 145, 249, 230, 114, 91, 71, 88, 192, 34, 224, 177, 239, 66, 117, 191, 123, 108, 91, 252, 17, 212, 95, 144, 136, 185, 65, 245, 78, 177, 229, 155, 184, 188, 57, 160, 191, 18, 48, 127, 92, 79, 219, 112, 197, 129, 178, 63, 118, 182, 58, 202, 225, 202, 166, 183, 144, 45, 82, 82, 103, 53, 72, 138, 14, 241, 60, 109, 154, 81, 191, 164, 171, 58, 216, 52, 119, 150, 82, 77, 142, 246, 161, 103, 181, 164, 24, 37, 217, 103, 225, 68, 229, 20, 5, 100, 37, 28, 202, 203, 131, 230, 180, 134, 246, 179, 202, 63, 121, 113, 80, 96, 38, 192, 184, 87, 246, 137, 150, 40, 86, 222, 212, 1, 10, 189, 11, 230, 33, 195, 163, 150, 10, 84, 231, 16, 195, 117, 242, 99, 117, 215, 1, 65, 3, 164, 181, 67, 48, 193, 152, 175, 18, 97, 22, 210, 39, 110, 17, 113, 95, 105, 56, 119, 250, 215, 239, 9, 202, 219, 9, 74, 233, 30, 26, 21, 151]),
        generator: BigUint::from_bytes_be(&[63, 179, 44, 155, 115, 19, 77, 11, 46, 119, 80, 102, 96, 237, 189, 72, 76, 167, 177, 143, 33, 239, 32, 84, 7, 244, 121, 58, 26, 11, 161, 37, 16, 219, 193, 80, 119, 190, 70, 63, 255, 79, 237, 74, 172, 11, 181, 85, 190, 58, 108, 27, 12, 107, 71, 177, 188, 55, 115, 191, 126, 140, 111, 98, 144, 18, 40, 248, 194, 140, 187, 24, 165, 90, 227, 19, 65, 0, 10, 101, 1, 150, 249, 49, 199, 122, 87, 242, 221, 244, 99, 229, 233, 236, 20, 75, 119, 125, 230, 42, 170, 184, 168, 98, 138, 195, 118, 210, 130, 214, 237, 56, 100, 230, 121, 130, 66, 142, 188, 131, 29, 20, 52, 143, 111, 47, 145, 147, 181, 4, 90, 242, 118, 113, 100, 225, 223, 201, 103, 193, 251, 63, 46, 85, 164, 189, 27, 255, 232, 59, 156, 128, 208, 82, 185, 133, 209, 130, 234, 10, 219, 42, 59, 115, 19, 211, 254, 20, 200, 72, 75, 30, 5, 37, 136, 185, 183, 210, 187, 210, 223, 1, 97, 153, 236, 208, 110, 21, 87, 205, 9, 21, 179, 53, 59, 187, 100, 224, 236, 55, 127, 208, 40, 55, 13, 249, 43, 82, 199, 137, 20, 40, 205, 198, 126, 182, 24, 75, 82, 61, 29, 178, 70, 195, 47, 99, 7, 132, 144, 240, 14, 248, 214, 71, 209, 72, 212, 121, 84, 81, 94, 35, 39, 207, 239, 152, 197, 130, 102, 75, 76, 15, 108, 196, 22, 89]),
        public_key: BigUint::from_bytes_be(&[45, 48, 255, 175, 224, 178, 34, 113, 55, 121, 103, 94, 57, 230, 149, 227, 2, 8, 211, 56, 135, 63, 75, 228, 67, 79, 182, 168, 130, 79, 28, 56, 65, 78, 255, 48, 67, 5, 243, 1, 170, 131, 242, 24, 216, 174, 93, 89, 249, 12, 215, 25, 248, 12, 146, 191, 38, 9, 239, 136, 197, 113, 125, 222, 79, 184, 149, 180, 198, 185, 10, 161, 28, 53, 69, 19, 173, 197, 112, 73, 23, 172, 239, 88, 66, 170, 206, 185, 238, 228, 152, 153, 163, 198, 94, 147, 212, 117, 120, 83, 30, 158, 8, 70, 1, 73, 134, 237, 77, 162, 147, 56, 224, 231, 179, 30, 110, 19, 55, 253, 176, 115, 101, 171, 146, 59, 227, 37, 145, 200, 156, 20, 33, 186, 8, 34, 118, 162, 125, 114, 229, 11, 202, 36, 115, 124, 83, 60, 251, 141, 83, 244, 164, 213, 197, 199, 2, 130, 173, 22, 120, 61, 63, 196, 111, 60, 184, 58, 17, 34, 166, 237, 250, 238, 19, 150, 192, 123, 172, 162, 70, 227, 90, 165, 58, 139, 124, 87, 199, 135, 30, 146, 142, 203, 133, 133, 54, 26, 54, 229, 134, 122, 117, 207, 31, 184, 148, 68, 232, 89, 132, 91, 246, 40, 87, 225, 14, 74, 23, 81, 228, 241, 146, 171, 106, 211, 196, 222, 192, 142, 81, 207, 169, 185, 24, 161, 88, 75, 138, 97, 111, 92, 43, 214, 190, 140, 12, 124, 177, 67, 125, 237, 147, 195, 41, 40]),
    },
    [68, 72, 80, 66, 0, 1, 0, 0, 135, 168, 230, 29, 180, 182, 102, 60, 255, 187, 209, 156, 101, 25, 89, 153, 140, 238, 246, 8, 102, 13, 208, 242, 93, 44, 238, 212, 67, 94, 59, 0, 224, 13, 248, 241, 214, 25, 87, 212, 250, 247, 223, 69, 97, 178, 170, 48, 22, 195, 217, 17, 52, 9, 111, 170, 59, 244, 41, 109, 131, 14, 154, 124, 32, 158, 12, 100, 151, 81, 122, 189, 90, 138, 157, 48, 107, 207, 103, 237, 145, 249, 230, 114, 91, 71, 88, 192, 34, 224, 177, 239, 66, 117, 191, 123, 108, 91, 252, 17, 212, 95, 144, 136, 185, 65, 245, 78, 177, 229, 155, 184, 188, 57, 160, 191, 18, 48, 127, 92, 79, 219, 112, 197, 129, 178, 63, 118, 182, 58, 202, 225, 202, 166, 183, 144, 45, 82, 82, 103, 53, 72, 138, 14, 241, 60, 109, 154, 81, 191, 164, 171, 58, 216, 52, 119, 150, 82, 77, 142, 246, 161, 103, 181, 164, 24, 37, 217, 103, 225, 68, 229, 20, 5, 100, 37, 28, 202, 203, 131, 230, 180, 134, 246, 179, 202, 63, 121, 113, 80, 96, 38, 192, 184, 87, 246, 137, 150, 40, 86, 222, 212, 1, 10, 189, 11, 230, 33, 195, 163, 150, 10, 84, 231, 16, 195, 117, 242, 99, 117, 215, 1, 65, 3, 164, 181, 67, 48, 193, 152, 175, 18, 97, 22, 210, 39, 110, 17, 113, 95, 105, 56, 119, 250, 215, 239, 9, 202, 219, 9, 74, 233, 30, 26, 21, 151, 63, 179, 44, 155, 115, 19, 77, 11, 46, 119, 80, 102, 96, 237, 189, 72, 76, 167, 177, 143, 33, 239, 32, 84, 7, 244, 121, 58, 26, 11, 161, 37, 16, 219, 193, 80, 119, 190, 70, 63, 255, 79, 237, 74, 172, 11, 181, 85, 190, 58, 108, 27, 12, 107, 71, 177, 188, 55, 115, 191, 126, 140, 111, 98, 144, 18, 40, 248, 194, 140, 187, 24, 165, 90, 227, 19, 65, 0, 10, 101, 1, 150, 249, 49, 199, 122, 87, 242, 221, 244, 99, 229, 233, 236, 20, 75, 119, 125, 230, 42, 170, 184, 168, 98, 138, 195, 118, 210, 130, 214, 237, 56, 100, 230, 121, 130, 66, 142, 188, 131, 29, 20, 52, 143, 111, 47, 145, 147, 181, 4, 90, 242, 118, 113, 100, 225, 223, 201, 103, 193, 251, 63, 46, 85, 164, 189, 27, 255, 232, 59, 156, 128, 208, 82, 185, 133, 209, 130, 234, 10, 219, 42, 59, 115, 19, 211, 254, 20, 200, 72, 75, 30, 5, 37, 136, 185, 183, 210, 187, 210, 223, 1, 97, 153, 236, 208, 110, 21, 87, 205, 9, 21, 179, 53, 59, 187, 100, 224, 236, 55, 127, 208, 40, 55, 13, 249, 43, 82, 199, 137, 20, 40, 205, 198, 126, 182, 24, 75, 82, 61, 29, 178, 70, 195, 47, 99, 7, 132, 144, 240, 14, 248, 214, 71, 209, 72, 212, 121, 84, 81, 94, 35, 39, 207, 239, 152, 197, 130, 102, 75, 76, 15, 108, 196, 22, 89, 45, 48, 255, 175, 224, 178, 34, 113, 55, 121, 103, 94, 57, 230, 149, 227, 2, 8, 211, 56, 135, 63, 75, 228, 67, 79, 182, 168, 130, 79, 28, 56, 65, 78, 255, 48, 67, 5, 243, 1, 170, 131, 242, 24, 216, 174, 93, 89, 249, 12, 215, 25, 248, 12, 146, 191, 38, 9, 239, 136, 197, 113, 125, 222, 79, 184, 149, 180, 198, 185, 10, 161, 28, 53, 69, 19, 173, 197, 112, 73, 23, 172, 239, 88, 66, 170, 206, 185, 238, 228, 152, 153, 163, 198, 94, 147, 212, 117, 120, 83, 30, 158, 8, 70, 1, 73, 134, 237, 77, 162, 147, 56, 224, 231, 179, 30, 110, 19, 55, 253, 176, 115, 101, 171, 146, 59, 227, 37, 145, 200, 156, 20, 33, 186, 8, 34, 118, 162, 125, 114, 229, 11, 202, 36, 115, 124, 83, 60, 251, 141, 83, 244, 164, 213, 197, 199, 2, 130, 173, 22, 120, 61, 63, 196, 111, 60, 184, 58, 17, 34, 166, 237, 250, 238, 19, 150, 192, 123, 172, 162, 70, 227, 90, 165, 58, 139, 124, 87, 199, 135, 30, 146, 142, 203, 133, 133, 54, 26, 54, 229, 134, 122, 117, 207, 31, 184, 148, 68, 232, 89, 132, 91, 246, 40, 87, 225, 14, 74, 23, 81, 228, 241, 146, 171, 106, 211, 196, 222, 192, 142, 81, 207, 169, 185, 24, 161, 88, 75, 138, 97, 111, 92, 43, 214, 190, 140, 12, 124, 177, 67, 125, 237, 147, 195, 41, 40]
}

test_encoding_decoding! {
    ecdh_key,
    EcdhKey,
    EcdhKey {
        curve: EllipticCurve::P256,
        key_length: 32,
        x: BigUint::from_bytes_be(&[55, 207, 128, 106, 197, 198, 140, 63, 65, 0, 159, 14, 21, 210, 20, 185, 6, 206, 148, 114, 80, 216, 60, 7, 162, 43, 89, 58, 4, 185, 244, 146]),
        y: BigUint::from_bytes_be(&[12, 96, 47, 29, 213, 226, 140, 169, 155, 108, 148, 93, 27, 55, 236, 228, 100, 7, 103, 201, 181, 118, 34, 92, 72, 181, 88, 110, 92, 34, 255, 192]),
    },
    [69, 67, 75, 49, 32, 0, 0, 0, 55, 207, 128, 106, 197, 198, 140, 63, 65, 0, 159, 14, 21, 210, 20, 185, 6, 206, 148, 114, 80, 216, 60, 7, 162, 43, 89, 58, 4, 185, 244, 146, 12, 96, 47, 29, 213, 226, 140, 169, 155, 108, 148, 93, 27, 55, 236, 228, 100, 7, 103, 201, 181, 118, 34, 92, 72, 181, 88, 110, 92, 34, 255, 192]
}

test_encoding_decoding! {
    group_key_envelope,
    GroupKeyEnvelope,
    GroupKeyEnvelope {
        flags: 2,
        l0: 361,
        l1: 17,
        l2: 8,
        root_key_identifier: uuid!("d778c271-9025-9a82-f6dc-b8960b8ad8c5"),
        kdf_alg: "SP800_108_CTR_HMAC".into(),
        kdf_parameters: vec![0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x53, 0x00, 0x48, 0x00, 0x41, 0x00, 0x35, 0x00, 0x31, 0x00, 0x32, 0x00, 0x00, 0x00],
        secret_algorithm: "DH".into(),
        secret_parameters: vec![12, 2, 0, 0, 68, 72, 80, 77, 0, 1, 0, 0, 135, 168, 230, 29, 180, 182, 102, 60, 255, 187, 209, 156, 101, 25, 89, 153, 140, 238, 246, 8, 102, 13, 208, 242, 93, 44, 238, 212, 67, 94, 59, 0, 224, 13, 248, 241, 214, 25, 87, 212, 250, 247, 223, 69, 97, 178, 170, 48, 22, 195, 217, 17, 52, 9, 111, 170, 59, 244, 41, 109, 131, 14, 154, 124, 32, 158, 12, 100, 151, 81, 122, 189, 90, 138, 157, 48, 107, 207, 103, 237, 145, 249, 230, 114, 91, 71, 88, 192, 34, 224, 177, 239, 66, 117, 191, 123, 108, 91, 252, 17, 212, 95, 144, 136, 185, 65, 245, 78, 177, 229, 155, 184, 188, 57, 160, 191, 18, 48, 127, 92, 79, 219, 112, 197, 129, 178, 63, 118, 182, 58, 202, 225, 202, 166, 183, 144, 45, 82, 82, 103, 53, 72, 138, 14, 241, 60, 109, 154, 81, 191, 164, 171, 58, 216, 52, 119, 150, 82, 77, 142, 246, 161, 103, 181, 164, 24, 37, 217, 103, 225, 68, 229, 20, 5, 100, 37, 28, 202, 203, 131, 230, 180, 134, 246, 179, 202, 63, 121, 113, 80, 96, 38, 192, 184, 87, 246, 137, 150, 40, 86, 222, 212, 1, 10, 189, 11, 230, 33, 195, 163, 150, 10, 84, 231, 16, 195, 117, 242, 99, 117, 215, 1, 65, 3, 164, 181, 67, 48, 193, 152, 175, 18, 97, 22, 210, 39, 110, 17, 113, 95, 105, 56, 119, 250, 215, 239, 9, 202, 219, 9, 74, 233, 30, 26, 21, 151, 63, 179, 44, 155, 115, 19, 77, 11, 46, 119, 80, 102, 96, 237, 189, 72, 76, 167, 177, 143, 33, 239, 32, 84, 7, 244, 121, 58, 26, 11, 161, 37, 16, 219, 193, 80, 119, 190, 70, 63, 255, 79, 237, 74, 172, 11, 181, 85, 190, 58, 108, 27, 12, 107, 71, 177, 188, 55, 115, 191, 126, 140, 111, 98, 144, 18, 40, 248, 194, 140, 187, 24, 165, 90, 227, 19, 65, 0, 10, 101, 1, 150, 249, 49, 199, 122, 87, 242, 221, 244, 99, 229, 233, 236, 20, 75, 119, 125, 230, 42, 170, 184, 168, 98, 138, 195, 118, 210, 130, 214, 237, 56, 100, 230, 121, 130, 66, 142, 188, 131, 29, 20, 52, 143, 111, 47, 145, 147, 181, 4, 90, 242, 118, 113, 100, 225, 223, 201, 103, 193, 251, 63, 46, 85, 164, 189, 27, 255, 232, 59, 156, 128, 208, 82, 185, 133, 209, 130, 234, 10, 219, 42, 59, 115, 19, 211, 254, 20, 200, 72, 75, 30, 5, 37, 136, 185, 183, 210, 187, 210, 223, 1, 97, 153, 236, 208, 110, 21, 87, 205, 9, 21, 179, 53, 59, 187, 100, 224, 236, 55, 127, 208, 40, 55, 13, 249, 43, 82, 199, 137, 20, 40, 205, 198, 126, 182, 24, 75, 82, 61, 29, 178, 70, 195, 47, 99, 7, 132, 144, 240, 14, 248, 214, 71, 209, 72, 212, 121, 84, 81, 94, 35, 39, 207, 239, 152, 197, 130, 102, 75, 76, 15, 108, 196, 22, 89],
        private_key_length: 512,
        public_key_length: 2048,
        domain_name: "domain.test".into(),
        forest_name: "domain.test".into(),
        l1_key: vec![0x9C, 0x8F, 0x03, 0x85, 0xD7, 0x46, 0x06, 0x2A, 0xFB, 0x90, 0xBA, 0x9D, 0x02, 0x3A, 0x3A, 0x5C, 0x24, 0x2E, 0xB5, 0x33, 0x43, 0x41, 0xBE, 0xFA, 0xDC, 0x49, 0xE2, 0x7A, 0x90, 0x8F, 0xC3, 0x39, 0x3B, 0xAC, 0x40, 0x14, 0x56, 0xA8, 0x65, 0x61, 0x04, 0xC8, 0x72, 0xD0, 0xC9, 0x96, 0xAA, 0x25, 0x9A, 0x95, 0x4B, 0xF5, 0xA3, 0x8B, 0x8D, 0x6E, 0xC7, 0xCD, 0xBA, 0xC1, 0x35, 0x9E, 0x5A, 0x09],
        l2_key: vec![0x1B, 0xAC, 0x68, 0xA1, 0xA7, 0xC8, 0xB9, 0xAC, 0x94, 0x4C, 0x8E, 0xB1, 0xEA, 0x39, 0x6C, 0xC3, 0x66, 0x68, 0x5E, 0x17, 0xA4, 0x11, 0x0A, 0x1F, 0xB5, 0x5E, 0x7C, 0x44, 0x11, 0xA6, 0xFA, 0xA5, 0x8F, 0x8E, 0x5B, 0xE1, 0x25, 0x24, 0xFA, 0xBB, 0xC3, 0x44, 0xC5, 0x9B, 0xEA, 0xF9, 0xB3, 0xEC, 0xE2, 0x18, 0xEA, 0x8E, 0x4F, 0x81, 0x1B, 0x6C, 0xAF, 0xEA, 0x4B, 0x77, 0xE7, 0xEF, 0x0A, 0xED],
    },
    [1, 0, 0, 0, 75, 68, 83, 75, 2, 0, 0, 0, 105, 1, 0, 0, 17, 0, 0, 0, 8, 0, 0, 0, 113, 194, 120, 215, 37, 144, 130, 154, 246, 220, 184, 150, 11, 138, 216, 197, 38, 0, 0, 0, 30, 0, 0, 0, 6, 0, 0, 0, 12, 2, 0, 0, 0, 2, 0, 0, 0, 8, 0, 0, 64, 0, 0, 0, 64, 0, 0, 0, 24, 0, 0, 0, 24, 0, 0, 0, 83, 0, 80, 0, 56, 0, 48, 0, 48, 0, 95, 0, 49, 0, 48, 0, 56, 0, 95, 0, 67, 0, 84, 0, 82, 0, 95, 0, 72, 0, 77, 0, 65, 0, 67, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 83, 0, 72, 0, 65, 0, 53, 0, 49, 0, 50, 0, 0, 0, 68, 0, 72, 0, 0, 0, 12, 2, 0, 0, 68, 72, 80, 77, 0, 1, 0, 0, 135, 168, 230, 29, 180, 182, 102, 60, 255, 187, 209, 156, 101, 25, 89, 153, 140, 238, 246, 8, 102, 13, 208, 242, 93, 44, 238, 212, 67, 94, 59, 0, 224, 13, 248, 241, 214, 25, 87, 212, 250, 247, 223, 69, 97, 178, 170, 48, 22, 195, 217, 17, 52, 9, 111, 170, 59, 244, 41, 109, 131, 14, 154, 124, 32, 158, 12, 100, 151, 81, 122, 189, 90, 138, 157, 48, 107, 207, 103, 237, 145, 249, 230, 114, 91, 71, 88, 192, 34, 224, 177, 239, 66, 117, 191, 123, 108, 91, 252, 17, 212, 95, 144, 136, 185, 65, 245, 78, 177, 229, 155, 184, 188, 57, 160, 191, 18, 48, 127, 92, 79, 219, 112, 197, 129, 178, 63, 118, 182, 58, 202, 225, 202, 166, 183, 144, 45, 82, 82, 103, 53, 72, 138, 14, 241, 60, 109, 154, 81, 191, 164, 171, 58, 216, 52, 119, 150, 82, 77, 142, 246, 161, 103, 181, 164, 24, 37, 217, 103, 225, 68, 229, 20, 5, 100, 37, 28, 202, 203, 131, 230, 180, 134, 246, 179, 202, 63, 121, 113, 80, 96, 38, 192, 184, 87, 246, 137, 150, 40, 86, 222, 212, 1, 10, 189, 11, 230, 33, 195, 163, 150, 10, 84, 231, 16, 195, 117, 242, 99, 117, 215, 1, 65, 3, 164, 181, 67, 48, 193, 152, 175, 18, 97, 22, 210, 39, 110, 17, 113, 95, 105, 56, 119, 250, 215, 239, 9, 202, 219, 9, 74, 233, 30, 26, 21, 151, 63, 179, 44, 155, 115, 19, 77, 11, 46, 119, 80, 102, 96, 237, 189, 72, 76, 167, 177, 143, 33, 239, 32, 84, 7, 244, 121, 58, 26, 11, 161, 37, 16, 219, 193, 80, 119, 190, 70, 63, 255, 79, 237, 74, 172, 11, 181, 85, 190, 58, 108, 27, 12, 107, 71, 177, 188, 55, 115, 191, 126, 140, 111, 98, 144, 18, 40, 248, 194, 140, 187, 24, 165, 90, 227, 19, 65, 0, 10, 101, 1, 150, 249, 49, 199, 122, 87, 242, 221, 244, 99, 229, 233, 236, 20, 75, 119, 125, 230, 42, 170, 184, 168, 98, 138, 195, 118, 210, 130, 214, 237, 56, 100, 230, 121, 130, 66, 142, 188, 131, 29, 20, 52, 143, 111, 47, 145, 147, 181, 4, 90, 242, 118, 113, 100, 225, 223, 201, 103, 193, 251, 63, 46, 85, 164, 189, 27, 255, 232, 59, 156, 128, 208, 82, 185, 133, 209, 130, 234, 10, 219, 42, 59, 115, 19, 211, 254, 20, 200, 72, 75, 30, 5, 37, 136, 185, 183, 210, 187, 210, 223, 1, 97, 153, 236, 208, 110, 21, 87, 205, 9, 21, 179, 53, 59, 187, 100, 224, 236, 55, 127, 208, 40, 55, 13, 249, 43, 82, 199, 137, 20, 40, 205, 198, 126, 182, 24, 75, 82, 61, 29, 178, 70, 195, 47, 99, 7, 132, 144, 240, 14, 248, 214, 71, 209, 72, 212, 121, 84, 81, 94, 35, 39, 207, 239, 152, 197, 130, 102, 75, 76, 15, 108, 196, 22, 89, 100, 0, 111, 0, 109, 0, 97, 0, 105, 0, 110, 0, 46, 0, 116, 0, 101, 0, 115, 0, 116, 0, 0, 0, 100, 0, 111, 0, 109, 0, 97, 0, 105, 0, 110, 0, 46, 0, 116, 0, 101, 0, 115, 0, 116, 0, 0, 0, 156, 143, 3, 133, 215, 70, 6, 42, 251, 144, 186, 157, 2, 58, 58, 92, 36, 46, 181, 51, 67, 65, 190, 250, 220, 73, 226, 122, 144, 143, 195, 57, 59, 172, 64, 20, 86, 168, 101, 97, 4, 200, 114, 208, 201, 150, 170, 37, 154, 149, 75, 245, 163, 139, 141, 110, 199, 205, 186, 193, 53, 158, 90, 9, 27, 172, 104, 161, 167, 200, 185, 172, 148, 76, 142, 177, 234, 57, 108, 195, 102, 104, 94, 23, 164, 17, 10, 31, 181, 94, 124, 68, 17, 166, 250, 165, 143, 142, 91, 225, 37, 36, 250, 187, 195, 68, 197, 155, 234, 249, 179, 236, 226, 24, 234, 142, 79, 129, 27, 108, 175, 234, 75, 119, 231, 239, 10, 237]
}


--- File: crates/dpapi-pdu/tests/dpapi_pdu/macros.rs ---
macro_rules! test_encoding_decoding {
    ($name:ident, $type:ty, $expected:expr, $data:expr) => {
        paste::paste! {
            #[test]
            fn [<$name:lower _encoding_decoding>]() {
                use dpapi_core::{EncodeVec, DecodeOwned, ReadCursor};

                let data = $data;

                let parsed = $type::decode_owned(&mut ReadCursor::new(data.as_slice())).unwrap();
                let encoded = parsed.encode_vec().unwrap();

                assert_eq!($expected, parsed);
                assert_eq!(data[..], encoded[..]);
            }
        }
    };
}


--- File: crates/dpapi-pdu/tests/dpapi_pdu/main.rs ---
#[macro_use]
mod macros;

mod gkdi;
mod rpc;


--- File: crates/dpapi-pdu/tests/dpapi_pdu/rpc/bind.rs ---
use dpapi_pdu::rpc::{ContextElement, ContextResult, ContextResultCode, SyntaxId};
use uuid::uuid;

test_encoding_decoding! {
    syntax_id,
    SyntaxId,
    SyntaxId {
        uuid: uuid!("b9785960-524f-11df-8b6d-83dcded72085"),
        version: 1,
        version_minor: 0,
    },
    [96, 89, 120, 185, 79, 82, 223, 17, 139, 109, 131, 220, 222, 215, 32, 133, 1, 0, 0, 0]
}

test_encoding_decoding! {
    context_element,
    ContextElement,
    ContextElement {
        context_id: 0,
        abstract_syntax: SyntaxId {
            uuid: uuid!("b9785960-524f-11df-8b6d-83dcded72085"),
            version: 1,
            version_minor: 0,
        },
        transfer_syntaxes: vec![
            SyntaxId {
                uuid: uuid!("71710533-beba-4937-8319-b5dbef9ccc36"),
                version: 1,
                version_minor: 0,
            }
        ],
    },
    [0, 0, 1, 0, 96, 89, 120, 185, 79, 82, 223, 17, 139, 109, 131, 220, 222, 215, 32, 133, 1, 0, 0, 0, 51, 5, 113, 113, 186, 190, 55, 73, 131, 25, 181, 219, 239, 156, 204, 54, 1, 0, 0, 0]
}

test_encoding_decoding! {
    context_result,
    ContextResult,
    ContextResult {
        result: ContextResultCode::Acceptance,
        reason: 0,
        syntax: uuid!("71710533-beba-4937-8319-b5dbef9ccc36"),
        syntax_version: 1,
    },
    [0, 0, 0, 0, 51, 5, 113, 113, 186, 190, 55, 73, 131, 25, 181, 219, 239, 156, 204, 54, 1, 0, 0, 0]
}


--- File: crates/dpapi-pdu/tests/dpapi_pdu/rpc/epm.rs ---
use dpapi_pdu::rpc::{
    EntryHandle, EptMap, EptMapResult, Floor, IpFloor, RpcConnectionOrientedFloor, TcpFloor, UuidFloor,
};
use uuid::uuid;

test_encoding_decoding! {
    ept_map,
    EptMap,
    EptMap {
        obj: None,
        tower: vec![
            Floor::Uuid(UuidFloor {
                uuid: uuid!("b9785960-524f-11df-8b6d-83dcded72085"),
                version: 1,
                version_minor: 0,
            }),
            Floor::Uuid(UuidFloor {
                uuid: uuid!("8a885d04-1ceb-11c9-9fe8-08002b104860"),
                version: 2,
                version_minor: 0,
            }),
            Floor::RpcConnectionOriented(RpcConnectionOrientedFloor {
                version_minor: 0,
            }),
            Floor::Tcp(TcpFloor {
                port: 135,
            }),
            Floor::Ip(IpFloor {
                addr: 0,
            }),
        ],
        entry_handle: EntryHandle(None),
        max_towers: 4,
    },
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 75, 0, 0, 0, 0, 0, 0, 0, 75, 0, 0, 0, 5, 0, 19, 0, 13, 96, 89, 120, 185, 79, 82, 223, 17, 139, 109, 131, 220, 222, 215, 32, 133, 1, 0, 2, 0, 0, 0, 19, 0, 13, 4, 93, 136, 138, 235, 28, 201, 17, 159, 232, 8, 0, 43, 16, 72, 96, 2, 0, 2, 0, 0, 0, 1, 0, 11, 2, 0, 0, 0, 1, 0, 7, 2, 0, 0, 135, 1, 0, 9, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0]
}

test_encoding_decoding! {
    ept_map_result,
    EptMapResult,
    EptMapResult {
        entry_handle: EntryHandle(None),
        towers: vec![
            vec![
                Floor::Uuid(UuidFloor {
                    uuid: uuid!("b9785960-524f-11df-8b6d-83dcded72085"),
                    version: 1,
                    version_minor: 0,
                }),
                Floor::Uuid(UuidFloor {
                    uuid: uuid!("8a885d04-1ceb-11c9-9fe8-08002b104860"),
                    version: 2,
                    version_minor: 0,
                }),
                Floor::RpcConnectionOriented(RpcConnectionOrientedFloor {
                    version_minor: 0,
                }),
                Floor::Tcp(TcpFloor {
                    port: 49668,
                }),
                Floor::Ip(IpFloor {
                    addr: u32::from_be_bytes([192, 168, 1, 104]),
                }),
            ],
            vec![
                Floor::Uuid(UuidFloor {
                    uuid: uuid!("b9785960-524f-11df-8b6d-83dcded72085"),
                    version: 1,
                    version_minor: 0,
                }),
                Floor::Uuid(UuidFloor {
                    uuid: uuid!("8a885d04-1ceb-11c9-9fe8-08002b104860"),
                    version: 2,
                    version_minor: 0,
                }),
                Floor::RpcConnectionOriented(RpcConnectionOrientedFloor {
                    version_minor: 0,
                }),
                Floor::Tcp(TcpFloor {
                    port: 49664,
                }),
                Floor::Ip(IpFloor {
                    addr: u32::from_be_bytes([192, 168, 1, 104]),
                }),
            ],
        ],
        status: 0,
    },
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 75, 0, 0, 0, 0, 0, 0, 0, 75, 0, 0, 0, 5, 0, 19, 0, 13, 96, 89, 120, 185, 79, 82, 223, 17, 139, 109, 131, 220, 222, 215, 32, 133, 1, 0, 2, 0, 0, 0, 19, 0, 13, 4, 93, 136, 138, 235, 28, 201, 17, 159, 232, 8, 0, 43, 16, 72, 96, 2, 0, 2, 0, 0, 0, 1, 0, 11, 2, 0, 0, 0, 1, 0, 7, 2, 0, 194, 4, 1, 0, 9, 4, 0, 192, 168, 1, 104, 0, 75, 0, 0, 0, 0, 0, 0, 0, 75, 0, 0, 0, 5, 0, 19, 0, 13, 96, 89, 120, 185, 79, 82, 223, 17, 139, 109, 131, 220, 222, 215, 32, 133, 1, 0, 2, 0, 0, 0, 19, 0, 13, 4, 93, 136, 138, 235, 28, 201, 17, 159, 232, 8, 0, 43, 16, 72, 96, 2, 0, 2, 0, 0, 0, 1, 0, 11, 2, 0, 0, 0, 1, 0, 7, 2, 0, 194, 0, 1, 0, 9, 4, 0, 192, 168, 1, 104, 0, 0, 0, 0, 0]
}


--- File: crates/dpapi-pdu/tests/dpapi_pdu/rpc/mod.rs ---
mod bind;
mod epm;
mod pdu;
mod verification;


--- File: crates/dpapi-pdu/tests/dpapi_pdu/rpc/pdu.rs ---
use dpapi_pdu::rpc::{
    AlterContext, AuthenticationLevel, Bind, BindAck, CharacterRepr, ContextElement, ContextResult, ContextResultCode,
    DataRepr, FloatingPointRepr, IntRepr, PacketFlags, PacketType, Pdu, PduData, PduHeader, Request, Response,
    SecurityProvider, SecurityTrailer, SyntaxId,
};
use uuid::uuid;

test_encoding_decoding! {
    data_rep,
    DataRepr,
    DataRepr::default(),
    [0x10, 0, 0, 0]
}

test_encoding_decoding! {
    sec_trailer,
    SecurityTrailer,
    SecurityTrailer {
        security_type: SecurityProvider::GssKerberos,
        level: AuthenticationLevel::PktPrivacy,
        pad_length: 0,
        context_id: 0,
        auth_value: vec![111, 129, 135, 48, 129, 132, 160, 3, 2, 1, 5, 161, 3, 2, 1, 15, 162, 120, 48, 118, 160, 3, 2, 1, 18, 162, 111, 4, 109, 119, 103, 226, 62, 224, 40, 10, 92, 235, 148, 195, 168, 140, 247, 167, 45, 22, 189, 35, 181, 182, 57, 109, 10, 207, 215, 253, 118, 167, 212, 69, 43, 39, 201, 54, 64, 99, 241, 39, 189, 178, 98, 111, 37, 181, 177, 174, 239, 217, 11, 149, 100, 143, 41, 205, 36, 175, 207, 83, 14, 69, 197, 91, 154, 186, 114, 47, 121, 9, 37, 33, 107, 120, 161, 209, 114, 38, 201, 202, 210, 13, 59, 9, 29, 146, 85, 134, 67, 107, 99, 129, 40, 249, 200, 138, 117, 235, 104, 139, 93, 199, 167, 84, 119, 12, 90, 55, 27, 109],
    },
    [16, 6, 0, 0, 0, 0, 0, 0, 111, 129, 135, 48, 129, 132, 160, 3, 2, 1, 5, 161, 3, 2, 1, 15, 162, 120, 48, 118, 160, 3, 2, 1, 18, 162, 111, 4, 109, 119, 103, 226, 62, 224, 40, 10, 92, 235, 148, 195, 168, 140, 247, 167, 45, 22, 189, 35, 181, 182, 57, 109, 10, 207, 215, 253, 118, 167, 212, 69, 43, 39, 201, 54, 64, 99, 241, 39, 189, 178, 98, 111, 37, 181, 177, 174, 239, 217, 11, 149, 100, 143, 41, 205, 36, 175, 207, 83, 14, 69, 197, 91, 154, 186, 114, 47, 121, 9, 37, 33, 107, 120, 161, 209, 114, 38, 201, 202, 210, 13, 59, 9, 29, 146, 85, 134, 67, 107, 99, 129, 40, 249, 200, 138, 117, 235, 104, 139, 93, 199, 167, 84, 119, 12, 90, 55, 27, 109]
}

test_encoding_decoding! {
    pdu_bind,
    Pdu,
    Pdu {
        header: PduHeader {
            version: 5,
            version_minor: 0,
            packet_type: PacketType::Bind,
            packet_flags: PacketFlags::PfcSupportHeaderSign | PacketFlags::PfcLastFrag | PacketFlags::PfcFirstFrag,
            data_rep: DataRepr {
                byte_order: IntRepr::LittleEndian,
                character: CharacterRepr::Ascii,
                floating_point: FloatingPointRepr::Ieee,
            },
            frag_len: 1624,
            auth_len: 1500,
            call_id: 1,
        },
        data: PduData::Bind(Bind {
            max_xmit_frag: 5840,
            max_recv_frag: 5840,
            assoc_group: 0,
            contexts: vec![
                ContextElement {
                    context_id: 0,
                    abstract_syntax: SyntaxId {
                        uuid: uuid!("b9785960-524f-11df-8b6d-83dcded72085"),
                        version: 1,
                        version_minor: 0,
                    },
                    transfer_syntaxes: vec![
                        SyntaxId {
                            uuid: uuid!("71710533-beba-4937-8319-b5dbef9ccc36"),
                            version: 1,
                            version_minor: 0,
                        }
                    ]
                },
                ContextElement {
                    context_id: 1,
                    abstract_syntax: SyntaxId {
                        uuid: uuid!("b9785960-524f-11df-8b6d-83dcded72085"),
                        version: 1,
                        version_minor: 0,
                    },
                    transfer_syntaxes: vec![
                        SyntaxId {
                            uuid: uuid!("6cb71c2c-9812-4540-0000-000000000000"),
                            version: 1,
                            version_minor: 0,
                        }
                    ]
                },
            ],
        }),
        security_trailer: Some(SecurityTrailer {
            security_type: SecurityProvider::GssKerberos,
            level: AuthenticationLevel::PktPrivacy,
            pad_length: 0,
            context_id: 0,
            auth_value: vec![110, 130, 5, 216, 48, 130, 5, 212, 160, 3, 2, 1, 5, 161, 3, 2, 1, 14, 162, 7, 3, 5, 0, 32, 0, 0, 0, 163, 130, 4, 122, 97, 130, 4, 118, 48, 130, 4, 114, 160, 3, 2, 1, 5, 161, 9, 27, 7, 84, 66, 84, 46, 67, 79, 77, 162, 42, 48, 40, 160, 3, 2, 1, 2, 161, 33, 48, 31, 27, 4, 104, 111, 115, 116, 27, 23, 119, 105, 110, 45, 57, 53, 54, 99, 113, 111, 115, 115, 106, 116, 102, 46, 116, 98, 116, 46, 99, 111, 109, 163, 130, 4, 50, 48, 130, 4, 46, 160, 3, 2, 1, 18, 161, 3, 2, 1, 9, 162, 130, 4, 32, 4, 130, 4, 28, 44, 103, 214, 219, 239, 134, 71, 190, 93, 33, 211, 36, 190, 6, 172, 121, 2, 89, 207, 145, 220, 145, 172, 231, 91, 117, 132, 111, 90, 170, 93, 68, 125, 232, 140, 82, 149, 113, 166, 160, 177, 128, 211, 60, 148, 255, 76, 218, 44, 251, 207, 172, 107, 5, 100, 116, 150, 169, 166, 9, 243, 215, 68, 138, 147, 181, 172, 57, 147, 162, 119, 199, 59, 114, 24, 246, 77, 200, 11, 70, 50, 177, 82, 16, 66, 204, 205, 184, 46, 235, 136, 252, 175, 19, 54, 232, 224, 42, 167, 220, 22, 230, 36, 196, 53, 64, 242, 190, 202, 121, 185, 201, 34, 254, 147, 167, 94, 244, 59, 7, 50, 175, 224, 79, 20, 81, 165, 16, 10, 139, 62, 188, 123, 240, 61, 227, 185, 45, 183, 229, 204, 78, 87, 196, 197, 234, 229, 130, 158, 133, 212, 167, 240, 86, 39, 192, 130, 213, 211, 136, 250, 130, 143, 151, 0, 242, 199, 20, 5, 218, 217, 222, 115, 183, 135, 28, 162, 0, 206, 176, 200, 131, 43, 121, 200, 78, 64, 202, 103, 223, 65, 195, 173, 108, 127, 210, 56, 103, 73, 27, 111, 57, 221, 127, 168, 81, 65, 65, 48, 231, 188, 175, 218, 158, 56, 220, 28, 51, 18, 78, 65, 9, 117, 136, 225, 226, 155, 211, 182, 155, 116, 29, 12, 235, 39, 120, 61, 238, 228, 78, 78, 29, 178, 197, 255, 52, 185, 164, 93, 132, 148, 163, 18, 168, 33, 44, 134, 83, 29, 249, 125, 166, 9, 211, 185, 82, 34, 99, 148, 121, 5, 114, 121, 41, 237, 194, 95, 80, 109, 247, 67, 238, 79, 200, 238, 178, 171, 47, 139, 138, 11, 26, 108, 22, 209, 244, 74, 6, 17, 164, 91, 111, 118, 100, 139, 205, 38, 213, 121, 250, 105, 51, 79, 228, 85, 111, 255, 26, 253, 154, 168, 212, 164, 22, 152, 185, 219, 58, 205, 182, 239, 137, 180, 82, 235, 101, 23, 93, 224, 96, 190, 43, 11, 183, 88, 237, 137, 193, 232, 156, 146, 174, 202, 44, 39, 49, 111, 198, 3, 44, 201, 32, 103, 132, 89, 10, 94, 203, 184, 64, 222, 78, 213, 92, 99, 74, 36, 229, 181, 181, 194, 62, 89, 102, 10, 98, 47, 241, 137, 250, 255, 219, 151, 85, 145, 205, 7, 34, 127, 226, 95, 200, 46, 36, 17, 243, 26, 38, 130, 139, 167, 215, 248, 100, 188, 6, 116, 142, 149, 249, 213, 198, 117, 43, 155, 240, 53, 202, 154, 253, 60, 78, 131, 30, 53, 59, 239, 67, 192, 197, 112, 100, 93, 255, 141, 85, 67, 172, 12, 167, 0, 13, 188, 129, 67, 127, 145, 220, 87, 22, 210, 46, 194, 105, 142, 151, 239, 192, 137, 218, 176, 178, 100, 62, 229, 212, 215, 195, 160, 29, 14, 177, 139, 124, 62, 142, 182, 34, 86, 149, 18, 106, 107, 215, 34, 130, 75, 181, 147, 5, 244, 131, 18, 25, 81, 63, 243, 228, 110, 188, 37, 142, 244, 25, 11, 210, 75, 26, 58, 37, 17, 46, 43, 179, 68, 0, 128, 84, 65, 169, 180, 244, 47, 114, 9, 96, 248, 216, 27, 157, 209, 39, 252, 25, 61, 203, 232, 148, 172, 157, 1, 48, 35, 24, 149, 87, 0, 154, 185, 121, 29, 233, 191, 234, 241, 109, 98, 30, 221, 214, 82, 238, 90, 212, 107, 205, 91, 222, 55, 181, 48, 156, 197, 78, 157, 139, 235, 169, 24, 243, 88, 230, 248, 87, 238, 146, 162, 45, 99, 222, 148, 133, 169, 41, 129, 46, 223, 223, 43, 251, 56, 5, 195, 101, 79, 15, 122, 137, 119, 192, 109, 211, 56, 33, 101, 49, 243, 82, 92, 93, 112, 115, 91, 202, 166, 57, 203, 165, 206, 134, 5, 10, 67, 157, 231, 38, 184, 188, 160, 206, 222, 183, 207, 212, 239, 167, 45, 121, 230, 184, 55, 147, 79, 5, 148, 176, 170, 74, 84, 17, 230, 112, 247, 198, 248, 70, 223, 205, 183, 133, 40, 7, 243, 102, 236, 53, 69, 67, 73, 50, 138, 50, 36, 199, 25, 146, 141, 162, 178, 93, 110, 156, 202, 72, 232, 51, 29, 156, 254, 42, 94, 113, 105, 138, 3, 45, 89, 58, 145, 99, 87, 246, 65, 118, 229, 216, 220, 169, 127, 206, 169, 142, 95, 155, 28, 43, 128, 13, 76, 5, 138, 15, 76, 239, 59, 248, 230, 97, 240, 3, 172, 68, 191, 165, 101, 68, 233, 66, 3, 218, 174, 118, 118, 81, 56, 127, 53, 156, 74, 150, 188, 12, 47, 11, 251, 197, 169, 70, 110, 67, 209, 139, 45, 200, 57, 206, 205, 22, 75, 53, 87, 63, 34, 207, 81, 153, 183, 54, 251, 107, 193, 139, 66, 237, 104, 5, 33, 38, 93, 190, 136, 235, 164, 58, 115, 109, 177, 34, 15, 208, 193, 175, 21, 5, 128, 255, 161, 158, 100, 4, 99, 30, 237, 212, 167, 208, 170, 31, 20, 137, 217, 213, 244, 100, 6, 110, 139, 131, 67, 44, 100, 24, 246, 35, 135, 139, 135, 221, 254, 168, 247, 177, 9, 200, 13, 92, 163, 162, 253, 192, 153, 10, 118, 71, 66, 65, 132, 227, 136, 104, 11, 103, 164, 63, 190, 181, 135, 140, 162, 237, 223, 52, 53, 211, 156, 28, 171, 224, 69, 40, 77, 196, 54, 99, 220, 214, 128, 5, 177, 177, 188, 78, 180, 83, 219, 160, 122, 140, 79, 244, 53, 57, 92, 94, 186, 17, 148, 52, 99, 202, 1, 121, 199, 28, 121, 175, 89, 251, 144, 39, 117, 252, 84, 253, 109, 68, 121, 82, 235, 176, 76, 83, 119, 16, 186, 94, 145, 11, 42, 60, 137, 18, 217, 69, 150, 69, 244, 232, 31, 76, 183, 58, 140, 111, 57, 149, 40, 26, 177, 79, 222, 235, 18, 227, 170, 47, 39, 177, 96, 106, 15, 170, 96, 36, 32, 147, 189, 227, 195, 40, 255, 180, 223, 9, 169, 68, 170, 149, 62, 72, 131, 193, 152, 7, 243, 75, 73, 97, 132, 115, 90, 80, 21, 214, 19, 182, 153, 198, 139, 68, 249, 21, 148, 89, 39, 108, 149, 5, 129, 96, 26, 21, 144, 236, 179, 160, 213, 108, 237, 111, 188, 51, 164, 130, 1, 63, 48, 130, 1, 59, 160, 3, 2, 1, 18, 162, 130, 1, 50, 4, 130, 1, 46, 132, 58, 70, 180, 118, 76, 164, 13, 174, 223, 44, 210, 119, 10, 168, 231, 247, 137, 253, 0, 147, 51, 147, 79, 64, 225, 162, 243, 64, 198, 106, 116, 122, 159, 132, 137, 232, 183, 137, 33, 162, 232, 196, 68, 112, 126, 64, 155, 62, 200, 181, 67, 40, 221, 74, 128, 117, 140, 57, 200, 172, 159, 121, 52, 122, 50, 39, 240, 175, 114, 10, 88, 171, 54, 116, 167, 7, 124, 93, 163, 59, 179, 206, 210, 91, 126, 205, 57, 115, 78, 180, 28, 107, 61, 141, 6, 140, 62, 77, 85, 238, 185, 48, 140, 110, 207, 21, 19, 215, 208, 77, 240, 165, 86, 2, 229, 151, 16, 91, 105, 6, 94, 158, 76, 182, 8, 244, 219, 144, 3, 186, 128, 170, 213, 97, 69, 240, 124, 236, 93, 147, 248, 221, 9, 43, 164, 185, 248, 67, 205, 74, 138, 9, 38, 149, 13, 198, 28, 40, 27, 84, 11, 17, 216, 24, 158, 156, 247, 65, 97, 65, 24, 187, 83, 92, 147, 203, 255, 213, 15, 109, 70, 251, 65, 36, 237, 175, 239, 41, 141, 249, 223, 134, 52, 53, 45, 193, 159, 184, 133, 93, 114, 189, 62, 16, 153, 182, 134, 210, 232, 230, 224, 31, 87, 142, 243, 63, 220, 180, 223, 196, 21, 52, 70, 254, 208, 122, 5, 169, 160, 148, 100, 219, 162, 142, 128, 131, 201, 197, 111, 208, 225, 174, 58, 77, 146, 16, 72, 221, 17, 132, 154, 11, 34, 102, 199, 154, 25, 111, 228, 229, 86, 208, 103, 90, 93, 239, 143, 131, 17, 122, 68, 45, 135, 227, 213, 105, 238, 55, 56, 254, 133, 76, 167, 163, 44, 163, 19, 29, 76, 244, 42, 72, 96, 219, 91, 235, 28, 9, 103, 117, 237]
        }),
    },
    [5, 0, 11, 7, 16, 0, 0, 0, 88, 6, 220, 5, 1, 0, 0, 0, 208, 22, 208, 22, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 1, 0, 96, 89, 120, 185, 79, 82, 223, 17, 139, 109, 131, 220, 222, 215, 32, 133, 1, 0, 0, 0, 51, 5, 113, 113, 186, 190, 55, 73, 131, 25, 181, 219, 239, 156, 204, 54, 1, 0, 0, 0, 1, 0, 1, 0, 96, 89, 120, 185, 79, 82, 223, 17, 139, 109, 131, 220, 222, 215, 32, 133, 1, 0, 0, 0, 44, 28, 183, 108, 18, 152, 64, 69, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 16, 6, 0, 0, 0, 0, 0, 0, 110, 130, 5, 216, 48, 130, 5, 212, 160, 3, 2, 1, 5, 161, 3, 2, 1, 14, 162, 7, 3, 5, 0, 32, 0, 0, 0, 163, 130, 4, 122, 97, 130, 4, 118, 48, 130, 4, 114, 160, 3, 2, 1, 5, 161, 9, 27, 7, 84, 66, 84, 46, 67, 79, 77, 162, 42, 48, 40, 160, 3, 2, 1, 2, 161, 33, 48, 31, 27, 4, 104, 111, 115, 116, 27, 23, 119, 105, 110, 45, 57, 53, 54, 99, 113, 111, 115, 115, 106, 116, 102, 46, 116, 98, 116, 46, 99, 111, 109, 163, 130, 4, 50, 48, 130, 4, 46, 160, 3, 2, 1, 18, 161, 3, 2, 1, 9, 162, 130, 4, 32, 4, 130, 4, 28, 44, 103, 214, 219, 239, 134, 71, 190, 93, 33, 211, 36, 190, 6, 172, 121, 2, 89, 207, 145, 220, 145, 172, 231, 91, 117, 132, 111, 90, 170, 93, 68, 125, 232, 140, 82, 149, 113, 166, 160, 177, 128, 211, 60, 148, 255, 76, 218, 44, 251, 207, 172, 107, 5, 100, 116, 150, 169, 166, 9, 243, 215, 68, 138, 147, 181, 172, 57, 147, 162, 119, 199, 59, 114, 24, 246, 77, 200, 11, 70, 50, 177, 82, 16, 66, 204, 205, 184, 46, 235, 136, 252, 175, 19, 54, 232, 224, 42, 167, 220, 22, 230, 36, 196, 53, 64, 242, 190, 202, 121, 185, 201, 34, 254, 147, 167, 94, 244, 59, 7, 50, 175, 224, 79, 20, 81, 165, 16, 10, 139, 62, 188, 123, 240, 61, 227, 185, 45, 183, 229, 204, 78, 87, 196, 197, 234, 229, 130, 158, 133, 212, 167, 240, 86, 39, 192, 130, 213, 211, 136, 250, 130, 143, 151, 0, 242, 199, 20, 5, 218, 217, 222, 115, 183, 135, 28, 162, 0, 206, 176, 200, 131, 43, 121, 200, 78, 64, 202, 103, 223, 65, 195, 173, 108, 127, 210, 56, 103, 73, 27, 111, 57, 221, 127, 168, 81, 65, 65, 48, 231, 188, 175, 218, 158, 56, 220, 28, 51, 18, 78, 65, 9, 117, 136, 225, 226, 155, 211, 182, 155, 116, 29, 12, 235, 39, 120, 61, 238, 228, 78, 78, 29, 178, 197, 255, 52, 185, 164, 93, 132, 148, 163, 18, 168, 33, 44, 134, 83, 29, 249, 125, 166, 9, 211, 185, 82, 34, 99, 148, 121, 5, 114, 121, 41, 237, 194, 95, 80, 109, 247, 67, 238, 79, 200, 238, 178, 171, 47, 139, 138, 11, 26, 108, 22, 209, 244, 74, 6, 17, 164, 91, 111, 118, 100, 139, 205, 38, 213, 121, 250, 105, 51, 79, 228, 85, 111, 255, 26, 253, 154, 168, 212, 164, 22, 152, 185, 219, 58, 205, 182, 239, 137, 180, 82, 235, 101, 23, 93, 224, 96, 190, 43, 11, 183, 88, 237, 137, 193, 232, 156, 146, 174, 202, 44, 39, 49, 111, 198, 3, 44, 201, 32, 103, 132, 89, 10, 94, 203, 184, 64, 222, 78, 213, 92, 99, 74, 36, 229, 181, 181, 194, 62, 89, 102, 10, 98, 47, 241, 137, 250, 255, 219, 151, 85, 145, 205, 7, 34, 127, 226, 95, 200, 46, 36, 17, 243, 26, 38, 130, 139, 167, 215, 248, 100, 188, 6, 116, 142, 149, 249, 213, 198, 117, 43, 155, 240, 53, 202, 154, 253, 60, 78, 131, 30, 53, 59, 239, 67, 192, 197, 112, 100, 93, 255, 141, 85, 67, 172, 12, 167, 0, 13, 188, 129, 67, 127, 145, 220, 87, 22, 210, 46, 194, 105, 142, 151, 239, 192, 137, 218, 176, 178, 100, 62, 229, 212, 215, 195, 160, 29, 14, 177, 139, 124, 62, 142, 182, 34, 86, 149, 18, 106, 107, 215, 34, 130, 75, 181, 147, 5, 244, 131, 18, 25, 81, 63, 243, 228, 110, 188, 37, 142, 244, 25, 11, 210, 75, 26, 58, 37, 17, 46, 43, 179, 68, 0, 128, 84, 65, 169, 180, 244, 47, 114, 9, 96, 248, 216, 27, 157, 209, 39, 252, 25, 61, 203, 232, 148, 172, 157, 1, 48, 35, 24, 149, 87, 0, 154, 185, 121, 29, 233, 191, 234, 241, 109, 98, 30, 221, 214, 82, 238, 90, 212, 107, 205, 91, 222, 55, 181, 48, 156, 197, 78, 157, 139, 235, 169, 24, 243, 88, 230, 248, 87, 238, 146, 162, 45, 99, 222, 148, 133, 169, 41, 129, 46, 223, 223, 43, 251, 56, 5, 195, 101, 79, 15, 122, 137, 119, 192, 109, 211, 56, 33, 101, 49, 243, 82, 92, 93, 112, 115, 91, 202, 166, 57, 203, 165, 206, 134, 5, 10, 67, 157, 231, 38, 184, 188, 160, 206, 222, 183, 207, 212, 239, 167, 45, 121, 230, 184, 55, 147, 79, 5, 148, 176, 170, 74, 84, 17, 230, 112, 247, 198, 248, 70, 223, 205, 183, 133, 40, 7, 243, 102, 236, 53, 69, 67, 73, 50, 138, 50, 36, 199, 25, 146, 141, 162, 178, 93, 110, 156, 202, 72, 232, 51, 29, 156, 254, 42, 94, 113, 105, 138, 3, 45, 89, 58, 145, 99, 87, 246, 65, 118, 229, 216, 220, 169, 127, 206, 169, 142, 95, 155, 28, 43, 128, 13, 76, 5, 138, 15, 76, 239, 59, 248, 230, 97, 240, 3, 172, 68, 191, 165, 101, 68, 233, 66, 3, 218, 174, 118, 118, 81, 56, 127, 53, 156, 74, 150, 188, 12, 47, 11, 251, 197, 169, 70, 110, 67, 209, 139, 45, 200, 57, 206, 205, 22, 75, 53, 87, 63, 34, 207, 81, 153, 183, 54, 251, 107, 193, 139, 66, 237, 104, 5, 33, 38, 93, 190, 136, 235, 164, 58, 115, 109, 177, 34, 15, 208, 193, 175, 21, 5, 128, 255, 161, 158, 100, 4, 99, 30, 237, 212, 167, 208, 170, 31, 20, 137, 217, 213, 244, 100, 6, 110, 139, 131, 67, 44, 100, 24, 246, 35, 135, 139, 135, 221, 254, 168, 247, 177, 9, 200, 13, 92, 163, 162, 253, 192, 153, 10, 118, 71, 66, 65, 132, 227, 136, 104, 11, 103, 164, 63, 190, 181, 135, 140, 162, 237, 223, 52, 53, 211, 156, 28, 171, 224, 69, 40, 77, 196, 54, 99, 220, 214, 128, 5, 177, 177, 188, 78, 180, 83, 219, 160, 122, 140, 79, 244, 53, 57, 92, 94, 186, 17, 148, 52, 99, 202, 1, 121, 199, 28, 121, 175, 89, 251, 144, 39, 117, 252, 84, 253, 109, 68, 121, 82, 235, 176, 76, 83, 119, 16, 186, 94, 145, 11, 42, 60, 137, 18, 217, 69, 150, 69, 244, 232, 31, 76, 183, 58, 140, 111, 57, 149, 40, 26, 177, 79, 222, 235, 18, 227, 170, 47, 39, 177, 96, 106, 15, 170, 96, 36, 32, 147, 189, 227, 195, 40, 255, 180, 223, 9, 169, 68, 170, 149, 62, 72, 131, 193, 152, 7, 243, 75, 73, 97, 132, 115, 90, 80, 21, 214, 19, 182, 153, 198, 139, 68, 249, 21, 148, 89, 39, 108, 149, 5, 129, 96, 26, 21, 144, 236, 179, 160, 213, 108, 237, 111, 188, 51, 164, 130, 1, 63, 48, 130, 1, 59, 160, 3, 2, 1, 18, 162, 130, 1, 50, 4, 130, 1, 46, 132, 58, 70, 180, 118, 76, 164, 13, 174, 223, 44, 210, 119, 10, 168, 231, 247, 137, 253, 0, 147, 51, 147, 79, 64, 225, 162, 243, 64, 198, 106, 116, 122, 159, 132, 137, 232, 183, 137, 33, 162, 232, 196, 68, 112, 126, 64, 155, 62, 200, 181, 67, 40, 221, 74, 128, 117, 140, 57, 200, 172, 159, 121, 52, 122, 50, 39, 240, 175, 114, 10, 88, 171, 54, 116, 167, 7, 124, 93, 163, 59, 179, 206, 210, 91, 126, 205, 57, 115, 78, 180, 28, 107, 61, 141, 6, 140, 62, 77, 85, 238, 185, 48, 140, 110, 207, 21, 19, 215, 208, 77, 240, 165, 86, 2, 229, 151, 16, 91, 105, 6, 94, 158, 76, 182, 8, 244, 219, 144, 3, 186, 128, 170, 213, 97, 69, 240, 124, 236, 93, 147, 248, 221, 9, 43, 164, 185, 248, 67, 205, 74, 138, 9, 38, 149, 13, 198, 28, 40, 27, 84, 11, 17, 216, 24, 158, 156, 247, 65, 97, 65, 24, 187, 83, 92, 147, 203, 255, 213, 15, 109, 70, 251, 65, 36, 237, 175, 239, 41, 141, 249, 223, 134, 52, 53, 45, 193, 159, 184, 133, 93, 114, 189, 62, 16, 153, 182, 134, 210, 232, 230, 224, 31, 87, 142, 243, 63, 220, 180, 223, 196, 21, 52, 70, 254, 208, 122, 5, 169, 160, 148, 100, 219, 162, 142, 128, 131, 201, 197, 111, 208, 225, 174, 58, 77, 146, 16, 72, 221, 17, 132, 154, 11, 34, 102, 199, 154, 25, 111, 228, 229, 86, 208, 103, 90, 93, 239, 143, 131, 17, 122, 68, 45, 135, 227, 213, 105, 238, 55, 56, 254, 133, 76, 167, 163, 44, 163, 19, 29, 76, 244, 42, 72, 96, 219, 91, 235, 28, 9, 103, 117, 237]
}

test_encoding_decoding! {
    pdu_bind_ack,
    Pdu,
    Pdu {
        header: PduHeader {
            version: 5,
            version_minor: 0,
            packet_type: PacketType::BindAck,
            packet_flags: PacketFlags::PfcSupportHeaderSign | PacketFlags::PfcLastFrag | PacketFlags::PfcFirstFrag,
            data_rep: DataRepr {
                byte_order: IntRepr::LittleEndian,
                character: CharacterRepr::Ascii,
                floating_point: FloatingPointRepr::Ieee,
            },
            frag_len: 230,
            auth_len: 138,
            call_id: 1,
        },
        data: PduData::BindAck(BindAck {
            max_xmit_frag: 5840,
            max_recv_frag: 5840,
            assoc_group: 0x00007320,
            sec_addr: String::from("49668"),
            results: vec![
                ContextResult {
                    result: ContextResultCode::Acceptance,
                    reason: 0,
                    syntax: uuid!("71710533-beba-4937-8319-b5dbef9ccc36"),
                    syntax_version: 1,
                },
                ContextResult {
                    result: ContextResultCode::NegotiateAck,
                    reason: 0,
                    syntax: uuid!("00000000-0000-0000-0000-000000000000"),
                    syntax_version: 0,
                },
            ],
        }),
        security_trailer: Some(SecurityTrailer {
            security_type: SecurityProvider::GssKerberos,
            level: AuthenticationLevel::PktPrivacy,
            pad_length: 0,
            context_id: 0,
            auth_value: vec![111, 129, 135, 48, 129, 132, 160, 3, 2, 1, 5, 161, 3, 2, 1, 15, 162, 120, 48, 118, 160, 3, 2, 1, 18, 162, 111, 4, 109, 119, 103, 226, 62, 224, 40, 10, 92, 235, 148, 195, 168, 140, 247, 167, 45, 22, 189, 35, 181, 182, 57, 109, 10, 207, 215, 253, 118, 167, 212, 69, 43, 39, 201, 54, 64, 99, 241, 39, 189, 178, 98, 111, 37, 181, 177, 174, 239, 217, 11, 149, 100, 143, 41, 205, 36, 175, 207, 83, 14, 69, 197, 91, 154, 186, 114, 47, 121, 9, 37, 33, 107, 120, 161, 209, 114, 38, 201, 202, 210, 13, 59, 9, 29, 146, 85, 134, 67, 107, 99, 129, 40, 249, 200, 138, 117, 235, 104, 139, 93, 199, 167, 84, 119, 12, 90, 55, 27, 109]
        }),
    },
    [5, 0, 12, 7, 16, 0, 0, 0, 230, 0, 138, 0, 1, 0, 0, 0, 208, 22, 208, 22, 32, 115, 0, 0, 6, 0, 52, 57, 54, 54, 56, 0, 2, 0, 0, 0, 0, 0, 0, 0, 51, 5, 113, 113, 186, 190, 55, 73, 131, 25, 181, 219, 239, 156, 204, 54, 1, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 6, 0, 0, 0, 0, 0, 0, 111, 129, 135, 48, 129, 132, 160, 3, 2, 1, 5, 161, 3, 2, 1, 15, 162, 120, 48, 118, 160, 3, 2, 1, 18, 162, 111, 4, 109, 119, 103, 226, 62, 224, 40, 10, 92, 235, 148, 195, 168, 140, 247, 167, 45, 22, 189, 35, 181, 182, 57, 109, 10, 207, 215, 253, 118, 167, 212, 69, 43, 39, 201, 54, 64, 99, 241, 39, 189, 178, 98, 111, 37, 181, 177, 174, 239, 217, 11, 149, 100, 143, 41, 205, 36, 175, 207, 83, 14, 69, 197, 91, 154, 186, 114, 47, 121, 9, 37, 33, 107, 120, 161, 209, 114, 38, 201, 202, 210, 13, 59, 9, 29, 146, 85, 134, 67, 107, 99, 129, 40, 249, 200, 138, 117, 235, 104, 139, 93, 199, 167, 84, 119, 12, 90, 55, 27, 109]
}

test_encoding_decoding! {
    pdu_alter_context,
    Pdu,
    Pdu {
        header: PduHeader {
            version: 5,
            version_minor: 0,
            packet_type: PacketType::AlterContext,
            packet_flags: PacketFlags::PfcSupportHeaderSign | PacketFlags::PfcLastFrag | PacketFlags::PfcFirstFrag,
            data_rep: DataRepr {
                byte_order: IntRepr::LittleEndian,
                character: CharacterRepr::Ascii,
                floating_point: FloatingPointRepr::Ieee,
            },
            frag_len: 173,
            auth_len: 93,
            call_id: 1,
        },
        data: PduData::AlterContext(AlterContext(Bind {
            max_xmit_frag: 5840,
            max_recv_frag: 5840,
            assoc_group: 0,
            contexts: vec![
                ContextElement {
                    context_id: 0,
                    abstract_syntax: SyntaxId {
                        uuid: uuid!("b9785960-524f-11df-8b6d-83dcded72085"),
                        version: 1,
                        version_minor: 0,
                    },
                    transfer_syntaxes: vec![
                        SyntaxId {
                            uuid: uuid!("71710533-beba-4937-8319-b5dbef9ccc36"),
                            version: 1,
                            version_minor: 0,
                        }
                    ]
                },
            ],
        })),
        security_trailer: Some(SecurityTrailer {
            security_type: SecurityProvider::GssKerberos,
            level: AuthenticationLevel::PktPrivacy,
            pad_length: 0,
            context_id: 0,
            auth_value: vec![111, 91, 48, 89, 160, 3, 2, 1, 5, 161, 3, 2, 1, 15, 162, 77, 48, 75, 160, 3, 2, 1, 18, 162, 68, 4, 66, 169, 200, 55, 118, 91, 23, 32, 40, 237, 31, 41, 10, 235, 96, 11, 206, 91, 184, 138, 167, 37, 44, 224, 129, 132, 69, 220, 201, 123, 20, 243, 60, 251, 187, 228, 62, 104, 246, 170, 121, 102, 22, 16, 1, 222, 154, 38, 2, 94, 168, 232, 219, 6, 47, 32, 21, 238, 30, 254, 203, 201, 245, 242, 109, 43, 132]
        }),
    },
    [5, 0, 14, 7, 16, 0, 0, 0, 173, 0, 93, 0, 1, 0, 0, 0, 208, 22, 208, 22, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 96, 89, 120, 185, 79, 82, 223, 17, 139, 109, 131, 220, 222, 215, 32, 133, 1, 0, 0, 0, 51, 5, 113, 113, 186, 190, 55, 73, 131, 25, 181, 219, 239, 156, 204, 54, 1, 0, 0, 0, 16, 6, 0, 0, 0, 0, 0, 0, 111, 91, 48, 89, 160, 3, 2, 1, 5, 161, 3, 2, 1, 15, 162, 77, 48, 75, 160, 3, 2, 1, 18, 162, 68, 4, 66, 169, 200, 55, 118, 91, 23, 32, 40, 237, 31, 41, 10, 235, 96, 11, 206, 91, 184, 138, 167, 37, 44, 224, 129, 132, 69, 220, 201, 123, 20, 243, 60, 251, 187, 228, 62, 104, 246, 170, 121, 102, 22, 16, 1, 222, 154, 38, 2, 94, 168, 232, 219, 6, 47, 32, 21, 238, 30, 254, 203, 201, 245, 242, 109, 43, 132]
}

test_encoding_decoding! {
    pdu_request,
    Pdu,
    Pdu {
        header: PduHeader {
            version: 5,
            version_minor: 0,
            packet_type: PacketType::Request,
            packet_flags: PacketFlags::PfcLastFrag | PacketFlags::PfcFirstFrag,
            data_rep: DataRepr {
                byte_order: IntRepr::LittleEndian,
                character: CharacterRepr::Ascii,
                floating_point: FloatingPointRepr::Ieee,
            },
            frag_len: 332,
            auth_len: 76,
            call_id: 1,
        },
        data: PduData::Request(Request {
            alloc_hint: 224,
            context_id: 0,
            opnum: 0,
            obj: None,
            stub_data: vec![70, 145, 235, 30, 109, 26, 31, 173, 254, 42, 137, 229, 243, 197, 44, 158, 238, 241, 41, 183, 81, 67, 57, 200, 254, 191, 147, 127, 205, 26, 3, 40, 255, 194, 91, 96, 55, 224, 130, 204, 168, 191, 33, 234, 237, 111, 175, 214, 140, 82, 127, 41, 174, 170, 228, 93, 51, 220, 223, 202, 204, 131, 102, 248, 202, 155, 5, 129, 117, 2, 229, 154, 46, 85, 137, 43, 189, 80, 105, 195, 207, 206, 50, 225, 121, 213, 208, 156, 244, 102, 76, 112, 244, 57, 173, 67, 116, 129, 185, 143, 232, 121, 52, 62, 241, 0, 14, 31, 208, 226, 155, 175, 16, 174, 156, 17, 53, 0, 163, 190, 217, 253, 107, 13, 206, 7, 225, 139, 156, 203, 149, 7, 247, 94, 222, 106, 236, 20, 57, 137, 82, 83, 240, 38, 131, 217, 130, 188, 85, 50, 55, 154, 150, 64, 148, 170, 48, 56, 219, 253, 162, 223, 243, 244, 116, 25, 228, 155, 93, 106, 187, 240, 80, 24, 0, 146, 192, 248, 239, 98, 144, 160, 17, 70, 74, 18, 17, 117, 215, 151, 189, 241, 77, 32, 193, 180, 71, 172, 118, 69, 103, 165, 79, 159, 190, 42, 51, 243, 86, 224, 148, 94, 89, 138, 70, 16, 158, 43, 179, 125, 70, 252, 89, 109],
        }),
        security_trailer: Some(SecurityTrailer {
            security_type: SecurityProvider::GssNegotiate,
            level: AuthenticationLevel::PktPrivacy,
            pad_length: 8,
            context_id: 0,
            auth_value: vec![5, 4, 6, 255, 0, 16, 0, 28, 0, 0, 0, 0, 79, 12, 105, 32, 144, 245, 113, 202, 80, 221, 101, 212, 65, 96, 235, 157, 134, 111, 198, 10, 115, 62, 240, 22, 254, 69, 248, 210, 242, 96, 170, 195, 58, 55, 129, 156, 207, 68, 71, 29, 72, 179, 60, 55, 242, 152, 3, 186, 10, 255, 63, 87, 127, 71, 33, 237, 173, 182, 94, 104, 149, 226, 47, 85],
        }),
    },
    [5, 0, 0, 3, 16, 0, 0, 0, 76, 1, 76, 0, 1, 0, 0, 0, 224, 0, 0, 0, 0, 0, 0, 0, 70, 145, 235, 30, 109, 26, 31, 173, 254, 42, 137, 229, 243, 197, 44, 158, 238, 241, 41, 183, 81, 67, 57, 200, 254, 191, 147, 127, 205, 26, 3, 40, 255, 194, 91, 96, 55, 224, 130, 204, 168, 191, 33, 234, 237, 111, 175, 214, 140, 82, 127, 41, 174, 170, 228, 93, 51, 220, 223, 202, 204, 131, 102, 248, 202, 155, 5, 129, 117, 2, 229, 154, 46, 85, 137, 43, 189, 80, 105, 195, 207, 206, 50, 225, 121, 213, 208, 156, 244, 102, 76, 112, 244, 57, 173, 67, 116, 129, 185, 143, 232, 121, 52, 62, 241, 0, 14, 31, 208, 226, 155, 175, 16, 174, 156, 17, 53, 0, 163, 190, 217, 253, 107, 13, 206, 7, 225, 139, 156, 203, 149, 7, 247, 94, 222, 106, 236, 20, 57, 137, 82, 83, 240, 38, 131, 217, 130, 188, 85, 50, 55, 154, 150, 64, 148, 170, 48, 56, 219, 253, 162, 223, 243, 244, 116, 25, 228, 155, 93, 106, 187, 240, 80, 24, 0, 146, 192, 248, 239, 98, 144, 160, 17, 70, 74, 18, 17, 117, 215, 151, 189, 241, 77, 32, 193, 180, 71, 172, 118, 69, 103, 165, 79, 159, 190, 42, 51, 243, 86, 224, 148, 94, 89, 138, 70, 16, 158, 43, 179, 125, 70, 252, 89, 109, 9, 6, 8, 0, 0, 0, 0, 0, 5, 4, 6, 255, 0, 16, 0, 28, 0, 0, 0, 0, 79, 12, 105, 32, 144, 245, 113, 202, 80, 221, 101, 212, 65, 96, 235, 157, 134, 111, 198, 10, 115, 62, 240, 22, 254, 69, 248, 210, 242, 96, 170, 195, 58, 55, 129, 156, 207, 68, 71, 29, 72, 179, 60, 55, 242, 152, 3, 186, 10, 255, 63, 87, 127, 71, 33, 237, 173, 182, 94, 104, 149, 226, 47, 85]
}

test_encoding_decoding! {
    pdu_response,
    Pdu,
    Pdu {
        header: PduHeader {
            version: 5,
            version_minor: 0,
            packet_type: PacketType::Response,
            packet_flags: PacketFlags::PfcLastFrag | PacketFlags::PfcFirstFrag,
            data_rep: DataRepr {
                byte_order: IntRepr::LittleEndian,
                character: CharacterRepr::Ascii,
                floating_point: FloatingPointRepr::Ieee,
            },
            frag_len: 988,
            auth_len: 76,
            call_id: 1,
        },
        data: PduData::Response(Response {
            alloc_hint: 868,
            context_id: 0,
            cancel_count: 0,
            stub_data: vec![140, 22, 170, 99, 118, 14, 170, 89, 139, 87, 80, 46, 170, 201, 100, 178, 117, 90, 91, 192, 162, 184, 19, 212, 23, 128, 138, 18, 254, 148, 164, 176, 99, 3, 173, 76, 201, 138, 131, 120, 250, 252, 185, 253, 65, 241, 2, 186, 42, 19, 121, 1, 56, 123, 222, 239, 124, 245, 220, 6, 164, 22, 214, 134, 144, 90, 18, 29, 229, 134, 221, 54, 240, 230, 26, 15, 183, 249, 98, 170, 169, 13, 141, 38, 170, 51, 82, 88, 193, 175, 211, 154, 234, 11, 120, 56, 240, 19, 15, 136, 13, 165, 63, 206, 201, 2, 9, 53, 183, 29, 88, 92, 143, 244, 110, 255, 33, 255, 9, 164, 168, 238, 77, 141, 6, 49, 232, 211, 232, 67, 105, 186, 181, 12, 147, 155, 165, 12, 73, 47, 8, 63, 114, 12, 1, 119, 37, 88, 209, 138, 30, 193, 104, 26, 204, 45, 221, 177, 79, 4, 80, 120, 16, 48, 168, 28, 112, 192, 173, 111, 216, 0, 229, 10, 241, 0, 179, 123, 144, 120, 181, 45, 149, 22, 121, 85, 167, 150, 73, 171, 76, 123, 5, 51, 58, 235, 34, 173, 73, 96, 1, 231, 83, 68, 203, 207, 59, 172, 137, 103, 1, 47, 188, 188, 72, 162, 133, 233, 185, 129, 155, 35, 73, 16, 197, 86, 236, 182, 255, 170, 26, 28, 107, 235, 192, 25, 233, 58, 230, 85, 181, 124, 234, 193, 229, 193, 13, 228, 61, 90, 160, 247, 223, 86, 113, 113, 233, 164, 118, 29, 108, 140, 188, 74, 59, 94, 73, 241, 159, 3, 113, 28, 212, 36, 111, 141, 154, 108, 79, 109, 134, 117, 54, 188, 18, 219, 148, 76, 2, 102, 5, 150, 51, 29, 121, 251, 142, 73, 0, 169, 202, 237, 139, 213, 78, 61, 152, 81, 120, 35, 96, 5, 105, 156, 72, 85, 252, 158, 1, 103, 55, 143, 39, 64, 16, 225, 118, 137, 22, 239, 139, 203, 140, 120, 196, 170, 15, 247, 249, 173, 206, 49, 156, 75, 167, 89, 138, 238, 6, 61, 254, 124, 56, 187, 179, 236, 94, 108, 119, 151, 255, 148, 20, 57, 141, 125, 38, 56, 235, 77, 239, 74, 97, 67, 217, 43, 231, 154, 164, 168, 131, 90, 140, 173, 247, 93, 215, 67, 111, 162, 255, 42, 161, 7, 37, 216, 94, 246, 125, 27, 45, 198, 172, 118, 137, 6, 216, 65, 106, 142, 54, 200, 151, 220, 174, 145, 45, 145, 16, 70, 202, 204, 202, 244, 91, 50, 0, 36, 147, 175, 167, 20, 47, 228, 211, 2, 12, 56, 72, 107, 161, 6, 55, 209, 89, 45, 176, 95, 140, 212, 175, 99, 203, 43, 102, 59, 188, 43, 57, 178, 155, 166, 213, 125, 4, 68, 252, 236, 202, 188, 235, 35, 17, 249, 247, 133, 93, 49, 158, 87, 195, 167, 201, 40, 168, 18, 239, 164, 176, 52, 45, 137, 9, 243, 47, 80, 147, 49, 56, 176, 212, 198, 127, 46, 50, 108, 135, 76, 27, 34, 242, 99, 199, 36, 93, 22, 41, 65, 157, 80, 69, 68, 109, 160, 141, 197, 104, 127, 151, 200, 37, 200, 4, 168, 185, 206, 19, 240, 126, 191, 73, 169, 223, 222, 118, 240, 123, 176, 140, 184, 117, 180, 116, 194, 231, 223, 126, 134, 67, 223, 11, 52, 233, 59, 188, 121, 131, 65, 235, 134, 141, 55, 115, 84, 29, 125, 12, 108, 128, 123, 4, 253, 70, 37, 161, 15, 23, 198, 135, 37, 234, 123, 123, 107, 161, 237, 38, 116, 13, 116, 2, 99, 181, 75, 10, 18, 253, 115, 56, 250, 239, 17, 153, 89, 8, 199, 121, 67, 223, 178, 18, 115, 6, 22, 183, 105, 238, 77, 167, 54, 59, 171, 149, 228, 107, 235, 183, 59, 224, 211, 227, 7, 198, 165, 27, 206, 9, 249, 49, 229, 19, 158, 195, 80, 162, 185, 187, 6, 12, 105, 75, 209, 197, 133, 232, 143, 178, 56, 247, 210, 254, 96, 227, 94, 103, 170, 146, 149, 234, 138, 229, 84, 227, 191, 133, 168, 2, 158, 38, 17, 147, 0, 169, 84, 197, 61, 230, 69, 62, 204, 224, 85, 78, 106, 161, 171, 100, 77, 118, 217, 162, 198, 130, 211, 94, 189, 87, 163, 235, 44, 121, 156, 211, 82, 203, 196, 238, 113, 190, 225, 155, 209, 9, 141, 97, 155, 187, 222, 153, 224, 41, 107, 85, 198, 26, 170, 41, 20, 246, 170, 120, 87, 224, 40, 241, 118, 87, 195, 240, 45, 119, 19, 31, 48, 88, 134, 196, 129, 13, 23, 246, 89, 53, 175, 210, 14, 225, 198, 192, 159, 201, 51, 131, 42, 115, 220, 41, 11, 92, 22, 35, 148, 150, 224, 49, 14, 105, 92, 89, 67, 73, 230, 6, 236, 200, 210, 171, 170, 179, 201, 225, 37, 209, 67, 17, 59, 65, 44, 27, 75, 29, 133, 43, 121, 171, 206, 138, 112, 65, 206, 2, 96, 29, 250, 87, 170, 131, 178, 248, 130, 249, 228, 87, 37, 47, 79, 220, 166, 70, 254, 118, 165, 223, 62, 6, 17, 242, 61, 210, 255, 137, 9, 229, 155, 39, 171, 33, 2, 238, 93, 198, 146, 131, 236, 116, 236, 179, 184, 102, 59],
        }),
        security_trailer: Some(SecurityTrailer {
            security_type: SecurityProvider::GssNegotiate,
            level: AuthenticationLevel::PktPrivacy,
            pad_length: 12,
            context_id: 0,
            auth_value: vec![5, 4, 7, 255, 0, 16, 0, 28, 0, 0, 0, 0, 51, 128, 170, 35, 94, 238, 241, 97, 204, 124, 66, 162, 119, 57, 190, 117, 249, 25, 174, 246, 194, 102, 133, 211, 241, 188, 128, 195, 227, 189, 65, 195, 40, 30, 231, 115, 38, 58, 165, 66, 11, 106, 157, 183, 70, 85, 36, 135, 69, 247, 93, 97, 111, 229, 75, 25, 99, 208, 247, 253, 227, 122, 252, 85],
        }),
    },
    [5, 0, 2, 3, 16, 0, 0, 0, 220, 3, 76, 0, 1, 0, 0, 0, 100, 3, 0, 0, 0, 0, 0, 0, 140, 22, 170, 99, 118, 14, 170, 89, 139, 87, 80, 46, 170, 201, 100, 178, 117, 90, 91, 192, 162, 184, 19, 212, 23, 128, 138, 18, 254, 148, 164, 176, 99, 3, 173, 76, 201, 138, 131, 120, 250, 252, 185, 253, 65, 241, 2, 186, 42, 19, 121, 1, 56, 123, 222, 239, 124, 245, 220, 6, 164, 22, 214, 134, 144, 90, 18, 29, 229, 134, 221, 54, 240, 230, 26, 15, 183, 249, 98, 170, 169, 13, 141, 38, 170, 51, 82, 88, 193, 175, 211, 154, 234, 11, 120, 56, 240, 19, 15, 136, 13, 165, 63, 206, 201, 2, 9, 53, 183, 29, 88, 92, 143, 244, 110, 255, 33, 255, 9, 164, 168, 238, 77, 141, 6, 49, 232, 211, 232, 67, 105, 186, 181, 12, 147, 155, 165, 12, 73, 47, 8, 63, 114, 12, 1, 119, 37, 88, 209, 138, 30, 193, 104, 26, 204, 45, 221, 177, 79, 4, 80, 120, 16, 48, 168, 28, 112, 192, 173, 111, 216, 0, 229, 10, 241, 0, 179, 123, 144, 120, 181, 45, 149, 22, 121, 85, 167, 150, 73, 171, 76, 123, 5, 51, 58, 235, 34, 173, 73, 96, 1, 231, 83, 68, 203, 207, 59, 172, 137, 103, 1, 47, 188, 188, 72, 162, 133, 233, 185, 129, 155, 35, 73, 16, 197, 86, 236, 182, 255, 170, 26, 28, 107, 235, 192, 25, 233, 58, 230, 85, 181, 124, 234, 193, 229, 193, 13, 228, 61, 90, 160, 247, 223, 86, 113, 113, 233, 164, 118, 29, 108, 140, 188, 74, 59, 94, 73, 241, 159, 3, 113, 28, 212, 36, 111, 141, 154, 108, 79, 109, 134, 117, 54, 188, 18, 219, 148, 76, 2, 102, 5, 150, 51, 29, 121, 251, 142, 73, 0, 169, 202, 237, 139, 213, 78, 61, 152, 81, 120, 35, 96, 5, 105, 156, 72, 85, 252, 158, 1, 103, 55, 143, 39, 64, 16, 225, 118, 137, 22, 239, 139, 203, 140, 120, 196, 170, 15, 247, 249, 173, 206, 49, 156, 75, 167, 89, 138, 238, 6, 61, 254, 124, 56, 187, 179, 236, 94, 108, 119, 151, 255, 148, 20, 57, 141, 125, 38, 56, 235, 77, 239, 74, 97, 67, 217, 43, 231, 154, 164, 168, 131, 90, 140, 173, 247, 93, 215, 67, 111, 162, 255, 42, 161, 7, 37, 216, 94, 246, 125, 27, 45, 198, 172, 118, 137, 6, 216, 65, 106, 142, 54, 200, 151, 220, 174, 145, 45, 145, 16, 70, 202, 204, 202, 244, 91, 50, 0, 36, 147, 175, 167, 20, 47, 228, 211, 2, 12, 56, 72, 107, 161, 6, 55, 209, 89, 45, 176, 95, 140, 212, 175, 99, 203, 43, 102, 59, 188, 43, 57, 178, 155, 166, 213, 125, 4, 68, 252, 236, 202, 188, 235, 35, 17, 249, 247, 133, 93, 49, 158, 87, 195, 167, 201, 40, 168, 18, 239, 164, 176, 52, 45, 137, 9, 243, 47, 80, 147, 49, 56, 176, 212, 198, 127, 46, 50, 108, 135, 76, 27, 34, 242, 99, 199, 36, 93, 22, 41, 65, 157, 80, 69, 68, 109, 160, 141, 197, 104, 127, 151, 200, 37, 200, 4, 168, 185, 206, 19, 240, 126, 191, 73, 169, 223, 222, 118, 240, 123, 176, 140, 184, 117, 180, 116, 194, 231, 223, 126, 134, 67, 223, 11, 52, 233, 59, 188, 121, 131, 65, 235, 134, 141, 55, 115, 84, 29, 125, 12, 108, 128, 123, 4, 253, 70, 37, 161, 15, 23, 198, 135, 37, 234, 123, 123, 107, 161, 237, 38, 116, 13, 116, 2, 99, 181, 75, 10, 18, 253, 115, 56, 250, 239, 17, 153, 89, 8, 199, 121, 67, 223, 178, 18, 115, 6, 22, 183, 105, 238, 77, 167, 54, 59, 171, 149, 228, 107, 235, 183, 59, 224, 211, 227, 7, 198, 165, 27, 206, 9, 249, 49, 229, 19, 158, 195, 80, 162, 185, 187, 6, 12, 105, 75, 209, 197, 133, 232, 143, 178, 56, 247, 210, 254, 96, 227, 94, 103, 170, 146, 149, 234, 138, 229, 84, 227, 191, 133, 168, 2, 158, 38, 17, 147, 0, 169, 84, 197, 61, 230, 69, 62, 204, 224, 85, 78, 106, 161, 171, 100, 77, 118, 217, 162, 198, 130, 211, 94, 189, 87, 163, 235, 44, 121, 156, 211, 82, 203, 196, 238, 113, 190, 225, 155, 209, 9, 141, 97, 155, 187, 222, 153, 224, 41, 107, 85, 198, 26, 170, 41, 20, 246, 170, 120, 87, 224, 40, 241, 118, 87, 195, 240, 45, 119, 19, 31, 48, 88, 134, 196, 129, 13, 23, 246, 89, 53, 175, 210, 14, 225, 198, 192, 159, 201, 51, 131, 42, 115, 220, 41, 11, 92, 22, 35, 148, 150, 224, 49, 14, 105, 92, 89, 67, 73, 230, 6, 236, 200, 210, 171, 170, 179, 201, 225, 37, 209, 67, 17, 59, 65, 44, 27, 75, 29, 133, 43, 121, 171, 206, 138, 112, 65, 206, 2, 96, 29, 250, 87, 170, 131, 178, 248, 130, 249, 228, 87, 37, 47, 79, 220, 166, 70, 254, 118, 165, 223, 62, 6, 17, 242, 61, 210, 255, 137, 9, 229, 155, 39, 171, 33, 2, 238, 93, 198, 146, 131, 236, 116, 236, 179, 184, 102, 59, 9, 6, 12, 0, 0, 0, 0, 0, 5, 4, 7, 255, 0, 16, 0, 28, 0, 0, 0, 0, 51, 128, 170, 35, 94, 238, 241, 97, 204, 124, 66, 162, 119, 57, 190, 117, 249, 25, 174, 246, 194, 102, 133, 211, 241, 188, 128, 195, 227, 189, 65, 195, 40, 30, 231, 115, 38, 58, 165, 66, 11, 106, 157, 183, 70, 85, 36, 135, 69, 247, 93, 97, 111, 229, 75, 25, 99, 208, 247, 253, 227, 122, 252, 85]
}


--- File: crates/dpapi-pdu/tests/dpapi_pdu/rpc/verification.rs ---
use dpapi_pdu::rpc::{
    CharacterRepr, Command, CommandBitmask, CommandFlags, CommandHeader2, CommandPContext, DataRepr, FloatingPointRepr,
    IntRepr, PacketType, SyntaxId, VerificationTrailer,
};
use uuid::uuid;

test_encoding_decoding! {
    verification_trailer_pcontext_end,
    VerificationTrailer,
    VerificationTrailer {
        commands: vec![
            Command::Pcontext(CommandPContext {
                flags: CommandFlags::SecVtCommandEnd,
                interface_id: SyntaxId {
                    uuid: uuid!("b9785960-524f-11df-8b6d-83dcded72085"),
                    version: 1,
                    version_minor: 0,
                },
                transfer_syntax: SyntaxId {
                    uuid: uuid!("71710533-beba-4937-8319-b5dbef9ccc36"),
                    version: 1,
                    version_minor: 0,
                },
            }),
        ],
    },
    [138, 227, 19, 113, 2, 244, 54, 113, 2, 64, 40, 0, 96, 89, 120, 185, 79, 82, 223, 17, 139, 109, 131, 220, 222, 215, 32, 133, 1, 0, 0, 0, 51, 5, 113, 113, 186, 190, 55, 73, 131, 25, 181, 219, 239, 156, 204, 54, 1, 0, 0, 0]
}

test_encoding_decoding! {
    command_bitmask,
    Command,
    Command::Bitmask1(CommandBitmask {
        bits: 1,
        flags: CommandFlags::None,
    }),
    [1, 0, 4, 0, 1, 0, 0, 0]
}

test_encoding_decoding! {
    command_pcontext,
    Command,
    Command::Pcontext(CommandPContext {
        flags: CommandFlags::SecVtCommandEnd,
        interface_id: SyntaxId {
            uuid: uuid!("b9785960-524f-11df-8b6d-83dcded72085"),
            version: 1,
            version_minor: 0,
        },
        transfer_syntax: SyntaxId {
            uuid: uuid!("71710533-beba-4937-8319-b5dbef9ccc36"),
            version: 1,
            version_minor: 0,
        },
    }),
    [2, 64, 40, 0, 96, 89, 120, 185, 79, 82, 223, 17, 139, 109, 131, 220, 222, 215, 32, 133, 1, 0, 0, 0, 51, 5, 113, 113, 186, 190, 55, 73, 131, 25, 181, 219, 239, 156, 204, 54, 1, 0, 0, 0]
}

test_encoding_decoding! {
    command_header2,
    Command,
    Command::Header2(CommandHeader2 {
        flags: CommandFlags::SecVtMustProcessCommand,
        packet_type: PacketType::Request,
        data_rep: DataRepr {
            byte_order: IntRepr::LittleEndian,
            character: CharacterRepr::Ascii,
            floating_point: FloatingPointRepr::Ieee,
        },
        call_id: 1,
        context_id: 2,
        opnum: 3,
    }),
    [3, 128, 16, 0, 0, 0, 0, 0, 16, 0, 0, 0, 1, 0, 0, 0, 2, 0, 3, 0]
}


--- File: crates/dpapi-transport/Cargo.toml ---
[package]
name = "dpapi-transport"
version = "0.1.0"
edition = "2021"
readme = "README.md"
license = "MIT/Apache-2.0"
homepage = "https://github.com/devolutions/sspi-rs"
repository = "https://github.com/devolutions/sspi-rs"
authors = ["Devolutions Inc. <infos@devolutions.net>"]
description = "Common types and traits for implementing DPAPI RPC transport"
publish = false # not ready yet

[dependencies]
url = "2.5"
thiserror = "2.0"
uuid.workspace = true

[lints]
workspace = true


--- File: crates/dpapi-transport/README.md ---
# DPAPI transport

Contains common types and traits for implementing custom DPAPI RPC communication transport.

--- File: crates/dpapi-transport/src/connect_options.rs ---
use std::future::Future;
use std::pin::Pin;

use thiserror::Error;
use url::Url;
use uuid::Uuid;

/// Type that represents a function for obtaining the session token.
///
/// We need it because we don't know the destination address in advance.
///
/// Parameters:
/// * `Uuid` is the session id.
/// * `Url` is the destination of the proxied connection.
pub type GetSessionTokenFn = dyn Fn(Uuid, Url) -> Pin<Box<dyn Future<Output = std::io::Result<String>>>>;

/// Default port for RPC communication.
pub const DEFAULT_RPC_PORT: u16 = 135;

const WSS_SCHEME: &str = "wss";
const WS_SCHEME: &str = "ws";
const TCP_SCHEME: &str = "tcp";

/// An error returned
#[derive(Debug, Error)]
pub enum Error {
    /// The RPC server (destination) or proxy URL is invalid.
    #[error("invalid URL: {0}")]
    InvalidUrl(&'static str),

    /// Failed to parse URL.
    #[error(transparent)]
    UrlParse(#[from] url::ParseError),
}

pub type Result<T> = core::result::Result<T, Error>;

/// Target server connection options.
pub enum ConnectOptions {
    /// Regular TCP connection. Contains target RPC server address.
    Tcp(Url),

    /// Tunneled connection via Devolutions Gateway using a WebSocket.
    WsTunnel {
        /// Devolutions Gateway address.
        proxy: Url,
        /// Target RPC server address.
        destination: Url,
        /// Callback for obtaining proxy session token.
        get_session_token: Box<GetSessionTokenFn>,
    },
}

/// Proxy connection options.
pub struct ProxyOptions {
    /// Devolutions Gateway address.
    pub proxy: Url,
    /// Callback for obtaining proxy session token.
    pub get_session_token: Box<GetSessionTokenFn>,
}

impl ConnectOptions {
    /// Constructs a new [ConnectOptions] object.
    ///
    /// Parameters:
    /// * `destination` - target RPC server URL.
    /// * `proxy_options` - proxying options.
    ///
    /// Returns an error if the provided URLs are not valid.
    pub fn new(destination: &str, proxy_options: Option<ProxyOptions>) -> Result<Self> {
        let mut destination = Url::parse(&if destination.contains("://") {
            destination.to_owned()
        } else {
            format!("tcp://{destination}")
        })?;

        if destination.scheme().is_empty() {
            destination.set_scheme(TCP_SCHEME).expect("TCP_SCHEME value is valid");
        }
        if destination.port().is_none() {
            destination
                .set_port(Some(DEFAULT_RPC_PORT))
                .expect("URL isn't `cannot-be-a-base`, so it should not fail");
        }

        if let Some(ProxyOptions {
            proxy,
            get_session_token,
        }) = proxy_options
        {
            match (proxy.scheme(), destination.scheme()) {
                (WS_SCHEME | WSS_SCHEME, TCP_SCHEME) => (),
                _ => {
                    return Err(Error::InvalidUrl(
                        "WS proxy or target server URL scheme is invalid or unsupported",
                    ));
                }
            }

            Ok(ConnectOptions::WsTunnel {
                proxy,
                destination,
                get_session_token,
            })
        } else {
            if destination.scheme() != TCP_SCHEME {
                return Err(Error::InvalidUrl(
                    "WS proxy or target server URL scheme is invalid or unsupported",
                ));
            }

            Ok(ConnectOptions::Tcp(destination))
        }
    }

    /// Sets the new port for the destination RPC server.
    pub fn set_destination_port(&mut self, new_port: u16) {
        match self {
            Self::Tcp(addr) => addr.set_port(Some(new_port)),
            Self::WsTunnel {
                destination: tcp_addr, ..
            } => tcp_addr.set_port(Some(new_port)),
        }
        .expect("URL isn't `cannot-be-a-base`, so it should not fail");
    }
}


--- File: crates/dpapi-transport/src/lib.rs ---
#![doc = include_str!("../README.md")]
#![warn(missing_docs)]

mod connect_options;

use std::future::Future;
use std::io::Result;

pub use connect_options::{
    ConnectOptions, Error as ConnectOptionsError, GetSessionTokenFn, ProxyOptions, DEFAULT_RPC_PORT,
};

/// Represents a transport for communicating with the target server.
pub trait Transport {
    /// A type that represents communication stream.
    type Stream: Stream;

    /// Connects to the target server.
    fn connect(connect_options: &ConnectOptions) -> impl Future<Output = Result<Self::Stream>>;
}

/// Stream for reading and writing bytes.
pub trait Stream {
    /// Reads an exact number of bytes from the stream and returns buffer as `Vec`.
    fn read_vec(&mut self, length: usize) -> impl Future<Output = Result<Vec<u8>>>;

    /// Read a data from the stream until it fully fills the buffer.
    fn read_exact(&mut self, buf: &mut [u8]) -> impl Future<Output = Result<()>>;

    /// Writes an entire buffer and flushes the stream.
    fn write_all(&mut self, buf: &[u8]) -> impl Future<Output = Result<()>>;
}


--- File: crates/dpapi-web/Cargo.toml ---
[package]
name = "dpapi-web"
version = "0.0.0"
edition = "2021"
description = "WebAssembly high-level bindings targeting web browsers"
readme = "README.md"
license = "MIT/Apache-2.0"
homepage = "https://github.com/devolutions/sspi-rs"
repository = "https://github.com/devolutions/sspi-rs"
authors = ["Devolutions Inc. <infos@devolutions.net>"]
publish = false

[lib]
doctest = false
test = false
crate-type = ["cdylib", "rlib"]

[features]
default = ["panic_hook"]
panic_hook = ["dep:console_error_panic_hook"]

[dependencies]

# DPAPI
dpapi.workspace = true
dpapi-transport.workspace = true
sspi = { path = "../..", version = "0.16" }

# WASM
wasm-bindgen = "0.2"
wasm-bindgen-futures = "0.4"
js-sys = "0.3"
gloo-net = { version = "0.6", default-features = false, features = ["websocket", "http", "io-util"] }
gloo-timers = { version = "0.3", default-features = false, features = ["futures"] }
tracing-web = "0.1"

# Async
futures-util = { version = "0.3", features = ["io"] }

# Logging
tracing.workspace = true
tracing-subscriber = { version = "0.3", features = ["time"] }

# The `console_error_panic_hook` crate provides better debugging of panics by
# logging them with `console.error`. This is great for development, but requires
# all the `std::fmt` and `std::panicking` infrastructure, so isn't great for
# code size when deploying.
console_error_panic_hook = { version = "0.1", optional = true }

reqwest = { version = "0.12", default-features = false, features = ["rustls-tls-webpki-roots"] }
rustls-pki-types = { version = "1.11", features = ["web"] }

# Utils
anyhow = "1"
url = "2.5"

uuid = { workspace = true, default-features = false }

# Enable WebAssembly support for a few crates
[target.'cfg(target_arch = "wasm32")'.dependencies]
getrandom02 = { package = "getrandom", version = "0.2", default-features = false, features = ["js"] }
getrandom03 = { package = "getrandom", version = "0.3", default-features = false, features = ["wasm_js"] }
time = { workspace = true, features = ["wasm-bindgen"] }

[lints]
workspace = true


--- File: crates/dpapi-web/README.md ---
# DPAPI web

WebAssembly high-level bindings targeting web browsers.

--- File: crates/dpapi-web/rust-toolchain.toml ---
[toolchain]
targets = ["wasm32-unknown-unknown"]
profile = "minimal"

--- File: crates/dpapi-web/src/error.rs ---
use wasm_bindgen::prelude::wasm_bindgen;

#[wasm_bindgen]
pub struct DpapiError {
    error: anyhow::Error,
}

#[wasm_bindgen]
impl DpapiError {
    pub fn backtrace(&self) -> String {
        format!("{:?}", self.error)
    }
}

impl From<anyhow::Error> for DpapiError {
    fn from(e: anyhow::Error) -> Self {
        Self { error: e }
    }
}

impl From<dpapi::Error> for DpapiError {
    fn from(err: dpapi::Error) -> Self {
        Self {
            error: anyhow::Error::new(err),
        }
    }
}

impl From<url::ParseError> for DpapiError {
    fn from(err: url::ParseError) -> Self {
        Self {
            error: anyhow::Error::new(err),
        }
    }
}


--- File: crates/dpapi-web/src/lib.rs ---
#![doc = include_str!("../README.md")]
#![warn(missing_docs)]
// Default trait can’t be used by wasm consumer anyway
#![allow(clippy::new_without_default)]

#[macro_use]
extern crate tracing;

mod error;
mod network_client;
mod session_token;
mod transport;

use std::cell::RefCell;
use std::rc::Rc;

use anyhow::Context;
use dpapi::{CryptProtectSecretArgs, CryptUnprotectSecretArgs};
use sspi::KerberosConfig;
use url::Url;
use wasm_bindgen::prelude::*;

use crate::error::DpapiError;
use crate::network_client::WasmNetworkClient;
use crate::session_token::session_token_fn;
use crate::transport::WasmTransport;

/// DPAPI command.
#[derive(Clone)]
enum Command {
    /// Encrypts the secret.
    Encrypt {
        /// User's SID.
        sid: String,
        /// Secret to encrypt.
        secret: String,
    },
    /// Decrypts the DPAPI blob.
    Decrypt {
        /// DPAPI blob.
        blob: Vec<u8>,
    },
}

#[derive(Clone)]
struct ProxyOptions {
    proxy: String,
    get_session_token: js_sys::Function,
}

/// DPAPI config.
#[wasm_bindgen]
#[derive(Clone)]
pub struct DpapiConfig(Rc<RefCell<DpapiConfigInner>>);

#[derive(Default)]
struct DpapiConfigInner {
    server: Option<String>,
    proxy: Option<ProxyOptions>,
    username: Option<String>,
    password: Option<String>,
    computer_name: Option<String>,
    command: Option<Command>,
    kdc_proxy_url: Option<String>,
}

#[wasm_bindgen]
impl DpapiConfig {
    /// Initializes the config.
    pub fn new() -> Self {
        Self(Rc::new(RefCell::new(DpapiConfigInner::default())))
    }

    /// Set the target RPC server address.
    ///
    /// **Required**.
    pub fn server(&mut self, server: String) -> Self {
        self.0.borrow_mut().server = Some(server);
        self.clone()
    }

    /// Set the KDC proxy URL.
    ///
    /// **Optional**.
    pub fn kdc_proxy_url(&self, kdc_proxy_url: Option<String>) -> Self {
        self.0.borrow_mut().kdc_proxy_url = kdc_proxy_url;
        self.clone()
    }

    /// Set the proxy address.
    ///
    /// **Required**.
    pub fn proxy(&mut self, proxy: String, get_session_token: js_sys::Function) -> Self {
        self.0.borrow_mut().proxy = Some(ProxyOptions {
            proxy,
            get_session_token,
        });
        self.clone()
    }

    /// Set the AD user name.
    ///
    /// **Required**.
    pub fn username(&mut self, username: String) -> Self {
        self.0.borrow_mut().username = Some(username);
        self.clone()
    }

    /// Set the AD user password.
    ///
    /// **Required**.
    pub fn password(&mut self, password: String) -> Self {
        self.0.borrow_mut().password = Some(password);
        self.clone()
    }

    /// Set the client's computer name.
    ///
    /// **Optional**.
    pub fn computer_name(&mut self, computer_name: String) -> Self {
        self.0.borrow_mut().computer_name = Some(computer_name);
        self.clone()
    }

    /// Set the encrypt command.
    ///
    /// Either [encrypt] or [decrypt] must be called at least once.
    pub fn encrypt(&mut self, sid: String, secret: String) -> Self {
        self.0.borrow_mut().command = Some(Command::Encrypt { sid, secret });
        self.clone()
    }

    /// Set the decrypt command.
    ///
    /// Either [encrypt] or [decrypt] must be called at least once.
    pub fn decrypt(&mut self, blob: Vec<u8>) -> Self {
        self.0.borrow_mut().command = Some(Command::Decrypt { blob });
        self.clone()
    }

    /// Run the DPAPI client.
    pub async fn run(&self) -> Result<Vec<u8>, DpapiError> {
        let (server, proxy, username, password, computer_name, command, kdc_proxy_url);

        {
            let inner = self.0.borrow_mut();

            server = inner.server.clone().context("server address missing")?;
            proxy = inner.proxy.clone().context("proxy missing")?;
            username = inner.username.clone().context("username missing")?;
            password = inner.password.clone().context("password missing")?;
            computer_name = inner.computer_name.clone();
            command = inner.command.clone().context("command missing")?;
            kdc_proxy_url = inner.kdc_proxy_url.clone();
        }

        let mut network_client = WasmNetworkClient;

        let ProxyOptions {
            proxy: proxy_url,
            get_session_token,
        } = proxy;
        let proxy_url = Url::parse(&proxy_url)?;
        let proxy = Some(dpapi_transport::ProxyOptions {
            proxy: proxy_url,
            get_session_token: session_token_fn(get_session_token),
        });
        // if kdc_proxy_url does not exit, give url parser a empty string, it will fail anyway and map to a None
        let kerberos_config = Url::parse(kdc_proxy_url.unwrap_or_default().as_str())
            .ok()
            .map(|url| KerberosConfig {
                kdc_url: Some(url),
                client_computer_name: computer_name.clone(),
            });

        match command {
            Command::Encrypt { sid, secret } => Ok(Box::pin(dpapi::n_crypt_protect_secret::<WasmTransport>(
                CryptProtectSecretArgs {
                    data: secret.into_bytes().into(),
                    sid,
                    root_key_id: None,
                    server: &server,
                    proxy,
                    username: &username,
                    password: password.into(),
                    client_computer_name: computer_name,
                    network_client: &mut network_client,
                    kerberos_config,
                },
            ))
            .await?),
            Command::Decrypt { blob } => Ok(Box::pin(dpapi::n_crypt_unprotect_secret::<WasmTransport>(
                CryptUnprotectSecretArgs {
                    blob: &blob,
                    server: &server,
                    proxy,
                    username: &username,
                    password: password.into(),
                    client_computer_name: computer_name,
                    network_client: &mut network_client,
                    kerberos_config,
                },
            ))
            .await?
            .as_ref()
            .to_owned()),
        }
    }
}

/// Initializes the panic hook and logger.
#[wasm_bindgen]
pub fn dpapi_init(log_level: &str) {
    // When the `console_error_panic_hook` feature is enabled, we can call the
    // `set_panic_hook` function at least once during initialization, and then
    // we will get better error messages if our code ever panics.
    //
    // For more details see
    // https://github.com/rustwasm/console_error_panic_hook#readme
    #[cfg(feature = "panic_hook")]
    console_error_panic_hook::set_once();

    if let Ok(level) = log_level.parse::<tracing::Level>() {
        set_logger_once(level);
    }
}

fn set_logger_once(level: tracing::Level) {
    use tracing_subscriber::filter::LevelFilter;
    use tracing_subscriber::fmt::time::UtcTime;
    use tracing_subscriber::prelude::*;
    use tracing_web::MakeConsoleWriter;

    static INIT: std::sync::Once = std::sync::Once::new();

    INIT.call_once(|| {
        let fmt_layer = tracing_subscriber::fmt::layer()
            .with_ansi(false)
            .with_timer(UtcTime::rfc_3339()) // std::time is not available in browsers
            .with_writer(MakeConsoleWriter);

        let level_filter = LevelFilter::from_level(level);

        tracing_subscriber::registry().with(fmt_layer).with(level_filter).init();

        debug!("DPAPI is ready");
    })
}


--- File: crates/dpapi-web/src/network_client.rs ---
use std::future::Future;
use std::pin::Pin;

use dpapi::sspi::network_client::AsyncNetworkClient;
use dpapi::sspi::{Error, ErrorKind, NetworkProtocol, NetworkRequest, Result};

#[derive(Debug)]
pub(crate) struct WasmNetworkClient;

impl AsyncNetworkClient for WasmNetworkClient {
    fn send<'a>(
        &'a mut self,
        network_request: &'a NetworkRequest,
    ) -> Pin<Box<dyn Future<Output = Result<Vec<u8>>> + 'a>> {
        Box::pin(async move {
            debug!(?network_request.protocol, ?network_request.url);

            match &network_request.protocol {
                NetworkProtocol::Http | NetworkProtocol::Https => {
                    let body = js_sys::Uint8Array::from(&network_request.data[..]);

                    let response = gloo_net::http::Request::post(network_request.url.as_str())
                        .header("keep-alive", "true")
                        .body(body)
                        .map_err(|e| {
                            Error::new(
                                ErrorKind::NoAuthenticatingAuthority,
                                format!("failed to send KDC request: {e}"),
                            )
                        })?
                        .send()
                        .await
                        .map_err(|err| match err {
                            err if err.to_string().to_lowercase().contains("certificate") => Error::new(
                                ErrorKind::CertificateUnknown,
                                format!("Invalid certificate data: {:?}", err),
                            ),
                            _ => Error::new(
                                ErrorKind::NoAuthenticatingAuthority,
                                format!("Unable to send the data to the KDC Proxy: {:?}", err),
                            ),
                        })?;

                    if !response.ok() {
                        return Err(Error::new(
                            ErrorKind::NoAuthenticatingAuthority,
                            format!(
                                "KdcProxy: HTTP status error ({} {})",
                                response.status(),
                                response.status_text(),
                            ),
                        ));
                    }

                    let body = response.binary().await.map_err(|err| {
                        Error::new(
                            ErrorKind::NoAuthenticatingAuthority,
                            format!("Unable to read the response data from the KDC Proxy: {:?}", err),
                        )
                    })?;

                    Ok(body)
                }
                unsupported => Err(Error::new(
                    ErrorKind::ApplicationProtocolMismatch,
                    format!("unsupported protocol: {unsupported:?}"),
                )),
            }
        })
    }
}


--- File: crates/dpapi-web/src/session_token.rs ---
use std::io::Error;

use dpapi_transport::GetSessionTokenFn;
use url::Url;
use uuid::Uuid;
use wasm_bindgen::prelude::*;
use wasm_bindgen_futures::JsFuture;

/// This function wraps a JS-function into a Rust closure which we can pass into the Rust API.
pub fn session_token_fn(get_session_token: js_sys::Function) -> Box<GetSessionTokenFn> {
    Box::new(move |session_id: Uuid, destination: Url| {
        let get_session_token = get_session_token.clone();
        Box::pin(async move {
            let session_id = JsValue::from_str(&session_id.to_string());
            let destination = JsValue::from_str(destination.as_str());

            let promise = get_session_token
                .call2(&JsValue::NULL, &session_id, &destination)
                .map_err(|err| Error::other(format!("failed to obtain the session token: {:?}", err)))?
                .dyn_into::<js_sys::Promise>()
                .map_err(|err| Error::other(format!("failed to obtain the session token: {:?}", err)))?;

            let session_token = JsFuture::from(promise)
                .await
                .map_err(|err| Error::other(format!("failed to obtain the session token: {:?}", err)))?;

            session_token
                .as_string()
                .ok_or_else(|| Error::other("obtained session token is not a String"))
        })
    })
}


--- File: crates/dpapi-web/src/transport.rs ---
use std::io::{Error, ErrorKind};
use std::time::Duration;

use dpapi_transport::{ConnectOptions, Stream, Transport};
use futures_util::{AsyncRead, AsyncWrite};
use gloo_net::websocket;
use gloo_net::websocket::futures::WebSocket;
use url::Url;
use uuid::Uuid;

pub trait AsyncReadWrite: AsyncRead + AsyncWrite + Unpin {}

impl<T> AsyncReadWrite for T where T: AsyncRead + AsyncWrite + Unpin + 'static {}

type ErasedReadWrite = Box<dyn AsyncReadWrite>;

pub struct FuturesStream<S> {
    stream: S,
}

impl<S> FuturesStream<S> {
    fn new(stream: S) -> Self {
        Self { stream }
    }
}

impl<S> Stream for FuturesStream<S>
where
    S: AsyncRead + AsyncWrite + Unpin,
{
    async fn read_vec(&mut self, length: usize) -> Result<Vec<u8>, Error> {
        let mut buf = vec![0; length];
        self.read_exact(&mut buf).await?;
        Ok(buf)
    }

    async fn read_exact(&mut self, mut buf: &mut [u8]) -> Result<(), Error> {
        use futures_util::AsyncReadExt as _;

        while !buf.is_empty() {
            let bytes_read = Box::pin(async { self.stream.read(buf).await }).await?;
            buf = &mut buf[bytes_read..];

            if bytes_read == 0 {
                return Err(ErrorKind::UnexpectedEof.into());
            }
        }

        Ok(())
    }

    async fn write_all(&mut self, buf: &[u8]) -> Result<(), Error> {
        use futures_util::AsyncWriteExt as _;

        Box::pin(async {
            self.stream.write_all(buf).await?;
            self.stream.flush().await?;

            Ok(())
        })
        .await
    }
}

/// WASM transport.
///
/// It uses the WEB API under the hood to open the WS connection.
pub struct WasmTransport;

impl WasmTransport {
    /// Connects to the RPC server via the Devolutions Gateway tunneled connection.
    async fn ws_connect(
        mut proxy: Url,
        session_id: Uuid,
        session_token: &str,
    ) -> Result<FuturesStream<ErasedReadWrite>, Error> {
        proxy.path_segments_mut().unwrap().extend([session_id.to_string()]);
        proxy.query_pairs_mut().append_pair("token", session_token);

        let ws = WebSocket::open(proxy.as_str()).map_err(Error::other)?;

        // NOTE: ideally, when the WebSocket can’t be opened, the above call should fail with details on why is that
        // (e.g., the proxy hostname could not be resolved, proxy service is not running), but errors are never
        // bubbled up in practice, so instead we poll the WebSocket state until we know its connected (i.e., the
        // WebSocket handshake is a success and user data can be exchanged).
        loop {
            match ws.state() {
                websocket::State::Closing | websocket::State::Closed => {
                    return Err(Error::new(
                        ErrorKind::BrokenPipe,
                        format!("failed to open a WS connection: {:?}", ws.state()),
                    ));
                }
                websocket::State::Connecting => {
                    trace!("WebSocket is connecting to proxy at {proxy}...");
                    gloo_timers::future::sleep(Duration::from_millis(50)).await;
                }
                websocket::State::Open => {
                    debug!("WebSocket connected to {proxy} with success");
                    break;
                }
            }
        }

        Ok(FuturesStream::new(Box::new(ws) as ErasedReadWrite))
    }
}

impl Transport for WasmTransport {
    type Stream = FuturesStream<ErasedReadWrite>;

    #[instrument(err, skip_all)]
    async fn connect(connection_options: &ConnectOptions) -> Result<Self::Stream, Error> {
        match connection_options {
            ConnectOptions::Tcp(_) => Err(Error::new(
                ErrorKind::Unsupported,
                "tcp transport is not supported for wasm32 target",
            )),
            ConnectOptions::WsTunnel {
                proxy,
                destination,
                get_session_token,
            } => {
                let session_id = Uuid::new_v4();
                debug!("session token");
                let session_token = get_session_token(session_id, destination.clone()).await?;

                Self::ws_connect(proxy.clone(), session_id, session_token.as_ref()).await
            }
        }
    }
}


--- File: crates/dpapi/Cargo.toml ---
[package]
name = "dpapi"
version = "0.2.0"
edition = "2021"
readme = "README.md"
license = "MIT/Apache-2.0"
homepage = "https://github.com/devolutions/sspi-rs"
repository = "https://github.com/devolutions/sspi-rs"
authors = ["Devolutions Inc. <infos@devolutions.net>"]
description = "A Rust implementation of Windows DPAPI"
publish = false # not ready yet

[lib]
name = "dpapi"

[features]
tsssp = ["sspi/tsssp"]

[dependencies]
bitflags.workspace = true
byteorder.workspace = true
num-derive.workspace = true
num-traits = { workspace = true, default-features = true }
uuid = { workspace = true, features = ["std"] }
picky-asn1.workspace = true
picky-asn1-der.workspace = true
picky-krb = "0.11"
picky-asn1-x509 = { workspace = true, features = ["pkcs7"] }
num-bigint-dig.workspace = true
sha1.workspace = true
sha2.workspace = true
rand.workspace = true
hmac.workspace = true
tracing = { workspace = true, default-features = true }
whoami.workspace = true

dpapi-core = { workspace = true, features = ["alloc"] }
dpapi-pdu.workspace = true
dpapi-transport.workspace = true
sspi = { path = "../..", version = "0.16" } # public

kbkdf = "0.0.1"
sha1-pre = { version = "0.11.0-pre.2", package = "sha1" }
sha2-pre = { version = "0.11.0-pre.2", package = "sha2" }
hmac-pre = { version = "0.13.0-pre.4", package = "hmac" }
digest-pre = { version = "0.11.0-pre.9", package = "digest", default-features = false }

elliptic-curve = { version = "0.13", features = ["sec1", "std"] }
p521 = { version = "0.13", features = ["ecdh"] }
p256 = { version = "0.13", features = ["ecdh"] }
p384 = { version = "0.13", features = ["ecdh"] }
concat-kdf = { version = "0.1", features = ["std"] }
typenum = "1.18"
aes-kw = { version = "0.2", features = ["std"] }
aes-gcm = { version = "0.10", features = ["std"] }
url = "2.5"

thiserror = "2.0"
regex = "1.11"

[dev-dependencies]
paste = "1.0"

[lints]
workspace = true


--- File: crates/dpapi/README.md ---
# dpapi-rs

This crate contains a Windows [DPAPI](https://learn.microsoft.com/en-us/windows/win32/seccng/cng-dpapi) implementation. It can encrypt the data/decrypt DPAPI blobs using the domain's root key.

It automatically makes RPC calls to obtain the root key. The user must provide credentials to authenticate in the DC.

It implements the [MS-GKDI Group Key Distribution Protocol](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gkdi/943dd4f6-6b80-4a66-8594-80df6d2aad0a).

The original DPAPI supports many [protection descriptors](https://learn.microsoft.com/en-us/windows/win32/seccng/protection-descriptors). This library implements only SID protection descriptor.

--- File: crates/dpapi/src/blob.rs ---
use dpapi_core::{decode_owned, EncodeVec};
use dpapi_pdu::gkdi::KeyIdentifier;
use picky_asn1::restricted_string::Utf8String;
use picky_asn1::wrapper::{
    Asn1SequenceOf, ExplicitContextTag0, ImplicitContextTag0, ObjectIdentifierAsn1, OctetStringAsn1, Optional,
    Utf8StringAsn1,
};
use picky_asn1_der::Asn1RawDer;
use picky_asn1_x509::cmsversion::CmsVersion;
use picky_asn1_x509::enveloped_data::{
    ContentEncryptionAlgorithmIdentifier, ContentInfo, ContentType, EncryptedContent, EncryptedContentInfo,
    EncryptedKey, EnvelopedData, GeneralProtectionDescriptor, KekIdentifier, KekRecipientInfo,
    KeyEncryptionAlgorithmIdentifier, OtherKeyAttribute, ProtectionDescriptor, RecipientInfo, RecipientInfos,
};
use picky_asn1_x509::oids;
use thiserror::Error;

use crate::sid::{ace_to_bytes, sd_to_bytes};

#[derive(Debug, Error)]
pub enum BlobError {
    #[error("unsupported protection descriptor: {0}")]
    UnsupportedProtectionDescriptor(String),

    #[error("invalid {name}: expected {expected} but got {actual}")]
    InvalidOid {
        name: &'static str,
        expected: String,
        actual: String,
    },

    #[error("invalid {name} version: expected {expected:?} but got {actual:?}")]
    InvalidCmsVersion {
        name: &'static str,
        expected: CmsVersion,
        actual: CmsVersion,
    },

    #[error("bad recipient infos amount: expected {expected} but got {actual}")]
    RecipientInfosAmount { expected: usize, actual: usize },

    #[error("missing {0} value")]
    MissingValue(&'static str),
}

#[derive(Debug, Clone, PartialEq, Eq, Default)]
pub enum ProtectionDescriptorType {
    #[default]
    Sid,
    KeyFile,
    Sddl,
    Local,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct SidProtectionDescriptor {
    pub sid: String,
}

impl SidProtectionDescriptor {
    pub fn get_target_sd(&self) -> crate::Result<Vec<u8>> {
        // Build the target security descriptor from the SID passed in. This SD
        // contains an ACE per target user with a mask of 0x3 and a final ACE of
        // the current user with a mask of 0x2. When viewing this over the wire
        // the current user is set as S-1-1-0 (World) and the owner/group is
        // S-1-5-18 (SYSTEM).
        sd_to_bytes(
            "S-1-5-18",
            "S-1-5-18",
            None,
            Some(&[ace_to_bytes(&self.sid, 3)?, ace_to_bytes("S-1-1-0", 2)?]),
        )
    }

    pub fn encode_asn1(&self) -> crate::Result<Vec<u8>> {
        Ok(picky_asn1_der::to_vec(&GeneralProtectionDescriptor {
            descriptor_type: ObjectIdentifierAsn1::from(oids::sid_protection_descriptor()),
            descriptors: Asn1SequenceOf::from(vec![Asn1SequenceOf::from(vec![ProtectionDescriptor {
                descriptor_type: Utf8StringAsn1::from(Utf8String::from_string("SID".to_owned())?),
                descriptor_value: Utf8StringAsn1::from(Utf8String::from_string(self.sid.clone())?),
            }])]),
        })?)
    }

    pub fn decode_asn1(data: &[u8]) -> crate::Result<Self> {
        let general_protection_descriptor: GeneralProtectionDescriptor = picky_asn1_der::from_bytes(data)?;

        if general_protection_descriptor.descriptor_type.0 != oids::sid_protection_descriptor() {
            Err(BlobError::UnsupportedProtectionDescriptor(
                general_protection_descriptor.descriptor_type.0.into(),
            ))?;
        }

        let ProtectionDescriptor {
            descriptor_type,
            descriptor_value,
        } = general_protection_descriptor
            .descriptors
            .0
            .first()
            .ok_or(BlobError::MissingValue("protection descriptor"))?
            .0
            .first()
            .ok_or(BlobError::MissingValue("protection descriptor"))?;

        if descriptor_type.0.as_utf8() != "SID" {
            Err(BlobError::UnsupportedProtectionDescriptor(
                descriptor_type.0.as_utf8().to_owned(),
            ))?;
        }

        Ok(Self {
            sid: descriptor_value.0.as_utf8().to_owned(),
        })
    }
}

/// Represents DPAPI blob.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct DpapiBlob {
    /// The key identifier for the KEK.
    pub key_identifier: KeyIdentifier,
    /// The protection descriptor that protects the key.
    pub protection_descriptor: SidProtectionDescriptor,
    /// The encrypted CEK.
    pub enc_cek: Vec<u8>,
    /// CEK encryption algorithm.
    pub enc_cek_algorithm_id: KeyEncryptionAlgorithmIdentifier,
    /// The encrypted content.
    pub enc_content: Vec<u8>,
    /// Content encryption algorithm.
    pub enc_content_algorithm_id: ContentEncryptionAlgorithmIdentifier,
}

impl DpapiBlob {
    // blob_in_envelope:
    // * `true` to store the encrypted blob in the EnvelopedData structure (NCryptProtectSecret general).
    // * `false` to append the encrypted blob after the EnvelopedData structure (LAPS style).
    pub fn encode(&self, blob_in_envelope: bool, dst: &mut Vec<u8>) -> crate::Result<()> {
        picky_asn1_der::to_writer(
            &ContentInfo {
                content_type: ObjectIdentifierAsn1::from(oids::enveloped_data()),
                content: ExplicitContextTag0::from(Asn1RawDer(picky_asn1_der::to_vec(&EnvelopedData {
                    version: CmsVersion::V2,
                    originator_info: Optional::from(None),
                    recipient_infos: RecipientInfos::from(vec![RecipientInfo::Kek(KekRecipientInfo {
                        version: CmsVersion::V4,
                        kek_id: KekIdentifier {
                            key_identifier: OctetStringAsn1::from(self.key_identifier.encode_vec()?),
                            date: Optional::from(None),
                            other: Optional::from(Some(OtherKeyAttribute {
                                key_attr_id: ObjectIdentifierAsn1::from(oids::protection_descriptor_type()),
                                key_attr: Some(Asn1RawDer(self.protection_descriptor.encode_asn1()?)),
                            })),
                        },
                        key_encryption_algorithm: self.enc_cek_algorithm_id.clone(),
                        encrypted_key: EncryptedKey::from(self.enc_cek.clone()),
                    })]),
                    encrypted_content_info: EncryptedContentInfo {
                        content_type: ContentType::from(oids::content_info_type_data()),
                        content_encryption_algorithm: self.enc_content_algorithm_id.clone(),
                        encrypted_content: Optional::from(if blob_in_envelope {
                            Some(ImplicitContextTag0::from(EncryptedContent::from(
                                self.enc_content.clone(),
                            )))
                        } else {
                            None
                        }),
                    },
                    unprotected_attrs: Optional::from(None),
                })?)),
            },
            &mut *dst,
        )?;

        if !blob_in_envelope {
            dst.extend_from_slice(&self.enc_content);
        }

        Ok(())
    }

    pub fn decode(mut src: &[u8]) -> crate::Result<Self> {
        let content_info: ContentInfo = picky_asn1_der::from_reader(&mut src)?;

        if content_info.content_type.0 != oids::enveloped_data() {
            let expected_content_type: String = oids::enveloped_data().into();
            let actual_content_type: String = content_info.content_type.0.into();

            Err(BlobError::InvalidOid {
                name: "blob content type",
                expected: expected_content_type,
                actual: actual_content_type,
            })?;
        }

        let enveloped_data: EnvelopedData = picky_asn1_der::from_bytes(&content_info.content.0 .0)?;

        if enveloped_data.version != CmsVersion::V2 {
            Err(BlobError::InvalidCmsVersion {
                name: "enveloped data",
                expected: CmsVersion::V2,
                actual: enveloped_data.version,
            })?;
        }

        if enveloped_data.recipient_infos.0.len() != 1 {
            Err(BlobError::RecipientInfosAmount {
                expected: 1,
                actual: enveloped_data.recipient_infos.0.len(),
            })?;
        }

        let RecipientInfo::Kek(kek_info) = enveloped_data.recipient_infos.0.first().unwrap();

        if kek_info.version != CmsVersion::V4 {
            Err(BlobError::InvalidCmsVersion {
                name: "KEK info",
                expected: CmsVersion::V4,
                actual: kek_info.version,
            })?;
        }

        let key_identifier: KeyIdentifier = decode_owned(&kek_info.kek_id.key_identifier.0 as &[u8])?;

        let protection_descriptor = if let Some(OtherKeyAttribute { key_attr_id, key_attr }) = &kek_info.kek_id.other.0
        {
            if key_attr_id.0 != oids::protection_descriptor_type() {
                let expected_descriptor: String = oids::protection_descriptor_type().into();
                let actual_descriptor: String = (&key_attr_id.0).into();

                Err(BlobError::InvalidOid {
                    name: "KEK recipient info OtherAttribute OID",
                    expected: expected_descriptor,
                    actual: actual_descriptor,
                })?;
            }

            if let Some(encoded_protection_descriptor) = key_attr {
                SidProtectionDescriptor::decode_asn1(&encoded_protection_descriptor.0)?
            } else {
                Err(BlobError::MissingValue("KEK recipient info OtherAttribute"))?
            }
        } else {
            Err(BlobError::MissingValue("KEK recipient info protection descriptor"))?
        };

        let enc_content = if let Some(enc_content) = enveloped_data.encrypted_content_info.encrypted_content.0 {
            // Some DPAPI blobs don't include the content in the PKCS7 payload but
            // just append it after the blob.
            if enc_content.0 .0.is_empty() {
                src.to_vec()
            } else {
                enc_content.0 .0
            }
        } else {
            src.to_vec()
        };
        let enc_content_algorithm_id = enveloped_data.encrypted_content_info.content_encryption_algorithm;

        let KekRecipientInfo {
            encrypted_key,
            key_encryption_algorithm,
            version: _,
            kek_id: _,
        } = kek_info;

        Ok(Self {
            key_identifier,
            protection_descriptor,
            enc_cek: encrypted_key.0.clone(),
            enc_cek_algorithm_id: key_encryption_algorithm.clone(),
            enc_content,
            enc_content_algorithm_id,
        })
    }
}


--- File: crates/dpapi/src/client.rs ---
use dpapi_core::{decode_owned, EncodeVec};
use dpapi_pdu::gkdi::{GetKey, GroupKeyEnvelope};
use dpapi_pdu::rpc::{
    build_tcpip_tower, BindAck, BindTimeFeatureNegotiationBitmask, Command, CommandFlags, CommandPContext,
    ContextElement, ContextResultCode, EntryHandle, EptMap, EptMapResult, Floor, Response, SecurityTrailer,
    VerificationTrailer, EPM,
};
use dpapi_transport::{ConnectOptions, ProxyOptions, Transport};
use picky_asn1_x509::enveloped_data::{ContentEncryptionAlgorithmIdentifier, KeyEncryptionAlgorithmIdentifier};
use picky_asn1_x509::{AesMode, AesParameters};
use sspi::credssp::SspiContext;
use sspi::negotiate::ProtocolConfig;
use sspi::network_client::AsyncNetworkClient;
use sspi::ntlm::NtlmConfig;
use sspi::{AuthIdentity, Credentials, KerberosConfig, Negotiate, NegotiateConfig, Secret, Username};
use thiserror::Error;
use uuid::Uuid;

use crate::blob::{DpapiBlob, SidProtectionDescriptor};
use crate::crypto::{cek_decrypt, cek_encrypt, cek_generate, content_decrypt, content_encrypt};
use crate::gkdi::{get_kek, new_kek, unpack_response, ISD_KEY};
use crate::rpc::auth::AuthError;
use crate::rpc::{bind_time_feature_negotiation, AuthProvider, RpcClient, NDR, NDR64};
use crate::{Error, Result};

#[derive(Debug, Error)]
pub enum ClientError {
    #[error("BindAcknowledge doesn't contain desired context element")]
    MissingDesiredContext,

    #[error("TCP floor is missing in EptMap response")]
    MissingTcpFloor,

    #[error("bad EptMap response status: {0}")]
    BadEptMapStatus(u32),

    #[error("failed to set rustls crypto provider")]
    CryptoProvider,
}

fn get_epm_contexts() -> Vec<ContextElement> {
    vec![ContextElement {
        context_id: 0,
        abstract_syntax: EPM,
        transfer_syntaxes: vec![NDR64],
    }]
}

fn get_isd_key_key_contexts() -> Vec<ContextElement> {
    vec![
        ContextElement {
            context_id: 0,
            abstract_syntax: ISD_KEY,
            transfer_syntaxes: vec![NDR64],
        },
        ContextElement {
            context_id: 1,
            abstract_syntax: ISD_KEY,
            transfer_syntaxes: vec![bind_time_feature_negotiation(BindTimeFeatureNegotiationBitmask::None)],
        },
    ]
}

fn get_ept_map_isd_key() -> EptMap {
    EptMap {
        obj: None,
        tower: build_tcpip_tower(ISD_KEY, NDR, 135, 0),
        entry_handle: EntryHandle(None),
        max_towers: 4,
    }
}

fn get_verification_trailer() -> VerificationTrailer {
    VerificationTrailer {
        commands: vec![Command::Pcontext(CommandPContext {
            flags: CommandFlags::SecVtCommandEnd,
            interface_id: ISD_KEY,
            transfer_syntax: NDR64,
        })],
    }
}

#[instrument(level = "trace", ret)]
fn process_bind_result(requested_contexts: &[ContextElement], bind_ack: BindAck, desired_context: u16) -> Result<()> {
    bind_ack
        .results
        .iter()
        .enumerate()
        .filter_map(|(index, result)| {
            if result.result == ContextResultCode::Acceptance {
                requested_contexts.get(index).map(|ctx| ctx.context_id)
            } else {
                None
            }
        })
        .find(|context_id| *context_id == desired_context)
        .ok_or(ClientError::MissingDesiredContext)?;

    Ok(())
}

#[instrument(level = "trace", ret)]
fn process_ept_map_result(response: &Response) -> Result<u16> {
    let map_response: EptMapResult = decode_owned(response.stub_data.as_slice())?;

    if map_response.status != 0 {
        Err(ClientError::BadEptMapStatus(map_response.status))?;
    }

    for tower in map_response.towers {
        for floor in tower {
            if let Floor::Tcp(tcp_floor) = floor {
                return Ok(tcp_floor.port);
            }
        }
    }

    Err(Error::from(ClientError::MissingTcpFloor))
}

#[instrument(level = "trace", ret)]
fn process_get_key_result(response: &Response, security_trailer: Option<SecurityTrailer>) -> Result<GroupKeyEnvelope> {
    let pad_length = response.stub_data.len()
        - security_trailer
            .as_ref()
            .map(|sec_trailer| usize::from(sec_trailer.pad_length))
            .unwrap_or_default();
    trace!(pad_length);

    let data = &response.stub_data[..pad_length];

    unpack_response(data)
}

#[instrument(ret, level = "debug")]
fn decrypt_blob(blob: &DpapiBlob, key: &GroupKeyEnvelope) -> Result<Vec<u8>> {
    let kek = get_kek(key, &blob.key_identifier)?;

    // With the kek we can unwrap the encrypted cek in the LAPS payload.
    let cek = cek_decrypt(&blob.enc_cek_algorithm_id, &kek, &blob.enc_cek)?;

    // With the cek we can decrypt the encrypted content in the LAPS payload.
    Ok(content_decrypt(
        &blob.enc_content_algorithm_id,
        &cek,
        &blob.enc_content,
    )?)
}

#[instrument(ret, level = "debug")]
fn encrypt_blob(
    data: &[u8],
    key: &GroupKeyEnvelope,
    protection_descriptor: SidProtectionDescriptor,
) -> Result<Vec<u8>> {
    let enc_cek_algorithm_id = KeyEncryptionAlgorithmIdentifier::new_aes256_empty(AesMode::Wrap);
    let (cek, iv) = cek_generate(&enc_cek_algorithm_id)?;

    let enc_content_algorithm_id =
        ContentEncryptionAlgorithmIdentifier::new_aes256(AesMode::Gcm, AesParameters::InitializationVector(iv.into()));

    let enc_content = content_encrypt(&enc_content_algorithm_id, &cek, data)?;

    let (kek, key_identifier) = new_kek(key)?;
    let enc_cek = cek_encrypt(&enc_cek_algorithm_id, &kek, &cek)?;

    let mut buf = Vec::new();

    DpapiBlob {
        key_identifier,
        protection_descriptor,
        enc_cek,
        enc_cek_algorithm_id,
        enc_content,
        enc_content_algorithm_id,
    }
    .encode(true, &mut buf)?;

    Ok(buf)
}

struct GetKeyArgs<'server, 'a> {
    server: &'server str,
    proxy: Option<ProxyOptions>,
    target_sd: Vec<u8>,
    root_key_id: Option<Uuid>,
    l0: i32,
    l1: i32,
    l2: i32,
    username: Username,
    password: Secret<String>,
    negotiate_config: NegotiateConfig,
    network_client: &'a mut dyn AsyncNetworkClient,
}

async fn get_key<T: Transport>(
    GetKeyArgs {
        server,
        proxy,
        target_sd,
        root_key_id,
        l0,
        l1,
        l2,
        username,
        password,
        negotiate_config,
        network_client,
    }: GetKeyArgs<'_, '_>,
) -> Result<GroupKeyEnvelope> {
    let mut connection_options = ConnectOptions::new(server, proxy)?;

    let mut rpc = RpcClient::<T>::connect(
        &connection_options,
        AuthProvider::new(
            SspiContext::Negotiate(Negotiate::new_client(negotiate_config.clone()).map_err(AuthError::from)?),
            Credentials::AuthIdentity(AuthIdentity {
                username: username.clone(),
                password: password.clone(),
            }),
            server,
            network_client,
        )?,
    )
    .await?;

    debug!("RPC connection has been established");

    let epm_contexts = get_epm_contexts();
    let context_id = epm_contexts[0].context_id;
    let bind_ack = rpc.bind(&epm_contexts).await?;

    debug!("RPC bind/bind_ack finished successfully");

    process_bind_result(&epm_contexts, bind_ack, context_id)?;

    let ept_map = get_ept_map_isd_key();
    let response = rpc.request(0, EptMap::OPNUM, ept_map.encode_vec()?).await?;

    let isd_key_port = process_ept_map_result(&response.try_into_response()?)?;

    debug!(isd_key_port);

    connection_options.set_destination_port(isd_key_port);

    let mut rpc = RpcClient::<T>::connect(
        &connection_options,
        AuthProvider::new(
            SspiContext::Negotiate(Negotiate::new_client(negotiate_config).map_err(AuthError::from)?),
            Credentials::AuthIdentity(AuthIdentity { username, password }),
            server,
            network_client,
        )?,
    )
    .await?;

    debug!("RPC connection has been established");

    let isd_key_contexts = get_isd_key_key_contexts();
    let context_id = isd_key_contexts[0].context_id;
    let bind_ack = rpc.bind_authenticate(&isd_key_contexts).await?;

    debug!("RPC bind/bind_ack finished successfully");

    process_bind_result(&isd_key_contexts, bind_ack, context_id)?;

    let get_key = GetKey {
        target_sd,
        root_key_id,
        l0_key_id: l0,
        l1_key_id: l1,
        l2_key_id: l2,
    };

    let response_pdu = rpc
        .authenticated_request(
            context_id,
            GetKey::OPNUM,
            get_key.encode_vec()?,
            Some(get_verification_trailer()),
        )
        .await?;
    let security_trailer = response_pdu.security_trailer.clone();

    debug!("RPC GetKey Request finished successfully");

    process_get_key_result(&response_pdu.try_into_response()?, security_trailer)
}

fn try_get_negotiate_config(
    client_computer_name: Option<String>,
    kerberos_config: Option<KerberosConfig>,
) -> Result<NegotiateConfig> {
    let client_computer_name = if let Some(name) = kerberos_config
        .as_ref()
        .and_then(|config| config.client_computer_name.as_ref())
    {
        name.to_owned()
    } else if let Some(name) = client_computer_name {
        name
    } else {
        whoami::fallible::hostname()?
    };

    let protocol_config: Box<dyn ProtocolConfig> = if let Some(kerberos_config) = kerberos_config {
        Box::new(kerberos_config)
    } else {
        Box::new(NtlmConfig {
            client_computer_name: Some(client_computer_name.clone()),
        })
    };

    Ok(NegotiateConfig::from_protocol_config(
        protocol_config,
        client_computer_name,
    ))
}

/// Arguments for `n_crypt_unprotect_secret` function.
pub struct CryptUnprotectSecretArgs<'server, 'blob, 'username, 'a> {
    /// Secret to encrypt.
    pub blob: &'blob [u8],
    /// Target server hostname.
    pub server: &'server str,
    /// Websocket proxy address.
    pub proxy: Option<ProxyOptions>,
    /// Username to encrypt the DPAPI blob.
    pub username: &'username str,
    /// User's password.
    pub password: Secret<String>,
    /// Client's computer name.
    pub client_computer_name: Option<String>,
    /// Network client for communicating with the KDC.
    pub network_client: &'a mut dyn AsyncNetworkClient,
    /// Optional Kerberos config.
    pub kerberos_config: Option<KerberosConfig>,
}

/// Decrypt the DPAPI blob.
///
/// This function simulated the `NCryptUnprotectSecret` function. Decryption requires making RPC calls to the domain.
/// The username can be specified in FQDN (DOMAIN\username) or UPN (username@domain) format.
/// _Note_: `server` value should be target domain server hostname. Do not use IP address here.
///
/// MSDN:
/// * [NCryptUnprotectSecret function (ncryptprotect.h)](https://learn.microsoft.com/en-us/windows/win32/api/ncryptprotect/nf-ncryptprotect-ncryptunprotectsecret).
pub async fn n_crypt_unprotect_secret<T: Transport>(
    CryptUnprotectSecretArgs {
        blob,
        server,
        proxy,
        username,
        password,
        client_computer_name,
        kerberos_config,
        network_client,
    }: CryptUnprotectSecretArgs<'_, '_, '_, '_>,
) -> Result<Secret<Vec<u8>>> {
    let dpapi_blob = DpapiBlob::decode(blob)?;
    let target_sd = dpapi_blob.protection_descriptor.get_target_sd()?;
    let username = Username::parse(username)
        .map_err(sspi::Error::from)
        .map_err(AuthError::from)?;

    let root_key = Box::pin(get_key::<T>(GetKeyArgs {
        server,
        proxy,
        target_sd,
        root_key_id: Some(dpapi_blob.key_identifier.root_key_identifier),
        l0: dpapi_blob.key_identifier.l0,
        l1: dpapi_blob.key_identifier.l1,
        l2: dpapi_blob.key_identifier.l2,
        username,
        password,
        negotiate_config: try_get_negotiate_config(client_computer_name, kerberos_config)?,
        network_client,
    }))
    .await?;

    debug!("Successfully requested root key");

    Ok(decrypt_blob(&dpapi_blob, &root_key)?.into())
}

/// Arguments for `n_crypt_protect_secret` function.
pub struct CryptProtectSecretArgs<'server, 'username, 'a> {
    /// Secret to encrypt.
    pub data: Secret<Vec<u8>>,
    /// User's SID.
    pub sid: String,
    /// Root key id.
    pub root_key_id: Option<Uuid>,
    /// Target server hostname.
    pub server: &'server str,
    /// Websocket proxy address.
    pub proxy: Option<ProxyOptions>,
    /// Username to encrypt the DPAPI blob.
    pub username: &'username str,
    /// User's password.
    pub password: Secret<String>,
    /// Client's computer name.
    pub client_computer_name: Option<String>,
    /// Network client for communicating with the KDC.
    pub network_client: &'a mut dyn AsyncNetworkClient,
    /// Optional Kerberos config.
    pub kerberos_config: Option<KerberosConfig>,
}

/// Encrypts data to a specified protection descriptor.
///
/// This function simulated the `NCryptProtectSecret` function. Encryption requires making RPCs call to the domain.
/// The username can be specified in FQDN (DOMAIN\username) or UPN (username@domain) format.
/// _Note_: `server` value should be target domain server hostname. Do not use IP address here.
///
/// MSDN:
/// * [NCryptProtectSecret function (`ncryptprotect.h`)](https://learn.microsoft.com/en-us/windows/win32/api/ncryptprotect/nf-ncryptprotect-ncryptprotectsecret).
pub async fn n_crypt_protect_secret<T: Transport>(
    CryptProtectSecretArgs {
        data,
        sid,
        root_key_id,
        server,
        proxy,
        username,
        password,
        client_computer_name,
        network_client,
        kerberos_config,
    }: CryptProtectSecretArgs<'_, '_, '_>,
) -> Result<Vec<u8>> {
    let l0 = -1;
    let l1 = -1;
    let l2 = -1;

    let descriptor = SidProtectionDescriptor { sid };
    let target_sd = descriptor.get_target_sd()?;
    let username = Username::parse(username)
        .map_err(sspi::Error::from)
        .map_err(AuthError::from)?;

    let root_key = Box::pin(get_key::<T>(GetKeyArgs {
        server,
        proxy,
        target_sd,
        root_key_id,
        l0,
        l1,
        l2,
        username,
        password,
        negotiate_config: try_get_negotiate_config(client_computer_name, kerberos_config)?,
        network_client,
    }))
    .await?;

    debug!("Successfully requested root key");

    encrypt_blob(data.as_ref(), &root_key, descriptor)
}


--- File: crates/dpapi/src/crypto/kout.rs ---
macro_rules! kout {
    ($name:ident, $size:ident) => {
        pub struct $name;

        impl digest_pre::crypto_common::KeySizeUser for $name {
            type KeySize = digest_pre::consts::$size;
        }
    };
}

kout!(Kout32, U32);
kout!(Kout64, U64);


--- File: crates/dpapi/src/crypto/mod.rs ---
mod kout;

use aes_gcm::aead::{Aead, KeyInit, OsRng};
use aes_gcm::{Aes256Gcm, Key};
use aes_kw::KekAes256;
use dpapi_core::str::{encode_utf16_le, str_utf16_len};
use dpapi_core::{decode_owned, EncodeVec, WriteCursor};
use dpapi_pdu::gkdi::{EcdhKey, EllipticCurve, FfcdhKey, GroupKeyEnvelope, HashAlg};
use num_bigint_dig::BigUint;
use picky_asn1_x509::enveloped_data::{ContentEncryptionAlgorithmIdentifier, KeyEncryptionAlgorithmIdentifier};
use picky_asn1_x509::{oids, AesParameters, AlgorithmIdentifierParameters};
use picky_krb::crypto::aes::AES256_KEY_SIZE;
use rand::Rng;
use thiserror::Error;
use uuid::Uuid;

use crate::Result;

#[derive(Debug, Error)]
pub enum CryptoError {
    #[error("invalid {name} algorithm id: expected {expected} but got {actual}")]
    InvalidAlgorithm {
        name: &'static str,
        expected: String,
        actual: String,
    },

    #[error("invalid AES parameters: {reason}")]
    InvalidAesParams {
        reason: &'static str,
        parameters: AlgorithmIdentifierParameters,
    },

    #[error("invalid elliptic curve point")]
    InvalidEllipticCurvePoint,

    #[error("invalid or unsupported secret algorithm: {0}")]
    InvalidSecretAlg(String),

    #[error("missing elliptic curve point {0} coordinate")]
    MissingPointCoordinate(&'static str),

    #[error(transparent)]
    EllipticCurve(#[from] elliptic_curve::Error),

    #[error(transparent)]
    ConcatKdf(#[from] concat_kdf::Error),

    #[error(transparent)]
    IntConversion(#[from] std::num::TryFromIntError),

    #[error(transparent)]
    AesGcm(#[from] aes_gcm::Error),

    #[error(transparent)]
    AesKw(#[from] aes_kw::Error),

    #[error("{0} is uninitialized")]
    Uninitialized(&'static str),

    #[error("invalid key length: expected {expected} bytes but got {actual}")]
    InvalidKeyLength { expected: usize, actual: usize },

    #[error("unsupported KBKDF output key length: {0}")]
    UnsupportedKbkdfOutputKeyLength(usize),

    #[error("key derivation error: {0}")]
    Kbkdf(#[from] kbkdf::Error),
}

pub type CryptoResult<T> = std::result::Result<T, CryptoError>;

// "KDS service\0" encoded in UTF16 le.
pub const KDS_SERVICE_LABEL: &[u8] = &[
    75, 0, 68, 0, 83, 0, 32, 0, 115, 0, 101, 0, 114, 0, 118, 0, 105, 0, 99, 0, 101, 0, 0, 0,
];

pub fn cek_decrypt(
    algorithm: &KeyEncryptionAlgorithmIdentifier,
    kek: &[u8],
    wrapped_key: &[u8],
) -> CryptoResult<Vec<u8>> {
    if algorithm.oid() != &oids::aes256_wrap() {
        return Err(CryptoError::InvalidAlgorithm {
            name: "aes256-wrap",
            expected: oids::aes256_wrap().into(),
            actual: algorithm.oid().into(),
        });
    }

    let kek = KekAes256::new(kek.into());

    Ok(kek.unwrap_vec(wrapped_key)?)
}

pub fn cek_encrypt(algorithm: &KeyEncryptionAlgorithmIdentifier, kek: &[u8], key: &[u8]) -> CryptoResult<Vec<u8>> {
    if algorithm.oid() != &oids::aes256_wrap() {
        return Err(CryptoError::InvalidAlgorithm {
            name: "aes256-wrap",
            expected: oids::aes256_wrap().into(),
            actual: algorithm.oid().into(),
        });
    }

    let kek = KekAes256::new(kek.into());

    Ok(kek.wrap_vec(key)?)
}

pub fn cek_generate(algorithm: &KeyEncryptionAlgorithmIdentifier) -> CryptoResult<(Vec<u8>, Vec<u8>)> {
    if algorithm.oid() != &oids::aes256_wrap() {
        return Err(CryptoError::InvalidAlgorithm {
            name: "aes256-wrap",
            expected: oids::aes256_wrap().into(),
            actual: algorithm.oid().into(),
        });
    }

    let mut rng = OsRng;
    let cek = Aes256Gcm::generate_key(&mut rng);
    let iv = rng.gen::<[u8; 12]>();

    Ok((cek.to_vec(), iv.to_vec()))
}

fn extract_iv(parameters: &AlgorithmIdentifierParameters) -> CryptoResult<&[u8]> {
    if let AlgorithmIdentifierParameters::Aes(aes_parameters) = parameters {
        if let AesParameters::InitializationVector(iv) = aes_parameters {
            Ok(iv.0.as_slice())
        } else if let AesParameters::AuthenticatedEncryptionParameters(enc_params) = aes_parameters {
            Ok(enc_params.nonce())
        } else {
            Err(CryptoError::InvalidAesParams {
                reason: "expected AES initialization vector",
                parameters: parameters.clone(),
            })
        }
    } else {
        Err(CryptoError::InvalidAesParams {
            reason: "provided ones are not AES parameters",
            parameters: parameters.clone(),
        })
    }
}

pub fn content_decrypt(
    algorithm: &ContentEncryptionAlgorithmIdentifier,
    cek: &[u8],
    data: &[u8],
) -> CryptoResult<Vec<u8>> {
    if algorithm.oid() != &oids::aes256_gcm() {
        return Err(CryptoError::InvalidAlgorithm {
            name: "aes256-gcm",
            expected: oids::aes256_gcm().into(),
            actual: algorithm.oid().into(),
        });
    }

    let iv = extract_iv(algorithm.parameters())?;

    let cipher = Aes256Gcm::new(Key::<Aes256Gcm>::from_slice(cek));
    Ok(cipher.decrypt(iv.into(), data)?)
}

pub fn content_encrypt(
    algorithm: &ContentEncryptionAlgorithmIdentifier,
    cek: &[u8],
    plaintext: &[u8],
) -> CryptoResult<Vec<u8>> {
    if algorithm.oid() != &oids::aes256_gcm() {
        return Err(CryptoError::InvalidAlgorithm {
            name: "aes256-gcm",
            expected: oids::aes256_gcm().into(),
            actual: algorithm.oid().into(),
        });
    }

    let iv = extract_iv(algorithm.parameters())?;

    let cipher = Aes256Gcm::new(Key::<Aes256Gcm>::from_slice(cek));
    Ok(cipher.encrypt(iv.into(), plaintext)?)
}

pub fn kdf(algorithm: HashAlg, secret: &[u8], label: &[u8], context: &[u8], length: usize) -> CryptoResult<Vec<u8>> {
    use hmac_pre::Hmac;
    use kbkdf::{Counter, Kbkdf, Params};
    use kout::*;

    macro_rules! derive_key {
        ($prf_ty:ty, { $($l_value:expr => $l_ty:ty,)* }) => {
            $(
                if $l_value == length {
                    return Ok(Counter::<$prf_ty, $l_ty>::default()
                        .derive(Params::builder(secret).with_label(label).with_context(context).use_counter(true).use_l(true).build())?
                        .to_vec());
                }
            )*
        };
    }

    match algorithm {
        HashAlg::Sha1 => {
            derive_key!(Hmac<sha1_pre::Sha1>, { 32 => Kout32, 64 => Kout64, });
        }
        HashAlg::Sha256 => {
            derive_key!(Hmac<sha2_pre::Sha256>, { 32 => Kout32, 64 => Kout64, });
        }
        HashAlg::Sha384 => {
            derive_key!(Hmac<sha2_pre::Sha384>, { 32 => Kout32, 64 => Kout64, });
        }
        HashAlg::Sha512 => {
            derive_key!(Hmac<sha2_pre::Sha512>, { 32 => Kout32, 64 => Kout64, });
        }
    }

    Err(CryptoError::UnsupportedKbkdfOutputKeyLength(length))
}

fn kdf_concat(
    algorithm: HashAlg,
    shared_secret: &[u8],
    algorithm_id: &[u8],
    party_uinfo: &[u8],
    party_vinfo: &[u8],
) -> CryptoResult<Vec<u8>> {
    let mut other_info = algorithm_id.to_vec();
    other_info.extend_from_slice(party_uinfo);
    other_info.extend_from_slice(party_vinfo);

    Ok(match algorithm {
        HashAlg::Sha1 => concat_kdf::derive_key::<sha1::Sha1>(shared_secret, &other_info, 20)?,
        HashAlg::Sha256 => concat_kdf::derive_key::<sha2::Sha256>(shared_secret, &other_info, 32)?,
        HashAlg::Sha384 => concat_kdf::derive_key::<sha2::Sha384>(shared_secret, &other_info, 48)?,
        HashAlg::Sha512 => concat_kdf::derive_key::<sha2::Sha512>(shared_secret, &other_info, 64)?,
    })
}

fn compute_kdf_context(key_guid: Uuid, l0: i32, l1: i32, l2: i32) -> Vec<u8> {
    let mut buf = vec![0; 28];

    buf[0..16].copy_from_slice(&key_guid.to_bytes_le());
    buf[16..20].copy_from_slice(&l0.to_le_bytes());
    buf[20..24].copy_from_slice(&l1.to_le_bytes());
    buf[24..28].copy_from_slice(&l2.to_le_bytes());

    buf
}

pub fn compute_l1_key(
    target_sd: &[u8],
    root_key_id: Uuid,
    l0: i32,
    root_key: &[u8],
    algorithm: HashAlg,
) -> CryptoResult<Vec<u8>> {
    // Note: 512 is number of bits, we use byte length here
    // Key(SD, RK, L0, -1, -1) = KDF(
    //   HashAlg,
    //   RK.msKds-RootKeyData,
    //   "KDS service",
    //   RKID || L0 || 0xffffffff || 0xffffffff,
    //   512
    // )
    let l0_seed = kdf(
        algorithm,
        root_key,
        KDS_SERVICE_LABEL,
        &compute_kdf_context(root_key_id, l0, -1, -1),
        64,
    )?;

    // Key(SD, RK, L0, 31, -1) = KDF(
    //   HashAlg,
    //   Key(SD, RK, L0, -1, -1),
    //   "KDS service",
    //   RKID || L0 || 31 || 0xffffffff || SD,
    //   512
    // )
    let mut kdf_context = compute_kdf_context(root_key_id, l0, 31, -1);
    kdf_context.extend_from_slice(target_sd);

    kdf(algorithm, &l0_seed, KDS_SERVICE_LABEL, &kdf_context, 64)
}

pub fn compute_l2_key(
    algorithm: HashAlg,
    request_l1: i32,
    request_l2: i32,
    rk: &GroupKeyEnvelope,
) -> CryptoResult<Vec<u8>> {
    let mut l1 = rk.l1;
    let mut l1_key = rk.l1_key.clone();
    let mut l2 = rk.l2;
    let mut l2_key = rk.l2_key.clone();
    let mut reseed_l2 = l2 == 31 || rk.l1 != request_l1;

    //  MS-GKDI 2.2.4 Group key Envelope
    //  If the value in the L2 index field is equal to 31, this contains the
    //  L1 key with group key identifier (L0 index, L1 index, -1). In all
    //  other cases, this field contains the L1 key with group key identifier
    //  (L0 index, L1 index - 1, -1). If this field is present, its length
    //  MUST be equal to 64 bytes.
    if l2 != 31 && l1 != request_l1 {
        l1 -= 1;
    }

    while l1 != request_l1 {
        reseed_l2 = true;
        l1 -= 1;

        l1_key = kdf(
            algorithm,
            &l1_key,
            KDS_SERVICE_LABEL,
            &compute_kdf_context(rk.root_key_identifier, rk.l0, l1, -1),
            64,
        )?;
    }

    if reseed_l2 {
        l2 = 31;
        l2_key = kdf(
            algorithm,
            &l1_key,
            KDS_SERVICE_LABEL,
            &compute_kdf_context(rk.root_key_identifier, rk.l0, l1, l2),
            64,
        )?;
    }

    while l2 != request_l2 {
        l2 -= 1;

        l2_key = kdf(
            algorithm,
            &l2_key,
            KDS_SERVICE_LABEL,
            &compute_kdf_context(rk.root_key_identifier, rk.l0, l1, l2),
            64,
        )?;
    }

    Ok(l2_key)
}

pub fn compute_kek_from_public_key(
    algorithm: HashAlg,
    seed: &[u8],
    secret_algorithm: &str,
    public_key: &[u8],
    private_key_length: usize,
) -> Result<Vec<u8>> {
    let mut encoded_secret_algorithm = vec![0; str_utf16_len(secret_algorithm)];
    encode_utf16_le(
        secret_algorithm,
        &mut WriteCursor::new(encoded_secret_algorithm.as_mut_slice()),
    );

    let private_key = kdf(
        algorithm,
        seed,
        KDS_SERVICE_LABEL,
        &encoded_secret_algorithm,
        private_key_length,
    )?;

    compute_kek(algorithm, secret_algorithm, &private_key, public_key)
}

pub fn compute_kek(
    algorithm: HashAlg,
    secret_algorithm: &str,
    private_key: &[u8],
    public_key: &[u8],
) -> Result<Vec<u8>> {
    let (shared_secret, secret_hash_algorithm) = if secret_algorithm == "DH" {
        let dh_pub_key: FfcdhKey = decode_owned(public_key)?;
        let shared_secret = dh_pub_key
            .public_key
            .modpow(&BigUint::from_bytes_be(private_key), &dh_pub_key.field_order);
        let mut shared_secret = shared_secret.to_bytes_be();

        while shared_secret.len() < usize::try_from(dh_pub_key.key_length)? {
            shared_secret.insert(0, 0);
        }

        (shared_secret, HashAlg::Sha256)
    } else if secret_algorithm.starts_with("ECDH_P") {
        use elliptic_curve::scalar::ScalarPrimitive;
        use elliptic_curve::sec1::FromEncodedPoint;
        use elliptic_curve::{PublicKey, SecretKey};

        let ecdh_pub_key_info: EcdhKey = decode_owned(public_key)?;

        match ecdh_pub_key_info.curve {
            EllipticCurve::P256 => {
                let public_key: p256::PublicKey = Option::from(PublicKey::from_encoded_point(
                    &p256::EncodedPoint::from_affine_coordinates(
                        ecdh_pub_key_info.x.to_bytes_be().as_slice().into(),
                        ecdh_pub_key_info.y.to_bytes_be().as_slice().into(),
                        false,
                    ),
                ))
                .ok_or(CryptoError::InvalidEllipticCurvePoint)?;
                let secret_key = SecretKey::new(ScalarPrimitive::from_slice(private_key).map_err(CryptoError::from)?);
                let shared_secret: p256::ecdh::SharedSecret =
                    p256::ecdh::diffie_hellman(secret_key.to_nonzero_scalar(), public_key.as_affine());

                (shared_secret.raw_secret_bytes().as_slice().to_vec(), HashAlg::Sha256)
            }
            EllipticCurve::P384 => {
                let public_key: p384::PublicKey = Option::from(PublicKey::from_encoded_point(
                    &p384::EncodedPoint::from_affine_coordinates(
                        ecdh_pub_key_info.x.to_bytes_be().as_slice().into(),
                        ecdh_pub_key_info.y.to_bytes_be().as_slice().into(),
                        false,
                    ),
                ))
                .ok_or(CryptoError::InvalidEllipticCurvePoint)?;
                let secret_key = SecretKey::new(ScalarPrimitive::from_slice(private_key).map_err(CryptoError::from)?);
                let shared_secret: p384::ecdh::SharedSecret =
                    p384::ecdh::diffie_hellman(secret_key.to_nonzero_scalar(), public_key.as_affine());

                (shared_secret.raw_secret_bytes().as_slice().to_vec(), HashAlg::Sha384)
            }
            EllipticCurve::P521 => {
                let public_key: p521::PublicKey = Option::from(PublicKey::from_encoded_point(
                    &p521::EncodedPoint::from_affine_coordinates(
                        ecdh_pub_key_info.x.to_bytes_be().as_slice().into(),
                        ecdh_pub_key_info.y.to_bytes_be().as_slice().into(),
                        false,
                    ),
                ))
                .ok_or(CryptoError::InvalidEllipticCurvePoint)?;
                let secret_key = SecretKey::new(ScalarPrimitive::from_slice(private_key).map_err(CryptoError::from)?);
                let shared_secret: p521::ecdh::SharedSecret =
                    p384::ecdh::diffie_hellman(secret_key.to_nonzero_scalar(), public_key.as_affine());

                (shared_secret.raw_secret_bytes().as_slice().to_vec(), HashAlg::Sha512)
            }
        }
    } else {
        Err(CryptoError::InvalidSecretAlg(secret_algorithm.to_owned()))?
    };

    // "KDS public key\0" encoded in UTF16 le.
    let kek_context = &[
        75, 0, 68, 0, 83, 0, 32, 0, 112, 0, 117, 0, 98, 0, 108, 0, 105, 0, 99, 0, 32, 0, 107, 0, 101, 0, 121, 0, 0, 0,
    ];

    // This part isn't documented but we use the key derivation algorithm
    // SP 800-56A to derive the kek secret input value. On Windows this uses
    // BCryptDeriveKey with the following parameters.
    //   KDF_ALGORITHMID - SHA512
    //   KDF_PARTYUINFO  - KDS public key
    //   KDF_PARTYVINFO  - KDS service
    // Each of these is just appended to the otherinfo value used in
    // cryptography as the UTF-16-LE NULL terminated strings.
    let secret = kdf_concat(
        secret_hash_algorithm,
        &shared_secret,
        // "SHA512\0" encoded in UTF16 le.
        &[83, 0, 72, 0, 65, 0, 53, 0, 49, 0, 50, 0, 0, 0],
        kek_context,
        KDS_SERVICE_LABEL,
    )?;

    Ok(kdf(
        algorithm,
        &secret,
        KDS_SERVICE_LABEL,
        kek_context,
        AES256_KEY_SIZE,
    )?)
}

pub fn compute_public_key(secret_algorithm: &str, private_key: &[u8], peer_public_key: &[u8]) -> Result<Vec<u8>> {
    if secret_algorithm == "DH" {
        let FfcdhKey {
            key_length,
            field_order,
            generator,
            public_key: _,
        } = decode_owned(peer_public_key)?;

        let my_pub_key = generator.modpow(&BigUint::from_bytes_be(private_key), &field_order);

        Ok(FfcdhKey {
            key_length,
            field_order,
            generator,
            public_key: my_pub_key,
        }
        .encode_vec()?)
    } else if secret_algorithm.starts_with("ECDH_P") {
        use elliptic_curve::scalar::ScalarPrimitive;
        use elliptic_curve::sec1::ToEncodedPoint;

        let ecdh_pub_key_info: EcdhKey = decode_owned(peer_public_key)?;

        let (x, y) = match ecdh_pub_key_info.curve {
            EllipticCurve::P256 => {
                let secret_key =
                    p256::SecretKey::new(ScalarPrimitive::from_slice(private_key).map_err(CryptoError::from)?);
                let public_key = secret_key.public_key();
                let point = public_key.to_encoded_point(false);

                (
                    BigUint::from_bytes_be(point.x().ok_or(CryptoError::MissingPointCoordinate("x"))?),
                    BigUint::from_bytes_be(point.y().ok_or(CryptoError::MissingPointCoordinate("y"))?),
                )
            }
            EllipticCurve::P384 => {
                let secret_key =
                    p384::SecretKey::new(ScalarPrimitive::from_slice(private_key).map_err(CryptoError::from)?);
                let public_key = secret_key.public_key();
                let point = public_key.to_encoded_point(false);

                (
                    BigUint::from_bytes_be(point.x().ok_or(CryptoError::MissingPointCoordinate("x"))?),
                    BigUint::from_bytes_be(point.y().ok_or(CryptoError::MissingPointCoordinate("y"))?),
                )
            }
            EllipticCurve::P521 => {
                let secret_key =
                    p521::SecretKey::new(ScalarPrimitive::from_slice(private_key).map_err(CryptoError::from)?);
                let public_key = secret_key.public_key();
                let point = public_key.to_encoded_point(false);

                (
                    BigUint::from_bytes_be(point.x().ok_or(CryptoError::MissingPointCoordinate("x"))?),
                    BigUint::from_bytes_be(point.y().ok_or(CryptoError::MissingPointCoordinate("y"))?),
                )
            }
        };

        Ok(EcdhKey {
            curve: ecdh_pub_key_info.curve,
            key_length: ecdh_pub_key_info.key_length,
            x,
            y,
        }
        .encode_vec()?)
    } else {
        Ok(Err(CryptoError::InvalidSecretAlg(secret_algorithm.to_owned()))?)
    }
}


--- File: crates/dpapi/src/error.rs ---
use dpapi_core::{DecodeError, EncodeError};
use dpapi_transport::ConnectOptionsError;
use thiserror::Error;
use url::Url;

#[derive(Debug, Error)]
pub enum Error {
    #[error("invalid URL `{url}`: {description}")]
    InvalidUrl { url: Url, description: &'static str },

    #[error("{0}")]
    DecodeError(DecodeError),

    #[error("{0}")]
    EncodeError(EncodeError),

    #[error(transparent)]
    PduError(#[from] dpapi_pdu::rpc::PduError),

    #[error(transparent)]
    DpapiCore(#[from] dpapi_pdu::Error),

    #[error(transparent)]
    Gkdi(#[from] crate::gkdi::GkdiError),

    #[error(transparent)]
    Blob(#[from] crate::blob::BlobError),

    #[error(transparent)]
    Sid(#[from] crate::sid::SidError),

    #[error(transparent)]
    Crypto(#[from] crate::crypto::CryptoError),

    #[error(transparent)]
    RpcClient(#[from] crate::rpc::client::RpcClientError),

    #[error(transparent)]
    Auth(#[from] crate::rpc::auth::AuthError),

    #[error(transparent)]
    Client(#[from] crate::client::ClientError),

    #[error("IO error")]
    Io(#[from] std::io::Error),

    #[error(transparent)]
    ConnectionUrlParse(#[from] ConnectOptionsError),

    #[error("UUID error: {0}")]
    Uuid(#[from] uuid::Error),

    #[error(transparent)]
    IntConversion(#[from] std::num::TryFromIntError),

    #[error("provided buf contains invalid UTF-8 data")]
    Utf8(#[from] std::string::FromUtf8Error),

    #[error("{description}: {value}: {error}")]
    ParseInt {
        description: &'static str,
        value: String,
        error: std::num::ParseIntError,
    },

    #[error(transparent)]
    Asn1(#[from] picky_asn1_der::Asn1DerError),

    #[error(transparent)]
    CharSet(#[from] picky_asn1::restricted_string::CharSetError),
}

pub type Result<T> = std::result::Result<T, Error>;

impl From<DecodeError> for Error {
    fn from(err: DecodeError) -> Self {
        Self::DecodeError(err)
    }
}

impl From<EncodeError> for Error {
    fn from(err: EncodeError) -> Self {
        Self::EncodeError(err)
    }
}


--- File: crates/dpapi/src/gkdi.rs ---
use byteorder::{LittleEndian, ReadBytesExt};
use dpapi_core::{compute_padding, decode_owned, read_padding, DecodeOwned, ReadCursor};
use dpapi_pdu::gkdi::{GroupKeyEnvelope, KdfParameters, KeyIdentifier, KDF_ALGORITHM_NAME};
use dpapi_pdu::rpc::SyntaxId;
use picky_krb::crypto::aes::AES256_KEY_SIZE;
use rand::rngs::OsRng;
use rand::Rng;
use thiserror::Error;
use uuid::uuid;

use crate::crypto::{
    compute_kek, compute_kek_from_public_key, compute_l2_key, compute_public_key, kdf, KDS_SERVICE_LABEL,
};
use crate::Result;

pub const ISD_KEY: SyntaxId = SyntaxId {
    uuid: uuid!("b9785960-524f-11df-8b6d-83dcded72085"),
    version: 1,
    version_minor: 0,
};

#[derive(Debug, Error)]
pub enum GkdiError {
    #[error("invalid kdf algorithm name: expected {expected} but got {actual}")]
    InvalidKdfAlgName { expected: &'static str, actual: String },

    #[error("current user is not authorized to retrieve the KEK information")]
    IsNotAuthorized,

    #[error("l0 index does not match requested l0 index")]
    InvalidL0Index,

    #[error("bad GetKey response: {0}")]
    BadResponse(&'static str),

    #[error("bad GetKey hresult: {0:x?}")]
    BadHresult(u32),
}

/// Checks the RPC GetKey Response status (`hresult`) and tries to parse the data into [GroupKeyEnvelope].
pub fn unpack_response(data: &[u8]) -> Result<GroupKeyEnvelope> {
    if data.len() < 4 /* key_length */ + 4 /* padding */ + 8 /* referent id */ + 8 /* pointer size */ + 4
    /* status */
    {
        Err(GkdiError::BadResponse("response data length is too small"))?;
    }

    let (key_buf, mut hresult_buf) = data.split_at(data.len() - size_of::<u32>());

    let hresult = hresult_buf.read_u32::<LittleEndian>()?;
    if hresult != 0 {
        Err(GkdiError::BadHresult(hresult))?;
    }

    let mut src = ReadCursor::new(key_buf);

    let _key_length = src.read_u32();

    read_padding(compute_padding(8, 4 /* key length */), &mut src)?;

    // Skip the referent id and double up on pointer size
    src.read_u64();
    src.read_u64();

    Ok(GroupKeyEnvelope::decode_owned(&mut src)?)
}

pub fn new_kek(group_key: &GroupKeyEnvelope) -> Result<(Vec<u8>, KeyIdentifier)> {
    if group_key.kdf_alg != KDF_ALGORITHM_NAME {
        Err(GkdiError::InvalidKdfAlgName {
            expected: KDF_ALGORITHM_NAME,
            actual: group_key.kdf_alg.clone(),
        })?;
    }

    let kdf_parameters: KdfParameters = decode_owned(group_key.kdf_parameters.as_slice())?;
    let hash_alg = kdf_parameters.hash_alg;

    let mut rand = OsRng;

    let (kek, key_info) = if group_key.is_public_key() {
        // the L2 key is the peer's public key

        let mut private_key = vec![0; group_key.private_key_length.div_ceil(8).try_into()?];
        rand.fill(private_key.as_mut_slice());

        let kek = compute_kek(hash_alg, &group_key.secret_algorithm, &private_key, &group_key.l2_key)?;
        let key_info = compute_public_key(&group_key.secret_algorithm, &private_key, &group_key.l2_key)?;

        (kek, key_info)
    } else {
        let key_info = rand.gen::<[u8; AES256_KEY_SIZE]>();
        let kek = kdf(
            hash_alg,
            &group_key.l2_key,
            KDS_SERVICE_LABEL,
            &key_info,
            AES256_KEY_SIZE,
        )?;

        (kek, key_info.to_vec())
    };

    Ok((
        kek,
        KeyIdentifier {
            version: KeyIdentifier::DEFAULT_VERSION,
            flags: group_key.flags,

            l0: group_key.l0,
            l1: group_key.l1,
            l2: group_key.l2,
            root_key_identifier: group_key.root_key_identifier,

            key_info,
            domain_name: group_key.domain_name.clone(),
            forest_name: group_key.forest_name.clone(),
        },
    ))
}

pub fn get_kek(group_key: &GroupKeyEnvelope, key_identifier: &KeyIdentifier) -> Result<Vec<u8>> {
    if group_key.is_public_key() {
        Err(GkdiError::IsNotAuthorized)?;
    }

    if group_key.l0 != key_identifier.l0 {
        Err(GkdiError::InvalidL0Index)?;
    }

    if group_key.kdf_alg != KDF_ALGORITHM_NAME {
        Err(GkdiError::InvalidKdfAlgName {
            expected: KDF_ALGORITHM_NAME,
            actual: group_key.kdf_alg.clone(),
        })?;
    }

    let kdf_parameters: KdfParameters = decode_owned(group_key.kdf_parameters.as_slice())?;
    let hash_alg = kdf_parameters.hash_alg;
    let l2_key = compute_l2_key(hash_alg, key_identifier.l1, key_identifier.l2, group_key)?;

    if key_identifier.is_public_key() {
        Ok(compute_kek_from_public_key(
            hash_alg,
            &l2_key,
            &group_key.secret_algorithm,
            &key_identifier.key_info,
            group_key.private_key_length.div_ceil(8).try_into()?,
        )?)
    } else {
        Ok(kdf(
            hash_alg,
            &l2_key,
            KDS_SERVICE_LABEL,
            &key_identifier.key_info,
            AES256_KEY_SIZE,
        )?)
    }
}


--- File: crates/dpapi/src/lib.rs ---
#![doc = include_str!("../README.md")]
#![warn(clippy::large_futures)]

#[macro_use]
extern crate tracing;

pub mod blob;
mod client;
pub mod crypto;
pub mod error;
pub mod gkdi;
pub mod rpc;
pub(crate) mod sid;

pub use client::{n_crypt_protect_secret, n_crypt_unprotect_secret, CryptProtectSecretArgs, CryptUnprotectSecretArgs};
pub use error::{Error, Result};
pub use sspi;


--- File: crates/dpapi/src/rpc/auth.rs ---
use dpapi_pdu::rpc::{AuthenticationLevel, SecurityProvider, SecurityTrailer};
use sspi::builders::{AcquireCredentialsHandle, WithoutCredentialUse};
use sspi::credssp::SspiContext;
use sspi::network_client::AsyncNetworkClient;
use sspi::{
    AcquireCredentialsHandleResult, BufferType, ClientRequestFlags, CredentialUse, Credentials, CredentialsBuffers,
    DataRepresentation, EncryptionFlags, NegotiatedProtocol, SecurityBuffer, SecurityBufferFlags, SecurityBufferRef,
    SecurityStatus, Sspi, SspiImpl,
};
use thiserror::Error;

#[derive(Error, Debug)]
pub enum AuthError {
    #[error("{0} security provider is not supported")]
    SecurityProviderNotSupported(&'static str),

    #[error("SSPI authorization error: {0}")]
    Sspi(#[from] sspi::Error),

    #[error("{0}")]
    IntConversion(String),
}

pub type AuthResult<T> = Result<T, AuthError>;

/// Performs RPC authentication using underlying SSPI provider.
///
/// Basically, this is a convenient wrapper over [SspiContext].
/// It allows to perform RPC authentication without going into details of SSPI configuration and
/// authentication parameters.
pub struct AuthProvider<'a> {
    security_context: SspiContext,
    credentials_handle: Option<CredentialsBuffers>,
    is_finished: bool,
    target_name: String,
    network_client: &'a mut dyn AsyncNetworkClient,
}

impl<'a> AuthProvider<'a> {
    /// Creates a new [AuthProvider].
    pub fn new(
        mut security_context: SspiContext,
        credentials: Credentials,
        target_host: &str,
        network_client: &'a mut dyn AsyncNetworkClient,
    ) -> AuthResult<Self> {
        let builder = AcquireCredentialsHandle::<'_, _, _, WithoutCredentialUse>::new();
        let AcquireCredentialsHandleResult { credentials_handle, .. } = builder
            .with_auth_data(&credentials)
            .with_credential_use(CredentialUse::Outbound)
            .execute(&mut security_context)?;

        Ok(Self {
            security_context,
            is_finished: false,
            credentials_handle,
            target_name: format!("host/{}", target_host),
            network_client,
        })
    }

    /// Determines if the selected authorization protocol needs negotiation.
    ///
    /// If the returned value is positive, then the client needs to call the `initialize_security_context` method
    /// twice in order to skip the negotiation phase.
    pub fn needs_negotication(&self) -> bool {
        // The first `initialize_security_context` call is Negotiation in our Kerberos implementation.
        // We don't need its result during the RPC authentication.
        match &self.security_context {
            SspiContext::Kerberos(_) => true,
            SspiContext::Negotiate(negotiate) => {
                matches!(negotiate.negotiated_protocol(), NegotiatedProtocol::Kerberos(_))
            }
            _ => false,
        }
    }

    /// Returns [SecurityProvider] type in use.
    ///
    /// We determine [SecurityProvider] every time we need to construct [SecurityTrailer].
    /// We cannot cache it, because it can be changed during the authentication in the case of [SspiContext::Negotiate].
    fn security_type(&self) -> AuthResult<SecurityProvider> {
        Ok(match &self.security_context {
            SspiContext::Ntlm(_) => SecurityProvider::Winnt,
            SspiContext::Kerberos(_) => SecurityProvider::GssKerberos,
            // Note: we don't use `SecurityProvider::GssNegotiate` on purpose.
            //
            // Using `SecurityProvider::GssNegotiate` requires creating SPNEGO packets inside `Negotiate` module,
            // which is not implemented. So, we use `SecurityProvider::Winnt` or `SecurityProvider::GssKerberos`
            // even in the case of `Negotiate` module.
            SspiContext::Negotiate(negotiate) => match negotiate.negotiated_protocol() {
                NegotiatedProtocol::Ntlm(_) => SecurityProvider::Winnt,
                NegotiatedProtocol::Kerberos(_) => SecurityProvider::GssKerberos,
                NegotiatedProtocol::Pku2u(_) => Err(AuthError::SecurityProviderNotSupported("PKU2U"))?,
            },
            SspiContext::Pku2u(_) => Err(AuthError::SecurityProviderNotSupported("PKU2U"))?,
            #[cfg(feature = "tsssp")]
            SspiContext::CredSsp(_) => Err(AuthError::SecurityProviderNotSupported("CredSSP"))?,
        })
    }

    /// Returns a `bool` value indicating whether authentication is complete.
    pub fn is_finished(&self) -> bool {
        self.is_finished
    }

    /// Returns an empty [SecurityTrailer] with correct parameters.
    pub fn empty_trailer(&mut self, pad_length: u8) -> AuthResult<SecurityTrailer> {
        let security_trailer_len = self.security_context.query_context_sizes()?.security_trailer;
        Ok(SecurityTrailer {
            security_type: self.security_type()?,
            level: AuthenticationLevel::PktPrivacy,
            pad_length,
            context_id: 0,
            auth_value: vec![
                0;
                security_trailer_len
                    .try_into()
                    .map_err(|_| AuthError::IntConversion(format!(
                        "cannot convert security trailer length ({}) to usize",
                        security_trailer_len
                    )))?
            ],
        })
    }

    /// Encrypts input buffers using inner SSPI security context.
    ///
    /// This method is an equivalent to `GSS_WrapEx()`. More info: [Kerberos Binding of GSS_WrapEx()](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/e94b3acd-8415-4d0d-9786-749d0c39d550).
    ///
    /// **Important**. `header`, `body`, `security_trailer_header`, `security_trailer_data` are parts of one RPC PDU:
    /// * `header`: RPC PDU header + header data from the RPC PDU body.
    /// * `body` contains data from the RPC PDU body that must be encrypted.
    /// * `security_trailer_header`: RPC PDU security trailer header data (i.e. security trailer without `auth_value`).
    /// * `security_trailer_data`: RPC PDU security trailer `auth_value`. Basically, it's a Kerberos Wrap Token.
    ///
    /// All encryption is performed in-place.
    #[instrument(ret, level = "debug", skip(self))]
    pub fn wrap_with_header_sign(
        &mut self,
        header: &mut [u8],
        body: &mut [u8],
        security_trailer_header: &mut [u8],
        security_trailer_data: &mut [u8],
    ) -> AuthResult<()> {
        let mut message = vec![
            SecurityBufferRef::data_buf(header).with_flags(SecurityBufferFlags::SECBUFFER_READONLY_WITH_CHECKSUM),
            SecurityBufferRef::data_buf(body),
            SecurityBufferRef::data_buf(security_trailer_header)
                .with_flags(SecurityBufferFlags::SECBUFFER_READONLY_WITH_CHECKSUM),
            SecurityBufferRef::token_buf(security_trailer_data),
        ];

        self.security_context
            .encrypt_message(EncryptionFlags::empty(), &mut message, 0)?;

        Ok(())
    }

    /// Encrypts input buffers using inner SSPI security context.
    ///
    /// This method is an equivalent to `GSS_WrapEx()`. More info: [Kerberos Binding of GSS_WrapEx()](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/e94b3acd-8415-4d0d-9786-749d0c39d550).
    ///
    /// **Important**. `body` and `security_trailer_data` are parts of one RPC PDU:
    /// * `body` contains data from the RPC PDU body that must be encrypted.
    /// * `security_trailer_data`: RPC PDU security trailer `auth_value`. Basically, it's a Kerberos Wrap Token.
    ///
    /// All encryption is performed in-place.
    pub fn wrap(&mut self, body: &mut [u8], security_trailer_data: &mut [u8]) -> AuthResult<()> {
        let mut message = vec![
            SecurityBufferRef::data_buf(body),
            SecurityBufferRef::token_buf(security_trailer_data),
        ];

        self.security_context
            .encrypt_message(EncryptionFlags::empty(), &mut message, 0)?;

        Ok(())
    }

    /// Decrypts input buffers using inner SSPI security context.
    ///
    /// This method is an equivalent to `GSS_UnwrapEx()`. More info: [Kerberos Binding of GSS_WrapEx()](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/e94b3acd-8415-4d0d-9786-749d0c39d550) and [GSS_UnwrapEx() Call](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/9e3981a9-6564-4db6-a70e-4af4c07d03b3).
    ///
    /// **Important**. `header`, `body`, `security_trailer_header`, and `security_trailer_data` are parts of one RPC PDU:
    /// * `header`: RPC PDU header + header data from the RPC PDU body.
    /// * `body` contains data from the RPC PDU body that needs to be decrypted.
    /// * `security_trailer_header`: RPC PDU security trailer header data (i.e. security trailer without `auth_value`).
    /// * `security_trailer_data`: `auth_value` of the RPC PDU security trailer. Basically, it's a Kerberos Wrap Token.
    ///
    /// All decryption is performed in-place.
    #[instrument(ret, level = "debug", skip(self))]
    pub fn unwrap_with_header_sign(
        &mut self,
        header: &mut [u8],
        body: &mut [u8],
        security_trailer_header: &mut [u8],
        security_trailer_data: &mut [u8],
    ) -> AuthResult<Vec<u8>> {
        let mut message = vec![
            SecurityBufferRef::data_buf(header).with_flags(SecurityBufferFlags::SECBUFFER_READONLY_WITH_CHECKSUM),
            SecurityBufferRef::data_buf(body),
            SecurityBufferRef::data_buf(security_trailer_header)
                .with_flags(SecurityBufferFlags::SECBUFFER_READONLY_WITH_CHECKSUM),
            SecurityBufferRef::token_buf(security_trailer_data),
        ];

        self.security_context.decrypt_message(&mut message, 0)?;

        Ok(message[1].data().to_vec())
    }

    /// Decrypts input buffers using inner SSPI security context.
    ///
    /// This method is an equivalent to `GSS_UnwrapEx()`. More info: [Kerberos Binding of GSS_WrapEx()](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/e94b3acd-8415-4d0d-9786-749d0c39d550) and [GSS_UnwrapEx() Call](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/9e3981a9-6564-4db6-a70e-4af4c07d03b3).
    ///
    /// **Important**. `body` and `security_trailer_data` are parts of one RPC PDU:
    /// * `body` contains data from the RPC PDU body that needs to be decrypted.
    /// * `security_trailer_data`: `auth_value` of the RPC PDU security trailer. Basically, it's a Kerberos Wrap Token.
    ///
    /// All decryption is performed in-place.
    #[instrument(ret, level = "debug", skip(self))]
    pub fn unwrap(&mut self, body: &mut [u8], security_trailer_data: &mut [u8]) -> AuthResult<Vec<u8>> {
        let mut message = vec![
            SecurityBufferRef::data_buf(body),
            SecurityBufferRef::token_buf(security_trailer_data),
        ];

        self.security_context.decrypt_message(&mut message, 0)?;

        Ok(message[1].data().to_vec())
    }

    /// Performs one step in authorization process.
    ///
    /// The client should call this method until `self.is_finished()` is `true`.
    #[instrument(ret, level = "debug", fields(state = ?self.is_finished), skip(self))]
    pub async fn initialize_security_context(&mut self, in_token: Vec<u8>) -> AuthResult<SecurityTrailer> {
        let mut input_token = [SecurityBuffer::new(in_token, BufferType::Token)];
        let mut output_token = vec![SecurityBuffer::new(Vec::with_capacity(1024), BufferType::Token)];
        let mut credentials_handle = self.credentials_handle.take();

        let mut builder = self
            .security_context
            .initialize_security_context()
            .with_credentials_handle(&mut credentials_handle)
            .with_context_requirements(
                // Warning: do not change these flags if you don't know what you are doing.
                // The absence or presence of some flags can break the RPC auth. For example,
                // if you enable the `ClientRequestFlags::USE_SESSION_KEY`, then it will fail.
                ClientRequestFlags::MUTUAL_AUTH
                    | ClientRequestFlags::INTEGRITY
                    | ClientRequestFlags::USE_DCE_STYLE
                    | ClientRequestFlags::SEQUENCE_DETECT
                    | ClientRequestFlags::REPLAY_DETECT
                    | ClientRequestFlags::CONFIDENTIALITY,
            )
            .with_target_data_representation(DataRepresentation::Native)
            .with_target_name(&self.target_name)
            .with_input(&mut input_token)
            .with_output(&mut output_token);
        let result = self
            .security_context
            .initialize_security_context_impl(&mut builder)?
            .resolve_with_async_client(self.network_client)
            .await?;

        self.is_finished = result.status == SecurityStatus::Ok;

        self.credentials_handle = credentials_handle;
        let auth_value = output_token.remove(0).buffer;

        Ok(SecurityTrailer {
            security_type: self.security_type()?,
            level: AuthenticationLevel::PktPrivacy,
            pad_length: 0,
            context_id: 0,
            auth_value,
        })
    }
}


--- File: crates/dpapi/src/rpc/client.rs ---
use dpapi_core::{compute_padding, decode_owned, EncodeVec, FixedPartSize};
use dpapi_pdu::rpc::{
    AlterContext, Bind, BindAck, BindTimeFeatureNegotiationBitmask, ContextElement, ContextResultCode, DataRepr,
    PacketFlags, PacketType, Pdu, PduData, PduHeader, Request, SecurityTrailer, SyntaxId, VerificationTrailer,
};
use dpapi_transport::{ConnectOptions, Stream, Transport};
use thiserror::Error;
use uuid::{uuid, Uuid};

use crate::rpc::AuthProvider;
use crate::Result;

pub const NDR64: SyntaxId = SyntaxId {
    uuid: uuid!("71710533-beba-4937-8319-b5dbef9ccc36"),
    version: 1,
    version_minor: 0,
};
pub const NDR: SyntaxId = SyntaxId {
    uuid: uuid!("8a885d04-1ceb-11c9-9fe8-08002b104860"),
    version: 2,
    version_minor: 0,
};
pub const CALL_ID: u32 = 1;

pub fn bind_time_feature_negotiation(flags: BindTimeFeatureNegotiationBitmask) -> SyntaxId {
    SyntaxId {
        uuid: Uuid::from_fields(0x6cb71c2c, 0x9812, 0x4540, &flags.as_u64().to_be_bytes()),
        version: 1,
        version_minor: 0,
    }
}

#[derive(Debug, Error)]
pub enum RpcClientError {
    #[error("invalid encryption offset: {0}")]
    InvalidEncryptionOffset(&'static str),
}

/// Represents structural offsets in RPC PDU.
///
/// This structure is used to split the encoded RPC PDU into separate parts before encryption or decryption.
#[derive(Debug, Copy, Clone)]
struct EncryptionOffsets {
    /// RPC PDU header length.
    pub pdu_header_len: usize,
    /// Indicated how many bytes precede RPC PDU security trailer.
    pub security_trailer_offset: usize,
}

impl EncryptionOffsets {
    /// RPC PDU header length + RPC Request header data length.
    const REQUEST_PDU_HEADER_LEN: usize = 24;
}

/// General RPC client.
///
/// All RPC communication is done using this RPC client. It can connect to RPC server,
/// authenticate, and send RPC requests.
pub struct RpcClient<'a, T: Transport> {
    stream: T::Stream,
    sign_header: bool,
    auth: AuthProvider<'a>,
}

impl<'a, T: Transport> RpcClient<'a, T> {
    /// Connects to the RPC server.
    ///
    /// Returns a new RPC client that is ready to send/receive data.
    pub async fn connect(connection_options: &ConnectOptions, auth: AuthProvider<'a>) -> Result<Self> {
        let stream = T::connect(connection_options).await?;

        Ok(Self {
            stream,
            sign_header: false,
            auth,
        })
    }

    fn create_pdu_header(packet_type: PacketType, packet_flags: PacketFlags, auth_len: u16, call_id: u32) -> PduHeader {
        PduHeader {
            version: 5,
            version_minor: 0,
            packet_type,
            packet_flags: packet_flags | PacketFlags::PfcLastFrag | PacketFlags::PfcFirstFrag,
            data_rep: DataRepr::default(),
            // We will set `frag_len` later after building the PDU.
            frag_len: 0,
            auth_len,
            call_id,
        }
    }

    fn create_bind_pdu(contexts: Vec<ContextElement>, security_trailer: Option<SecurityTrailer>) -> Result<Pdu> {
        let (auth_len, packet_flags) = if let Some(security_trailer) = security_trailer.as_ref() {
            (security_trailer.auth_value.len(), PacketFlags::PfcSupportHeaderSign)
        } else {
            (0, PacketFlags::None)
        };

        Ok(Pdu {
            header: Self::create_pdu_header(PacketType::Bind, packet_flags, auth_len.try_into()?, CALL_ID),
            data: PduData::Bind(Bind {
                max_xmit_frag: 5840,
                max_recv_frag: 5840,
                assoc_group: 0,
                contexts,
            }),
            security_trailer,
        })
    }

    fn create_alter_context_pdu(&self, contexts: Vec<ContextElement>, sec_trailer: SecurityTrailer) -> Result<Pdu> {
        let packet_flags = if self.sign_header {
            PacketFlags::PfcSupportHeaderSign
        } else {
            PacketFlags::None
        };

        Ok(Pdu {
            header: Self::create_pdu_header(
                PacketType::AlterContext,
                packet_flags,
                sec_trailer.auth_value.len().try_into()?,
                CALL_ID,
            ),
            data: PduData::AlterContext(AlterContext(Bind {
                max_xmit_frag: 5840,
                max_recv_frag: 5840,
                assoc_group: 0,
                contexts,
            })),
            security_trailer: Some(sec_trailer),
        })
    }

    #[instrument(level = "trace", ret, skip(self))]
    fn create_authenticated_request(
        &mut self,
        context_id: u16,
        opnum: u16,
        mut stub_data: Vec<u8>,
        verification_trailer: Option<VerificationTrailer>,
    ) -> Result<(Pdu, EncryptionOffsets)> {
        if let Some(verification_trailer) = verification_trailer.as_ref() {
            stub_data.extend_from_slice(&vec![0; compute_padding(4, stub_data.len())]);

            let encoded_verification_trailer = verification_trailer.encode_vec()?;
            stub_data.extend_from_slice(&encoded_verification_trailer);
        }

        // The security trailer must be aligned to the next 16 byte boundary after the stub data.
        // This padding is included as part of the stub data to be encrypted.
        let padding_len = compute_padding(16, stub_data.len());
        stub_data.extend_from_slice(&vec![0; padding_len]);
        let security_trailer = self.auth.empty_trailer(padding_len.try_into()?)?;

        let encrypt_offsets = EncryptionOffsets {
            pdu_header_len: EncryptionOffsets::REQUEST_PDU_HEADER_LEN,
            security_trailer_offset: EncryptionOffsets::REQUEST_PDU_HEADER_LEN + stub_data.len(),
        };

        Ok((
            Pdu {
                header: Self::create_pdu_header(
                    PacketType::Request,
                    PacketFlags::None,
                    security_trailer.auth_value.len().try_into()?,
                    CALL_ID,
                ),
                data: PduData::Request(Request {
                    alloc_hint: stub_data.len().try_into()?,
                    context_id,
                    opnum,
                    obj: None,
                    stub_data,
                }),
                security_trailer: Some(security_trailer),
            },
            encrypt_offsets,
        ))
    }

    #[instrument(level = "trace", ret, skip(self))]
    fn create_request(&self, context_id: u16, opnum: u16, stub_data: Vec<u8>) -> Result<Pdu> {
        Ok(Pdu {
            header: Self::create_pdu_header(PacketType::Request, PacketFlags::None, 0, CALL_ID),
            data: PduData::Request(Request {
                alloc_hint: stub_data.len().try_into()?,
                context_id,
                opnum,
                obj: None,
                stub_data,
            }),
            security_trailer: None,
        })
    }

    #[instrument(level = "trace", ret, skip(self))]
    fn encrypt_pdu(&mut self, pdu_encoded: &mut [u8], encrypt_offsets: EncryptionOffsets) -> Result<()> {
        let EncryptionOffsets {
            pdu_header_len,
            security_trailer_offset,
        } = encrypt_offsets;

        if pdu_encoded.len() < security_trailer_offset + SecurityTrailer::FIXED_PART_SIZE {
            Err(RpcClientError::InvalidEncryptionOffset(
                "security trailer offset is too big or PDU is corrupted",
            ))?;
        }

        let (header, data) = pdu_encoded.split_at_mut(pdu_header_len);
        let (body, data) = data.split_at_mut(security_trailer_offset - pdu_header_len);
        let (sec_trailer_header, sec_trailer_auth_value) = data.split_at_mut(SecurityTrailer::FIXED_PART_SIZE);

        if self.sign_header {
            self.auth
                .wrap_with_header_sign(header, body, sec_trailer_header, sec_trailer_auth_value)?;
        } else {
            self.auth.wrap(body, sec_trailer_auth_value)?;
        }

        Ok(())
    }

    fn process_bind_ack(ack: &BindAck, contexts: &[ContextElement]) -> Vec<ContextElement> {
        contexts
            .iter()
            .enumerate()
            .filter_map(|(index, context)| {
                if let Some(result) = ack.results.get(index) {
                    if result.result == ContextResultCode::Acceptance {
                        Some(context.clone())
                    } else {
                        None
                    }
                } else {
                    None
                }
            })
            .collect()
    }

    #[instrument(level = "trace", ret, skip(self))]
    fn decrypt_response(
        &mut self,
        response: &mut [u8],
        pdu_header: &PduHeader,
        encrypt_offsets: EncryptionOffsets,
    ) -> Result<()> {
        let EncryptionOffsets {
            pdu_header_len,
            security_trailer_offset: _,
        } = encrypt_offsets;

        let security_trailer_offset =
            usize::from(pdu_header.frag_len) - usize::from(pdu_header.auth_len) - SecurityTrailer::FIXED_PART_SIZE;

        if response.len() < security_trailer_offset + SecurityTrailer::FIXED_PART_SIZE {
            Err(RpcClientError::InvalidEncryptionOffset(
                "security trailer offset is too big or PDU is corrupted",
            ))?;
        }

        let (header, data) = response.split_at_mut(pdu_header_len);
        let (body, data) = data.split_at_mut(security_trailer_offset - pdu_header_len);
        let (sec_trailer_header, sec_trailer_data) = data.split_at_mut(SecurityTrailer::FIXED_PART_SIZE);

        if self.sign_header {
            self.auth
                .unwrap_with_header_sign(header, body, sec_trailer_header, sec_trailer_data)?;
        } else {
            self.auth.unwrap(body, sec_trailer_data)?;
        }

        Ok(())
    }

    #[instrument(level = "trace", ret, skip(self))]
    async fn send_pdu(&mut self, pdu: Pdu, encrypt_offsets: Option<EncryptionOffsets>) -> Result<Pdu> {
        let mut pdu_encoded = pdu.encode_vec()?;
        let frag_len = u16::try_from(pdu_encoded.len())?;
        // Set `frag_len` in the PDU header.
        pdu_encoded[8..10].copy_from_slice(&frag_len.to_le_bytes());

        if let Some(encrypt_offsets) = encrypt_offsets {
            self.encrypt_pdu(&mut pdu_encoded, encrypt_offsets)?;
        }

        self.stream.write_all(&pdu_encoded).await?;

        // Read PDU header
        let mut pdu_buf = self.stream.read_vec(PduHeader::FIXED_PART_SIZE).await?;
        let pdu_header: PduHeader = decode_owned(pdu_buf.as_slice())?;

        pdu_buf.resize(usize::from(pdu_header.frag_len), 0);
        self.stream
            .read_exact(&mut pdu_buf[PduHeader::FIXED_PART_SIZE..])
            .await?;

        if let (true, Some(encrypt_offsets)) = (pdu_header.auth_len > 0, encrypt_offsets) {
            self.decrypt_response(&mut pdu_buf, &pdu_header, encrypt_offsets)?;
        }

        let mut pdu: Pdu = decode_owned(pdu_buf.as_slice())?;
        pdu.data = pdu.data.into_error()?;

        Ok(pdu)
    }

    /// Sends the authenticated RPC request.
    #[instrument(level = "trace", ret, skip(self))]
    pub async fn authenticated_request(
        &mut self,
        context_id: u16,
        opnum: u16,
        stub_data: Vec<u8>,
        verification_trailer: Option<VerificationTrailer>,
    ) -> Result<Pdu> {
        let (pdu, encrypt_offsets) =
            self.create_authenticated_request(context_id, opnum, stub_data, verification_trailer)?;

        self.send_pdu(pdu, Some(encrypt_offsets)).await
    }

    /// Sends the RPC request.
    #[instrument(level = "trace", ret, skip(self))]
    pub async fn request(&mut self, context_id: u16, opnum: u16, stub_data: Vec<u8>) -> Result<Pdu> {
        let pdu = self.create_request(context_id, opnum, stub_data)?;

        self.send_pdu(pdu, None).await
    }

    /// Performs the RPC bind/bind_ack exchange.
    #[instrument(level = "trace", ret, skip(self))]
    pub async fn bind(&mut self, contexts: &[ContextElement]) -> Result<BindAck> {
        let bind = Self::create_bind_pdu(contexts.to_vec(), None)?;
        let pdu_resp = self.send_pdu(bind, None).await?;

        let Pdu {
            header: _,
            data,
            security_trailer: _,
        } = pdu_resp;

        Ok(data.bind_ack()?)
    }

    /// Performs the RPC bind/bind_ack exchange.
    ///
    /// The bind/bind_ack exchange continues until authentication is finished.
    #[instrument(level = "trace", ret, skip(self))]
    pub async fn bind_authenticate(&mut self, contexts: &[ContextElement]) -> Result<BindAck> {
        let security_trailer = self.auth.initialize_security_context(Vec::new()).await?;

        // This is a small dirty trick. We do not have separate abstractions for SPNEGO and GSS API.
        // Thus, our Kerberos implementation contains parts of SPNEGO and GSS API. But we do not need
        // them during the RPC auth. We skip the unneeded output by calling the `initialize_security_context`
        // method twice.
        let security_trailer = if self.auth.needs_negotication() {
            self.auth.initialize_security_context(Vec::new()).await?
        } else {
            security_trailer
        };

        let bind = Self::create_bind_pdu(contexts.to_vec(), Some(security_trailer))?;

        self.sign_header = true;

        let pdu_resp = self.send_pdu(bind, None).await?;

        let Pdu {
            header: _,
            data,
            security_trailer,
        } = pdu_resp;
        let bind_ack = data.bind_ack()?;

        let final_contexts = Self::process_bind_ack(&bind_ack, contexts);
        let mut in_token = security_trailer.map(|security_trailer| security_trailer.auth_value);

        while !self.auth.is_finished() {
            let security_trailer = self
                .auth
                .initialize_security_context(in_token.unwrap_or_default())
                .await?;

            let alter_context = self.create_alter_context_pdu(final_contexts.clone(), security_trailer)?;
            let alter_context_resp = self.send_pdu(alter_context, None).await?;

            in_token = alter_context_resp
                .security_trailer
                .map(|security_trailer| security_trailer.auth_value);
        }

        Ok(bind_ack)
    }
}


--- File: crates/dpapi/src/rpc/mod.rs ---
pub mod auth;
pub mod client;

pub use auth::AuthProvider;
pub use client::{bind_time_feature_negotiation, RpcClient, NDR, NDR64};


--- File: crates/dpapi/src/sid.rs ---
use std::sync::LazyLock;

use regex::Regex;
use thiserror::Error;

use crate::{Error, Result};

#[derive(Debug, Error)]
pub enum SidError {
    #[error("invalid sid value: {0}")]
    InvalidSid(String),
}

static SID_PATTERN: LazyLock<Regex> =
    LazyLock::new(|| Regex::new(r"^S-(\d)-(\d+)(?:-\d+){1,15}$").expect("valid SID regex"));

pub fn sid_to_bytes(sid: &str) -> Result<Vec<u8>> {
    if !SID_PATTERN.is_match(sid) {
        Err(SidError::InvalidSid(sid.to_owned()))?;
    }

    let parts = sid.split('-').collect::<Vec<_>>();

    if parts.len() < 3 {
        Err(SidError::InvalidSid(sid.to_owned()))?;
    }

    let revision = parts[1].parse::<u8>().map_err(|error| Error::ParseInt {
        description: "cannot parse SID part",
        value: parts[1].to_owned(),
        error,
    })?;
    let authority = parts[2].parse::<u64>().map_err(|error| Error::ParseInt {
        description: "cannot parse SID part",
        value: parts[2].to_owned(),
        error,
    })?;

    let mut data = Vec::new();
    data.extend_from_slice(&authority.to_be_bytes());
    data[0] = revision;
    data[1] = u8::try_from(parts.len() - 3)?;

    for part in parts.iter().skip(3) {
        let sub_auth = part.parse::<u32>().map_err(|error| Error::ParseInt {
            description: "cannot parse SID part",
            value: part.to_string(),
            error,
        })?;
        data.extend_from_slice(&sub_auth.to_le_bytes());
    }

    Ok(data)
}

pub fn ace_to_bytes(sid: &str, access_mask: u32) -> Result<Vec<u8>> {
    let sid = sid_to_bytes(sid)?;

    let mut data = Vec::new();

    // AceType, AceFlags - ACCESS_ALLOWED_ACE_TYPE.
    data.extend_from_slice(&[0, 0]);
    data.extend_from_slice(&u16::try_from(8 + sid.len())?.to_le_bytes());
    data.extend_from_slice(&access_mask.to_le_bytes());
    data.extend_from_slice(&sid);

    Ok(data)
}

pub fn acl_to_bytes(aces: &[Vec<u8>]) -> Result<Vec<u8>> {
    let ace_data_len = aces.iter().map(|a| a.len()).sum::<usize>();

    let mut data = Vec::new();

    // AclRevision, Sbz1 - ACL_REVISION.
    data.extend_from_slice(&[0x02, 0x00]);
    data.extend_from_slice(&u16::try_from(8 + ace_data_len)?.to_le_bytes());
    data.extend_from_slice(&u16::try_from(aces.len())?.to_le_bytes());
    // Sbz1.
    data.extend_from_slice(&[0x00, 0x00]);
    for ace in aces {
        data.extend_from_slice(ace);
    }

    Ok(data)
}

pub fn sd_to_bytes(owner: &str, group: &str, sacl: Option<&[Vec<u8>]>, dacl: Option<&[Vec<u8>]>) -> Result<Vec<u8>> {
    // Self-Relative.
    let mut control: u16 = 0b10000000 << 8;

    // While MS-DTYP state there is no required order for the dynamic data, it
    // is important that the raw bytes are exactly what Microsoft uses on the
    // server side when it computes the seed key values. Luckily the footnote
    // give the correct order the MS-GKDI expects: Sacl, Dacl, Owner, Group
    // https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/11e1608c-6169-4fbc-9c33-373fc9b224f4#Appendix_A_72
    let mut dynamic_data = Vec::new();

    // Length of the SD header bytes
    let mut current_offset: u32 = 20;

    let mut sacl_offset = 0;
    if let Some(sacl) = sacl {
        let sacl_bytes = acl_to_bytes(sacl)?;
        sacl_offset = current_offset;
        current_offset += u32::try_from(sacl_bytes.len())?;

        // SACL Present.
        control |= 0b00010000;
        dynamic_data.extend_from_slice(&sacl_bytes);
    }

    let mut dacl_offset = 0;
    if let Some(dacl) = dacl {
        let dacl_bytes = acl_to_bytes(dacl)?;
        dacl_offset = current_offset;
        current_offset += u32::try_from(dacl_bytes.len())?;

        // DACL Present.
        control |= 0b00000100;
        dynamic_data.extend_from_slice(&dacl_bytes);
    }

    let owner_bytes = sid_to_bytes(owner)?;
    let owner_offset = current_offset;
    current_offset += u32::try_from(owner_bytes.len())?;
    dynamic_data.extend_from_slice(&owner_bytes);

    let group_bytes = sid_to_bytes(group)?;
    let group_offset = current_offset;
    dynamic_data.extend_from_slice(&group_bytes);

    // Revision and Sbz1.
    let mut data = [0x01, 0x00].to_vec();

    data.extend_from_slice(&control.to_le_bytes());
    data.extend_from_slice(&owner_offset.to_le_bytes());
    data.extend_from_slice(&group_offset.to_le_bytes());
    data.extend_from_slice(&sacl_offset.to_le_bytes());
    data.extend_from_slice(&dacl_offset.to_le_bytes());
    data.extend_from_slice(&dynamic_data);

    Ok(data)
}


--- File: crates/dpapi/tests/dpapi/blob.rs ---
use dpapi::blob::*;
use dpapi_pdu::gkdi::KeyIdentifier;
use picky_asn1_x509::enveloped_data::{ContentEncryptionAlgorithmIdentifier, KeyEncryptionAlgorithmIdentifier};
use picky_asn1_x509::{AesAuthEncParams, AesMode, AesParameters};
use uuid::uuid;

const DPAPI_BLOB_DATA: &[u8] = &[
    48, 130, 4, 77, 6, 9, 42, 134, 72, 134, 247, 13, 1, 7, 3, 160, 130, 4, 62, 48, 130, 4, 58, 2, 1, 2, 49, 130, 4, 6,
    162, 130, 4, 2, 2, 1, 4, 48, 130, 3, 196, 4, 130, 3, 108, 1, 0, 0, 0, 75, 68, 83, 75, 3, 0, 0, 0, 105, 1, 0, 0, 16,
    0, 0, 0, 3, 0, 0, 0, 113, 194, 120, 215, 37, 144, 130, 154, 246, 220, 184, 150, 11, 138, 216, 197, 8, 3, 0, 0, 24,
    0, 0, 0, 24, 0, 0, 0, 68, 72, 80, 66, 0, 1, 0, 0, 135, 168, 230, 29, 180, 182, 102, 60, 255, 187, 209, 156, 101,
    25, 89, 153, 140, 238, 246, 8, 102, 13, 208, 242, 93, 44, 238, 212, 67, 94, 59, 0, 224, 13, 248, 241, 214, 25, 87,
    212, 250, 247, 223, 69, 97, 178, 170, 48, 22, 195, 217, 17, 52, 9, 111, 170, 59, 244, 41, 109, 131, 14, 154, 124,
    32, 158, 12, 100, 151, 81, 122, 189, 90, 138, 157, 48, 107, 207, 103, 237, 145, 249, 230, 114, 91, 71, 88, 192, 34,
    224, 177, 239, 66, 117, 191, 123, 108, 91, 252, 17, 212, 95, 144, 136, 185, 65, 245, 78, 177, 229, 155, 184, 188,
    57, 160, 191, 18, 48, 127, 92, 79, 219, 112, 197, 129, 178, 63, 118, 182, 58, 202, 225, 202, 166, 183, 144, 45, 82,
    82, 103, 53, 72, 138, 14, 241, 60, 109, 154, 81, 191, 164, 171, 58, 216, 52, 119, 150, 82, 77, 142, 246, 161, 103,
    181, 164, 24, 37, 217, 103, 225, 68, 229, 20, 5, 100, 37, 28, 202, 203, 131, 230, 180, 134, 246, 179, 202, 63, 121,
    113, 80, 96, 38, 192, 184, 87, 246, 137, 150, 40, 86, 222, 212, 1, 10, 189, 11, 230, 33, 195, 163, 150, 10, 84,
    231, 16, 195, 117, 242, 99, 117, 215, 1, 65, 3, 164, 181, 67, 48, 193, 152, 175, 18, 97, 22, 210, 39, 110, 17, 113,
    95, 105, 56, 119, 250, 215, 239, 9, 202, 219, 9, 74, 233, 30, 26, 21, 151, 63, 179, 44, 155, 115, 19, 77, 11, 46,
    119, 80, 102, 96, 237, 189, 72, 76, 167, 177, 143, 33, 239, 32, 84, 7, 244, 121, 58, 26, 11, 161, 37, 16, 219, 193,
    80, 119, 190, 70, 63, 255, 79, 237, 74, 172, 11, 181, 85, 190, 58, 108, 27, 12, 107, 71, 177, 188, 55, 115, 191,
    126, 140, 111, 98, 144, 18, 40, 248, 194, 140, 187, 24, 165, 90, 227, 19, 65, 0, 10, 101, 1, 150, 249, 49, 199,
    122, 87, 242, 221, 244, 99, 229, 233, 236, 20, 75, 119, 125, 230, 42, 170, 184, 168, 98, 138, 195, 118, 210, 130,
    214, 237, 56, 100, 230, 121, 130, 66, 142, 188, 131, 29, 20, 52, 143, 111, 47, 145, 147, 181, 4, 90, 242, 118, 113,
    100, 225, 223, 201, 103, 193, 251, 63, 46, 85, 164, 189, 27, 255, 232, 59, 156, 128, 208, 82, 185, 133, 209, 130,
    234, 10, 219, 42, 59, 115, 19, 211, 254, 20, 200, 72, 75, 30, 5, 37, 136, 185, 183, 210, 187, 210, 223, 1, 97, 153,
    236, 208, 110, 21, 87, 205, 9, 21, 179, 53, 59, 187, 100, 224, 236, 55, 127, 208, 40, 55, 13, 249, 43, 82, 199,
    137, 20, 40, 205, 198, 126, 182, 24, 75, 82, 61, 29, 178, 70, 195, 47, 99, 7, 132, 144, 240, 14, 248, 214, 71, 209,
    72, 212, 121, 84, 81, 94, 35, 39, 207, 239, 152, 197, 130, 102, 75, 76, 15, 108, 196, 22, 89, 45, 48, 255, 175,
    224, 178, 34, 113, 55, 121, 103, 94, 57, 230, 149, 227, 2, 8, 211, 56, 135, 63, 75, 228, 67, 79, 182, 168, 130, 79,
    28, 56, 65, 78, 255, 48, 67, 5, 243, 1, 170, 131, 242, 24, 216, 174, 93, 89, 249, 12, 215, 25, 248, 12, 146, 191,
    38, 9, 239, 136, 197, 113, 125, 222, 79, 184, 149, 180, 198, 185, 10, 161, 28, 53, 69, 19, 173, 197, 112, 73, 23,
    172, 239, 88, 66, 170, 206, 185, 238, 228, 152, 153, 163, 198, 94, 147, 212, 117, 120, 83, 30, 158, 8, 70, 1, 73,
    134, 237, 77, 162, 147, 56, 224, 231, 179, 30, 110, 19, 55, 253, 176, 115, 101, 171, 146, 59, 227, 37, 145, 200,
    156, 20, 33, 186, 8, 34, 118, 162, 125, 114, 229, 11, 202, 36, 115, 124, 83, 60, 251, 141, 83, 244, 164, 213, 197,
    199, 2, 130, 173, 22, 120, 61, 63, 196, 111, 60, 184, 58, 17, 34, 166, 237, 250, 238, 19, 150, 192, 123, 172, 162,
    70, 227, 90, 165, 58, 139, 124, 87, 199, 135, 30, 146, 142, 203, 133, 133, 54, 26, 54, 229, 134, 122, 117, 207, 31,
    184, 148, 68, 232, 89, 132, 91, 246, 40, 87, 225, 14, 74, 23, 81, 228, 241, 146, 171, 106, 211, 196, 222, 192, 142,
    81, 207, 169, 185, 24, 161, 88, 75, 138, 97, 111, 92, 43, 214, 190, 140, 12, 124, 177, 67, 125, 237, 147, 195, 41,
    40, 100, 0, 111, 0, 109, 0, 97, 0, 105, 0, 110, 0, 46, 0, 116, 0, 101, 0, 115, 0, 116, 0, 0, 0, 100, 0, 111, 0,
    109, 0, 97, 0, 105, 0, 110, 0, 46, 0, 116, 0, 101, 0, 115, 0, 116, 0, 0, 0, 48, 82, 6, 9, 43, 6, 1, 4, 1, 130, 55,
    74, 1, 48, 69, 6, 10, 43, 6, 1, 4, 1, 130, 55, 74, 1, 1, 48, 55, 48, 53, 48, 51, 12, 3, 83, 73, 68, 12, 44, 83, 45,
    49, 45, 53, 45, 50, 49, 45, 51, 51, 51, 55, 51, 51, 55, 57, 55, 51, 45, 51, 50, 57, 55, 48, 55, 56, 48, 50, 56, 45,
    52, 51, 55, 51, 56, 54, 48, 54, 54, 45, 53, 49, 50, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 1, 45, 4, 40, 137,
    127, 196, 63, 116, 142, 253, 9, 87, 39, 221, 233, 143, 78, 26, 111, 251, 157, 65, 99, 211, 159, 179, 116, 208, 73,
    199, 61, 137, 105, 12, 126, 250, 69, 230, 190, 17, 158, 13, 107, 48, 43, 6, 9, 42, 134, 72, 134, 247, 13, 1, 7, 1,
    48, 30, 6, 9, 96, 134, 72, 1, 101, 3, 4, 1, 46, 48, 17, 4, 12, 158, 91, 46, 23, 194, 63, 4, 252, 53, 37, 225, 24,
    2, 1, 16, 228, 205, 246, 84, 114, 42, 73, 213, 95, 83, 8, 85, 14, 196, 232, 170, 198, 208, 190, 73, 81, 22, 246,
    19, 42, 77, 89, 23, 159, 215, 19, 142, 201, 75, 83, 110, 37, 17, 213, 202, 13, 55, 141, 236, 60, 66, 61, 85, 197,
    10, 96, 220, 65, 143, 144, 23, 130, 72, 70, 224, 43, 98, 4, 200, 179, 39, 60, 159, 196, 67, 55, 99, 148, 71, 59,
    249, 123, 220, 85, 128, 9, 81, 173, 249, 35, 141, 138, 2, 255, 224, 56, 205, 77, 123, 22, 1, 47, 122, 232, 184,
    121, 3, 224, 80, 0, 216, 227, 16, 222, 27, 45, 28, 163, 68, 178, 242, 103, 58, 61, 90, 92, 77, 228, 99, 38, 75,
    149, 100, 235, 158, 176, 76, 82, 113, 28, 51, 197, 167, 169, 116, 13, 102, 84, 136, 85, 182,
];

fn testing_blob() -> DpapiBlob {
    DpapiBlob {
        key_identifier: KeyIdentifier {
            version: 1,
            flags: 3,
            l0: 361,
            l1: 16,
            l2: 3,
            root_key_identifier: uuid!("d778c271-9025-9a82-f6dc-b8960b8ad8c5"),
            key_info: vec![
                68, 72, 80, 66, 0, 1, 0, 0, 135, 168, 230, 29, 180, 182, 102, 60, 255, 187, 209, 156, 101, 25, 89, 153,
                140, 238, 246, 8, 102, 13, 208, 242, 93, 44, 238, 212, 67, 94, 59, 0, 224, 13, 248, 241, 214, 25, 87,
                212, 250, 247, 223, 69, 97, 178, 170, 48, 22, 195, 217, 17, 52, 9, 111, 170, 59, 244, 41, 109, 131, 14,
                154, 124, 32, 158, 12, 100, 151, 81, 122, 189, 90, 138, 157, 48, 107, 207, 103, 237, 145, 249, 230,
                114, 91, 71, 88, 192, 34, 224, 177, 239, 66, 117, 191, 123, 108, 91, 252, 17, 212, 95, 144, 136, 185,
                65, 245, 78, 177, 229, 155, 184, 188, 57, 160, 191, 18, 48, 127, 92, 79, 219, 112, 197, 129, 178, 63,
                118, 182, 58, 202, 225, 202, 166, 183, 144, 45, 82, 82, 103, 53, 72, 138, 14, 241, 60, 109, 154, 81,
                191, 164, 171, 58, 216, 52, 119, 150, 82, 77, 142, 246, 161, 103, 181, 164, 24, 37, 217, 103, 225, 68,
                229, 20, 5, 100, 37, 28, 202, 203, 131, 230, 180, 134, 246, 179, 202, 63, 121, 113, 80, 96, 38, 192,
                184, 87, 246, 137, 150, 40, 86, 222, 212, 1, 10, 189, 11, 230, 33, 195, 163, 150, 10, 84, 231, 16, 195,
                117, 242, 99, 117, 215, 1, 65, 3, 164, 181, 67, 48, 193, 152, 175, 18, 97, 22, 210, 39, 110, 17, 113,
                95, 105, 56, 119, 250, 215, 239, 9, 202, 219, 9, 74, 233, 30, 26, 21, 151, 63, 179, 44, 155, 115, 19,
                77, 11, 46, 119, 80, 102, 96, 237, 189, 72, 76, 167, 177, 143, 33, 239, 32, 84, 7, 244, 121, 58, 26,
                11, 161, 37, 16, 219, 193, 80, 119, 190, 70, 63, 255, 79, 237, 74, 172, 11, 181, 85, 190, 58, 108, 27,
                12, 107, 71, 177, 188, 55, 115, 191, 126, 140, 111, 98, 144, 18, 40, 248, 194, 140, 187, 24, 165, 90,
                227, 19, 65, 0, 10, 101, 1, 150, 249, 49, 199, 122, 87, 242, 221, 244, 99, 229, 233, 236, 20, 75, 119,
                125, 230, 42, 170, 184, 168, 98, 138, 195, 118, 210, 130, 214, 237, 56, 100, 230, 121, 130, 66, 142,
                188, 131, 29, 20, 52, 143, 111, 47, 145, 147, 181, 4, 90, 242, 118, 113, 100, 225, 223, 201, 103, 193,
                251, 63, 46, 85, 164, 189, 27, 255, 232, 59, 156, 128, 208, 82, 185, 133, 209, 130, 234, 10, 219, 42,
                59, 115, 19, 211, 254, 20, 200, 72, 75, 30, 5, 37, 136, 185, 183, 210, 187, 210, 223, 1, 97, 153, 236,
                208, 110, 21, 87, 205, 9, 21, 179, 53, 59, 187, 100, 224, 236, 55, 127, 208, 40, 55, 13, 249, 43, 82,
                199, 137, 20, 40, 205, 198, 126, 182, 24, 75, 82, 61, 29, 178, 70, 195, 47, 99, 7, 132, 144, 240, 14,
                248, 214, 71, 209, 72, 212, 121, 84, 81, 94, 35, 39, 207, 239, 152, 197, 130, 102, 75, 76, 15, 108,
                196, 22, 89, 45, 48, 255, 175, 224, 178, 34, 113, 55, 121, 103, 94, 57, 230, 149, 227, 2, 8, 211, 56,
                135, 63, 75, 228, 67, 79, 182, 168, 130, 79, 28, 56, 65, 78, 255, 48, 67, 5, 243, 1, 170, 131, 242, 24,
                216, 174, 93, 89, 249, 12, 215, 25, 248, 12, 146, 191, 38, 9, 239, 136, 197, 113, 125, 222, 79, 184,
                149, 180, 198, 185, 10, 161, 28, 53, 69, 19, 173, 197, 112, 73, 23, 172, 239, 88, 66, 170, 206, 185,
                238, 228, 152, 153, 163, 198, 94, 147, 212, 117, 120, 83, 30, 158, 8, 70, 1, 73, 134, 237, 77, 162,
                147, 56, 224, 231, 179, 30, 110, 19, 55, 253, 176, 115, 101, 171, 146, 59, 227, 37, 145, 200, 156, 20,
                33, 186, 8, 34, 118, 162, 125, 114, 229, 11, 202, 36, 115, 124, 83, 60, 251, 141, 83, 244, 164, 213,
                197, 199, 2, 130, 173, 22, 120, 61, 63, 196, 111, 60, 184, 58, 17, 34, 166, 237, 250, 238, 19, 150,
                192, 123, 172, 162, 70, 227, 90, 165, 58, 139, 124, 87, 199, 135, 30, 146, 142, 203, 133, 133, 54, 26,
                54, 229, 134, 122, 117, 207, 31, 184, 148, 68, 232, 89, 132, 91, 246, 40, 87, 225, 14, 74, 23, 81, 228,
                241, 146, 171, 106, 211, 196, 222, 192, 142, 81, 207, 169, 185, 24, 161, 88, 75, 138, 97, 111, 92, 43,
                214, 190, 140, 12, 124, 177, 67, 125, 237, 147, 195, 41, 40,
            ],
            domain_name: "domain.test".into(),
            forest_name: "domain.test".into(),
        },
        protection_descriptor: SidProtectionDescriptor {
            sid: "S-1-5-21-3337337973-3297078028-437386066-512".into(),
        },
        enc_cek: vec![
            137, 127, 196, 63, 116, 142, 253, 9, 87, 39, 221, 233, 143, 78, 26, 111, 251, 157, 65, 99, 211, 159, 179,
            116, 208, 73, 199, 61, 137, 105, 12, 126, 250, 69, 230, 190, 17, 158, 13, 107,
        ],
        enc_cek_algorithm_id: KeyEncryptionAlgorithmIdentifier::new_aes256_empty(AesMode::Wrap),
        enc_content: vec![
            228, 205, 246, 84, 114, 42, 73, 213, 95, 83, 8, 85, 14, 196, 232, 170, 198, 208, 190, 73, 81, 22, 246, 19,
            42, 77, 89, 23, 159, 215, 19, 142, 201, 75, 83, 110, 37, 17, 213, 202, 13, 55, 141, 236, 60, 66, 61, 85,
            197, 10, 96, 220, 65, 143, 144, 23, 130, 72, 70, 224, 43, 98, 4, 200, 179, 39, 60, 159, 196, 67, 55, 99,
            148, 71, 59, 249, 123, 220, 85, 128, 9, 81, 173, 249, 35, 141, 138, 2, 255, 224, 56, 205, 77, 123, 22, 1,
            47, 122, 232, 184, 121, 3, 224, 80, 0, 216, 227, 16, 222, 27, 45, 28, 163, 68, 178, 242, 103, 58, 61, 90,
            92, 77, 228, 99, 38, 75, 149, 100, 235, 158, 176, 76, 82, 113, 28, 51, 197, 167, 169, 116, 13, 102, 84,
            136, 85, 182,
        ],
        enc_content_algorithm_id: ContentEncryptionAlgorithmIdentifier::new_aes256(
            AesMode::Gcm,
            AesParameters::AuthenticatedEncryptionParameters(AesAuthEncParams::new(
                vec![158, 91, 46, 23, 194, 63, 4, 252, 53, 37, 225, 24],
                16,
            )),
        ),
    }
}

#[test]
fn dpapi_blob_decoding() {
    let blob = DpapiBlob::decode(DPAPI_BLOB_DATA).unwrap();

    assert_eq!(testing_blob(), blob);
}

#[test]
fn dpapi_blob_encoding() {
    let blob = testing_blob();

    let mut buf = Vec::new();
    blob.encode(false, &mut buf).unwrap();

    assert_eq!(DPAPI_BLOB_DATA, &buf);
}

#[test]
fn get_target_sd() {
    let expected = [
        1, 0, 4, 128, 84, 0, 0, 0, 96, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 2, 0, 64, 0, 2, 0, 0, 0, 0, 0, 36, 0, 3, 0, 0,
        0, 1, 5, 0, 0, 0, 0, 0, 5, 21, 0, 0, 0, 223, 243, 137, 88, 86, 131, 83, 53, 105, 218, 109, 33, 80, 4, 0, 0, 0,
        0, 20, 0, 2, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 5, 18, 0, 0, 0, 1, 1, 0, 0, 0,
        0, 0, 5, 18, 0, 0, 0,
    ];
    let sid = SidProtectionDescriptor {
        sid: "S-1-5-21-1485435871-894665558-560847465-1104".to_owned(),
    };

    let target_sd = sid.get_target_sd().unwrap();

    assert_eq!(expected[..], target_sd[..]);
}


--- File: crates/dpapi/tests/dpapi/crypto.rs ---
use dpapi::crypto::{
    cek_decrypt, cek_encrypt, compute_kek, compute_public_key, content_decrypt, content_encrypt, kdf, KDS_SERVICE_LABEL,
};
use dpapi_pdu::gkdi::HashAlg;
use picky_asn1::wrapper::OctetStringAsn1;
use picky_asn1_x509::enveloped_data::{ContentEncryptionAlgorithmIdentifier, KeyEncryptionAlgorithmIdentifier};
use picky_asn1_x509::{AesMode, AesParameters};

const SECRET_KEY: &[u8] = &[
    213, 85, 238, 100, 120, 222, 109, 53, 48, 101, 43, 187, 152, 206, 110, 105, 123, 251, 227, 253, 232, 85, 197, 24,
    217, 190, 118, 74, 54, 226, 8, 188, 163, 141, 155, 170, 208, 164, 97, 125, 32, 172, 65, 183, 251, 135, 229, 224,
    214, 22, 98, 18, 170, 254, 220, 105, 217, 11, 142, 135, 141, 104, 82, 189,
];
const CONTEXT: &[u8] = &[
    228, 137, 183, 195, 107, 83, 44, 167, 62, 235, 215, 116, 108, 38, 108, 149, 107, 206, 154, 191, 189, 219, 105, 175,
    72, 213, 172, 131, 94, 207, 58, 208,
];
const PRIVATE_KEY_DH: &[u8] = &[
    139, 93, 50, 184, 90, 214, 77, 2, 57, 23, 5, 0, 155, 2, 202, 140, 58, 27, 111, 51, 97, 204, 165, 167, 18, 41, 158,
    25, 48, 44, 42, 198, 74, 238, 245, 201, 107, 49, 243, 27, 164, 205, 223, 112, 31, 100, 146, 48, 90, 81, 126, 112,
    38, 0, 194, 4, 195, 140, 122, 134, 104, 123, 211, 100,
];
const PUBLIC_KEY_DH: &[u8] = &[
    68, 72, 80, 66, 0, 1, 0, 0, 135, 168, 230, 29, 180, 182, 102, 60, 255, 187, 209, 156, 101, 25, 89, 153, 140, 238,
    246, 8, 102, 13, 208, 242, 93, 44, 238, 212, 67, 94, 59, 0, 224, 13, 248, 241, 214, 25, 87, 212, 250, 247, 223, 69,
    97, 178, 170, 48, 22, 195, 217, 17, 52, 9, 111, 170, 59, 244, 41, 109, 131, 14, 154, 124, 32, 158, 12, 100, 151,
    81, 122, 189, 90, 138, 157, 48, 107, 207, 103, 237, 145, 249, 230, 114, 91, 71, 88, 192, 34, 224, 177, 239, 66,
    117, 191, 123, 108, 91, 252, 17, 212, 95, 144, 136, 185, 65, 245, 78, 177, 229, 155, 184, 188, 57, 160, 191, 18,
    48, 127, 92, 79, 219, 112, 197, 129, 178, 63, 118, 182, 58, 202, 225, 202, 166, 183, 144, 45, 82, 82, 103, 53, 72,
    138, 14, 241, 60, 109, 154, 81, 191, 164, 171, 58, 216, 52, 119, 150, 82, 77, 142, 246, 161, 103, 181, 164, 24, 37,
    217, 103, 225, 68, 229, 20, 5, 100, 37, 28, 202, 203, 131, 230, 180, 134, 246, 179, 202, 63, 121, 113, 80, 96, 38,
    192, 184, 87, 246, 137, 150, 40, 86, 222, 212, 1, 10, 189, 11, 230, 33, 195, 163, 150, 10, 84, 231, 16, 195, 117,
    242, 99, 117, 215, 1, 65, 3, 164, 181, 67, 48, 193, 152, 175, 18, 97, 22, 210, 39, 110, 17, 113, 95, 105, 56, 119,
    250, 215, 239, 9, 202, 219, 9, 74, 233, 30, 26, 21, 151, 63, 179, 44, 155, 115, 19, 77, 11, 46, 119, 80, 102, 96,
    237, 189, 72, 76, 167, 177, 143, 33, 239, 32, 84, 7, 244, 121, 58, 26, 11, 161, 37, 16, 219, 193, 80, 119, 190, 70,
    63, 255, 79, 237, 74, 172, 11, 181, 85, 190, 58, 108, 27, 12, 107, 71, 177, 188, 55, 115, 191, 126, 140, 111, 98,
    144, 18, 40, 248, 194, 140, 187, 24, 165, 90, 227, 19, 65, 0, 10, 101, 1, 150, 249, 49, 199, 122, 87, 242, 221,
    244, 99, 229, 233, 236, 20, 75, 119, 125, 230, 42, 170, 184, 168, 98, 138, 195, 118, 210, 130, 214, 237, 56, 100,
    230, 121, 130, 66, 142, 188, 131, 29, 20, 52, 143, 111, 47, 145, 147, 181, 4, 90, 242, 118, 113, 100, 225, 223,
    201, 103, 193, 251, 63, 46, 85, 164, 189, 27, 255, 232, 59, 156, 128, 208, 82, 185, 133, 209, 130, 234, 10, 219,
    42, 59, 115, 19, 211, 254, 20, 200, 72, 75, 30, 5, 37, 136, 185, 183, 210, 187, 210, 223, 1, 97, 153, 236, 208,
    110, 21, 87, 205, 9, 21, 179, 53, 59, 187, 100, 224, 236, 55, 127, 208, 40, 55, 13, 249, 43, 82, 199, 137, 20, 40,
    205, 198, 126, 182, 24, 75, 82, 61, 29, 178, 70, 195, 47, 99, 7, 132, 144, 240, 14, 248, 214, 71, 209, 72, 212,
    121, 84, 81, 94, 35, 39, 207, 239, 152, 197, 130, 102, 75, 76, 15, 108, 196, 22, 89, 63, 246, 158, 197, 238, 228,
    177, 87, 255, 7, 170, 179, 251, 65, 155, 170, 131, 138, 187, 46, 97, 142, 5, 165, 60, 250, 49, 231, 45, 194, 253,
    138, 19, 51, 17, 14, 58, 138, 220, 159, 243, 234, 232, 20, 213, 21, 252, 63, 24, 156, 7, 240, 21, 148, 36, 254,
    147, 3, 29, 43, 52, 13, 13, 153, 78, 16, 128, 153, 153, 114, 253, 211, 219, 59, 84, 206, 244, 233, 243, 222, 144,
    228, 133, 135, 176, 87, 48, 253, 16, 188, 170, 171, 53, 228, 102, 234, 1, 38, 120, 251, 65, 104, 155, 189, 160, 74,
    150, 128, 13, 242, 122, 148, 52, 206, 158, 237, 95, 106, 96, 236, 190, 43, 173, 141, 144, 42, 198, 40, 92, 242,
    100, 42, 54, 249, 250, 249, 97, 19, 168, 10, 109, 182, 35, 138, 248, 158, 153, 45, 181, 175, 160, 65, 6, 210, 191,
    73, 164, 230, 167, 12, 140, 148, 222, 156, 10, 62, 149, 64, 13, 150, 200, 169, 109, 49, 149, 52, 227, 37, 250, 250,
    208, 109, 50, 187, 91, 242, 40, 102, 200, 248, 182, 96, 18, 87, 71, 238, 88, 8, 220, 157, 201, 237, 178, 250, 211,
    77, 95, 21, 98, 248, 205, 24, 172, 212, 96, 169, 101, 35, 47, 40, 187, 132, 216, 243, 39, 131, 24, 135, 88, 17,
    245, 208, 83, 162, 58, 194, 84, 192, 227, 105, 145, 134, 13, 44, 216, 9, 102, 61, 99, 224, 239, 153, 66, 232, 191,
    24,
];

#[test]
fn test_kdf_sha1() {
    let expected_key = [
        117, 25, 15, 198, 42, 170, 180, 156, 140, 156, 188, 164, 163, 245, 40, 18, 53, 43, 149, 141, 135, 152, 11, 248,
        80, 84, 1, 195, 212, 7, 149, 35,
    ];

    let key = kdf(HashAlg::Sha1, SECRET_KEY, KDS_SERVICE_LABEL, CONTEXT, 32).unwrap();

    assert_eq!(expected_key[..], key[..]);
}

#[test]
fn test_kdf_sha256() {
    let expected_key = [
        95, 246, 71, 210, 202, 186, 163, 251, 24, 175, 54, 107, 191, 107, 87, 35, 241, 202, 64, 106, 34, 201, 185, 5,
        213, 175, 222, 111, 249, 145, 238, 162,
    ];

    let key = kdf(HashAlg::Sha256, SECRET_KEY, KDS_SERVICE_LABEL, CONTEXT, 32).unwrap();

    assert_eq!(expected_key[..], key[..]);
}

#[test]
fn test_kdf_sha384() {
    let expected_key = [
        91, 218, 125, 86, 51, 207, 96, 224, 6, 253, 16, 137, 142, 10, 95, 156, 163, 217, 31, 186, 206, 88, 81, 141,
        231, 62, 224, 200, 168, 156, 189, 71, 60, 220, 166, 65, 141, 47, 92, 145, 241, 112, 91, 39, 27, 237, 88, 122,
        103, 38, 115, 222, 26, 214, 185, 78, 34, 7, 170, 54, 74, 18, 206, 75,
    ];

    let key = kdf(HashAlg::Sha384, SECRET_KEY, KDS_SERVICE_LABEL, CONTEXT, 64).unwrap();

    assert_eq!(expected_key[..], key[..]);
}

#[test]
fn test_kdf_sha512() {
    let expected_key = [
        56, 219, 230, 175, 76, 173, 241, 49, 216, 97, 145, 27, 74, 153, 173, 79, 201, 145, 64, 135, 166, 0, 111, 19,
        164, 112, 171, 230, 130, 28, 71, 240, 122, 88, 46, 26, 192, 243, 50, 182, 242, 217, 179, 190, 12, 13, 85, 1,
        202, 211, 212, 169, 83, 208, 162, 227, 217, 30, 33, 226, 101, 230, 8, 109,
    ];

    let key = kdf(HashAlg::Sha512, SECRET_KEY, KDS_SERVICE_LABEL, CONTEXT, 64).unwrap();

    assert_eq!(expected_key[..], key[..]);
}

#[test]
fn test_compute_public_key_dh() {
    let expected_key = [
        68, 72, 80, 66, 0, 1, 0, 0, 135, 168, 230, 29, 180, 182, 102, 60, 255, 187, 209, 156, 101, 25, 89, 153, 140,
        238, 246, 8, 102, 13, 208, 242, 93, 44, 238, 212, 67, 94, 59, 0, 224, 13, 248, 241, 214, 25, 87, 212, 250, 247,
        223, 69, 97, 178, 170, 48, 22, 195, 217, 17, 52, 9, 111, 170, 59, 244, 41, 109, 131, 14, 154, 124, 32, 158, 12,
        100, 151, 81, 122, 189, 90, 138, 157, 48, 107, 207, 103, 237, 145, 249, 230, 114, 91, 71, 88, 192, 34, 224,
        177, 239, 66, 117, 191, 123, 108, 91, 252, 17, 212, 95, 144, 136, 185, 65, 245, 78, 177, 229, 155, 184, 188,
        57, 160, 191, 18, 48, 127, 92, 79, 219, 112, 197, 129, 178, 63, 118, 182, 58, 202, 225, 202, 166, 183, 144, 45,
        82, 82, 103, 53, 72, 138, 14, 241, 60, 109, 154, 81, 191, 164, 171, 58, 216, 52, 119, 150, 82, 77, 142, 246,
        161, 103, 181, 164, 24, 37, 217, 103, 225, 68, 229, 20, 5, 100, 37, 28, 202, 203, 131, 230, 180, 134, 246, 179,
        202, 63, 121, 113, 80, 96, 38, 192, 184, 87, 246, 137, 150, 40, 86, 222, 212, 1, 10, 189, 11, 230, 33, 195,
        163, 150, 10, 84, 231, 16, 195, 117, 242, 99, 117, 215, 1, 65, 3, 164, 181, 67, 48, 193, 152, 175, 18, 97, 22,
        210, 39, 110, 17, 113, 95, 105, 56, 119, 250, 215, 239, 9, 202, 219, 9, 74, 233, 30, 26, 21, 151, 63, 179, 44,
        155, 115, 19, 77, 11, 46, 119, 80, 102, 96, 237, 189, 72, 76, 167, 177, 143, 33, 239, 32, 84, 7, 244, 121, 58,
        26, 11, 161, 37, 16, 219, 193, 80, 119, 190, 70, 63, 255, 79, 237, 74, 172, 11, 181, 85, 190, 58, 108, 27, 12,
        107, 71, 177, 188, 55, 115, 191, 126, 140, 111, 98, 144, 18, 40, 248, 194, 140, 187, 24, 165, 90, 227, 19, 65,
        0, 10, 101, 1, 150, 249, 49, 199, 122, 87, 242, 221, 244, 99, 229, 233, 236, 20, 75, 119, 125, 230, 42, 170,
        184, 168, 98, 138, 195, 118, 210, 130, 214, 237, 56, 100, 230, 121, 130, 66, 142, 188, 131, 29, 20, 52, 143,
        111, 47, 145, 147, 181, 4, 90, 242, 118, 113, 100, 225, 223, 201, 103, 193, 251, 63, 46, 85, 164, 189, 27, 255,
        232, 59, 156, 128, 208, 82, 185, 133, 209, 130, 234, 10, 219, 42, 59, 115, 19, 211, 254, 20, 200, 72, 75, 30,
        5, 37, 136, 185, 183, 210, 187, 210, 223, 1, 97, 153, 236, 208, 110, 21, 87, 205, 9, 21, 179, 53, 59, 187, 100,
        224, 236, 55, 127, 208, 40, 55, 13, 249, 43, 82, 199, 137, 20, 40, 205, 198, 126, 182, 24, 75, 82, 61, 29, 178,
        70, 195, 47, 99, 7, 132, 144, 240, 14, 248, 214, 71, 209, 72, 212, 121, 84, 81, 94, 35, 39, 207, 239, 152, 197,
        130, 102, 75, 76, 15, 108, 196, 22, 89, 112, 124, 225, 37, 170, 121, 200, 204, 39, 82, 73, 239, 179, 79, 50,
        51, 207, 130, 16, 9, 49, 150, 137, 59, 156, 72, 231, 118, 10, 79, 87, 132, 54, 160, 121, 120, 82, 45, 130, 61,
        11, 207, 93, 176, 13, 49, 155, 223, 213, 26, 171, 188, 84, 184, 62, 16, 149, 16, 26, 35, 72, 12, 173, 68, 176,
        48, 84, 175, 37, 188, 209, 38, 57, 183, 57, 184, 123, 249, 56, 131, 229, 224, 39, 66, 9, 178, 36, 254, 21, 73,
        60, 212, 212, 119, 130, 245, 84, 33, 111, 156, 95, 19, 172, 13, 82, 37, 38, 109, 52, 223, 45, 162, 130, 115,
        64, 186, 53, 50, 42, 119, 173, 13, 128, 224, 12, 40, 93, 71, 136, 205, 137, 185, 138, 201, 202, 158, 184, 18,
        77, 242, 208, 18, 49, 124, 69, 105, 20, 3, 114, 204, 98, 30, 64, 153, 254, 165, 198, 129, 124, 53, 251, 168,
        187, 150, 176, 245, 34, 42, 159, 27, 186, 65, 126, 35, 175, 148, 173, 231, 57, 68, 198, 175, 117, 130, 17, 248,
        234, 224, 220, 238, 197, 226, 200, 190, 121, 5, 81, 66, 133, 13, 41, 74, 89, 29, 106, 14, 56, 186, 246, 156,
        51, 204, 84, 247, 202, 39, 58, 62, 38, 170, 170, 191, 8, 18, 15, 65, 53, 239, 223, 98, 245, 69, 40, 70, 147,
        81, 9, 177, 119, 78, 158, 68, 179, 94, 183, 150, 34, 134, 172, 28, 86, 63, 192, 65, 4, 216,
    ];

    let public_key = compute_public_key("DH", PRIVATE_KEY_DH, PUBLIC_KEY_DH).unwrap();

    assert_eq!(expected_key[..], public_key[..]);
}

#[test]
fn test_compute_kek_dh() {
    let expected_key = [
        9, 171, 213, 100, 174, 219, 112, 33, 135, 63, 151, 51, 231, 55, 121, 167, 132, 216, 251, 190, 174, 207, 209,
        164, 141, 125, 85, 196, 84, 60, 232, 36,
    ];

    let kek = compute_kek(HashAlg::Sha512, "DH", PRIVATE_KEY_DH, PUBLIC_KEY_DH).unwrap();

    assert_eq!(expected_key[..], kek[..]);
}

#[test]
fn test_cek_encrypt() {
    let expected_key = [
        177, 34, 69, 51, 190, 164, 94, 127, 38, 205, 148, 208, 11, 108, 215, 29, 178, 61, 153, 114, 42, 203, 15, 82,
        30, 72, 228, 118, 78, 34, 29, 117, 181, 56, 147, 124, 62, 48, 255, 39,
    ];

    let wrapped_key = cek_encrypt(
        &KeyEncryptionAlgorithmIdentifier::new_aes256_empty(AesMode::Wrap),
        &[
            9, 171, 213, 100, 174, 219, 112, 33, 135, 63, 151, 51, 231, 55, 121, 167, 132, 216, 251, 190, 174, 207,
            209, 164, 141, 125, 85, 196, 84, 60, 232, 36,
        ],
        &[
            206, 232, 113, 60, 84, 106, 53, 122, 24, 150, 171, 198, 170, 126, 87, 228, 7, 22, 212, 151, 162, 93, 220,
            211, 115, 74, 24, 231, 235, 112, 110, 133,
        ],
    )
    .unwrap();

    assert_eq!(expected_key[..], wrapped_key[..]);
}

#[test]
fn test_cek_decrypt() {
    let expected_key = [
        237, 217, 97, 116, 100, 107, 229, 54, 97, 127, 233, 172, 141, 83, 124, 250, 21, 115, 218, 160, 137, 22, 103,
        96, 167, 25, 59, 35, 65, 126, 69, 192,
    ];

    let key = cek_decrypt(
        &KeyEncryptionAlgorithmIdentifier::new_aes256_empty(AesMode::Wrap),
        &[
            166, 59, 66, 26, 83, 122, 242, 219, 236, 155, 114, 107, 185, 13, 252, 191, 239, 219, 244, 91, 42, 197, 34,
            82, 11, 8, 251, 120, 137, 197, 250, 110,
        ],
        &[
            79, 59, 241, 186, 249, 240, 229, 63, 50, 183, 56, 137, 17, 64, 57, 136, 49, 12, 176, 219, 163, 106, 132,
            25, 1, 87, 85, 16, 179, 52, 21, 138, 173, 143, 110, 15, 16, 0, 99, 244,
        ],
    )
    .unwrap();

    assert_eq!(expected_key[..], key[..]);
}

const PLAINTEXT: &[u8] = &[84, 104, 101, 66, 101, 115, 116, 84, 118, 97, 114, 121, 110, 107, 97];
const CIPHER_TEXT: &[u8] = &[
    141, 73, 82, 191, 110, 35, 212, 200, 182, 19, 135, 174, 143, 253, 167, 179, 170, 9, 181, 213, 130, 114, 20, 4, 145,
    63, 224, 92, 231, 37, 18,
];
const AES256_GCM_IV: &[u8] = &[127, 98, 187, 173, 250, 133, 155, 4, 74, 60, 109, 245];
const AES256_GCM_KEY: &[u8] = &[
    237, 217, 97, 116, 100, 107, 229, 54, 97, 127, 233, 172, 141, 83, 124, 250, 21, 115, 218, 160, 137, 22, 103, 96,
    167, 25, 59, 35, 65, 126, 69, 192,
];

#[test]
fn test_content_decrypt() {
    let plaintext = content_decrypt(
        &ContentEncryptionAlgorithmIdentifier::new_aes256(
            AesMode::Gcm,
            AesParameters::InitializationVector(OctetStringAsn1::from(AES256_GCM_IV.to_vec())),
        ),
        AES256_GCM_KEY,
        CIPHER_TEXT,
    )
    .unwrap();

    assert_eq!(PLAINTEXT[..], plaintext[..]);
}

#[test]
fn test_content_encrypt() {
    let cipher_text = content_encrypt(
        &ContentEncryptionAlgorithmIdentifier::new_aes256(
            AesMode::Gcm,
            AesParameters::InitializationVector(OctetStringAsn1::from(AES256_GCM_IV.to_vec())),
        ),
        AES256_GCM_KEY,
        PLAINTEXT,
    )
    .unwrap();

    assert_eq!(CIPHER_TEXT[..], cipher_text[..]);
}


--- File: crates/dpapi/tests/dpapi/main.rs ---
mod blob;
mod crypto;


--- File: crates/ffi-types/Cargo.toml ---
[package]
name = "ffi-types"
version = "0.0.0"
license = "MIT/Apache-2.0"
edition = "2021"
publish = false

[features]
default = []
winscard = []

[lints]
workspace = true


--- File: crates/ffi-types/src/common.rs ---
use std::ffi::c_void;

pub type LpStr = *mut u8;
pub type LpCStr = *const u8;
pub type Dword = u32;
pub type LpDword = *mut u32;
pub type WChar = u16;
pub type LpWStr = *mut u16;
pub type LpCWStr = *const u16;
pub type LpCByte = *const u8;
pub type LpByte = *mut u8;
pub type LpCVoid = *const c_void;
pub type LpVoid = *mut c_void;
pub type Handle = isize;
pub type Bool = i32;

/// [Guid](https://learn.microsoft.com/en-us/windows/win32/api/guiddef/ns-guiddef-guid)
///
/// ```not_rust
/// typedef struct _GUID {
///   unsigned long  Data1;
///   unsigned short Data2;
///   unsigned short Data3;
///   unsigned char  Data4[8];
/// } GUID;
/// ```
#[derive(Clone, Copy)]
#[repr(C)]
pub struct Guid {
    pub data1: u32,
    pub data2: u16,
    pub data3: u16,
    pub data4: [u8; 8],
}
pub type LpCGuid = *const Guid;
pub type LpGuid = *mut Guid;
pub type Uuid = Guid;
pub type LpUuid = *mut Uuid;
pub type LpCUuid = *const Uuid;


--- File: crates/ffi-types/src/lib.rs ---
pub mod common;
#[cfg(feature = "winscard")]
pub mod winscard;

pub use common::*;


--- File: crates/ffi-types/src/winscard/functions.rs ---
use std::ffi::c_void;

use super::{
    LpCScardIoRequest, LpOpenCardNameA, LpOpenCardNameExA, LpOpenCardNameExW, LpOpenCardNameW, LpScardAtrMask,
    LpScardContext, LpScardHandle, LpScardIoRequest, LpScardReaderStateA, LpScardReaderStateW, ScardContext,
    ScardHandle, ScardStatus,
};
use crate::winscard::ScardIoRequest;
use crate::{
    Handle, LpByte, LpCByte, LpCGuid, LpCStr, LpCVoid, LpCWStr, LpDword, LpGuid, LpStr, LpUuid, LpVoid, LpWStr,
};

pub type SCardEstablishContextFn =
    unsafe extern "system" fn(u32, *const c_void, *const c_void, LpScardContext) -> ScardStatus;
pub type SCardReleaseContextFn = unsafe extern "system" fn(ScardContext) -> ScardStatus;
pub type SCardIsValidContextFn = unsafe extern "system" fn(ScardContext) -> ScardStatus;
pub type SCardListReaderGroupsAFn = unsafe extern "system" fn(ScardContext, LpStr, LpDword) -> ScardStatus;
pub type SCardListReaderGroupsWFn = unsafe extern "system" fn(ScardContext, LpWStr, LpDword) -> ScardStatus;
pub type SCardListReadersAFn = unsafe extern "system" fn(ScardContext, LpCStr, LpStr, LpDword) -> ScardStatus;
pub type SCardListReadersWFn = unsafe extern "system" fn(ScardContext, LpCWStr, LpWStr, LpDword) -> ScardStatus;
pub type SCardListCardsAFn =
    unsafe extern "system" fn(ScardContext, LpCByte, LpCGuid, u32, *mut u8, LpDword) -> ScardStatus;
pub type SCardListCardsWFn =
    unsafe extern "system" fn(ScardContext, LpCByte, LpCGuid, u32, *mut u16, LpDword) -> ScardStatus;
pub type SCardListInterfacesAFn = unsafe extern "system" fn(ScardContext, LpCStr, LpGuid, LpDword) -> ScardStatus;
pub type SCardListInterfacesWFn = unsafe extern "system" fn(ScardContext, LpCWStr, LpGuid, LpDword) -> ScardStatus;
pub type SCardGetProviderIdAFn = unsafe extern "system" fn(ScardContext, LpCStr, LpGuid) -> ScardStatus;
pub type SCardGetProviderIdWFn = unsafe extern "system" fn(ScardContext, LpCWStr, LpGuid) -> ScardStatus;
pub type SCardGetCardTypeProviderNameAFn =
    unsafe extern "system" fn(ScardContext, LpCStr, u32, *mut u8, LpDword) -> ScardStatus;
pub type SCardGetCardTypeProviderNameWFn =
    unsafe extern "system" fn(ScardContext, LpCWStr, u32, *mut u16, LpDword) -> ScardStatus;
pub type SCardIntroduceReaderGroupAFn = unsafe extern "system" fn(ScardContext, LpCStr) -> ScardStatus;
pub type SCardIntroduceReaderGroupWFn = unsafe extern "system" fn(ScardContext, LpCWStr) -> ScardStatus;
pub type SCardForgetReaderGroupAFn = unsafe extern "system" fn(ScardContext, LpCStr) -> ScardStatus;
pub type SCardForgetReaderGroupWFn = unsafe extern "system" fn(ScardContext, LpCWStr) -> ScardStatus;
pub type SCardIntroduceReaderAFn = unsafe extern "system" fn(ScardContext, LpCStr, LpCStr) -> ScardStatus;
pub type SCardIntroduceReaderWFn = unsafe extern "system" fn(ScardContext, LpCWStr, LpCWStr) -> ScardStatus;
pub type SCardForgetReaderAFn = unsafe extern "system" fn(ScardContext, LpCStr) -> ScardStatus;
pub type SCardForgetReaderWFn = unsafe extern "system" fn(ScardContext, LpCWStr) -> ScardStatus;
pub type SCardAddReaderToGroupAFn = unsafe extern "system" fn(ScardContext, LpCStr, LpCStr) -> ScardStatus;
pub type SCardAddReaderToGroupWFn = unsafe extern "system" fn(ScardContext, LpCWStr, LpCWStr) -> ScardStatus;
pub type SCardRemoveReaderFromGroupAFn = unsafe extern "system" fn(ScardContext, LpCStr, LpCStr) -> ScardStatus;
pub type SCardRemoveReaderFromGroupWFn = unsafe extern "system" fn(ScardContext, LpCWStr, LpCWStr) -> ScardStatus;
pub type SCardIntroduceCardTypeAFn =
    unsafe extern "system" fn(ScardContext, LpCStr, LpCGuid, LpCGuid, u32, LpCByte, LpCByte, u32) -> ScardStatus;
pub type SCardIntroduceCardTypeWFn =
    unsafe extern "system" fn(ScardContext, LpCWStr, LpCGuid, LpCGuid, u32, LpCByte, LpCByte, u32) -> ScardStatus;
pub type SCardSetCardTypeProviderNameAFn = unsafe extern "system" fn(ScardContext, LpCStr, u32, LpCStr) -> ScardStatus;
pub type SCardSetCardTypeProviderNameWFn =
    unsafe extern "system" fn(ScardContext, LpCWStr, u32, LpCWStr) -> ScardStatus;
pub type SCardForgetCardTypeAFn = unsafe extern "system" fn(ScardContext, LpCStr) -> ScardStatus;
pub type SCardForgetCardTypeWFn = unsafe extern "system" fn(ScardContext, LpCWStr) -> ScardStatus;
pub type SCardFreeMemoryFn = unsafe extern "system" fn(ScardContext, LpCVoid) -> ScardStatus;
pub type SCardAccessStartedEventFn = unsafe extern "system" fn() -> Handle;
pub type SCardReleaseStartedEventFn = unsafe extern "system" fn();
pub type SCardLocateCardsAFn = unsafe extern "system" fn(ScardContext, LpCStr, LpScardReaderStateA, u32) -> ScardStatus;
pub type SCardLocateCardsWFn =
    unsafe extern "system" fn(ScardContext, LpCWStr, LpScardReaderStateW, u32) -> ScardStatus;
pub type SCardLocateCardsByATRAFn =
    unsafe extern "system" fn(ScardContext, LpScardAtrMask, u32, LpScardReaderStateA, u32) -> ScardStatus;
pub type SCardLocateCardsByATRWFn =
    unsafe extern "system" fn(ScardContext, LpScardAtrMask, u32, LpScardReaderStateW, u32) -> ScardStatus;
pub type SCardGetStatusChangeAFn =
    unsafe extern "system" fn(ScardContext, u32, LpScardReaderStateA, u32) -> ScardStatus;
pub type SCardGetStatusChangeWFn =
    unsafe extern "system" fn(ScardContext, u32, LpScardReaderStateW, u32) -> ScardStatus;
pub type SCardCancelFn = unsafe extern "system" fn(ScardContext) -> ScardStatus;
pub type SCardReadCacheAFn =
    unsafe extern "system" fn(ScardContext, LpUuid, u32, LpStr, LpByte, LpDword) -> ScardStatus;
pub type SCardReadCacheWFn =
    unsafe extern "system" fn(ScardContext, LpUuid, u32, LpWStr, LpByte, LpDword) -> ScardStatus;
pub type SCardWriteCacheAFn = unsafe extern "system" fn(ScardContext, LpUuid, u32, LpStr, LpCByte, u32) -> ScardStatus;
pub type SCardWriteCacheWFn = unsafe extern "system" fn(ScardContext, LpUuid, u32, LpWStr, LpCByte, u32) -> ScardStatus;
pub type SCardGetReaderIconAFn = unsafe extern "system" fn(ScardContext, LpCStr, LpByte, LpDword) -> ScardStatus;
pub type SCardGetReaderIconWFn = unsafe extern "system" fn(ScardContext, LpCWStr, LpByte, LpDword) -> ScardStatus;
pub type SCardGetDeviceTypeIdAFn = unsafe extern "system" fn(ScardContext, LpCStr, LpDword) -> ScardStatus;
pub type SCardGetDeviceTypeIdWFn = unsafe extern "system" fn(ScardContext, LpCWStr, LpDword) -> ScardStatus;
pub type SCardGetReaderDeviceInstanceIdAFn =
    unsafe extern "system" fn(ScardContext, LpCStr, LpStr, LpDword) -> ScardStatus;
pub type SCardGetReaderDeviceInstanceIdWFn =
    unsafe extern "system" fn(ScardContext, LpCWStr, LpWStr, LpDword) -> ScardStatus;
pub type SCardListReadersWithDeviceInstanceIdAFn =
    unsafe extern "system" fn(ScardContext, LpCStr, LpStr, LpDword) -> ScardStatus;
pub type SCardListReadersWithDeviceInstanceIdWFn =
    unsafe extern "system" fn(ScardContext, LpCWStr, LpWStr, LpDword) -> ScardStatus;
pub type SCardAuditFn = unsafe extern "system" fn(ScardContext, u32) -> ScardStatus;
pub type SCardConnectAFn =
    unsafe extern "system" fn(ScardContext, LpCStr, u32, u32, LpScardHandle, LpDword) -> ScardStatus;
pub type SCardConnectWFn =
    unsafe extern "system" fn(ScardContext, LpCWStr, u32, u32, LpScardHandle, LpDword) -> ScardStatus;
pub type SCardReconnectFn = unsafe extern "system" fn(ScardHandle, u32, u32, u32, LpDword) -> ScardStatus;
pub type SCardDisconnectFn = unsafe extern "system" fn(ScardHandle, u32) -> ScardStatus;
pub type SCardBeginTransactionFn = unsafe extern "system" fn(ScardHandle) -> ScardStatus;
pub type SCardEndTransactionFn = unsafe extern "system" fn(ScardHandle, u32) -> ScardStatus;
pub type SCardCancelTransactionFn = unsafe extern "system" fn(ScardHandle) -> ScardStatus;
pub type SCardStateFn = unsafe extern "system" fn(ScardHandle, LpDword, LpDword, LpByte, LpDword) -> ScardStatus;
pub type SCardStatusAFn =
    unsafe extern "system" fn(ScardHandle, LpStr, LpDword, LpDword, LpDword, LpByte, LpDword) -> ScardStatus;
pub type SCardStatusWFn =
    unsafe extern "system" fn(ScardHandle, LpWStr, LpDword, LpDword, LpDword, LpByte, LpDword) -> ScardStatus;
pub type SCardTransmitFn = unsafe extern "system" fn(
    ScardHandle,
    LpCScardIoRequest,
    LpCByte,
    u32,
    LpScardIoRequest,
    LpByte,
    LpDword,
) -> ScardStatus;
pub type SCardGetTransmitCountFn = unsafe extern "system" fn(ScardHandle, LpDword) -> ScardStatus;
pub type SCardControlFn =
    unsafe extern "system" fn(ScardHandle, u32, LpCVoid, u32, LpVoid, u32, LpDword) -> ScardStatus;
pub type SCardGetAttribFn = unsafe extern "system" fn(ScardHandle, u32, LpByte, LpDword) -> ScardStatus;
pub type SCardSetAttribFn = unsafe extern "system" fn(ScardHandle, u32, LpCByte, u32) -> ScardStatus;
pub type SCardUIDlgSelectCardAFn = unsafe extern "system" fn(LpOpenCardNameExA) -> ScardStatus;
pub type SCardUIDlgSelectCardWFn = unsafe extern "system" fn(LpOpenCardNameExW) -> ScardStatus;
pub type GetOpenCardNameAFn = unsafe extern "system" fn(LpOpenCardNameA) -> ScardStatus;
pub type GetOpenCardNameWFn = unsafe extern "system" fn(LpOpenCardNameW) -> ScardStatus;
// Not a part of the standard winscard.h API
pub type GetSCardApiFunctionTableFn = unsafe extern "system" fn() -> PSCardApiFunctionTable;

// https://github.com/FreeRDP/FreeRDP/blob/88f79c5748f4031cb50dfae3ebadcc6619b69f1c/winpr/include/winpr/smartcard.h#L1114
#[derive(Debug)]
#[repr(C)]
#[allow(non_snake_case)]
pub struct SCardApiFunctionTable {
    pub dw_version: u32,
    pub dw_flags: u32,

    pub SCardEstablishContext: SCardEstablishContextFn,
    pub SCardReleaseContext: SCardReleaseContextFn,
    pub SCardIsValidContext: SCardIsValidContextFn,
    pub SCardListReaderGroupsA: SCardListReaderGroupsAFn,
    pub SCardListReaderGroupsW: SCardListReaderGroupsWFn,
    pub SCardListReadersA: SCardListReadersAFn,
    pub SCardListReadersW: SCardListReadersWFn,
    pub SCardListCardsA: SCardListCardsAFn,
    pub SCardListCardsW: SCardListCardsWFn,
    pub SCardListInterfacesA: SCardListInterfacesAFn,
    pub SCardListInterfacesW: SCardListInterfacesWFn,
    pub SCardGetProviderIdA: SCardGetProviderIdAFn,
    pub SCardGetProviderIdW: SCardGetProviderIdWFn,
    pub SCardGetCardTypeProviderNameA: SCardGetCardTypeProviderNameAFn,
    pub SCardGetCardTypeProviderNameW: SCardGetCardTypeProviderNameWFn,
    pub SCardIntroduceReaderGroupA: SCardIntroduceReaderGroupAFn,
    pub SCardIntroduceReaderGroupW: SCardIntroduceReaderGroupWFn,
    pub SCardForgetReaderGroupA: SCardForgetReaderGroupAFn,
    pub SCardForgetReaderGroupW: SCardForgetReaderGroupWFn,
    pub SCardIntroduceReaderA: SCardIntroduceReaderAFn,
    pub SCardIntroduceReaderW: SCardIntroduceReaderWFn,
    pub SCardForgetReaderA: SCardForgetReaderAFn,
    pub SCardForgetReaderW: SCardForgetReaderWFn,
    pub SCardAddReaderToGroupA: SCardAddReaderToGroupAFn,
    pub SCardAddReaderToGroupW: SCardAddReaderToGroupWFn,
    pub SCardRemoveReaderFromGroupA: SCardRemoveReaderFromGroupAFn,
    pub SCardRemoveReaderFromGroupW: SCardRemoveReaderFromGroupWFn,
    pub SCardIntroduceCardTypeA: SCardIntroduceCardTypeAFn,
    pub SCardIntroduceCardTypeW: SCardIntroduceCardTypeWFn,
    pub SCardSetCardTypeProviderNameA: SCardSetCardTypeProviderNameAFn,
    pub SCardSetCardTypeProviderNameW: SCardSetCardTypeProviderNameWFn,
    pub SCardFreeMemory: SCardFreeMemoryFn,
    pub SCardAccessStartedEvent: SCardAccessStartedEventFn,
    pub SCardReleaseStartedEvent: SCardReleaseStartedEventFn,
    pub SCardLocateCardsA: SCardLocateCardsAFn,
    pub SCardLocateCardsW: SCardLocateCardsWFn,
    pub SCardLocateCardsByATRA: SCardLocateCardsByATRAFn,
    pub SCardLocateCardsByATRW: SCardLocateCardsByATRWFn,
    pub SCardGetStatusChangeA: SCardGetStatusChangeAFn,
    pub SCardGetStatusChangeW: SCardGetStatusChangeWFn,
    pub SCardCancel: SCardCancelFn,
    pub SCardConnectA: SCardConnectAFn,
    pub SCardConnectW: SCardConnectWFn,
    pub SCardReconnect: SCardReconnectFn,
    pub SCardDisconnect: SCardDisconnectFn,
    pub SCardBeginTransaction: SCardBeginTransactionFn,
    pub SCardEndTransaction: SCardEndTransactionFn,
    pub SCardCancelTransaction: SCardCancelTransactionFn,
    pub SCardState: SCardStateFn,
    pub SCardStatusA: SCardStatusAFn,
    pub SCardStatusW: SCardStatusWFn,
    pub SCardTransmit: SCardTransmitFn,
    pub SCardGetTransmitCount: SCardGetTransmitCountFn,
    pub SCardControl: SCardControlFn,
    pub SCardGetAttrib: SCardGetAttribFn,
    pub SCardSetAttrib: SCardSetAttribFn,
    pub SCardUIDlgSelectCardA: SCardUIDlgSelectCardAFn,
    pub SCardUIDlgSelectCardW: SCardUIDlgSelectCardWFn,
    pub GetOpenCardNameA: GetOpenCardNameAFn,
    pub GetOpenCardNameW: GetOpenCardNameWFn,
    pub SCardReadCacheA: SCardReadCacheAFn,
    pub SCardReadCacheW: SCardReadCacheWFn,
    pub SCardWriteCacheA: SCardWriteCacheAFn,
    pub SCardWriteCacheW: SCardWriteCacheWFn,
    pub SCardGetReaderIconA: SCardGetReaderIconAFn,
    pub SCardGetReaderIconW: SCardGetReaderIconWFn,
    pub SCardGetDeviceTypeIdA: SCardGetDeviceTypeIdAFn,
    pub SCardGetDeviceTypeIdW: SCardGetDeviceTypeIdWFn,
    pub SCardGetReaderDeviceInstanceIdA: SCardGetReaderDeviceInstanceIdAFn,
    pub SCardGetReaderDeviceInstanceIdW: SCardGetReaderDeviceInstanceIdWFn,
    pub SCardListReadersWithDeviceInstanceIdA: SCardListReadersWithDeviceInstanceIdAFn,
    pub SCardListReadersWithDeviceInstanceIdW: SCardListReadersWithDeviceInstanceIdWFn,
    pub SCardAudit: SCardAuditFn,

    pub g_rgSCardT0Pci: &'static ScardIoRequest,
    pub g_rgSCardT1Pci: &'static ScardIoRequest,
    pub g_rgSCardRawPci: &'static ScardIoRequest,
}

pub type PSCardApiFunctionTable = *mut SCardApiFunctionTable;


--- File: crates/ffi-types/src/winscard/mod.rs ---
pub mod functions;

use crate::common::{Bool, Handle, LpCGuid, LpCStr, LpCWStr, LpStr, LpVoid, LpWStr};

pub type ScardStatus = u32;

pub type ScardContext = usize;
pub type LpScardContext = *mut ScardContext;

pub type ScardHandle = usize;
pub type LpScardHandle = *mut ScardHandle;
pub type Hwnd = Handle;
pub type Hicon = Handle;
// https://docs.rs/winapi/latest/winapi/um/winscard/type.LPOCNCHKPROC.html
pub type LpOcnChkProc = Option<unsafe extern "system" fn(_: ScardContext, _: ScardHandle, _: LpVoid) -> Bool>;
// https://docs.rs/winapi/latest/winapi/um/winscard/type.LPOCNCONNPROCA.html
pub type LpOcnConnProcA =
    Option<unsafe extern "system" fn(_: ScardContext, _: LpStr, _: LpStr, _: LpVoid) -> ScardHandle>;
// https://docs.rs/winapi/latest/winapi/um/winscard/type.LPOCNCONNPROCW.html
pub type LpOcnConnProcW =
    Option<unsafe extern "system" fn(_: ScardContext, _: LpWStr, _: LpWStr, _: LpVoid) -> ScardHandle>;
// https://docs.rs/winapi/latest/winapi/um/winscard/type.LPOCNDSCPROC.html
pub type LpOcnDscProc = Option<unsafe extern "system" fn(_: ScardContext, _: ScardHandle, _: LpVoid)>;

/// [SCARD_READERSTATEA](https://learn.microsoft.com/en-us/windows/win32/api/winscard/ns-winscard-scard_readerstatea)
///
/// ```not_rut
/// typedef struct {
///   LPCSTR szReader;
///   LPVOID pvUserData;
///   DWORD  dwCurrentState;
///   DWORD  dwEventState;
///   DWORD  cbAtr;
///   BYTE   rgbAtr[36];
/// } SCARD_READERSTATEA, *PSCARD_READERSTATEA, *LPSCARD_READERSTATEA;
/// ```
#[repr(C)]
pub struct ScardReaderStateA {
    pub sz_reader: LpCStr,
    pub pv_user_data: LpVoid,
    pub dw_current_state: u32,
    pub dw_event_state: u32,
    pub cb_atr: u32,
    pub rgb_atr: [u8; 36],
}

pub type LpScardReaderStateA = *mut ScardReaderStateA;

/// [SCARD_READERSTATEW](https://learn.microsoft.com/en-us/windows/win32/api/winscard/ns-winscard-scard_readerstatew)
///
/// ```not_rut
/// typedef struct {
///   LPCWSTR szReader;
///   LPVOID pvUserData;
///   DWORD  dwCurrentState;
///   DWORD  dwEventState;
///   DWORD  cbAtr;
///   BYTE   rgbAtr[36];
/// } SCARD_READERSTATEW, *PSCARD_READERSTATEW, *LPSCARD_READERSTATEW;
/// ```
#[derive(Debug)]
#[repr(C)]
pub struct ScardReaderStateW {
    pub sz_reader: LpCWStr,
    pub pv_user_data: LpVoid,
    pub dw_current_state: u32,
    pub dw_event_state: u32,
    pub cb_atr: u32,
    pub rgb_atr: [u8; 36],
}

pub type LpScardReaderStateW = *mut ScardReaderStateW;

/// [SCARD_ATRMASK](https://learn.microsoft.com/en-us/windows/win32/api/winscard/ns-winscard-scard_atrmask)
///
/// ```not_rust
/// typedef struct _SCARD_ATRMASK {
///   DWORD cbAtr;
///   BYTE  rgbAtr[36];
///   BYTE  rgbMask[36];
/// } SCARD_ATRMASK, *PSCARD_ATRMASK, *LPSCARD_ATRMASK;
/// ```
#[repr(C)]
pub struct ScardAtrMask {
    cb_atr: u32,
    rgb_atr: [u8; 36],
    rgb_mask: [u8; 36],
}

pub type LpScardAtrMask = *mut ScardAtrMask;

/// [SCARD_IO_REQUEST](https://learn.microsoft.com/en-us/windows/win32/secauthn/scard-io-request)
///
/// ```not_rust
/// typedef struct {
///   DWORD dwProtocol;
///   DWORD cbPciLength;
/// } SCARD_IO_REQUEST;
/// ```
#[derive(Debug)]
#[repr(C)]
pub struct ScardIoRequest {
    pub dw_protocol: u32,
    pub cb_pci_length: u32,
}

pub type LpScardIoRequest = *mut ScardIoRequest;
pub type LpCScardIoRequest = *const ScardIoRequest;

/// [OPENCARD_SEARCH_CRITERIAA](https://learn.microsoft.com/en-us/windows/win32/api/winscard/ns-winscard-opencard_search_criteriaa)
///
/// ```not_rust
/// typedef struct {
///   DWORD          dwStructSize;
///   LPSTR          lpstrGroupNames;
///   DWORD          nMaxGroupNames;
///   LPCGUID        rgguidInterfaces;
///   DWORD          cguidInterfaces;
///   LPSTR          lpstrCardNames;
///   DWORD          nMaxCardNames;
///   LPOCNCHKPROC   lpfnCheck;
///   LPOCNCONNPROCA lpfnConnect;
///   LPOCNDSCPROC   lpfnDisconnect;
///   LPVOID         pvUserData;
///   DWORD          dwShareMode;
///   DWORD          dwPreferredProtocols;
/// } OPENCARD_SEARCH_CRITERIAA, *POPENCARD_SEARCH_CRITERIAA, *LPOPENCARD_SEARCH_CRITERIAA;
/// ```
#[repr(C)]
pub struct OpenCardSearchCriteriaA {
    dw_struct_size: u32,
    lpstr_group_names: LpStr,
    n_max_group_names: u32,
    rgguid_interfaces: LpCGuid,
    cguid_interfaces: u32,
    lpstr_card_names: LpStr,
    n_max_card_names: u32,
    lpfn_check: LpOcnChkProc,
    lpfn_connect: LpOcnConnProcA,
    lpfn_disconnect: LpOcnChkProc,
    pv_user_data: LpVoid,
    dw_share_mode: u32,
    dw_preferred_protocols: u32,
}

pub type LpOpenCardSearchCriteriaA = *mut OpenCardSearchCriteriaA;

/// [OPENCARD_SEARCH_CRITERIAW](https://learn.microsoft.com/en-us/windows/win32/api/winscard/ns-winscard-opencard_search_criteriaw)
///
/// ```not_rust
/// typedef struct {
///   DWORD          dwStructSize;
///   LPWSTR         lpstrGroupNames;
///   DWORD          nMaxGroupNames;
///   LPCGUID        rgguidInterfaces;
///   DWORD          cguidInterfaces;
///   LPWSTR         lpstrCardNames;
///   DWORD          nMaxCardNames;
///   LPOCNCHKPROC   lpfnCheck;
///   LPOCNCONNPROCW lpfnConnect;
///   LPOCNDSCPROC   lpfnDisconnect;
///   LPVOID         pvUserData;
///   DWORD          dwShareMode;
///   DWORD          dwPreferredProtocols;
/// } OPENCARD_SEARCH_CRITERIAW, *POPENCARD_SEARCH_CRITERIAW, *LPOPENCARD_SEARCH_CRITERIAW;
/// ```
#[repr(C)]
pub struct OpenCardSearchCriteriaW {
    dw_struct_size: u32,
    lpstr_group_names: LpWStr,
    n_max_group_names: u32,
    rgguid_interfaces: LpCGuid,
    cguid_interfaces: u32,
    lpstr_card_names: LpWStr,
    n_max_card_names: u32,
    lpfn_check: LpOcnChkProc,
    lpfn_connect: LpOcnConnProcW,
    lpfn_disconnect: LpOcnChkProc,
    pv_user_data: LpVoid,
    dw_share_mode: u32,
    dw_preferred_protocols: u32,
}

pub type LpOpenCardSearchCriteriaW = *mut OpenCardSearchCriteriaW;

/// [OPENCARDNAME_EXA](https://learn.microsoft.com/en-us/windows/win32/api/winscard/ns-winscard-opencardname_exa)
///
/// ```not_rust
/// typedef struct {
///   DWORD                      dwStructSize;
///   SCARDCONTEXT               hSCardContext;
///   HWND                       hwndOwner;
///   DWORD                      dwFlags;
///   LPCSTR                     lpstrTitle;
///   LPCSTR                     lpstrSearchDesc;
///   HICON                      hIcon;
///   POPENCARD_SEARCH_CRITERIAA pOpenCardSearchCriteria;
///   LPOCNCONNPROCA             lpfnConnect;
///   LPVOID                     pvUserData;
///   DWORD                      dwShareMode;
///   DWORD                      dwPreferredProtocols;
///   LPSTR                      lpstrRdr;
///   DWORD                      nMaxRdr;
///   LPSTR                      lpstrCard;
///   DWORD                      nMaxCard;
///   DWORD                      dwActiveProtocol;
///   SCARDHANDLE                hCardHandle;
/// } OPENCARDNAME_EXA, *POPENCARDNAME_EXA, *LPOPENCARDNAME_EXA;
/// ```
#[repr(C)]
pub struct OpenCardNameExA {
    dw_struct_size: u32,
    h_scard_context: ScardContext,
    hwnd_owner: Hwnd,
    dw_flags: u32,
    lpstr_title: LpCStr,
    lpstr_search_sesc: LpCStr,
    h_icon: Hicon,
    p_open_card_search_criteria: LpOpenCardSearchCriteriaA,
    lpfn_connect: LpOcnConnProcA,
    pv_user_data: LpVoid,
    dw_share_mode: u32,
    dw_preferred_protocols: u32,
    lpstr_rdr: LpStr,
    n_max_rdr: u32,
    lpstr_card: LpStr,
    n_max_card: u32,
    dw_active_protocol: u32,
    h_card_handle: ScardHandle,
}

pub type LpOpenCardNameExA = *mut OpenCardNameExA;

/// [OPENCARDNAME_EXW](https://learn.microsoft.com/en-us/windows/win32/api/winscard/ns-winscard-opencardname_exw)
///
/// ```not_rust
/// typedef struct {
///   DWORD                      dwStructSize;
///   SCARDCONTEXT               hSCardContext;
///   HWND                       hwndOwner;
///   DWORD                      dwFlags;
///   LPCWSTR                    lpstrTitle;
///   LPCWSTR                    lpstrSearchDesc;
///   HICON                      hIcon;
///   POPENCARD_SEARCH_CRITERIAW pOpenCardSearchCriteria;
///   LPOCNCONNPROCW             lpfnConnect;
///   LPVOID                     pvUserData;
///   DWORD                      dwShareMode;
///   DWORD                      dwPreferredProtocols;
///   LPWSTR                     lpstrRdr;
///   DWORD                      nMaxRdr;
///   LPWSTR                     lpstrCard;
///   DWORD                      nMaxCard;
///   DWORD                      dwActiveProtocol;
///   SCARDHANDLE                hCardHandle;
/// } OPENCARDNAME_EXW, *POPENCARDNAME_EXW, *LPOPENCARDNAME_EXW;
/// ```
#[repr(C)]
pub struct OpenCardNameExW {
    dw_struct_size: u32,
    h_scard_context: ScardContext,
    hwnd_owner: Hwnd,
    dw_flags: u32,
    lpstr_title: LpCWStr,
    lpstr_search_sesc: LpCWStr,
    h_icon: Hicon,
    p_open_card_search_criteria: LpOpenCardSearchCriteriaW,
    lpfn_connect: LpOcnConnProcW,
    pv_user_data: LpVoid,
    dw_share_mode: u32,
    dw_preferred_protocols: u32,
    lpstr_rdr: LpStr,
    n_max_rdr: u32,
    lpstr_card: LpStr,
    n_max_card: u32,
    dw_active_protocol: u32,
    h_card_handle: ScardHandle,
}

pub type LpOpenCardNameExW = *mut OpenCardNameExW;

/// [OPENCARDNAMEA](https://learn.microsoft.com/en-us/windows/win32/api/winscard/ns-winscard-opencardnamea)
///
/// ```not_rust
/// typedef struct {
///   DWORD          dwStructSize;
///   HWND           hwndOwner;
///   SCARDCONTEXT   hSCardContext;
///   LPSTR          lpstrGroupNames;
///   DWORD          nMaxGroupNames;
///   LPSTR          lpstrCardNames;
///   DWORD          nMaxCardNames;
///   LPCGUID        rgguidInterfaces;
///   DWORD          cguidInterfaces;
///   LPSTR          lpstrRdr;
///   DWORD          nMaxRdr;
///   LPSTR          lpstrCard;
///   DWORD          nMaxCard;
///   LPCSTR         lpstrTitle;
///   DWORD          dwFlags;
///   LPVOID         pvUserData;
///   DWORD          dwShareMode;
///   DWORD          dwPreferredProtocols;
///   DWORD          dwActiveProtocol;
///   LPOCNCONNPROCA lpfnConnect;
///   LPOCNCHKPROC   lpfnCheck;
///   LPOCNDSCPROC   lpfnDisconnect;
///   SCARDHANDLE    hCardHandle;
/// } OPENCARDNAMEA, *POPENCARDNAMEA, *LPOPENCARDNAMEA;
/// ```
#[repr(C)]
pub struct OpenCardNameA {
    dw_struct_size: u32,
    hwnd_owner: Hwnd,
    h_scard_context: ScardContext,
    lpstr_group_names: LpStr,
    n_max_group_names: u32,
    lpstr_card_names: LpStr,
    n_max_card_names: u32,
    rgguid_interfaces: LpCGuid,
    cguid_interfaces: u32,
    lpstr_rdr: LpStr,
    n_max_rdr: u32,
    lpstr_card: LpStr,
    n_max_card: u32,
    lpstr_title: u32,
    dw_flags: u32,
    pv_user_data: LpVoid,
    dw_share_mode: u32,
    dw_preferred_protocols: u32,
    dw_active_protocol: u32,
    lpfn_connect: LpOcnConnProcA,
    lpfn_check: LpOcnChkProc,
    lpfn_disconnect: LpOcnDscProc,
    h_card_handle: ScardHandle,
}

pub type LpOpenCardNameA = *mut OpenCardNameA;

/// [OPENCARDNAMEW](https://learn.microsoft.com/en-us/windows/win32/api/winscard/ns-winscard-opencardnamew)
///
/// ```not_rust
/// typedef struct {
///   DWORD          dwStructSize;
///   HWND           hwndOwner;
///   SCARDCONTEXT   hSCardContext;
///   LPWSTR         lpstrGroupNames;
///   DWORD          nMaxGroupNames;
///   LPWSTR         lpstrCardNames;
///   DWORD          nMaxCardNames;
///   LPCGUID        rgguidInterfaces;
///   DWORD          cguidInterfaces;
///   LPWSTR         lpstrRdr;
///   DWORD          nMaxRdr;
///   LPWSTR         lpstrCard;
///   DWORD          nMaxCard;
///   LPCWSTR        lpstrTitle;
///   DWORD          dwFlags;
///   LPVOID         pvUserData;
///   DWORD          dwShareMode;
///   DWORD          dwPreferredProtocols;
///   DWORD          dwActiveProtocol;
///   LPOCNCONNPROCW lpfnConnect;
///   LPOCNCHKPROC   lpfnCheck;
///   LPOCNDSCPROC   lpfnDisconnect;
///   SCARDHANDLE    hCardHandle;
/// } OPENCARDNAMEW, *POPENCARDNAMEW, *LPOPENCARDNAMEW;
/// ```
#[repr(C)]
pub struct OpenCardNameW {
    dw_struct_size: u32,
    hwnd_owner: Hwnd,
    h_scard_context: ScardContext,
    lpstr_group_names: LpWStr,
    n_max_group_names: u32,
    lpstr_card_names: LpWStr,
    n_max_card_names: u32,
    rgguid_interfaces: LpCGuid,
    cguid_interfaces: u32,
    lpstr_rdr: LpStr,
    n_max_rdr: u32,
    lpstr_card: LpStr,
    n_max_card: u32,
    lpstr_title: u32,
    dw_flags: u32,
    pv_user_data: LpVoid,
    dw_share_mode: u32,
    dw_preferred_protocols: u32,
    dw_active_protocol: u32,
    lpfn_connect: LpOcnConnProcW,
    lpfn_check: LpOcnChkProc,
    lpfn_disconnect: LpOcnDscProc,
    h_card_handle: ScardHandle,
}

pub type LpOpenCardNameW = *mut OpenCardNameW;


--- File: crates/winscard/CHANGELOG.md ---
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).


## [[0.2.2](https://github.com/Devolutions/sspi-rs/compare/winscard-v0.2.1...winscard-v0.2.2)] - 2025-08-26

### <!-- 4 -->Bug Fixes

- Incorrect `SCARD_IO_REQUEST` usage (#487) ([7e23472a7a](https://github.com/Devolutions/sspi-rs/commit/7e23472a7af347460a89379f28dc56701f7be97e)) 

  Fixes incorrect [`SCARD_IO_REQUEST`](https://learn.microsoft.com/en-us/windows/win32/secauthn/scard-io-request) usage.


--- File: crates/winscard/Cargo.toml ---
[package]
name = "winscard"
version = "0.2.2"
edition = "2021"
readme = "README.md"
license = "MIT/Apache-2.0"
homepage = "https://github.com/devolutions/sspi-rs"
repository = "https://github.com/devolutions/sspi-rs"
authors = ["Devolutions Inc. <infos@devolutions.net>"]
description = "A Rust implementation of WinSCard"

[features]
std = ["tracing/std", "base64", "picky-asn1-der"]

[lib]
name = "winscard"

[dependencies]
bitflags.workspace = true
iso7816 = "0.1"
iso7816-tlv = "0.4"
picky = { workspace = true, features = ["x509"] }
picky-asn1-x509.workspace = true
tracing = { workspace = true, features = ["attributes"] }
time = { workspace = true, features = [
    "formatting",
] }
uuid = { workspace = true, features = ["v4"] }
flate2 = { version = "1.1", features = ["zlib", "rust_backend"], default-features = false }
rsa = { workspace = true, features = ["hazmat", "sha1"] }
rand_core = "0.6"
sha1.workspace = true
base64 = { workspace = true , optional = true }
picky-asn1-der = { workspace = true, optional = true }
num-derive.workspace = true
num-traits.workspace = true

[dev-dependencies]
proptest.workspace = true
rand.workspace = true

[lints]
workspace = true


--- File: crates/winscard/README.md ---
# winscard-rs


--- File: crates/winscard/assets/reader_icon.bmp ---
[Binary file: content not included]

--- File: crates/winscard/src/ber_tlv.rs ---
use alloc::vec;
use alloc::vec::Vec;

/// Encodes the length in BER encoding.
pub fn ber_tlv_length_encoding(length: usize) -> Vec<u8> {
    // ISO/IEC 7816-4, Section 5.2.2.2
    if length <= 0x7F {
        // length consists of 1 byte
        vec![length.try_into().unwrap()]
    } else {
        // if the length is > 0x7F, it consists of N consecutive bytes, where N is the first 7 lower bits of the first byte in the sequence
        let mut len_bytes: Vec<_> = length.to_be_bytes().into_iter().skip_while(|x| *x == 0).collect();
        // add the first byte that indicates how many consecutive bytes represent the object's actual length
        len_bytes.insert(
            0,
            0x80 | u8::try_from(len_bytes.len()).expect("length bytes amount < u8::MAX"),
        );
        len_bytes
    }
}


--- File: crates/winscard/src/card_capability_container.rs ---
use alloc::vec::Vec;

use crate::tlv_tags;

// ccc - Card Capability Container
// Table 8. Card Capability Container
// https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-73-4.pdf#page=39
pub fn build_ccc() -> Vec<u8> {
    let mut ccc = Vec::new();

    ccc.extend_from_slice(&[tlv_tags::DATA, 0x33]);

    // Card Identifier
    ccc.extend_from_slice(&[
        0xf0, 21, 160, 0, 0, 1, 22, 255, 2, 62, 243, 197, 122, 122, 55, 197, 117, 56, 169, 61, 186, 177, 253,
    ]);
    // Capability Container version number
    ccc.extend_from_slice(&[0xf1, 0x01, 0x21]);
    // Capability Grammar version number
    ccc.extend_from_slice(&[0xf2, 0x01, 0x21]);
    // Applications CardURL
    ccc.extend_from_slice(&[0xf3, 0x00]);
    // PKCS#15
    ccc.extend_from_slice(&[0xf4, 0x01, 0x00]);
    // Registered Data Model number
    ccc.extend_from_slice(&[0xf5, 0x01, 0x10]);
    // Access Control Rule Table
    ccc.extend_from_slice(&[0xf6, 0x00]);
    // Card APDUs
    ccc.extend_from_slice(&[0xf7, 0x00]);
    // Redirection Tag
    ccc.extend_from_slice(&[0xfa, 0x00]);
    // Capability Tuples (CTs)
    ccc.extend_from_slice(&[0xfb, 0x00]);
    // Status Tuples (STs)
    ccc.extend_from_slice(&[0xfc, 0x00]);
    // Next CCC
    ccc.extend_from_slice(&[0xfd, 0x00]);
    // Error Detection Code
    ccc.extend_from_slice(&[0xfe, 0x00]);

    ccc
}


--- File: crates/winscard/src/chuid.rs ---
use alloc::format;
use alloc::vec::Vec;

use time::{format_description, Duration, OffsetDateTime};
use uuid::Uuid;

use crate::{tlv_tags, Error, ErrorKind, WinScardResult};

// CHUID will always have a fixed length when excluding optional fields and asymmetric signature
pub const CHUID_LENGTH: usize = 61;

// The CHUID has to be encoded manually because for some weird reason all nested tags use the SIMPLE-TLV encoding.
// This makes it impossible to encode this particular object using iso7816_tlv crate (or any other BER-TLV crate out there)
pub(crate) fn build_chuid() -> WinScardResult<[u8; CHUID_LENGTH]> {
    // We do this by hand, because iso7816_tlv uses Vecs when constructing a new TLV value
    // By avoiding using Tlv::new(), we can avoid allocating a new Vec for each TLV value and use slices instead
    let mut chuid = Vec::with_capacity(CHUID_LENGTH);
    let data_length = 0x3B;
    chuid.extend_from_slice(&[tlv_tags::DATA, data_length]);
    let fasc_n_length = 0x19;
    chuid.extend_from_slice(&[tlv_tags::FASC_N, fasc_n_length]);
    // The FASC-N number is encoded using the BCD 4-Bit decimal format with odd parity as per https://www.idmanagement.gov/docs/pacs-tig-scepacs.pdf
    // The unencoded value is (whitespaces were added for readability): SS 9999 FS 9999 FS 999999 FS 0 FS 1 FS 0000000000 3 0000 1 ES LRC
    // The Agency Code is set to 9999 as stated in section 6.4
    // The system code and credential number can both be set to any number
    chuid.extend_from_slice(&[
        0xd4, 0xe7, 0x39, 0xda, 0x73, 0x9c, 0xed, 0x39, 0xce, 0x73, 0x9d, 0x83, 0x68, 0x58, 0x21, 0x08, 0x42, 0x10,
        0x84, 0x21, 0xc8, 0x42, 0x10, 0xc3, 0xeb,
    ]);
    let guid_length = 0x10;
    chuid.extend_from_slice(&[tlv_tags::GUID, guid_length]);
    // Section 3.4.1 of https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-73-4.pdf
    let uuid = Uuid::new_v4();
    chuid.extend_from_slice(uuid.as_bytes());
    let expiration_date_length = 0x8;
    chuid.extend_from_slice(&[tlv_tags::EXPIRATION_DATE, expiration_date_length]);
    // Section 3.1.2 of https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-73-4.pdf
    let year_from_today = OffsetDateTime::now_utc() + Duration::weeks(48);
    let expiration_date_format = format_description::parse("[year][month][day]").map_err(|e| {
        Error::new(
            ErrorKind::InternalError,
            format!("error while trying to parse the date format: {}", e),
        )
    })?;
    let expiration_date = year_from_today.format(&expiration_date_format).map_err(|e| {
        Error::new(
            ErrorKind::InternalError,
            format!("error while trying to format a date: {}", e),
        )
    })?;
    chuid.extend_from_slice(expiration_date.as_bytes());
    // both ISSUER_SIGNATURE and EDC don't have any value and both have a length of 0
    chuid.extend_from_slice(&[tlv_tags::ISSUER_SIGNATURE, 0x0]);
    chuid.extend_from_slice(&[tlv_tags::ERROR_DETECTION_CODE, 0x0]);
    // won't fail, as chuid is of fixed length
    Ok(chuid.try_into().unwrap())
}


--- File: crates/winscard/src/compression.rs ---
use alloc::format;
use alloc::vec::Vec;

use flate2::{Compress, Compression, FlushCompress, Status};

use crate::{Error, ErrorKind, WinScardResult};

// This function compresses the user-der-encoded certificate using the Zlib algorithm from the flate2 crate.
// We need to compress the certificate before storing it in the smart card cache.
// The resulting array slice corresponds to the compressed certificate in the buffer.
pub fn compress_cert<'c>(cert: &'_ [u8], buff: &'c mut Vec<u8>) -> WinScardResult<&'c [u8]> {
    let mut data_to_compress = cert;
    let mut total_written = 0;

    let mut compressor = Compress::new(Compression::fast(), /* zlib header */ true);

    loop {
        let read_before = compressor.total_in() as usize;
        let written_before = compressor.total_out() as usize;

        let status = compressor
            .compress(data_to_compress, &mut buff[total_written..], FlushCompress::Finish)
            .map_err(|err| {
                Error::new(
                    ErrorKind::InternalError,
                    format!("can not compress sc certificate: {:?}", err),
                )
            })?;

        let read_after = compressor.total_in() as usize;
        let written_after = compressor.total_out() as usize;

        let read_len = read_after - read_before;
        let written_len = written_after - written_before;

        total_written += written_len;
        data_to_compress = &data_to_compress[read_len..];

        match status {
            Status::BufError => {
                // This case should never happen because usually, buff len is equal to the uncompressed data len.
                // But we check it just in case.
                let len = buff.len();
                buff.resize(len * 2, 0);
            }
            Status::StreamEnd => break,
            Status::Ok => {}
        }
    }

    Ok(&buff[0..total_written])
}


--- File: crates/winscard/src/dummy_rng.rs ---
use rand_core::{CryptoRng, Error, RngCore};

// We use this generator only as a type parameter for the `rsa::hazmat::rsa_decrypt_and_check` function.
pub struct Dummy;

impl RngCore for Dummy {
    fn next_u32(&mut self) -> u32 {
        0
    }

    fn next_u64(&mut self) -> u64 {
        0
    }

    fn fill_bytes(&mut self, _: &mut [u8]) {}

    fn try_fill_bytes(&mut self, _: &mut [u8]) -> Result<(), Error> {
        Ok(())
    }
}

impl CryptoRng for Dummy {}


--- File: crates/winscard/src/env.rs ---
use std::fs;

use picky::key::PrivateKey;
use picky::x509::Cert;

use crate::{Error, ErrorKind, WinScardResult};

/// Emulated smart card PIN code.
pub const WINSCARD_PIN_ENV: &str = "WINSCARD_SMARTCARD_PIN";
/// Path to the user certificate to be used in emulated smart card.
pub const WINSCARD_CERT_PATH_ENV: &str = "WINSCARD_CERTIFICATE_FILE_PATH";
/// Smart card certificate data.
///
/// *Note.* The variable value should be one-line base64 string containing ASN1 DER certificate data.
pub const WINSCARD_CERT_DATA_ENV: &str = "WINSCARD_CERTIFICATE_FILE_DATA";
/// Path to the certificate private key.
pub const WINSCARD_PK_PATH_ENV: &str = "WINSCARD_PRIVATE_KEY_FILE_PATH";
/// Smart card private key data.
///
/// *Note.* The variable value should be one-line base64 string containing ASN1 DER private key.
pub const WINSCARD_PK_DATA_ENV: &str = "WINSCARD_PRIVATE_KEY_FILE_DATA";
/// Emulated smart card container name.
pub const WINSCARD_CONTAINER_NAME_ENV: &str = "WINSCARD_SMARTCARD_CONTAINER_NAME";
/// Emulated smart card reader name.
pub const WINSCARD_READER_NAME_ENV: &str = "WINSCARD_SMARTCARD_READER_NAME";

/// Tries to get the smart card container name from the environment variable.
///
/// For the successful execution, the [WINSCARD_CONTAINER_NAME_ENV] variable should be set.
pub fn container_name() -> WinScardResult<String> {
    env!(WINSCARD_CONTAINER_NAME_ENV)
}

/// Tries to read the smart card auth certificate from the environment variable.
///
/// For the successful execution, either [WINSCARD_CERT_DATA_ENV] or [WINSCARD_CERT_PATH_ENV] variable should be set.
pub fn auth_cert_from_env() -> WinScardResult<Cert> {
    if let Ok(cert_data) = env!(WINSCARD_CERT_DATA_ENV) {
        use base64::Engine;

        let cert_der = base64::engine::general_purpose::STANDARD.decode(cert_data)?;

        Ok(Cert::from_der(&cert_der)?)
    } else if let Ok(cert_path) = env!(WINSCARD_CERT_PATH_ENV) {
        let raw_certificate = fs::read_to_string(cert_path).map_err(|e| {
            Error::new(
                ErrorKind::InvalidParameter,
                format!("Unable to read certificate from the provided file: {}", e),
            )
        })?;
        Ok(Cert::from_pem_str(&raw_certificate)?)
    } else {
        return Err(Error::new(
            ErrorKind::InvalidParameter,
            format!(
                "Either \"{}\" or \"{}\" environment variable must be present",
                WINSCARD_CERT_DATA_ENV, WINSCARD_CERT_PATH_ENV
            ),
        ));
    }
}

/// Tries to read the smart card certificate private key from the environment variable.
///
/// For the successful execution, either [WINSCARD_PK_DATA_ENV] or [WINSCARD_PK_PATH_ENV] variable should be set.
pub fn private_key_from_env() -> WinScardResult<(String, PrivateKey)> {
    if let Ok(private_key_data) = env!(WINSCARD_PK_DATA_ENV) {
        use base64::Engine;

        let private_key_der = base64::engine::general_purpose::STANDARD.decode(private_key_data)?;

        let private_key = PrivateKey::from_pkcs8(&private_key_der)?;
        let raw_private_key = private_key.to_pem_str()?;

        Ok((raw_private_key, private_key))
    } else if let Ok(pk_path) = env!(WINSCARD_PK_PATH_ENV) {
        let raw_private_key = fs::read_to_string(pk_path).map_err(|e| {
            Error::new(
                ErrorKind::InvalidParameter,
                format!("Unable to read private key from the provided file: {}", e),
            )
        })?;
        let private_key = PrivateKey::from_pem_str(&raw_private_key).map_err(|e| {
            Error::new(
                ErrorKind::InvalidParameter,
                format!(
                    "Error while trying to read a private key from a pem-encoded string: {}",
                    e
                ),
            )
        })?;

        Ok((raw_private_key, private_key))
    } else {
        return Err(Error::new(
            ErrorKind::InvalidParameter,
            format!(
                "Either \"{}\" or \"{}\" environment variable must be present",
                WINSCARD_PK_DATA_ENV, WINSCARD_PK_PATH_ENV
            ),
        ));
    }
}


--- File: crates/winscard/src/lib.rs ---
#![cfg_attr(not(feature = "std"), no_std)]
#![warn(missing_docs)]
#![doc = include_str!("../README.md")]

#[macro_use]
extern crate tracing;

#[macro_use]
mod macros;

mod ber_tlv;
mod card_capability_container;
mod chuid;
mod compression;
mod dummy_rng;
/// Contains env variables names that represent smart card credentials.
#[cfg(feature = "std")]
pub mod env;
mod piv_cert;
mod scard;
mod scard_context;
/// Constants with most popular tags used in this PIV smart card implementation.
pub mod tlv_tags;
/// The [winscard] module contains traits for easier interop between WinSCard API and our emulated scard.
pub mod winscard;

extern crate alloc;

use alloc::format;
use alloc::string::String;
use alloc::vec::Vec;
use core::num::TryFromIntError;
use core::{fmt, result};

pub use ber_tlv::ber_tlv_length_encoding;
use iso7816_tlv::TlvError;
use num_derive::{FromPrimitive, ToPrimitive};
use picky::key::KeyError;
use picky::x509::certificate::CertError;
pub use scard::{SmartCard, ATR, CHUNK_SIZE, PIV_AID, SUPPORTED_CONNECTION_PROTOCOL};
pub use scard_context::{
    Reader, ScardContext, SmartCardInfo, DEFAULT_CARD_NAME, MICROSOFT_DEFAULT_CSP, MICROSOFT_DEFAULT_KSP,
    MICROSOFT_SCARD_DRIVER_LOCATION,
};

/// The [WinScardResult] type.
pub type WinScardResult<T> = result::Result<T, Error>;

/// Represents a response after the APDU command execution.
#[derive(Debug)]
pub struct Response {
    /// Resulting APDU status.
    pub status: Status,
    /// Output APDU.
    pub data: Option<Vec<u8>>,
}

impl Response {
    /// Creates a new [Response] based on the `status` and `data`.
    pub fn new(status: Status, data: Option<Vec<u8>>) -> Self {
        Response { status, data }
    }
}

impl From<Status> for Response {
    fn from(value: Status) -> Self {
        Response::new(value, None)
    }
}

impl From<Response> for Vec<u8> {
    fn from(value: Response) -> Self {
        let status_as_bytes: [u8; 2] = value.status.into();
        let vec_capacity = status_as_bytes.len() + value.data.as_ref().map(|data| data.len()).unwrap_or(0);
        let mut encoded: Vec<u8> = Vec::with_capacity(vec_capacity);
        if let Some(bytes) = value.data {
            encoded.extend(bytes);
        }
        encoded.extend(status_as_bytes);
        encoded
    }
}

/// Represents general WinSCard error.
#[derive(Debug)]
pub struct Error {
    /// Represents on the defined [Smart Card Return Values](https://learn.microsoft.com/en-us/windows/win32/secauthn/authentication-return-values).
    pub error_kind: ErrorKind,
    /// Additional error description.
    pub description: String,
}

impl Error {
    /// Creates a new [Error] based on the `error_kind` and `description`.
    pub fn new(error_kind: ErrorKind, description: impl Into<String>) -> Self {
        Error {
            error_kind,
            description: description.into(),
        }
    }
}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Error{{ {:?}: {} }}", self.error_kind, self.description)?;
        Ok(())
    }
}

#[cfg(feature = "std")]
impl std::error::Error for Error {}

#[cfg(feature = "std")]
impl From<picky_asn1_der::Asn1DerError> for Error {
    fn from(value: picky_asn1_der::Asn1DerError) -> Self {
        Self::new(ErrorKind::InvalidValue, value.to_string())
    }
}

#[cfg(feature = "std")]
impl From<base64::DecodeError> for Error {
    fn from(value: base64::DecodeError) -> Self {
        Self::new(ErrorKind::InvalidValue, value.to_string())
    }
}

impl From<KeyError> for Error {
    fn from(value: KeyError) -> Self {
        Error::new(
            ErrorKind::InternalError,
            format!("error: an unexpected KeyError happened: {}", value),
        )
    }
}

impl From<rsa::Error> for Error {
    fn from(value: rsa::Error) -> Self {
        Error::new(
            ErrorKind::InternalError,
            format!("Error: an unexpected RsaError happened: {}", value),
        )
    }
}

impl From<TlvError> for Error {
    fn from(value: TlvError) -> Self {
        Error::new(
            ErrorKind::InternalError,
            format!("error: an unexpected TlvError happened: {}", value),
        )
    }
}

impl From<TryFromIntError> for Error {
    fn from(value: TryFromIntError) -> Self {
        Error::new(
            ErrorKind::InsufficientBuffer,
            format!("error: can not convert integers: {}", value),
        )
    }
}

impl From<CertError> for Error {
    fn from(value: CertError) -> Self {
        Error::new(ErrorKind::InsufficientBuffer, format!("certificate error: {}", value))
    }
}

impl From<core::convert::Infallible> for Error {
    fn from(_: core::convert::Infallible) -> Self {
        Error::new(ErrorKind::InternalError, "Infallible")
    }
}

impl From<core::str::Utf8Error> for Error {
    fn from(value: core::str::Utf8Error) -> Self {
        #[cfg(not(feature = "std"))]
        use alloc::string::ToString;

        Error::new(ErrorKind::InternalError, value.to_string())
    }
}

#[cfg(feature = "std")]
impl From<std::ffi::NulError> for Error {
    fn from(value: std::ffi::NulError) -> Self {
        Error::new(ErrorKind::InvalidParameter, value.to_string())
    }
}

/// [Smart Card Return Values](https://learn.microsoft.com/en-us/windows/win32/secauthn/authentication-return-values).
#[derive(Debug, PartialEq, ToPrimitive, FromPrimitive)]
#[repr(u32)]
pub enum ErrorKind {
    /// The client attempted a smart card operation in a remote session, such as a client session running on a terminal server,
    /// and the operating system in use does not support smart card redirection.
    BrokenPipe = 0x00000109,
    /// An error occurred in setting the smart card file object pointer.
    BadSeek = 0x80100029,
    /// The action was canceled by an SCardCancel request.
    Canceled = 0x80100002,
    /// The system could not dispose of the media in the requested manner.
    CantDispose = 0x8010000E,
    /// The smart card does not meet minimal requirements for support.
    CardUnsupported = 0x8010001C,
    /// The requested certificate could not be obtained.
    CertificateUnavailable = 0x8010002D,
    /// A communications error with the smart card has been detected.
    CommDataLost = 0x8010002F,
    /// The specified directory does not exist in the smart card.
    DirNotFound = 0x80100023,
    /// The reader driver did not produce a unique reader name.
    DuplicateReader = 0x8010001B,
    /// The specified file does not exist in the smart card.
    FileNotFound = 0x80100024,
    /// The requested order of object creation is not supported.
    IccCreateOrder = 0x80100021,
    /// No primary provider can be found for the smart card.
    IccInstallation = 0x80100020,
    /// The data buffer for returned data is too small for the returned data.
    InsufficientBuffer = 0x80100008,
    /// An ATR string obtained from the registry is not a valid ATR string.
    InvalidAtr = 0x80100015,
    /// The supplied PIN is incorrect.
    InvalidChv = 0x8010002A,
    /// The supplied handle was not valid.
    InvalidHandle = 0x80100003,
    /// One or more of the supplied parameters could not be properly interpreted.
    InvalidParameter = 0x80100004,
    /// Registry startup information is missing or not valid.
    InvalidTarget = 0x80100005,
    /// One or more of the supplied parameter values could not be properly interpreted.
    InvalidValue = 0x80100011,
    /// Access is denied to the file.
    NoAccess = 0x80100027,
    /// The supplied path does not represent a smart card directory.
    NoDir = 0x80100025,
    /// The supplied path does not represent a smart card file.
    NoFile = 0x80100026,
    /// The requested key container does not exist on the smart card.
    NoKeyContainer = 0x80100030,
    /// Not enough memory available to complete this command.
    NoMemory = 0x80100006,
    /// The smart card PIN cannot be cached.
    NoPinCache = 0x80100033,
    /// No smart card reader is available.
    NoReadersAvailable = 0x8010002E,
    /// The smart card resource manager is not running.
    NoService = 0x8010001D,
    /// The operation requires a smart card, but no smart card is currently in the device.
    NoSmartCard = 0x8010000C,
    /// The requested certificate does not exist.
    NoSuchCertificate = 0x8010002C,
    /// The reader or card is not ready to accept commands.
    NotReady = 0x80100010,
    /// An attempt was made to end a nonexistent transaction.
    NotTransacted = 0x80100016,
    /// The PCI receive buffer was too small.
    PciTooSmall = 0x80100019,
    /// The smart card PIN cache has expired.
    PinCacheExpired = 0x80100032,
    /// The requested protocols are incompatible with the protocol currently in use with the card.
    ProtoMismatch = 0x8010000F,
    /// The smart card is read-only and cannot be written to.
    ReadOnlyCard = 0x80100034,
    /// The specified reader is not currently available for use.
    ReaderUnavailable = 0x80100017,
    /// The reader driver does not meet minimal requirements for support.
    ReaderUnsupported = 0x8010001A,
    /// The smart card resource manager is too busy to complete this operation.
    ServerTooBusy = 0x80100031,
    /// The smart card resource manager has shut down.
    ServiceStopped = 0x8010001E,
    /// The smart card cannot be accessed because of other outstanding connections.
    SharingViolation = 0x8010000B,
    /// The action was canceled by the system, presumably to log off or shut down.
    SystemCanceled = 0x80100012,
    /// The user-specified time-out value has expired.
    Timeout = 0x8010000A,
    /// An unexpected card error has occurred.
    Unexpected = 0x8010001F,
    /// The specified smart card name is not recognized.
    UnknownCard = 0x8010000D,
    /// The specified reader name is not recognized.
    UnknownReader = 0x80100009,
    /// An unrecognized error code was returned.
    UnknownResMng = 0x8010002B,
    /// This smart card does not support the requested feature.
    UnsupportedFeature = 0x80100022,
    /// An attempt was made to write more data than would fit in the target object.
    WriteTooMany = 0x80100028,
    /// An internal communications error has been detected.
    CommError = 0x80100013,
    /// An internal consistency check failed.
    InternalError = 0x80100001,
    /// An internal error has been detected, but the source is unknown.
    UnknownError = 0x80100014,
    /// An internal consistency timer has expired.
    WaitedTooLong = 0x80100007,
    /// The operation has been aborted to allow the server application to exit.
    Shutdown = 0x80100018,
    /// No error was encountered.
    Success = 0,
    /// The action was canceled by the user.
    CanceledByUser = 0x8010006E,
    /// The requested item could not be found in the cache.
    CacheItemNotFound = 0x80100070,
    /// The requested cache item is too old and was deleted from the cache.
    CacheItemStale = 0x80100071,
    /// The new cache item exceeds the maximum per-item size defined for the cache.
    CacheItemTooBig = 0x80100072,
    /// No PIN was presented to the smart card.
    CardNotAuthenticated = 0x8010006F,
    /// The card cannot be accessed because the maximum number of PIN entry attempts has been reached.
    ChvBlocked = 0x8010006C,
    /// The end of the smart card file has been reached.
    Eof = 0x8010006D,
    /// The smart card has been removed, so further communication is not possible.
    RemovedCard = 0x80100069,
    /// The smart card was reset.
    ResetCard = 0x80100068,
    /// Access was denied because of a security violation.
    SecurityViolation = 0x8010006A,
    /// Power has been removed from the smart card, so that further communication is not possible.
    UnpoweredCard = 0x80100067,
    /// The smart card is not responding to a reset.
    UnresponsiveCard = 0x80100066,
    /// The reader cannot communicate with the card, due to ATR string configuration conflicts.
    UnsupportedCard = 0x80100065,
    /// The card cannot be accessed because the wrong PIN was presented.
    WrongChv = 0x8010006B,
}

impl From<ErrorKind> for u32 {
    fn from(value: ErrorKind) -> Self {
        value as u32
    }
}

/// Represents Status Word (SW) - a 2-byte value returned by a card command at the card edge.
/// [Table 6. Status Words](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-73-4.pdf#page=36)
#[derive(Debug, Clone, PartialEq)]
pub enum Status {
    /// Data object or application not found.
    NotFound,
    /// Successful execution.
    OK,
    /// Verification failed, X indicates the number of further allowed retries or resets.
    /// Number of allowed retries is always 9.
    VerificationFailedWithRetries,
    /// Successful execution where SW2 encodes the number of response data bytes still available.
    MoreAvailable(u8),
    /// Referenced data or reference data not found.
    KeyReferenceNotFound,
    /// Security status not satisfied.
    SecurityStatusNotSatisfied,
    /// Incorrect parameter in P1 or P2.
    IncorrectP1orP2,
    /// Incorrect parameter in command data field.
    IncorrectDataField,
    /// Instruction code not supported or invalid.
    InstructionNotSupported,
}

// ISO/IEC 7816-4, Section 5.1.3, Tables 5-6
impl From<Status> for [u8; 2] {
    fn from(value: Status) -> Self {
        match value {
            Status::NotFound => [0x6A, 0x82],
            Status::OK => [0x90, 0x00],
            Status::VerificationFailedWithRetries => [0x63, 0xC9],
            Status::MoreAvailable(bytes_left) => [0x61, bytes_left],
            Status::KeyReferenceNotFound => [0x6A, 0x88],
            Status::SecurityStatusNotSatisfied => [0x69, 0x82],
            Status::IncorrectP1orP2 => [0x6A, 0x86],
            Status::IncorrectDataField => [0x6A, 0x80],
            Status::InstructionNotSupported => [0x6D, 0x00],
        }
    }
}


--- File: crates/winscard/src/macros.rs ---
#[cfg(feature = "std")]
macro_rules! env {
    ($name:expr) => {{
        std::env::var($name).map_err(|_| {
            crate::Error::new(
                crate::ErrorKind::InvalidParameter,
                format!("The {} env var is not present or invalid", $name),
            )
        })
    }};
}


--- File: crates/winscard/src/piv_cert.rs ---
use alloc::vec::Vec;

use iso7816_tlv::simple::{Tag, Tlv};

use crate::ber_tlv::ber_tlv_length_encoding;
use crate::{tlv_tags, WinScardResult};

// The X.509 Certificate for PIV Authentication has to be encoded manually because for some weird reason all nested tags use the SIMPLE-TLV encoding.
// This makes it impossible to encode this particular object using iso7816_tlv crate (or any other BER-TLV crate out there)
pub(crate) fn build_auth_cert(auth_cert: Vec<u8>) -> WinScardResult<Vec<u8>> {
    // SIMPLE-TLV encoding
    // We do use Tlv::new() here to avoid calculating SIMPLE-TLV length ourselves (as a certificate is most certainly > 254 bytes in length)
    let certificate = Tlv::new(Tag::try_from(tlv_tags::CERTIFICATE)?, auth_cert)?.to_vec();
    let cert_info_length = 0x01;
    // 0x00 indicates that the certificate is uncompressed
    // NIST.SP.800-73-4, Part 1, Appendix A, table 39
    let cert_info_value = 0x00;
    let cert_info = &[tlv_tags::CERT_INFO, cert_info_length, cert_info_value];
    // NIST.SP.800-73-4, Part 1, Appendix A, table 10
    let edc_length = 0x00;
    let edc = &[tlv_tags::ERROR_DETECTION_CODE, edc_length];
    let data_value_len = certificate.len() + cert_info.len() + edc.len();
    // BER-TLV encoding of the data_value_len
    let encoded_data_value_len = ber_tlv_length_encoding(data_value_len);
    let mut result: Vec<u8> = Vec::with_capacity(1 + encoded_data_value_len.len() + data_value_len);
    result.extend_from_slice(&[tlv_tags::DATA]);
    result.extend_from_slice(&encoded_data_value_len);
    result.extend_from_slice(&certificate);
    result.extend_from_slice(cert_info);
    result.extend_from_slice(edc);
    Ok(result)
}


--- File: crates/winscard/src/scard.rs ---
use alloc::borrow::Cow;
use alloc::collections::BTreeMap;
use alloc::string::ToString;
use alloc::vec::Vec;
use alloc::{format, vec};

use iso7816::{Aid, Command, Instruction};
use iso7816_tlv::ber::{Tag, Tlv, Value};
use picky::key::PrivateKey;
use rsa::traits::PublicKeyParts;
use rsa::{Pkcs1v15Sign, RsaPrivateKey};
use sha1::Sha1;

use crate::card_capability_container::build_ccc;
use crate::chuid::{build_chuid, CHUID_LENGTH};
use crate::piv_cert::build_auth_cert;
use crate::winscard::{AttributeId, ControlCode, Protocol, ReaderAction, ShareMode, TransmitOutData, WinScard};
use crate::{tlv_tags, winscard, Error, ErrorKind, Response, Status, WinScardResult};

/// [NIST.SP.800-73-4, part 1, section 2.2](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-73-4.pdf#page=16).
pub const PIV_AID: Aid = Aid::new_truncatable(&[0xA0, 0x00, 0x00, 0x03, 0x08, 0x00, 0x00, 0x10, 0x00, 0x01, 0x00], 9);
/// The max amount of data one APDU response can transmit.
pub const CHUNK_SIZE: usize = 256;
// NIST.SP.800-73-4, part 1, section 4.3, Table 3
const CARD_AUTH_CERT_TAG: &[u8] = &[0x5F, 0xC1, 0x01];
// NIST.SP.800-73-4, part 1, section 4.3, Table 3
const CHUID_TAG: &[u8] = &[0x5F, 0xC1, 0x02];
// NIST.SP.800-73-4, part 1, section 4.3, Table 3
const PIV_CERT_TAG: &[u8] = &[0x5F, 0xC1, 0x05];
// NIST.SP.800-73-4, part 1, section 4.3, Table 3
const CARD_CAPABILITY_CONTAINER_TAG: &[u8] = &[0x5F, 0xC1, 0x07];
// NIST.SP.800-73-4, part 1, section 4.3, Table 3
const DIGITAL_SIGNATURE_CERT_TAG: &[u8] = &[0x5F, 0xC1, 0x0A];
// NIST.SP.800-73-4, part 1, section 4.3, Table 3
const KEY_MANAGEMENT_CERT_TAG: &[u8] = &[0x5F, 0xC1, 0x0B];
// NIST.SP.800-73-4 part 2, section 2.4.3
const PIN_LENGTH_RANGE_LOW_BOUND: usize = 6;
// NIST.SP.800-73-4 part 2, section 2.4.3
const PIN_LENGTH_RANGE_HIGH_BOUND: usize = 8;
/// Supported connection protocol in emulated smart cards.
///
/// We are always using the T1 protocol as the original Windows TPM smart card does
pub const SUPPORTED_CONNECTION_PROTOCOL: Protocol = Protocol::T1;
// Only one supported control code.
// `#define CM_IOCTL_GET_FEATURE_REQUEST SCARD_CTL_CODE(3400)`
// Request features described in the *PC/SC 2.0 Specification Part 10*
const IO_CTL: u32 = 0x00313520;

/// The original winscard ATR is not suitable because it contains AID bytes.
/// So we need to construct our own. Read more about our constructed ATR string:
/// <https://smartcard-atr.apdu.fr/parse?ATR=3B+8D+01+80+FB+A0+00+00+03+08+00+00+10+00+01+00+4D>
#[rustfmt::skip]
pub const ATR: [u8; 17] = [
    // TS. Direct Convention
    0x3b,
    // T0. Y(1): b1000, K: 13 (historical bytes)
    0x8d,
    // TD. Y(i+1) = b0000, Protocol T=1
    0x01,
    // Historical bytes
    0x80,
    // Tag: 15, Len: 11.
    0xfb,
    // PIV AID
    0xa0, 0x00, 0x00, 0x03, 0x08, 0x00, 0x00, 0x10, 0x00, 0x01, 0x00,
    // TCK (Checksum)
    0x4d,
];

/// Emulated smart card.
///
/// Currently, we support one key container per smart card.
#[derive(Debug, Clone)]
pub struct SmartCard<'a> {
    reader_name: Cow<'a, str>,
    chuid: [u8; CHUID_LENGTH],
    ccc: Vec<u8>,
    pin: Vec<u8>,
    auth_cert: Vec<u8>,
    auth_pk: PrivateKey,
    state: SCardState,
    // We don't need to track actual transactions for the emulated smart card.
    // We are using this flag to track incorrect smart card usage.
    transaction: bool,
    pending_command: Option<Command<1024>>,
    pending_response: Option<Vec<u8>>,
    // We keep it just for compatibility reasons with WinSCard API.
    // Usually, the mstsc.exe doesn't use scard attributes for connection establishing.
    attributes: BTreeMap<AttributeId, Cow<'a, [u8]>>,
}

impl SmartCard<'_> {
    /// Creates a smart card instance based on the provided data.
    pub fn new(
        reader_name: Cow<str>,
        pin: Vec<u8>,
        auth_cert_der: Vec<u8>,
        auth_pk: PrivateKey,
    ) -> WinScardResult<SmartCard<'_>> {
        let chuid = build_chuid()?;
        let auth_cert = build_auth_cert(auth_cert_der)?;

        Ok(SmartCard {
            reader_name,
            chuid,
            ccc: build_ccc(),
            pin: SmartCard::validate_and_pad_pin(pin)?,
            auth_cert,
            auth_pk,
            state: SCardState::Ready,
            transaction: false,
            pending_command: None,
            pending_response: None,
            attributes: BTreeMap::new(),
        })
    }

    fn validate_and_pad_pin(pin: Vec<u8>) -> WinScardResult<Vec<u8>> {
        // All PIN requirements can be found here: NIST.SP.800-73-4 part 2, section 2.4.3
        if !(PIN_LENGTH_RANGE_LOW_BOUND..=PIN_LENGTH_RANGE_HIGH_BOUND).contains(&pin.len()) {
            return Err(Error::new(
                ErrorKind::InvalidValue,
                "PIN should be no shorter than 6 bytes and no longer than 8",
            ));
        }
        if pin.iter().any(|byte| !byte.is_ascii_digit()) {
            return Err(Error::new(
                ErrorKind::InvalidValue,
                "PIN should consist only of ASCII values representing decimal digits (0-9)",
            ));
        };

        Ok(Self::pad_pin(pin))
    }

    fn pad_pin(mut pin: Vec<u8>) -> Vec<u8> {
        if pin.len() < PIN_LENGTH_RANGE_HIGH_BOUND {
            // NIST.SP.800-73-4 part 2, section 2.4.3
            const PIN_PAD_VALUE: u8 = 0xFF;
            pin.resize(PIN_LENGTH_RANGE_HIGH_BOUND, PIN_PAD_VALUE);
        }

        pin
    }

    /// This functions handles one APDU command.
    #[instrument(level = "debug", ret, fields(state = ?self.state), skip(self))]
    pub fn handle_command(&mut self, data: &[u8]) -> WinScardResult<Response> {
        let cmd = Command::<1024>::try_from(data).map_err(|error| {
            error!(?error, "APDU command parsing error");
            Error::new(
                ErrorKind::InternalError,
                format!("error: an error happened while parsing an APDU command: {:?}", error),
            )
        })?;
        let cmd = if let Some(mut chained) = self.pending_command.take() {
            chained.extend_from_command(&cmd).map_err(|_| {
                Error::new(
                    ErrorKind::InternalError,
                    "error: an error happened while trying to build a chained APDU command",
                )
            })?;
            chained
        } else {
            cmd
        };

        if cmd.class().chain().not_the_last() {
            self.pending_command = Some(cmd);
            return Ok(Status::OK.into());
        }
        if self.state == SCardState::Ready && cmd.instruction() != Instruction::Select {
            // if the application wasn't selected, only the SELECT command can be used
            return Ok(Status::NotFound.into());
        } else if self.state == SCardState::PivAppSelected && cmd.instruction() == Instruction::GeneralAuthenticate {
            // GENERAL AUTHENTICATE can only be used if the smart card has already been unlocked using the PIN code
            return Ok(Status::SecurityStatusNotSatisfied.into());
        }
        match cmd.instruction() {
            Instruction::Select => self.select(cmd),
            Instruction::GetData => self.get_data(cmd),
            Instruction::Verify => self.verify(cmd),
            Instruction::GeneralAuthenticate => self.general_authenticate(cmd),
            Instruction::GetResponse => self.get_response(),
            _ => {
                error!(instruction = ?cmd.instruction(), "unimplemented instruction");
                Ok(Status::InstructionNotSupported.into())
            }
        }
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip(self))]
    fn select(&mut self, cmd: Command<1024>) -> WinScardResult<Response> {
        // NIST.SP.800-73-4, Part 2, Section 3.1.1
        // PIV SELECT command
        //      CLA - 0x00
        //      INS - 0xA4
        //      P1  - 0x04
        //      P2  - 0x00

        // ISO/IEC 7816-4, Section 7.1.1, Table 39
        const APPLICATION_IDENTIFIER: u8 = 0x04;
        // ISO/IEC 7816-4, Section 7.1.1, Table 40
        const FIRST_OR_ONLY_OCCURRENCE: u8 = 0x00;

        if cmd.p1 != APPLICATION_IDENTIFIER || cmd.p2 != FIRST_OR_ONLY_OCCURRENCE || !PIV_AID.matches(cmd.data()) {
            return Ok(Status::NotFound.into());
        }
        let data = Tlv::new(
            Tag::try_from(tlv_tags::APPLICATION_PROPERTY_TEMPLATE)?,
            Value::Constructed(vec![
                Tlv::new(
                    Tag::try_from(tlv_tags::APPLICATION_IDENTIFIER)?,
                    // application portion + version portion of the PIV AID
                    // NIST.SP.800-73-4 Part 1, section 2.2
                    Value::Primitive(vec![0x00, 0x00, 0x10, 0x00, 0x01, 0x00]),
                )?,
                Tlv::new(
                    Tag::try_from(tlv_tags::COEXISTING_TAG_ALLOCATION_AUTHORITY)?,
                    Value::Constructed(vec![Tlv::new(
                        Tag::try_from(tlv_tags::APPLICATION_IDENTIFIER)?,
                        Value::Primitive(PIV_AID.to_vec()),
                    )?]),
                )?,
            ]),
        )?;
        self.state = SCardState::PivAppSelected;
        Ok(Response::new(Status::OK, Some(data.to_vec())))
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip(self))]
    fn verify(&mut self, cmd: Command<1024>) -> WinScardResult<Response> {
        // NIST.SP.800-73-4, Part 2, Section 3.2.1
        // PIV VERIFY command
        //      CLA  - 0x00
        //      INS  - 0x20
        //      P1   - 0x00 | 0xFF
        //      P2   - 0x80
        //      Data - PIN
        //
        // If P1 is 0xFF, the Data field should be empty

        // ISO/IEC 7816-4, Section 7.5.1
        const NO_IDENTIFIER: u8 = 0x00;
        // NIST.SP.800-73-4, Part 2, Section 3.2.1
        const RESET_SECURITY_STATUS: u8 = 0xFF;
        // ISO/IEC 7816-4, Section 7.5.1, Table 65
        const SPECIFIC_REFERENCE_DATA: u8 = 0x80;

        if cmd.p1 == RESET_SECURITY_STATUS && !cmd.data().is_empty() {
            return Ok(Status::IncorrectP1orP2.into());
        }
        if cmd.p2 != SPECIFIC_REFERENCE_DATA {
            return Ok(Status::KeyReferenceNotFound.into());
        }
        match cmd.p1 {
            NO_IDENTIFIER => {
                // PIN was already verified -> return OK
                if self.state != SCardState::PinVerified {
                    if !cmd.data().is_empty()
                        && !(PIN_LENGTH_RANGE_LOW_BOUND..=PIN_LENGTH_RANGE_HIGH_BOUND).contains(&cmd.data().len())
                    {
                        // Incorrect PIN length -> do not proceed and return an error
                        return Ok(Status::IncorrectDataField.into());
                    }
                    // Retrieve the number of further allowed retries if the data field is absent
                    // Otherwise just compare the provided PIN with the stored one
                    if cmd.data().is_empty() || cmd.data() != self.pin.as_slice() {
                        return Ok(Status::VerificationFailedWithRetries.into());
                    } else {
                        // data field is present and the provided PIN is correct -> change state and return OK
                        self.state = SCardState::PinVerified;
                    }
                }
            }
            RESET_SECURITY_STATUS => {
                // p1 is 0xFF and the data field is absent -> reset the security status and return OK
                self.state = SCardState::PivAppSelected;
            }
            _ => return Ok(Status::IncorrectP1orP2.into()),
        };
        Ok(Status::OK.into())
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip(self))]
    fn get_data(&mut self, cmd: Command<1024>) -> WinScardResult<Response> {
        // NIST.SP.800-73-4, Part 2, Section 3.1.2
        // PIV GET DATA command
        //      CLA  - 0x00
        //      INS  - 0xCB
        //      P1   - 0x3F
        //      P2   - 0xFF
        //      Data - a single BER-TLV tag of the data object to be retrieved
        //
        // Our PIV smart card only supports:
        //      5FC102 - Card Holder Unique Identifier
        //      5FC105 - X.509 Certificate for PIV Authentication

        // ISO/IEC 7816-4, Section 7.4.1
        const FIRST_BYTE_OF_CURRENT_DF: u8 = 0x3F;
        const SECOND_BYTE_OF_CURRENT_DF: u8 = 0xFF;

        if cmd.p1 != FIRST_BYTE_OF_CURRENT_DF || cmd.p2 != SECOND_BYTE_OF_CURRENT_DF {
            return Ok(Status::IncorrectP1orP2.into());
        }
        let request = Tlv::from_bytes(cmd.data())?;
        if request.tag() != &Tag::try_from(tlv_tags::TAG_LIST)? {
            return Ok(Status::NotFound.into());
        }

        match request.value() {
            Value::Primitive(tag) => match tag.as_slice() {
                CHUID_TAG => Ok(Response::new(Status::OK, Some(self.chuid.to_vec()))),
                PIV_CERT_TAG | CARD_AUTH_CERT_TAG | KEY_MANAGEMENT_CERT_TAG | DIGITAL_SIGNATURE_CERT_TAG => {
                    // certificate is almost certainly longer than 256 bytes, so we can just set a pending response and call the GET RESPONSE handler
                    self.pending_response = Some(self.auth_cert.clone());
                    self.get_response()
                }
                CARD_CAPABILITY_CONTAINER_TAG => Ok(Response::new(Status::OK, Some(self.ccc.clone()))),
                _ => Ok(Status::NotFound.into()),
            },
            Value::Constructed(_) => Ok(Status::NotFound.into()),
        }
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip(self))]
    fn get_response(&mut self) -> WinScardResult<Response> {
        // ISO/IEC 7816-4, Section 7.6.1
        // The smart card uses the standard (short) APDU response form, so the maximum amount of data transferred in one response is 256 bytes
        match self.get_next_response_chunk() {
            Some((chunk, bytes_left)) => {
                let status = if bytes_left == 0 {
                    self.pending_response = None;
                    Status::OK
                } else if bytes_left < CHUNK_SIZE {
                    // conversion is safe as we know that bytes_left isn't bigger than 256
                    Status::MoreAvailable(bytes_left.try_into().unwrap())
                } else {
                    // 0 indicates that we have 256 or more bytes left to be read
                    Status::MoreAvailable(0)
                };
                Ok(Response::new(status, Some(chunk)))
            }
            None => Ok(Status::NotFound.into()),
        }
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip(self))]
    fn general_authenticate(&mut self, cmd: Command<1024>) -> WinScardResult<Response> {
        // NIST.SP.800-73-4, Part 2, Section 3.2.4
        // PIV GENERAL AUTHENTICATE command
        //      CLA  - 0x00 | 0x10 (command chaining)
        //      INS  - 0x87
        //      P1   - 0x07 - RSA
        //      P2   - 0x9A - PIV Authentication Key
        //      Data - Dynamic Authentication Template with Challenge inside
        //
        // There are many possible P1 and P2 values in this command, but our smart card only supports the RSA algorithm and data signing using the PIV Authentication Key

        // NIST.SP.800-73-4, Part 1, Table 5
        const RSA_ALGORITHM: u8 = 0x07;
        // NIST.SP.800-73-4, Part 1, Table 4b
        const PIV_DIGITAL_SIGNATURE_KEY: u8 = 0x9C;

        if cmd.p1 != RSA_ALGORITHM || cmd.p2 != PIV_DIGITAL_SIGNATURE_KEY {
            return Err(Error::new(
                ErrorKind::UnsupportedFeature,
                format!("Provided algorithm or key reference isn't supported: got algorithm {:x}, expected 0x07; got key reference {:x}, expected 0x9A", cmd.p1, cmd.p2)
            ));
        }
        let request = Tlv::from_bytes(cmd.data())?;
        if request.tag() != &Tag::try_from(tlv_tags::DYNAMIC_AUTHENTICATION_TEMPLATE)?
            || !request.value().is_constructed()
        {
            // wrong TLV request structure
            return Err(Error::new(
                ErrorKind::InvalidValue,
                "TLV structure is invalid: wrong top-level tag structure".to_string(),
            ));
        }
        let inner_tlv = match request.value() {
            // we already know that the value is constructed at this point
            Value::Primitive(_) => unreachable!(),
            Value::Constructed(tlv_vec) => tlv_vec,
        };
        // to avoid constructing the tag on each iteration
        let challenge_tag = Tag::try_from(tlv_tags::DAT_CHALLENGE)?;
        let challenge = inner_tlv
            .iter()
            .find(|&tlv| tlv.tag() == &challenge_tag)
            .ok_or(Error::new(
                ErrorKind::InvalidValue,
                "TLV structure is invalid: no challenge field is present in the request".to_string(),
            ))?;
        // Signature creation is described in NIST.SP.800-73-4, Part 2, Appendix A, Sections A.1-3 and Section A.4.1
        let challenge = match challenge.value() {
            Value::Primitive(ref challenge) => challenge,
            Value::Constructed(_) => {
                // this tag must contain a primitive value
                return Err(Error::new(
                    ErrorKind::InvalidValue,
                    "TLV structure is invalid: challenge field contains constructed value".to_string(),
                ));
            }
        };
        let signed_challenge = self.sign_padded(challenge)?;
        let response = Tlv::new(
            Tag::try_from(tlv_tags::DYNAMIC_AUTHENTICATION_TEMPLATE)?,
            Value::Constructed(vec![Tlv::new(
                Tag::try_from(tlv_tags::DAT_RESPONSE)?,
                Value::Primitive(signed_challenge),
            )?]),
        )?
        .to_vec();
        self.pending_response = Some(response);
        self.get_response()
    }

    fn sign_padded(&self, data: impl AsRef<[u8]>) -> WinScardResult<Vec<u8>> {
        use rsa::BigUint;

        let rsa_private_key = RsaPrivateKey::try_from(&self.auth_pk)?;
        // According to the specification, the PIV smart card accepts already padded digest.
        // So, it's safe to use the `rsa_decrypt_and_check` function here.
        let signature = rsa::hazmat::rsa_decrypt_and_check(
            &rsa_private_key,
            None::<&mut crate::dummy_rng::Dummy>,
            &BigUint::from_bytes_be(data.as_ref()),
        )?;

        let mut signature = signature.to_bytes_be();

        while signature.len() < rsa_private_key.size() {
            signature.insert(0, 0);
        }

        Ok(signature)
    }

    /// Signs the provided data using the smart card private key.
    /// *Warning 1*. The input data should be a *SHA1* hash of the actually you want to sign.
    pub fn sign_hashed(&self, data: impl AsRef<[u8]>) -> WinScardResult<Vec<u8>> {
        let rsa_private_key = RsaPrivateKey::try_from(&self.auth_pk)?;
        let signature = rsa_private_key.sign(Pkcs1v15Sign::new::<Sha1>(), data.as_ref())?;

        Ok(signature)
    }

    /// Verifies the PIN code. This method alters the scard state.
    pub fn verify_pin(&mut self, pin: &[u8]) -> WinScardResult<()> {
        if self.pin != Self::pad_pin(pin.into()) {
            return Err(Error::new(
                ErrorKind::InvalidValue,
                "PIN verification error: Invalid PIN",
            ));
        }

        self.state = SCardState::PinVerified;

        Ok(())
    }

    fn get_next_response_chunk(&mut self) -> Option<(Vec<u8>, usize)> {
        let vec = self.pending_response.as_mut()?;
        if vec.is_empty() {
            return None;
        }
        let next_chunk_length = CHUNK_SIZE.min(vec.len());
        let chunk = vec.drain(0..next_chunk_length).collect::<Vec<u8>>();
        Some((chunk, vec.len()))
    }
}

#[derive(Debug, Clone, PartialEq)]
enum SCardState {
    Ready,
    PivAppSelected,
    PinVerified,
}

impl WinScard for SmartCard<'_> {
    fn status(&self) -> WinScardResult<winscard::Status> {
        Ok(winscard::Status {
            readers: vec![self.reader_name.clone()],
            // The original winscard always returns SCARD_SPECIFIC for a working inserted card
            state: winscard::State::Specific,
            // We are always using the T1 protocol as the original Windows TPM smart card does
            protocol: SUPPORTED_CONNECTION_PROTOCOL,
            atr: ATR.into(),
        })
    }

    fn control(&mut self, code: ControlCode, _input: &[u8]) -> WinScardResult<()> {
        if code != IO_CTL {
            return Err(Error::new(
                ErrorKind::InvalidValue,
                format!("unsupported control code: {:?}", code),
            ));
        }

        Ok(())
    }

    fn control_with_output(&mut self, code: ControlCode, input: &[u8], _output: &mut [u8]) -> WinScardResult<usize> {
        self.control(code, input)?;

        Ok(0)
    }

    fn transmit(&mut self, input_apdu: &[u8]) -> WinScardResult<TransmitOutData> {
        let Response { status, data } = self.handle_command(input_apdu)?;

        let mut output_apdu = data.unwrap_or_default();
        let status_data: [u8; 2] = status.into();
        output_apdu.extend_from_slice(&status_data);

        Ok(TransmitOutData {
            output_apdu,
            receive_pci: None,
        })
    }

    fn begin_transaction(&mut self) -> WinScardResult<()> {
        if self.transaction {
            return Err(Error::new(
                ErrorKind::InternalError,
                "the transaction already in progress",
            ));
        }
        self.transaction = true;
        Ok(())
    }

    fn end_transaction(&mut self, _disposition: ReaderAction) -> WinScardResult<()> {
        if !self.transaction {
            return Err(Error::new(ErrorKind::NotTransacted, "the transaction is not started"));
        }
        self.transaction = false;
        Ok(())
    }

    fn reconnect(&mut self, _: ShareMode, _: Option<Protocol>, _: ReaderAction) -> WinScardResult<Protocol> {
        // Because it's an emulated smart card, we do nothing and return success.
        Ok(SUPPORTED_CONNECTION_PROTOCOL)
    }

    fn get_attribute(&self, attribute_id: AttributeId) -> WinScardResult<Cow<[u8]>> {
        let data = self.attributes.get(&attribute_id).map(AsRef::as_ref).ok_or_else(|| {
            Error::new(
                ErrorKind::InvalidParameter,
                format!("The {:?} attribute id is not present", attribute_id),
            )
        })?;

        Ok(Cow::Borrowed(data))
    }

    fn set_attribute(&mut self, attribute_id: AttributeId, attribute_data: &[u8]) -> WinScardResult<()> {
        self.attributes
            .insert(attribute_id, Cow::Owned(attribute_data.to_vec()));

        Ok(())
    }

    fn disconnect(&mut self, _disposition: ReaderAction) -> WinScardResult<()> {
        // We don't need any actions during the disconnection in emulated smart cards.
        // It's enough just to drop the card object.

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    extern crate std;

    use picky::hash::HashAlgorithm;
    use picky::signature::SignatureAlgorithm;
    use proptest::prelude::*;
    use proptest::{collection, option, prop_compose};
    use rand::distributions::Uniform;
    use rand::Rng;
    use rsa::traits::PublicKeyParts;
    use rsa::BigUint;

    use super::*;
    use crate::ber_tlv::ber_tlv_length_encoding;

    fn arb_status() -> impl Strategy<Value = Status> {
        prop_oneof![
            Just(Status::NotFound),
            Just(Status::OK),
            Just(Status::VerificationFailedWithRetries),
            any::<u8>().prop_map(Status::MoreAvailable),
            Just(Status::KeyReferenceNotFound),
            Just(Status::SecurityStatusNotSatisfied),
            Just(Status::IncorrectP1orP2),
            Just(Status::IncorrectDataField),
            Just(Status::InstructionNotSupported)
        ]
    }

    prop_compose! {
        fn arb_response()(status in arb_status(), data in option::of(collection::vec(any::<u8>(), 0..256))) -> Response {
            Response::new(status, data)
        }
    }

    proptest! {
        #[test]
        fn response_is_encoded_correctly(arb_response in arb_response()) {
            let data = arb_response.data.clone();
            let status: [u8; 2] = arb_response.status.clone().into();
            let expected_result = if let Some(mut bytes) = data {
                bytes.extend(status);
                bytes
            } else {
                Vec::from(status)
            };
            assert_eq!(expected_result, Vec::from(arb_response));
        }
    }

    fn new_scard() -> SmartCard<'static> {
        let rsa_2048_private_key = "-----BEGIN RSA PRIVATE KEY-----
MIIEowIBAAKCAQEAiJ/d1/2d1CQYlJfZ02TOH7F/5U53a6IZc8QwTQEsBQbVGfQO
RN/+b09NzJJZmtyuLdBAXLzP8lEzKcfgn4JNl5G7DuKOxRreE5tq8uA+j2SQCw7m
Sm6todEOvkWG5Dov3Q9QnlPbvqp871pfbRsfKwOo2RxJIjbjpM5FQnlqOd+3gu2I
TF8dt+/PY+wl1w6kPTUZg/mzElY95WSnOE9bFlHcVL//Sl3caW85AB0lLUbd96b/
7PMO6IWJQyvS0ssG0emcyQYllvvSCFSpVWA/e1EGzKrwbtG1Xn9je5L4mIKiSw/p
gbjnYE9g+pibLJNobBBLkzGdo/KzyCQbMWirkQIDAQABAoIBAEbAm28mXNymkMAq
31g1BPWuwy/p8bggqxOjjuvh5nz369XT6KvMYAQeyohdZd/n1p/ND/e2o+22FUvW
wcF5Bluu0XNE6nCymD0JKFp8vIkfp+TCI4p6RJrfG8Z3VQLOC0lsi/BiNxNHUQnX
AEINYJey/nboygrY6AzJ8V4aaGNtbtnz7tfyALJHUK0qRa+AmyLCzaZR5RSbDgB5
srCX9J5OCxH2s5tVSfqg48Z0RIiBcDFPYbJDakZWLRNLD8ByW3e0jEFDA1vQPsaj
CsyY4E6UZwYNZemC60zW0e8BYJYnOAhcmwaYnaxvL5xy0aW5pUGr+FgnO4NrNr33
pKT2eFECgYEA2LJdjjFGdTsuW8esbTn+9hGyNnUR9gxYGdNhcINhPHMhoR8GkakC
5sLOlpgCDpdzHDduW2GjhIAUnXt50yZNpkXQuSWdjucbYGc2G5ySc8eHaP+5tHAr
svyZBchE+Kf4p2nNoXoQxsgxY2Qgz/ctUgCR7SnbgRW0cHDH7HIXlJ0CgYEAoWeY
rt2q8PFW3sEWy1RK0dxD+7UnuN76x5rd0IUxi2HS5F4tyfiDy3LgVs0XJqF9IN6K
IQ7pX/0C1g91NbUl8pAnu+k7R/CiynqGAmQumkMscIRO4VoR+v3+Hta9NV6sy/0U
fDfQSK9AnrFXGCpHPLC+YrmgbVnKqJ526vBxboUCgYEAvx4pJ0TMWI62p1nm+HrD
JLGc1SzRh4mBll15PeuRsef1DA66E3PVzEKaQ/WTMt1eN8+ntE7cEfuIsxB49MJ+
j5xZp0HGwYeQ/Khq71VbUWP0SKXqWnrn/7eLGq90LT6wLq9BHh7zdu6PqJJh4iml
vgIkseBN6X6EIvtFSIOjyn0CgYBRvEiRpSd/xHedbmLArPsGs2ip+t8Wu7R7iG1z
vz+Lugo2I4tEkFkNmisJSerDYVwgXRHOE+MS/OmGxWUxwX5qC55ThpTCpZWKu+lJ
JLqE3CeRAy9+50HbvOwHae9/K2aOFqddEFaluDodIulcD2zrywVesWoQdjwuj7Dg
4MpQkQKBgA4vlTf+n8kpOJWls2YMyZaauY48xcNzDdhpBGFCjVm+aiKX5dyIjAQK
9LX8/iVau8ZRM+qSLpuEP+o8qGR11TbGZrLH/wITc7r9cWnaGDsozmPAnxMcu1zz
9IRTY9zr9QWzxGiSqr834q5IZIQ/5uDBW/857MP0bpMl6cTdxzg0
-----END RSA PRIVATE KEY-----";
        let auth_pk = PrivateKey::from_pem_str(rsa_2048_private_key).unwrap();
        let certificate_stub = vec![0xff; 1024];
        let pin = vec![0x39; 6];
        SmartCard::new(Cow::Borrowed("Reader 0"), pin, certificate_stub, auth_pk).unwrap()
    }

    // Helper function that calls the GET RESPONSE handler until there is no more data to read
    fn get_all_available_data(mut response: Response, scard: &mut SmartCard) -> Vec<u8> {
        let mut complete_response = vec![];
        while let Status::MoreAvailable(bytes_left) = response.status {
            complete_response.extend_from_slice(&response.data.expect("Data should be present"));
            let apdu_get_response = vec![0x00, 0xC0, 0x00, 0x00, bytes_left];
            response = scard
                .handle_command(&apdu_get_response)
                .expect("Can't retrieve all available data");
        }
        assert_eq!(response.status, Status::OK);
        complete_response.extend_from_slice(&response.data.expect("The last chunk of data isn't present"));
        complete_response
    }

    #[test]
    fn invalid_apdu_command() {
        // Verify that smart card correctly handles invalid APDU commands
        let mut scard = new_scard();

        let bad_apdu_command = vec![0x00; 2048];
        let response = scard.handle_command(&bad_apdu_command);
        assert!(response.is_err_and(|err| err.error_kind == ErrorKind::InternalError));
    }

    #[test]
    fn wrong_command_order() {
        // Verify that the smart card prohibits using any commands besides SELECT when no app was selected
        let mut scard = new_scard();

        let mut apdu_verify_cmd = vec![0x00, 0x20, 0x00, 0x80, 0x08];
        // add pin
        apdu_verify_cmd.extend_from_slice(&[0xA9; 8]);
        let response = scard.handle_command(&apdu_verify_cmd);
        assert!(response.is_ok_and(|resp| resp.status == Status::NotFound));
    }

    #[test]
    fn invalid_select_command() {
        // Verify that the SELECT handler correctly responds if called with an invalid AID
        let mut scard = new_scard();

        let bad_aid = vec![0xff; 11];

        let mut apdu_select_cmd = vec![0x00, 0xA4, 0x04, 0x00, 0x0B];
        apdu_select_cmd.extend_from_slice(&bad_aid);
        let response = scard.handle_command(&apdu_select_cmd);
        assert!(response.is_ok_and(|resp| resp.status == Status::NotFound));
    }

    #[test]
    fn select_command() {
        // Verify that the SELECT command works as expected and returns expected output
        let mut scard = new_scard();

        let mut expected_response = vec![
            0x61, 0x17, 0x4F, 0x06, 0x00, 0x00, 0x10, 0x00, 0x01, 0x00, 0x79, 0x0D, 0x4F, 0x0B,
        ];
        expected_response.extend_from_slice(&PIV_AID);

        let mut apdu_select_cmd = vec![0x00, 0xA4, 0x04, 0x00, 0x0B];
        apdu_select_cmd.extend_from_slice(&PIV_AID);
        let response = scard.handle_command(&apdu_select_cmd);
        assert!(response.is_ok_and(
            |resp| resp.status == Status::OK && resp.data.expect("Data should be present") == expected_response
        ));
    }

    #[test]
    fn unsupported_command() {
        // Verify that smart card correctly handles unsupported commands
        let mut scard = new_scard();
        scard.state = SCardState::PivAppSelected;

        // RESET RETRY COUNTER APDU command
        let apdu_reset_retry_cmd = vec![0x00, 0x2C, 0x00, 0x80, 0x00];
        let response = scard.handle_command(&apdu_reset_retry_cmd);
        assert!(response.is_ok_and(|resp| resp.status == Status::InstructionNotSupported));
    }

    #[test]
    fn invalid_verify_commands() {
        // Verify that the VERIFY command handler correctly handles badly structured or malformed requests
        let mut scard = new_scard();
        scard.state = SCardState::PivAppSelected;

        // p1 can only be 0x00 or 0xFF
        let apdu_verify_bad_p1 = vec![0x00, 0x20, 0xAA, 0x80, 0x00];
        let response = scard.handle_command(&apdu_verify_bad_p1);
        assert!(response.is_ok_and(|resp| resp.status == Status::IncorrectP1orP2));

        // if p1 is 0xFF, the data field should be empty
        let apdu_verify_bad_p1_data = vec![0x00, 0x20, 0xFF, 0x80, 0x02, 0xFF, 0xFF];
        let response = scard.handle_command(&apdu_verify_bad_p1_data);
        assert!(response.is_ok_and(|resp| resp.status == Status::IncorrectP1orP2));

        // p2 should always be 0x80
        let apdu_verify_bad_p2 = vec![0x00, 0x20, 0x00, 0x81, 0x02, 0xFF, 0xFF];
        let response = scard.handle_command(&apdu_verify_bad_p2);
        assert!(response.is_ok_and(|resp| resp.status == Status::KeyReferenceNotFound));

        // PIN should be no shorter than six bytes and no longer than 8
        let apdu_verify_bad_pin = vec![0x00, 0x20, 0x00, 0x80, 0x02, 0xAA, 0xAA];
        let response = scard.handle_command(&apdu_verify_bad_pin);
        assert!(response.is_ok_and(|resp| resp.status == Status::IncorrectDataField));
    }

    #[test]
    fn verify_command() {
        // Verify that the VERIFY command handler correctly handles all supported types of requests
        let mut scard = new_scard();
        scard.state = SCardState::PivAppSelected;

        // retrieve number of allowed retries by omitting the data field
        let apdu_verify_no_data = vec![0x00, 0x20, 0x00, 0x80, 0x00];
        let response = scard.handle_command(&apdu_verify_no_data);
        assert!(response.is_ok_and(|resp| resp.status == Status::VerificationFailedWithRetries));

        // VERIFY command with the wrong PIN code
        let mut apdu_verify_wrong_pin = vec![0x00, 0x20, 0x00, 0x80, 0x08];
        apdu_verify_wrong_pin.extend_from_slice(&[0xCC; 8]);
        let response = scard.handle_command(&apdu_verify_wrong_pin);
        assert!(response.is_ok_and(|resp| resp.status == Status::VerificationFailedWithRetries));

        // VERIFY command with the correct PIN code
        let mut apdu_verify_correct_pin = vec![0x00, 0x20, 0x00, 0x80, 0x08];
        apdu_verify_correct_pin.extend_from_slice(&[0x39; 6]);
        // 0xFF padding
        apdu_verify_correct_pin.extend_from_slice(&[0xFF; 2]);
        let response = scard.handle_command(&apdu_verify_correct_pin);
        assert!(response.is_ok_and(|resp| resp.status == Status::OK));
        assert_eq!(scard.state, SCardState::PinVerified);

        // Reset the security status
        let apdu_verify_reset = vec![0x00, 0x20, 0xFF, 0x80, 0x00];
        let response = scard.handle_command(&apdu_verify_reset);
        assert!(response.is_ok_and(|resp| resp.status == Status::OK));
        assert_eq!(scard.state, SCardState::PivAppSelected);
    }

    #[test]
    fn get_response_command() {
        // Verify that the GET RESPONSE handler correctly sends the data
        let mut scard = new_scard();
        scard.state = SCardState::PivAppSelected;
        let mut rng = rand::thread_rng();

        // get a random Vec<u8> of length 513
        let data: Vec<u8> = (0..513).map(|_| rng.sample(Uniform::new(0, 255))).collect();
        // we will have to make 3 calls to get this data
        scard.pending_response = Some(data.clone());

        let mut received_result = vec![];
        // 0 means any valid number in range 0..=256
        // We set this to 0 on the first call so that the smart card returns whatever it got
        let bytes_left = 0;
        let mut apdu_get_response = vec![0x00, 0xC0, 0x00, 0x00, bytes_left];

        let response = scard.handle_command(&apdu_get_response);
        assert!(response
            .as_ref()
            .is_ok_and(|resp| resp.status == Status::MoreAvailable(0)
                && resp.data.is_some()
                && resp.data.as_ref().unwrap() == &data[0..256]));
        received_result.extend_from_slice(&response.unwrap().data.unwrap());

        let response = scard.handle_command(&apdu_get_response);
        assert!(response
            .as_ref()
            .is_ok_and(|resp| resp.status == Status::MoreAvailable(1)
                && resp.data.is_some()
                && resp.data.as_ref().unwrap() == &data[256..512]));
        received_result.extend_from_slice(&response.unwrap().data.unwrap());

        // set the Le field to 1 so that we get the last remaining byte
        apdu_get_response[4] = 1;
        let response = scard.handle_command(&apdu_get_response);
        assert!(response.as_ref().is_ok_and(|resp| resp.status == Status::OK
            && resp.data.is_some()
            && resp.data.as_ref().unwrap() == &data[512..]));
        received_result.extend_from_slice(&response.unwrap().data.unwrap());

        assert_eq!(received_result, data);
    }

    #[test]
    fn invalid_get_data_command() {
        // Verify that the GET DATA handler correctly handles invalid requests
        let mut scard = new_scard();
        scard.state = SCardState::PivAppSelected;

        // p1 should always be 0x3F; p2 should always be 0xFF
        let apdu_get_data_bad_p1_p2 = vec![0x00, 0xCB, 0x10, 0x21, 0x00];
        let response = scard.handle_command(&apdu_get_data_bad_p1_p2);
        assert!(response.is_ok_and(|resp| resp.status == Status::IncorrectP1orP2));

        // bad object tag in the data field
        let apdu_get_data_bad_tag = vec![0x00, 0xCB, 0x3F, 0xFF, 0x05, 0x5C, 0x03, 0x5F, 0xC1, 0x08];
        let response = scard.handle_command(&apdu_get_data_bad_tag);
        assert!(response.is_ok_and(|resp| resp.status == Status::NotFound));
    }

    #[test]
    fn get_data_command() {
        // Verify that the GET DATA handler correctly handles all supported requests and returns correct data
        let mut scard = new_scard();
        scard.state = SCardState::PivAppSelected;

        // get CHUID
        let apdu_get_data_chuid = vec![0x00, 0xCB, 0x3F, 0xFF, 0x05, 0x5C, 0x03, 0x5F, 0xC1, 0x02];
        let response = scard.handle_command(&apdu_get_data_chuid);
        assert!(
            response.is_ok_and(|resp| resp.status == Status::OK && resp.data.expect("Expected CHUID") == scard.chuid)
        );

        // get PIV authentication certificate
        let apdu_get_data_chuid = vec![0x00, 0xCB, 0x3F, 0xFF, 0x05, 0x5C, 0x03, 0x5F, 0xC1, 0x05];
        let response = scard.handle_command(&apdu_get_data_chuid);
        // verify the contents
        assert!(response.is_ok_and(|resp| {
            // as the certificate is larger than 256 bytes, we have to call the GET RESPONSE function a few times
            let complete_response = get_all_available_data(resp, &mut scard);
            complete_response == scard.auth_cert
        }));
    }

    #[test]
    fn general_authenticate_no_pin() {
        // Verify that the GENERAL AUTHENTICATE handler can't be used without unlocking the smart card first
        let mut scard = new_scard();
        scard.state = SCardState::PivAppSelected;

        let apdu_general_authenticate = vec![0x00, 0x87, 0x07, 0x9A, 0x00];
        let response = scard.handle_command(&apdu_general_authenticate);
        assert!(response.is_ok_and(|resp| resp.status == Status::SecurityStatusNotSatisfied));
    }

    #[test]
    fn invalid_general_authenticate_command() {
        // Verify that the GENERAL AUTHENTICATE handler correctly handles invalid requests
        let mut scard = new_scard();
        scard.state = SCardState::PinVerified;

        // p1 should always be 0x07; p2 should always be 0x9A
        let apdu_general_authenticate = vec![0x00, 0x87, 0xFF, 0xCC, 0x00];
        let response = scard.handle_command(&apdu_general_authenticate);
        assert!(response.is_err_and(|err| err.error_kind == ErrorKind::UnsupportedFeature));
    }

    #[test]
    fn general_authenticate_command() {
        // Verify that the GENERAL AUTHENTICATE handler correctly encrypts the provided data
        let mut scard = new_scard();
        scard.state = SCardState::PinVerified;

        let data = "My message".as_bytes();

        let rsa_pk = rsa::RsaPrivateKey::try_from(&scard.auth_pk).expect("Can't convert the private key");
        // sign the data using the PKCS1-v1.5 padding scheme
        let signature_algorithm = SignatureAlgorithm::RsaPkcs1v15(HashAlgorithm::SHA3_512);
        let signed_data = signature_algorithm
            .sign(data, &scard.auth_pk)
            .expect("Error while signing the data");
        // extract the padded hash by decrypting the signature using the public key
        // we need to extract the padded hash to calculate the signature ourselves
        let padded_hash = BigUint::from_bytes_be(&signed_data)
            .modpow(rsa_pk.e(), rsa_pk.n())
            .to_bytes_be();

        // the hash is bigger than 127, so we have to use BER-TLV encoding
        let encoded_hash_length = ber_tlv_length_encoding(padded_hash.len());
        // encoded_hash_length + tag + hash
        let dat_tag_data_length = ber_tlv_length_encoding(1 + encoded_hash_length.len() + padded_hash.len());

        // use command chaining to send the data that is bigger than 255 bytes
        let mut apdu_general_authenticate = vec![0x10, 0x87, 0x07, 0x9A, 0xFF, 0x7C];
        apdu_general_authenticate.extend_from_slice(&dat_tag_data_length);
        apdu_general_authenticate.extend_from_slice(&[0x81]);
        apdu_general_authenticate.extend_from_slice(&encoded_hash_length);
        apdu_general_authenticate.extend_from_slice(&padded_hash[..248]);

        let response = scard.handle_command(&apdu_general_authenticate);
        assert!(response.is_ok_and(|resp| resp.status == Status::OK));

        // send the remaining data and end command chaining by setting the CLA byte to 0x00
        let mut apdu_general_authenticate = vec![0x00, 0x87, 0x07, 0x9A, 0x07];
        apdu_general_authenticate.extend_from_slice(&padded_hash[248..]);
        // Le
        apdu_general_authenticate.extend_from_slice(&[0x00]);

        let response = scard
            .handle_command(&apdu_general_authenticate)
            .expect("Shouldn't have failed");

        let complete_response = get_all_available_data(response, &mut scard);
        let parsed_response =
            Tlv::from_bytes(&complete_response).expect("Couldn't parse a TLV object sent from the smart card");

        // verify the structure of the response and extract the signed hash
        assert_eq!(
            parsed_response.tag(),
            &Tag::try_from(tlv_tags::DYNAMIC_AUTHENTICATION_TEMPLATE).expect("Couldn't construct a TLV tag")
        );
        let response_tag = match parsed_response.value() {
            Value::Constructed(data) => data
                .iter()
                .find(|tlv_object| {
                    tlv_object.tag() == &Tag::try_from(tlv_tags::DAT_RESPONSE).expect("Couldn't construct a TLV tag")
                })
                .expect("The inner TLV object should contain a Response tag"),
            Value::Primitive(_) => panic!("Dynamic Authentication Template should contain constructed value"),
        };
        let signed_hash = match response_tag.value() {
            Value::Constructed(_) => panic!("Response tag should contain a primitive value"),
            Value::Primitive(signed_hash) => signed_hash,
        };
        // verify that the returned signature can be verified using the corresponding public key
        assert!(signature_algorithm
            .verify(
                &scard
                    .auth_pk
                    .to_public_key()
                    .expect("Error while creating public key from a private key"),
                data,
                signed_hash
            )
            .is_ok());
    }
}


--- File: crates/winscard/src/scard_context.rs ---
use alloc::borrow::{Cow, ToOwned};
use alloc::boxed::Box;
use alloc::collections::BTreeMap;
use alloc::string::String;
use alloc::vec::Vec;
use alloc::{format, vec};

use picky::key::PrivateKey;
use picky_asn1_x509::{PublicKey, SubjectPublicKeyInfo};
use uuid::Uuid;

use crate::scard::{SmartCard, SUPPORTED_CONNECTION_PROTOCOL};
use crate::winscard::{
    CurrentState, DeviceTypeId, Icon, Protocol, ProviderId, ReaderState, ScardConnectData, ShareMode, WinScardContext,
};
use crate::{Error, ErrorKind, WinScardResult};

/// https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardgetstatuschangew
/// To be notified of the arrival of a new smart card reader,
/// set the szReader member of a SCARD_READERSTATE structure to "\\?PnP?\Notification",
const NEW_READER_NOTIFICATION: &str = "\\\\?PnP?\\Notification";

/// Default name of the emulated smart card.
pub const DEFAULT_CARD_NAME: &str = "Sspi-rs emulated smart card";
/// Default CSP name.
pub const MICROSOFT_DEFAULT_CSP: &str = "Microsoft Base Smart Card Crypto Provider";
/// Default KSP name.
pub const MICROSOFT_DEFAULT_KSP: &str = "Microsoft Smart Card Key Storage Provider";
/// Default smart card driver location.
pub const MICROSOFT_SCARD_DRIVER_LOCATION: &str = "msclmd.dll\0";

/// Describes a smart card reader.
#[derive(Debug, Clone)]
pub struct Reader<'a> {
    /// Reader name.
    pub name: Cow<'a, str>,
    /// Reader icon buff.
    pub icon: Icon<'a>,
    /// Device Type Id.
    pub device_type_id: DeviceTypeId,
}

/// Describes smart card info used for the smart card creation.
#[derive(Debug, Clone)]
pub struct SmartCardInfo<'a> {
    /// Container name which stores the certificate along with its private key.
    pub container_name: Cow<'a, str>,
    /// Smart card PIN code.
    pub pin: Vec<u8>,
    /// DER-encoded smart card certificate.
    pub auth_cert_der: Vec<u8>,
    /// Encoded private key (pem).
    pub auth_pk_pem: Cow<'a, str>,
    /// Private key.
    pub auth_pk: PrivateKey,
    /// Information about smart card reader.
    pub reader: Reader<'a>,
}

impl<'a> SmartCardInfo<'a> {
    /// Returns image bytes (BMP encoded) of the stadard Windowss Reader Icon.
    pub fn reader_icon() -> &'static [u8] {
        include_bytes!("../assets/reader_icon.bmp")
    }

    /// Tries to create [SmartCardInfo] structure based on environment variables.
    /// Required environment variables are listed in the `env` module of this crate.
    #[cfg(feature = "std")]
    pub fn try_from_env() -> WinScardResult<Self> {
        use crate::env::{
            auth_cert_from_env, container_name, private_key_from_env, WINSCARD_PIN_ENV, WINSCARD_READER_NAME_ENV,
        };

        let container_name = container_name()?.into();
        let reader_name: Cow<'_, str> = env!(WINSCARD_READER_NAME_ENV)?.into();
        let pin = env!(WINSCARD_PIN_ENV)?.into();

        let auth_cert_der = auth_cert_from_env()?.to_der()?;
        let (raw_private_key, private_key) = private_key_from_env()?;

        // Standard Windows Reader Icon
        let icon: &[u8] = Self::reader_icon();
        let reader: Reader<'_> = Reader {
            name: reader_name,
            icon: Icon::from(icon),
            device_type_id: DeviceTypeId::Tpm,
        };

        Ok(Self {
            container_name,
            pin,
            auth_cert_der,
            auth_pk_pem: raw_private_key.into(),
            auth_pk: private_key,
            reader,
        })
    }

    /// Creates a new [ScardContext] based on the provided data.
    pub fn new(
        container_name: Cow<'a, str>,
        reader_name: Cow<'a, str>,
        pin: Vec<u8>,
        auth_cert_der: Vec<u8>,
        auth_pk_pem: Cow<'a, str>,
        auth_pk: PrivateKey,
    ) -> Self {
        // Standard Windows Reader Icon
        let icon: &[u8] = Self::reader_icon();
        let reader: Reader<'_> = Reader {
            name: reader_name,
            icon: Icon::from(icon),
            device_type_id: DeviceTypeId::Tpm,
        };
        SmartCardInfo {
            container_name,
            pin,
            auth_cert_der,
            auth_pk_pem,
            auth_pk,
            reader,
        }
    }
}

/// Represents the resource manager context (the scope).
///
/// Currently, we support only one smart card per smart card context.
#[derive(Debug, Clone)]
pub struct ScardContext<'a> {
    smart_card_info: SmartCardInfo<'a>,
    cache: BTreeMap<String, Vec<u8>>,
}

impl<'a> ScardContext<'a> {
    /// Creates a new smart card based on the list of smart card readers
    pub fn new(smart_card_info: SmartCardInfo<'a>) -> WinScardResult<Self> {
        // Freshness values may vary at different points in time.
        // We do not need to change them in runtime, so we hardcode them here.
        // Those values do not mean anything special. They are just extracted from the real TPM smart card.
        const PIN_FRESHNESS: [u8; 2] = [0x00, 0x00];
        const CONTAINER_FRESHNESS: [u8; 2] = [0x01, 0x00];
        const FILE_FRESHNESS: [u8; 2] = [0x0b, 0x00];

        // The following header is formed based on the extracted information from the Windows Smart Card Minidriver (`msclmd.dll`).
        // Do not change it unless you know what you are doing.
        // A broken cache will break the entire authentication.
        const CACHE_ITEM_HEADER: [u8; 6] = {
            let mut header = [0; 6];

            // reference: msclmd!I_GetPIVCache
            header[0] = 1;
            header[1] = PIN_FRESHNESS[1];
            header[2] = CONTAINER_FRESHNESS[0] + 1;
            header[3] = CONTAINER_FRESHNESS[1];
            header[4] = FILE_FRESHNESS[0] + 1;
            header[5] = FILE_FRESHNESS[1];

            header
        };

        let mut cache = BTreeMap::new();
        cache.insert("Cached_CardProperty_Read Only Mode_0".into(), {
            let mut value = CACHE_ITEM_HEADER.to_vec();
            // unkown flags
            value.extend_from_slice(&[0, 0, 0, 0, 0, 0]);
            // actual data len
            value.extend_from_slice(&4_u32.to_le_bytes());
            // false
            value.extend_from_slice(&0_u32.to_le_bytes());

            value
        });
        cache.insert("Cached_CardProperty_Cache Mode_0".into(), {
            let mut value = CACHE_ITEM_HEADER.to_vec();
            // unkown flags
            value.extend_from_slice(&[0, 0, 0, 0, 0, 0]);
            // actual data len
            value.extend_from_slice(&4_u32.to_le_bytes());
            // true
            value.extend_from_slice(&1_u32.to_le_bytes());

            value
        });
        cache.insert("Cached_CardProperty_Supports Windows x.509 Enrollment_0".into(), {
            let mut value = CACHE_ITEM_HEADER.to_vec();
            // unkown flags
            value.extend_from_slice(&[0, 0, 0, 0, 0, 0]);
            // actual data len
            value.extend_from_slice(&4_u32.to_le_bytes());
            // true
            value.extend_from_slice(&1_u32.to_le_bytes());

            value
        });
        cache.insert("Cached_GeneralFile/mscp/cmapfile".into(), {
            let mut value = CACHE_ITEM_HEADER.to_vec();
            // unkown flags
            value.extend_from_slice(&[0, 0, 0, 0, 0, 0]);
            // actual data len: size_of<CONTAINER_MAP_RECORD>()
            // https://github.com/selfrender/Windows-Server-2003/blob/5c6fe3db626b63a384230a1aa6b92ac416b0765f/ds/security/csps/wfsccsp/inc/basecsp.h#L104-L110
            value.extend_from_slice(&86_u32.to_le_bytes());
            // CONTAINER_MAP_RECORD:
            let container = smart_card_info
                .container_name
                .as_ref()
                .encode_utf16()
                .chain(core::iter::once(0))
                .flat_map(|v| v.to_le_bytes())
                .collect::<Vec<_>>();
            value.extend_from_slice(&container); // wszGuid
            value.extend_from_slice(&[3, 0]); // bFlags
            value.extend_from_slice(&[0, 0]); // wSigKeySizeBits
            value.extend_from_slice(&[0, 8]); // wKeyExchangeKeySizeBits

            value
        });
        cache.insert("Cached_CardmodFile\\Cached_CMAPFile".into(), {
            // CONTAINER_MAP_RECORD:
            let mut value = smart_card_info
                .container_name
                .as_ref()
                .encode_utf16()
                .chain(core::iter::once(0))
                .flat_map(|v| v.to_le_bytes())
                .collect::<Vec<_>>(); // wszGuid
            value.extend_from_slice(&[3, 0]); // bFlags
            value.extend_from_slice(&[0, 0]); // wSigKeySizeBits
            value.extend_from_slice(&[0, 8]); // wKeyExchangeKeySizeBits

            value
        });
        cache.insert("Cached_ContainerProperty_PIN Identifier_0".into(), {
            let mut value = CACHE_ITEM_HEADER.to_vec();
            // unkown flags
            value.extend_from_slice(&[0, 0, 0, 0, 0, 0]);
            // actual data len
            value.extend_from_slice(&4_u32.to_le_bytes());
            // PIN identifier
            value.extend_from_slice(&1_u32.to_le_bytes());

            value
        });
        cache.insert("Cached_ContainerInfo_00".into(), {
            // Note. We can hardcode lengths values in this cache item because we support only 2048 RSA keys.
            // RSA 4096 is not defined in the specification so we don't support it.
            // https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-73-4.pdf#page=34
            // 5.3 Cryptographic Mechanism Identifiers
            // '07' - RSA 2048

            let mut value = CACHE_ITEM_HEADER.to_vec();
            // unkown flags
            value.extend_from_slice(&[0, 0, 0, 0, 0, 0]);
            // actual data len (precalculated)
            value.extend_from_slice(&292_u32.to_le_bytes());

            value.extend_from_slice(&[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x14, 0x01, 0x00, 0x00]); // container info header

            // https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/ns-wincrypt-publickeystruc
            // PUBLICKEYSTRUC
            value.push(0x06); // bType = PUBLICKEYBLOB
            value.push(0x02); // bVersion = 0x2
            value.extend_from_slice(&[0x00, 0x00]); // reserved
            value.extend_from_slice(&[0x00, 0xa4, 0x00, 0x00]); // aiKeyAlg = CALG_RSA_KEYX

            // https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/ns-wincrypt-rsapubkey
            // RSAPUBKEY
            value.extend_from_slice(b"RSA1"); // magic = RSA1
            value.extend_from_slice(&2048_u32.to_le_bytes()); // bitlen = 2048

            // let pub_key = smart_cards_info.
            let public_key = smart_card_info
                .auth_pk
                .to_public_key()
                .expect("rsa private key to public key");
            let public_key: &SubjectPublicKeyInfo = public_key.as_ref();
            let (modulus, public_exponent) = match &public_key.subject_public_key {
                PublicKey::Rsa(rsa) => (
                    {
                        let mut modulus = rsa.0.modulus.to_vec();
                        modulus.reverse();
                        modulus.resize(256, 0);
                        modulus
                    },
                    {
                        let mut pub_exp = rsa.0.public_exponent.to_vec();
                        pub_exp.reverse();
                        pub_exp.resize(4, 0);
                        pub_exp
                    },
                ),
                _ => {
                    return Err(Error::new(
                        ErrorKind::UnsupportedFeature,
                        "only RSA 2048 keys are supported",
                    ))
                }
            };

            value.extend_from_slice(&public_exponent); // pubexp
            value.extend_from_slice(&modulus); // public key

            value
        });
        cache.insert("Cached_GeneralFile/mscp/kxc00".into(), {
            let mut value = CACHE_ITEM_HEADER.to_vec();
            // unkown flags
            value.extend_from_slice(&[0, 0, 0, 0, 0, 0]);

            let mut compressed_cert = vec![0; smart_card_info.auth_cert_der.len()];
            let compressed = crate::compression::compress_cert(&smart_card_info.auth_cert_der, &mut compressed_cert)?;

            let total_value_len =
                (compressed.len() + 2 /* unknown flags */ + 2/* uncompressed certificate len */) as u32;
            value.extend_from_slice(&total_value_len.to_le_bytes());

            value.extend_from_slice(&[0x01, 0x00]); // flags that specify that the certificate is compressed
            value.extend_from_slice(&(smart_card_info.auth_cert_der.len() as u16).to_le_bytes()); // uncompressed certificate data len
            value.extend_from_slice(&compressed_cert);

            value
        });
        cache.insert("Cached_CardProperty_Capabilities_0".into(), {
            let mut value = CACHE_ITEM_HEADER.to_vec();
            // unkown flags
            value.extend_from_slice(&[0, 0, 0, 0, 0, 0]);
            // actual data len
            value.extend_from_slice(&12_u32.to_le_bytes());
            // Here should be the CARD_CAPABILITIES struct but the actual extracted data is different.
            // So, we just insert the extracted data from a real smart card.
            // Card capabilities:
            value.extend_from_slice(&[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]);

            value
        });

        cache.insert("Cached_CardProperty_Key Sizes_2".into(), {
            let mut value = CACHE_ITEM_HEADER.to_vec();
            // unkown flags
            value.extend_from_slice(&[0, 0, 0, 0, 0, 0]);
            // actual data len
            value.extend_from_slice(&20_u32.to_le_bytes());
            // https://learn.microsoft.com/en-us/previous-versions/windows/desktop/secsmart/card-key-sizes
            value.extend_from_slice(&[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]);
            value.extend_from_slice(&[
                1, 0, 0, 0, // dwVersion = 1
                0, 4, 0, 0, // dwMinimumBitlen = 1024
                0, 4, 0, 0, // dwDefaultBitlen = 1048
                0, 8, 0, 0, // dwMaximumBitlen = 2048
                0, 4, 0, 0, // dwIncrementalBitlen = 1024
            ]);

            value
        });

        cache.insert("Cached_CardProperty_Key Sizes_1".into(), {
            let mut value = CACHE_ITEM_HEADER.to_vec();
            // unkown flags
            value.extend_from_slice(&[0, 0, 0, 0, 0, 0]);
            // actual data len
            value.extend_from_slice(&20_u32.to_le_bytes());
            // https://learn.microsoft.com/en-us/previous-versions/windows/desktop/secsmart/card-key-sizes
            value.extend_from_slice(&[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]);
            value.extend_from_slice(&[
                1, 0, 0, 0, // dwVersion = 1
                0, 4, 0, 0, // dwMinimumBitlen = 1024
                0, 4, 0, 0, // dwDefaultBitlen = 1048
                0, 8, 0, 0, // dwMaximumBitlen = 2048
                0, 4, 0, 0, // dwIncrementalBitlen = 1024
            ]);

            value
        });

        cache.insert(
            "Cached_CardmodFile\\Cached_Pin_Freshness".into(),
            PIN_FRESHNESS.to_vec(),
        );
        cache.insert(
            "Cached_CardmodFile\\Cached_File_Freshness".into(),
            FILE_FRESHNESS.to_vec(),
        );
        cache.insert(
            "Cached_CardmodFile\\Cached_Container_Freshness".into(),
            CONTAINER_FRESHNESS.to_vec(),
        );

        Ok(Self { smart_card_info, cache })
    }

    /// Returns available smart card reader name.
    pub fn reader_name(&self) -> &str {
        self.smart_card_info.reader.name.as_ref()
    }
}

impl WinScardContext for ScardContext<'_> {
    fn connect(
        &self,
        reader_name: &str,
        _share_mode: ShareMode,
        _protocol: Option<Protocol>,
    ) -> WinScardResult<ScardConnectData> {
        if self.smart_card_info.reader.name != reader_name {
            return Err(Error::new(
                ErrorKind::UnknownReader,
                format!("reader {:?} not found", reader_name),
            ));
        }

        Ok(ScardConnectData {
            handle: Box::new(SmartCard::new(
                Cow::Owned(reader_name.to_owned()),
                self.smart_card_info.pin.clone(),
                self.smart_card_info.auth_cert_der.clone(),
                self.smart_card_info.auth_pk.clone(),
            )?),
            protocol: SUPPORTED_CONNECTION_PROTOCOL,
        })
    }

    fn list_readers(&self) -> WinScardResult<Vec<Cow<str>>> {
        Ok(vec![self.smart_card_info.reader.name.clone()])
    }

    fn device_type_id(&self, reader_name: &str) -> WinScardResult<DeviceTypeId> {
        if self.smart_card_info.reader.name != reader_name {
            return Err(Error::new(
                ErrorKind::UnknownReader,
                format!("reader {:?} not found", reader_name),
            ));
        }

        Ok(self.smart_card_info.reader.device_type_id)
    }

    fn reader_icon(&self, reader_name: &str) -> WinScardResult<Icon> {
        if self.smart_card_info.reader.name != reader_name {
            return Err(Error::new(
                ErrorKind::UnknownReader,
                format!("reader {:?} not found", reader_name),
            ));
        }

        Ok(self.smart_card_info.reader.icon.clone())
    }

    fn is_valid(&self) -> bool {
        true
    }

    fn read_cache(&self, _: Uuid, _: u32, key: &str) -> WinScardResult<Cow<[u8]>> {
        self.cache
            .get(key)
            .map(|item| Cow::Borrowed(item.as_slice()))
            .ok_or_else(|| Error::new(ErrorKind::CacheItemNotFound, format!("Cache item '{}' not found", key)))
    }

    fn write_cache(&mut self, _: Uuid, _: u32, key: String, value: Vec<u8>) -> WinScardResult<()> {
        self.cache.insert(key, value);

        Ok(())
    }

    fn list_reader_groups(&self) -> WinScardResult<Vec<Cow<str>>> {
        // We don't support configuring or introducing reader groups. So, we just return hardcoded values.
        //
        // https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardlistreadergroupsw
        // SCARD_DEFAULT_READERS: TEXT("SCard$DefaultReaders\000")
        // Default group to which all readers are added when introduced into the system.
        Ok(vec![Cow::Borrowed("SCard$DefaultReaders\u{0}00")])
    }

    fn cancel(&mut self) -> WinScardResult<()> {
        // https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardcancel
        // The only requests that you can cancel are those that require waiting for external action by the smart card or user.
        //
        // We don't have any external actions, so we just return success.
        Ok(())
    }

    fn get_status_change(&mut self, _timeout: u32, reader_states: &mut [ReaderState]) -> WinScardResult<()> {
        use crate::ATR;

        let supported_readers = self.list_readers()?;

        for reader_state in reader_states {
            if supported_readers.contains(&reader_state.reader_name) {
                reader_state.event_state = CurrentState::SCARD_STATE_UNNAMED_CONSTANT
                    | CurrentState::SCARD_STATE_INUSE
                    | CurrentState::SCARD_STATE_PRESENT
                    | CurrentState::SCARD_STATE_CHANGED;
                reader_state.atr[0..ATR.len()].copy_from_slice(&ATR);
                reader_state.atr_len = ATR.len();
            } else if reader_state.reader_name.as_ref() == NEW_READER_NOTIFICATION {
                reader_state.event_state = CurrentState::SCARD_STATE_UNNAMED_CONSTANT;
            } else {
                error!(?reader_state.reader_name, "Unsupported reader");
            }
        }

        Ok(())
    }

    fn list_cards(&self, _atr: Option<&[u8]>, _required_interfaces: Option<&[Uuid]>) -> WinScardResult<Vec<Cow<str>>> {
        // we have only one smart card with only one default name
        Ok(vec![DEFAULT_CARD_NAME.into()])
    }

    fn get_card_type_provider_name(&self, _card_name: &str, provider_id: ProviderId) -> WinScardResult<Cow<str>> {
        Ok(match provider_id {
            ProviderId::Primary => {
                return Err(Error::new(
                    ErrorKind::UnsupportedFeature,
                    "ProviderId::Primary is not supported for emulated smart card",
                ))
            }
            ProviderId::Csp => MICROSOFT_DEFAULT_CSP.into(),
            ProviderId::Ksp => MICROSOFT_DEFAULT_KSP.into(),
            ProviderId::CardModule => MICROSOFT_SCARD_DRIVER_LOCATION.into(),
        })
    }
}


--- File: crates/winscard/src/tlv_tags.rs ---
/// BER-TLV with the tag `0x53` containing in the value field of the
/// requested data object.
pub const DATA: u8 = 0x53;
/// [FASC-N](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-73-4.pdf#page=36).
pub const FASC_N: u8 = 0x30;
/// [GUID](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-73-4.pdf#page=36).
pub const GUID: u8 = 0x34;
/// [Expiration Date](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-73-4.pdf#page=36).
pub const EXPIRATION_DATE: u8 = 0x35;
/// [Issuer Asymmetric Signature](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-73-4.pdf#page=36).
pub const ISSUER_SIGNATURE: u8 = 0x3E;
/// [Error Detection Code](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-73-4.pdf#page=39).
pub const ERROR_DETECTION_CODE: u8 = 0xFE;
/// [PIV Card Application Property Template](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-73-4.pdf#page=84).
pub const APPLICATION_PROPERTY_TEMPLATE: u8 = 0x61;
/// [PIV Card Application AID](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-73-4.pdf#page=36).
pub const APPLICATION_IDENTIFIER: u8 = 0x4F;
/// [Coexistent Tag Allocation Authority Template](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-73-4.pdf#page=84).
pub const COEXISTING_TAG_ALLOCATION_AUTHORITY: u8 = 0x79;
/// [Tag list](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-73-4.pdf#page=85).
pub const TAG_LIST: u8 = 0x5C;
/// [Certificate](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-73-4.pdf#page=40).
pub const CERTIFICATE: u8 = 0x70;
/// [CertInfo](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-73-4.pdf#page=40).
pub const CERT_INFO: u8 = 0x71;
/// [Dynamic Authentication Template](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-73-4.pdf#page=93).
pub const DYNAMIC_AUTHENTICATION_TEMPLATE: u8 = 0x7C;
/// [Challenge](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-73-4.pdf#page=93).
pub const DAT_CHALLENGE: u8 = 0x81;
/// [Response](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-73-4.pdf#page=93).
pub const DAT_RESPONSE: u8 = 0x82;


--- File: crates/winscard/src/winscard.rs ---
use alloc::borrow::Cow;
use alloc::boxed::Box;
use alloc::format;
use alloc::string::String;
use alloc::vec::Vec;

use bitflags::bitflags;
use num_derive::{FromPrimitive, ToPrimitive};
use uuid::Uuid;

use crate::{Error, ErrorKind, WinScardResult};

/// Control code for the `SCardControl` operation.
///
/// This value identifies the specific operation to be performed. More info:
/// * [WinSCard SCardControl](https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardcontrol).
/// * [pcsc-lite SCardControl](https://pcsclite.apdu.fr/api/group__API.html#gac3454d4657110fd7f753b2d3d8f4e32f).
pub type ControlCode = u32;

/// Action to be taken on the reader.
///
/// More info:
/// * [SCardEndTransaction](https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardendtransaction).
/// * [SCardReconnect](https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardreconnect).
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[repr(u32)]
pub enum ReaderAction {
    /// Do not do anything special.
    LeaveCard = 0,
    /// Reset the card.
    ResetCard = 1,
    /// Power down the card.
    UnpowerCard = 2,
    /// Eject the card.
    EjectCard = 3,
}

impl TryFrom<u32> for ReaderAction {
    type Error = Error;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        Ok(match value {
            0 => ReaderAction::LeaveCard,
            1 => ReaderAction::ResetCard,
            2 => ReaderAction::UnpowerCard,
            3 => ReaderAction::EjectCard,
            _ => {
                return Err(Error::new(
                    ErrorKind::InvalidParameter,
                    format!("Gow invalid disposition value: {}", value),
                ))
            }
        })
    }
}

impl From<ReaderAction> for u32 {
    fn from(value: ReaderAction) -> Self {
        value as u32
    }
}

impl From<ReaderAction> for u64 {
    fn from(value: ReaderAction) -> Self {
        value as u64
    }
}

/// A smart card attribute id.
///
/// This enum represents a scard attribute id. A set of variants is formed by merging `WinSCard` attr ids and `pscsc-lite` attr ids.
/// More info:
/// * [WinSCard SCardGetAttrib](https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardgetattrib).
/// * [pcsc-lite SCardGetAttrib](https://pcsclite.apdu.fr/api/group__API.html#gaacfec51917255b7a25b94c5104961602).
#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, FromPrimitive, ToPrimitive)]
#[repr(u32)]
pub enum AttributeId {
    /// <https://pcsclite.apdu.fr/api/reader_8h.html#a2e87e6925548b9fcca3fa0026b82500d>
    AsyncProtocolTypes = 0x0120,
    /// Answer to reset (ATR) string.
    AtrString = 0x0303,
    /// Channel id.
    ///
    /// See [SCardGetAttrib](https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardgetattrib) for more details.
    ChannelId = 0x0110,
    /// DWORD indicating which mechanical characteristics are supported. If zero, no special characteristics are supported.
    Characteristics = 0x0150,
    /// Current block waiting time.
    CurrentBwt = 0x0209,
    /// Current clock rate, in kHz.
    CurrentClk = 0x0202,
    /// Current character waiting time.
    CurrentCwt = 0x020a,
    /// Bit rate conversion factor.
    CurrentD = 0x0204,
    /// Current error block control encoding.
    CurrentEbcEncoding = 0x020b,
    /// Clock conversion factor.
    CurrentF = 0x0203,
    /// Current byte size for information field size card.
    CurrentIfsc = 0x0207,
    /// Current byte size for information field size device.
    CurrentIfsd = 0x0208,
    /// <https://pcsclite.apdu.fr/api/reader_8h.html#a9c6ee3dccc23e924907e3dc2e29a50f6>
    CurrentIoState = 0x0302,
    /// Current guard time.
    CurrentN = 0x0205,
    /// DWORD encoded as 0x0rrrpppp where rrr is RFU and should be 0x000. pppp encodes the current protocol type.
    /// Whichever bit has been set indicates which ISO protocol is currently in use. (For example, if bit zero is set,
    /// T=0 protocol is in effect.)
    CurrentProtocolType = 0x0201,
    /// Current work waiting time.
    CurrentW = 0x0206,
    /// Default clock rate, in kHz.
    DefaultClk = 0x0121,
    /// Default data rate, in bps.
    DefaultDataRate = 0x0123,
    /// Reader's display name.
    DeviceFriendlyName = 0x0003,
    /// Reader's display name but encoded in Wide string.
    DeviceFriendlyNameW = 0x0005,
    /// Reserved for future use.
    DeviceInUse = 0x0002,
    /// Reader's system name.
    DeviceSystemName = 0x0004,
    /// Reader's system name.
    DeviceSystemNameW = 0x0006,
    /// Instance of this vendor's reader attached to the computer. The first instance will be device unit 0,
    /// the next will be unit 1 (if it is the same brand of reader) and so on. Two different brands of readers
    /// will both have zero for this value.
    DeviceUnit = 0x0001,
    /// <https://pcsclite.apdu.fr/api/reader_8h.html#a1a1d31628ec9f49f79d2dda6651658d6>
    EscAuhRequest = 0xA005,
    /// <https://pcsclite.apdu.fr/api/reader_8h.html#a69d8dd84f5f433efbfa6e0fce2a95528>
    EscCancel = 0xA003,
    /// <https://pcsclite.apdu.fr/api/reader_8h.html#a55df7896fb65a2a942780d383d815071>
    EscReset = 0xA000,
    /// <https://pcsclite.apdu.fr/api/reader_8h.html#a5fcd5c979018130c164a64c728f0716d>
    ExtendedBt = 0x020c,
    /// Single byte. Zero if smart card electrical contact is not active; nonzero if contact is active.
    IccInterfaceStatus = 0x0301,
    /// Single byte indicating smart card presence.
    IccPresence = 0x0300,
    /// Single byte indicating smart card type.
    IccTypePerAtr = 0x0304,
    /// Maximum clock rate, in kHz.
    MaxClk = 0x0122,
    /// Maximum data rate, in bps.
    MaxDataRate = 0x0124,
    /// Maximum bytes for information file size device.
    MaxIfsd = 0x0125,
    /// <https://pcsclite.apdu.fr/api/reader_8h.html#a42ea634deb1ec51e10722b661aa73d01>
    MaxInput = 0xA007,
    /// Zero if device does not support power down while smart card is inserted. Nonzero otherwise.
    PowerMgmtSupport = 0x0131,
    /// <https://pcsclite.apdu.fr/api/reader_8h.html#a62d09db2a45663ea726239aeafaac747>
    SupresT1IfsRequest = 0x0007,
    /// DWORD encoded as 0x0rrrpppp where rrr is RFU and should be 0x000. pppp encodes the supported
    /// protocol types. A '1' in a given bit position indicates support for the associated ISO protocol,
    /// so if bits zero and one are set, both T=0 and T=1 protocols are supported.
    SyncProtocolTypes = 0x0126,
    /// <https://pcsclite.apdu.fr/api/reader_8h.html#a86eb3bba6a8a463aa0eac4ada7704785>
    UserAuthInputDevice = 0x0142,
    /// <https://pcsclite.apdu.fr/api/reader_8h.html#a60bf2dbb950d448099314aa86c14b2aa>
    UserToCardAuthDevice = 0x0140,
    /// Vendor-supplied interface device serial number.
    VendorIfdSerialNo = 0x0103,
    /// Vendor-supplied interface device type (model designation of reader).
    VendorIfdType = 0x0101,
    /// Vendor-supplied interface device version (DWORD in the form 0xMMmmbbbb where MM = major version,
    /// mm = minor version, and bbbb = build number).
    VendorIfdVersion = 0x0102,
    /// Vendor name.
    VendorName = 0x0100,
}

/// ATR string.
///
/// A sequence of bytes returned from a smart card when it is turned on.
/// These bytes are used to identify the card to the system.
///
/// [SCardStatusW](https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardstatusw)
/// `pbAtr` parameter:
/// A 32-byte buffer that holds the ATR string from the currently inserted card.
/// Note: 32 is a maximum ATR string len. In reality, the original Windows TPM smart card always returns 17-bytes len ATR string.
#[derive(Debug, Clone)]
pub struct Atr(Vec<u8>);

impl AsRef<[u8]> for Atr {
    fn as_ref(&self) -> &[u8] {
        self.0.as_slice()
    }
}

impl From<Vec<u8>> for Atr {
    fn from(value: Vec<u8>) -> Self {
        Self(value)
    }
}

impl From<[u8; 17]> for Atr {
    fn from(value: [u8; 17]) -> Self {
        Self(value.into())
    }
}

/// A buffer that contains a BLOB of the smart card reader icon as read from the icon file.
#[derive(Debug, Clone)]
pub struct Icon<'a>(Cow<'a, [u8]>);

impl AsRef<[u8]> for Icon<'_> {
    fn as_ref(&self) -> &[u8] {
        self.0.as_ref()
    }
}

impl<'a> From<&'a [u8]> for Icon<'a> {
    fn from(value: &'a [u8]) -> Self {
        Self(Cow::Borrowed(value))
    }
}

impl From<Vec<u8>> for Icon<'_> {
    fn from(value: Vec<u8>) -> Self {
        Self(Cow::Owned(value))
    }
}

/// [SCardGetDeviceTypeIdW](https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardgetdevicetypeidw)
/// The actual device type identifier. The list of reader types returned
/// by this function are listed under ReaderType member in the SCARD_READER_CAPABILITIES structure.
///
/// [SCARD_READER_CAPABILITIES](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/smclib/ns-smclib-_scard_reader_capabilities)
/// `ReaderType` parameter:
/// This member contains the reader type and is required. This member can have one of the values in the following table.
#[repr(u32)]
#[derive(Debug, Copy, Clone, FromPrimitive, ToPrimitive)]
pub enum DeviceTypeId {
    /// Serial reader
    Serial = 0x01,
    /// Parallel reader
    Paralell = 0x02,
    /// Keyboard-attached reader
    Keyboard = 0x04,
    /// SCSI reader
    Scsi = 0x08,
    /// IDE reader
    Ide = 0x10,
    /// USB reader
    Usb = 0x20,
    /// PCMCIA reader
    Pcmcia = 0x40,
    /// Reader that uses a TPM chip for key material storage and cryptographic operations
    Tpm = 0x80,
    /// Reader that uses a proprietary vendor bus
    Vendor = 0xf0,
}

impl From<DeviceTypeId> for u32 {
    fn from(value: DeviceTypeId) -> Self {
        value as u32
    }
}

/// [SCardEstablishContext](https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardestablishcontext)
///
/// `dwScope` parameter:
/// Scope of the resource manager context.
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum ScardScope {
    /// Database operations are performed within the domain of the user.
    User = 0,
    /// Database operations are performed within the domain of the system.
    /// The calling application must have appropriate access permissions for any database actions.
    System = 2,
}

impl TryFrom<u32> for ScardScope {
    type Error = Error;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        Ok(match value {
            0 => Self::User,
            2 => Self::System,
            _ => {
                return Err(Error::new(
                    ErrorKind::InvalidParameter,
                    format!("Invalid ScardScope value: {}", value),
                ))
            }
        })
    }
}

impl From<ScardScope> for u32 {
    fn from(value: ScardScope) -> Self {
        value as u32
    }
}

impl From<ScardScope> for u64 {
    fn from(value: ScardScope) -> Self {
        value as u64
    }
}

/// [SCardConnectW](https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardconnectw)
///
/// `dwShareMode` parameter:
/// A flag that indicates whether other applications may form connections to the card.
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum ShareMode {
    /// This application is not willing to share the card with other applications.
    Exclusive = 1,
    /// This application is willing to share the card with other applications.
    Shared = 2,
    /// This application is allocating the reader for its private use, and will be controlling it directly.
    /// No other applications are allowed access to it.
    Direct = 3,
}

impl From<ShareMode> for u32 {
    fn from(value: ShareMode) -> Self {
        value as u32
    }
}

impl From<ShareMode> for u64 {
    fn from(value: ShareMode) -> Self {
        value as u64
    }
}

impl TryFrom<u32> for ShareMode {
    type Error = Error;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            1 => Ok(Self::Exclusive),
            2 => Ok(Self::Shared),
            3 => Ok(Self::Direct),
            _ => Err(Error::new(
                ErrorKind::InvalidParameter,
                format!("Invalid ShareMode value: {}", value),
            )),
        }
    }
}

bitflags! {
    /// [SCardConnectW](https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardconnectw)
    ///
    /// `dwPreferredProtocols` and `pdwActiveProtocol` parameters:
    /// A bitmask of acceptable protocols for the connection.
    /// Possible values may be combined with the OR operation.
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Default)]
    pub struct Protocol: u32 {
        /// This parameter may be zero only if dwShareMode is set to SCARD_SHARE_DIRECT.
        /// In this case, no protocol negotiation will be performed by the drivers
        /// until an IOCTL_SMARTCARD_SET_PROTOCOL control directive is sent with SCardControl.
        const UNDEFINED = 0x00000000;
        /// The ISO 7816/3 T=0 protocol is in use.
        /// An asynchronous, character-oriented half-duplex transmission protocol.
        const T0 = 0x00000001;
        /// The ISO 7816/3 T=1 protocol is in use.
        /// An asynchronous, block-oriented half-duplex transmission protocol.
        const T1 = 0x00000002;
        /// The Raw Transfer protocol is in use.
        /// This flags can be used **only** in the `SCardStatusA/W` function in the `pdwProtocol` parameter.
        const Raw = 0x00010000;
    }
}

/// [SCardStatusW](https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardstatusw)
///
/// `pdwState` parameter:
/// Current state of the smart card in the reader. Upon success, it receives one of the following state indicators.
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum State {
    /// Unknown smart card status.
    Unknown = 0,
    /// There is no card in the reader.
    Absent = 1,
    /// There is a card in the reader, but it has not been moved into position for use.
    Present = 2,
    /// There is a card in the reader in position for use. The card is not powered.
    Swallowed = 3,
    /// Power is being provided to the card, but the reader driver is unaware of the mode of the card.
    Powered = 4,
    /// The card has been reset and is awaiting PTS negotiation.
    Negotiable = 5,
    /// The card has been reset and specific communication protocols have been established.
    Specific = 6,
}

impl TryFrom<u32> for State {
    type Error = Error;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        Ok(match value {
            0 => State::Unknown,
            1 => State::Absent,
            2 => State::Present,
            3 => State::Swallowed,
            4 => State::Powered,
            5 => State::Negotiable,
            6 => State::Specific,
            _ => {
                return Err(Error::new(
                    ErrorKind::InternalError,
                    format!("Invalid State value: {}", value),
                ))
            }
        })
    }
}

impl From<State> for u32 {
    fn from(value: State) -> Self {
        value as u32
    }
}

/// This structure described the current status and basic info about the smart card reader.
#[derive(Debug, Clone)]
pub struct Status<'a> {
    /// List of display names (multiple string) by which the currently connected reader is known.
    pub readers: Vec<Cow<'a, str>>,
    /// Current state of the smart card in the reader.
    pub state: State,
    /// Current protocol, if any. The returned value is meaningful only if the returned value of pdwState is `SCARD_SPECIFICMODE`.
    pub protocol: Protocol,
    /// Buffer that receives the ATR string from the currently inserted card, if available.
    ///
    /// [ATR string](https://learn.microsoft.com/en-us/windows/win32/secgloss/a-gly).
    pub atr: Atr,
}

impl Status<'_> {
    /// Returns owned [Status].
    pub fn into_owned(self) -> Status<'static> {
        let Status {
            atr,
            readers,
            protocol,
            state,
        } = self;

        Status {
            readers: readers.into_iter().map(|r| r.into_owned().into()).collect(),
            state,
            protocol,
            atr,
        }
    }
}

/// [SCARD_IO_REQUEST](https://learn.microsoft.com/en-us/windows/win32/secauthn/scard-io-request)
///
/// The SCARD_IO_REQUEST structure begins a protocol control information structure.
/// Any protocol-specific information then immediately follows this structure.
///
/// ```not_rust
/// typedef struct {
///   DWORD dwProtocol;
///   DWORD cbPciLength;
/// } SCARD_IO_REQUEST;
/// ```
#[derive(Debug, Clone)]
pub struct IoRequest {
    /// Protocol in use.
    pub protocol: Protocol,
    /// PCI-specific information.
    pub pci_info: Vec<u8>,
}

/// This structure represents the result of the `SCardTransmit` function.
#[derive(Debug, Clone)]
pub struct TransmitOutData {
    /// Data returned from the card. If no data is returned from the card,
    /// then this buffer will only contain the SW1 and SW2 status bytes.
    pub output_apdu: Vec<u8>,
    /// Returned protocol control information (PCI) specific to the protocol in use.
    pub receive_pci: Option<IoRequest>,
}

/// This structure represents the result of the `SCardConnect` function.
pub struct ScardConnectData {
    /// Established smart card handle.
    pub handle: Box<dyn WinScard>,
    /// Established protocol to this connection.
    pub protocol: Protocol,
}

bitflags! {
    /// [SCardGetStatusChangeW](https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardgetstatuschangew)
    ///
    /// Current state of the reader, as seen by the application. This field can take on any of the following values,
    /// in combination, as a bitmask.
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Default)]
    pub struct CurrentState: u32 {
        /// The application is unaware of the current state, and would like to know.
        const SCARD_STATE_UNAWARE = 0;
        /// The application is not interested in this reader, and it should not be considered during monitoring operations.
        /// If this bit value is set, all other bits are ignored.
        const SCARD_STATE_IGNORE = 1;
        /// There is a difference between the state believed by the application, and the state known by the resource manager.
        /// When this bit is set, the application may assume a significant state change has occurred on this reader.
        const SCARD_STATE_CHANGED = 2;
        /// The given reader name is not recognized by the resource manager. If this bit is set, then SCARD_STATE_CHANGED
        /// and SCARD_STATE_IGNORE will also be set.
        const SCARD_STATE_UNKNOWN = 4;
        /// The application expects that this reader is not available for use. If this bit is set,
        /// then all the following bits are ignored.
        const SCARD_STATE_UNAVAILABLE = 8;
        /// The application expects that there is no card in the reader. If this bit is set, all the following bits are ignored.
        const SCARD_STATE_EMPTY = 16;
        /// The application expects that there is a card in the reader.
        const SCARD_STATE_PRESENT = 32;
        /// The application expects that there is a card in the reader with an ATR that matches one of the target cards.
        /// If this bit is set, SCARD_STATE_PRESENT is assumed. This bit has no meaning to SCardGetStatusChange beyond
        /// SCARD_STATE_PRESENT.
        const SCARD_STATE_ATRMATCH = 64;
        /// The application expects that the card in the reader is allocated for exclusive use by another application.
        /// If this bit is set, SCARD_STATE_PRESENT is assumed.
        const SCARD_STATE_EXCLUSIVE = 128;
        /// The application expects that the card in the reader is in use by one or more other applications,
        /// but may be connected to in shared mode. If this bit is set, SCARD_STATE_PRESENT is assumed.
        const SCARD_STATE_INUSE = 256;
        /// The application expects that there is an unresponsive card in the reader.
        const SCARD_STATE_MUTE = 512;
        /// This implies that the card in the reader has not been powered up.
        const SCARD_STATE_UNPOWERED = 1024;
        /// Undocumented constant that appears in all API captures.
        const SCARD_STATE_UNNAMED_CONSTANT = 0x00010000;
    }
}

/// The `SCARD_READERSTATEW` structure is used by functions for tracking smart cards within readers.
///
/// [SCARD_READERSTATEW](https://learn.microsoft.com/en-us/windows/win32/api/winscard/ns-winscard-scard_readerstatew).
#[derive(Debug, Clone)]
pub struct ReaderState<'data> {
    /// The name of the reader being monitored.
    pub reader_name: Cow<'data, str>,
    /// Not used by the smart card subsystem. This member is used by the application.
    pub user_data: usize,
    /// Current state of the reader, as seen by the application.
    pub current_state: CurrentState,
    /// Current state of the reader, as known by the smart card resource manager.
    pub event_state: CurrentState,
    /// Number of bytes in the returned ATR.
    pub atr_len: usize,
    /// ATR of the inserted card, with extra alignment bytes.
    pub atr: [u8; 36],
}

/// Identifier for the provider associated with the card type.
///
/// [SCardGetCardTypeProviderNameW](https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardgetcardtypeprovidernamew)
/// `dwProviderId` parameter.
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum ProviderId {
    /// `SCARD_PROVIDER_PRIMARY`: The function retrieves the name of the smart card's primary service provider as a GUID string.
    Primary = 1,
    /// `SCARD_PROVIDER_CSP`: The function retrieves the name of the cryptographic service provider.
    Csp = 2,
    /// `SCARD_PROVIDER_KSP`: The function retrieves the name of the smart card key storage provider (KSP).
    Ksp = 3,
    /// `SCARD_PROVIDER_CARD_MODULE`: The function retrieves the name of the card module.
    CardModule = 0x80000001,
}

impl TryFrom<u32> for ProviderId {
    type Error = Error;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        Ok(match value {
            1 => ProviderId::Primary,
            2 => ProviderId::Csp,
            3 => ProviderId::Ksp,
            0x80000001 => ProviderId::CardModule,
            _ => {
                return Err(Error::new(
                    ErrorKind::InvalidParameter,
                    format!("Invalid provider id: {}", value),
                ))
            }
        })
    }
}

impl From<ProviderId> for u32 {
    fn from(value: ProviderId) -> Self {
        value as u32
    }
}

/// This trait provides interface for all available smart card related functions in the `winscard.h`.
///
/// # MSDN
///
/// * [winscard.h](https://learn.microsoft.com/en-us/windows/win32/api/winscard/)
pub trait WinScard {
    /// [SCardStatusW](https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardstatusw)
    ///
    /// The SCardStatus function provides the current status of a smart card in a reader.
    /// You can call it any time after a successful call to `SCardConnect` and before a successful
    /// call to `SCardDisconnect`. It does not affect the state of the reader or reader driver.
    fn status(&self) -> WinScardResult<Status>;

    /// [SCardControl](https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardcontrol)
    ///
    /// The SCardControl function gives you direct control of the reader.
    /// You can call it any time after a successful call to SCardConnect and before a successful call to SCardDisconnect.
    /// The effect on the state of the reader depends on the control code.
    /// This method assumes that there is no output data. Otherwise, then use the [WinScard::control_with_output] method.
    fn control(&mut self, code: ControlCode, input: &[u8]) -> WinScardResult<()>;

    /// [SCardControl](https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardcontrol)
    ///
    /// This function does the same as the [WinScard::control] but allows the used to pass a buffer for
    /// the operation's output data. The returned value is the number of bytes written to the output buffer.
    fn control_with_output(&mut self, code: ControlCode, input: &[u8], output: &mut [u8]) -> WinScardResult<usize>;

    /// [SCardTransmit](https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardtransmit)
    ///
    /// The SCardTransmit function sends a service request to the smart card and expects to receive data back from the card.
    fn transmit(&mut self, input_apdu: &[u8]) -> WinScardResult<TransmitOutData>;

    /// [SCardBeginTransaction](https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardbegintransaction)
    ///
    /// The SCardBeginTransaction function starts a transaction.
    /// The function waits for the completion of all other transactions before it begins.
    /// After the transaction starts, all other applications are blocked from accessing the smart card while the transaction is in progress.
    fn begin_transaction(&mut self) -> WinScardResult<()>;

    /// [SCardEndTransaction](https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardendtransaction)
    ///
    /// The SCardEndTransaction function completes a previously declared transaction,
    /// allowing other applications to resume interactions with the card.
    fn end_transaction(&mut self, disposition: ReaderAction) -> WinScardResult<()>;

    /// [SCardReconnect](https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardreconnect)
    ///
    /// The SCardReconnect function reestablishes an existing connection between the calling application and a smart card.
    /// This function moves a card handle from direct access to general access, or acknowledges and clears an error condition that is preventing further access to the card.
    fn reconnect(
        &mut self,
        share_mode: ShareMode,
        preferred_protocol: Option<Protocol>,
        initialization: ReaderAction,
    ) -> WinScardResult<Protocol>;

    /// [SCardGetAttrib](https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardgetattrib)
    ///
    /// The SCardGetAttrib function retrieves the current reader attributes for the given handle.
    /// It does not affect the state of the reader, driver, or card.
    fn get_attribute(&self, attribute_id: AttributeId) -> WinScardResult<Cow<[u8]>>;

    /// [SCardSetAttrib](https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardsetattrib)
    ///
    /// The SCardSetAttrib function sets the given reader attribute for the given handle. It does not affect
    /// the state of the reader, reader driver, or smart card. Not all attributes are supported
    /// by all readers (nor can they be set at all times) as many of the attributes are under direct control of the transport protocol.
    fn set_attribute(&mut self, attribute_id: AttributeId, attribute_data: &[u8]) -> WinScardResult<()>;

    /// [SCardDisconnect](https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scarddisconnect)
    ///
    /// The SCardDisconnect function terminates a connection previously opened between the calling application and
    /// a smart card in the target reader.
    fn disconnect(&mut self, disposition: ReaderAction) -> WinScardResult<()>;
}

/// This trait provides interface for all available smart card context (resource manager) related
/// functions in the `winscard.h`.
///
/// # MSDN
///
/// * [winscard.h](https://learn.microsoft.com/en-us/windows/win32/api/winscard/)
pub trait WinScardContext {
    /// [SCardConnectW](https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardconnectw)
    ///
    /// The SCardConnect function establishes a connection (using a specific resource manager context) between
    /// the calling application and a smart card contained by a specific reader.
    /// If no card exists in the specified reader, an error is returned.
    fn connect(
        &self,
        reader_name: &str,
        share_mode: ShareMode,
        protocol: Option<Protocol>,
    ) -> WinScardResult<ScardConnectData>;

    /// [SCardListReadersW](https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardlistreadersw)
    ///
    /// Provides the list of readers within a set of named reader groups, eliminating duplicates.
    fn list_readers(&self) -> WinScardResult<Vec<Cow<str>>>;

    /// [SCardListCardsW](https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardlistcardsw)
    ///
    /// The SCardListCards function searches the smart card database and provides a list of named cards previously
    /// introduced to the system by the user.
    fn list_cards(&self, atr: Option<&[u8]>, required_interfaces: Option<&[Uuid]>) -> WinScardResult<Vec<Cow<str>>>;

    /// [SCardGetDeviceTypeIdW](https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardgetdevicetypeidw)
    ///
    /// Gets the device type identifier of the card reader for the given reader name.
    /// This function does not affect the state of the reader.
    fn device_type_id(&self, reader_name: &str) -> WinScardResult<DeviceTypeId>;

    /// [SCardGetReaderIconW](https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardgetreadericonw)
    ///
    /// The SCardGetReaderIcon function gets an icon of the smart card reader for a given reader's name.
    /// This function does not affect the state of the card reader.
    fn reader_icon(&self, reader_name: &str) -> WinScardResult<Icon>;

    /// [SCardIsValidContext](https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardisvalidcontext)
    ///
    /// The SCardIsValidContext function determines whether a smart card context handle is valid.
    fn is_valid(&self) -> bool;

    /// [SCardReadCacheW](https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardreadcachew)
    ///
    /// The SCardReadCache function retrieves the value portion of a name-value pair from the global cache maintained by the Smart Card Resource Manager.
    fn read_cache(&self, card_id: Uuid, freshness_counter: u32, key: &str) -> WinScardResult<Cow<[u8]>>;

    /// [SCardWriteCacheW](https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardwritecachew)
    ///
    /// The SCardWriteCache function writes a name-value pair from a smart card to the global cache maintained by the Smart Card Resource Manager.
    fn write_cache(&mut self, card_id: Uuid, freshness_counter: u32, key: String, value: Vec<u8>)
        -> WinScardResult<()>;

    /// [SCardListReaderGroupsW](https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardlistreadergroupsw)
    ///
    /// The SCardListReaderGroups function provides the list of reader groups that have previously been introduced to the system.
    fn list_reader_groups(&self) -> WinScardResult<Vec<Cow<str>>>;

    /// [SCardCancel](https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardcancel)
    ///
    /// The SCardCancel function terminates all outstanding actions within a specific resource manager context.
    /// The only requests that you can cancel are those that require waiting for external action by the smart card or user.
    /// Any such outstanding action requests will terminate with a status indication that the action was canceled.
    fn cancel(&mut self) -> WinScardResult<()>;

    /// [SCardGetStatusChangeW](https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardgetstatuschangew)
    ///
    /// The SCardGetStatusChange function blocks execution until the current availability of the cards in a specific set of readers changes.
    fn get_status_change(&mut self, timeout: u32, reader_states: &mut [ReaderState]) -> WinScardResult<()>;

    /// [SCardGetCardTypeProviderNameW](https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardgetcardtypeprovidernamew)
    ///
    /// The SCardGetCardTypeProviderName function returns the name of the module (dynamic link library) that contains the provider for
    /// a given card name and provider type.
    fn get_card_type_provider_name(&self, card_name: &str, provider_id: ProviderId) -> WinScardResult<Cow<str>>;
}


--- File: examples/client.rs ---
// Based on the SSPI client example from MSDN: https://docs.microsoft.com/en-us/windows/win32/secauthn/using-sspi-with-a-windows-sockets-client

// This example works with the server example using SSPI. The client and server examples are designed to work together.
// This example demonstrates initializing an authenticating SSPI session with the NTLM, connecting with a server, establishing
// a secure communication session, receiving and decrypting a message from the server within the secure session.

use std::io;
use std::net::TcpStream;

use byteorder::{LittleEndian, ReadBytesExt, WriteBytesExt};
use sspi::{
    AuthIdentity, BufferType, ClientRequestFlags, CredentialUse, DataRepresentation, Ntlm, SecurityBuffer,
    SecurityBufferRef, SecurityStatus, Sspi, SspiImpl, Username,
};

const IP: &str = "127.0.0.1:8080";

fn main() -> Result<(), io::Error> {
    let mut stream = TcpStream::connect(IP).expect("Failed to connect to the server");

    println!("Connected to the server.");

    let mut ntlm = Ntlm::new();

    let account_name = whoami::username();
    let computer_name = whoami::fallible::hostname().unwrap();
    let username =
        Username::new(&account_name, Some(&computer_name)).map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;

    let identity = AuthIdentity {
        username,
        password: String::from("password").into(),
    };

    do_authentication(&mut ntlm, &identity, &mut stream).expect("Failed to authenticate connection");
    println!("Authenticated!");

    let mut trailer = Vec::new();

    // By agreement, the server encrypted the message and set the size
    // of the trailer block to be just what it needed. decrypt_message
    // needs the size of the trailer block.
    //
    // By agreement, the server placed the trailer at the beginning
    // of the message, and the data comes after the trailer.
    println!("Receiving the trailer...");
    read_message(&mut stream, &mut trailer)?;

    let mut data = Vec::new();
    println!("Receiving the data...");
    read_message(&mut stream, &mut data)?;

    println!("Encrypted message: {:?}", data);

    let mut msg_buffer = vec![
        SecurityBufferRef::token_buf(&mut trailer),
        SecurityBufferRef::data_buf(&mut data),
    ];

    let _decryption_flags = ntlm.decrypt_message(&mut msg_buffer, 0)?;

    println!("Decrypting...");
    println!(
        "Decrypted message: [{}]",
        std::str::from_utf8(msg_buffer[1].data()).unwrap()
    );

    println!("Communication successfully finished.");

    Ok(())
}

fn do_authentication(ntlm: &mut Ntlm, identity: &AuthIdentity, mut stream: &mut TcpStream) -> Result<(), io::Error> {
    let mut acq_cred_result = ntlm
        .acquire_credentials_handle()
        .with_credential_use(CredentialUse::Outbound)
        .with_auth_data(identity)
        .execute(ntlm)?;

    let mut output_buffer = vec![SecurityBuffer::new(Vec::new(), BufferType::Token)];
    let username = whoami::username();

    let mut builder = ntlm
        .initialize_security_context()
        .with_credentials_handle(&mut acq_cred_result.credentials_handle)
        .with_context_requirements(ClientRequestFlags::CONFIDENTIALITY | ClientRequestFlags::ALLOCATE_MEMORY)
        .with_target_data_representation(DataRepresentation::Native)
        .with_target_name(username.as_str())
        .with_output(&mut output_buffer);

    let _result = ntlm
        .initialize_security_context_impl(&mut builder)?
        .resolve_to_result()?;

    write_message(&mut stream, &output_buffer[0].buffer)?;

    let mut input_buffer = vec![SecurityBuffer::new(Vec::new(), BufferType::Token)];

    loop {
        output_buffer[0].buffer.clear();

        read_message(&mut stream, &mut input_buffer[0].buffer)?;

        let mut builder = ntlm
            .initialize_security_context()
            .with_credentials_handle(&mut acq_cred_result.credentials_handle)
            .with_context_requirements(ClientRequestFlags::CONFIDENTIALITY | ClientRequestFlags::ALLOCATE_MEMORY)
            .with_target_data_representation(DataRepresentation::Native)
            .with_target_name(username.as_str())
            .with_input(&mut input_buffer)
            .with_output(&mut output_buffer);

        let result = ntlm
            .initialize_security_context_impl(&mut builder)?
            .resolve_to_result()?;

        if [SecurityStatus::CompleteAndContinue, SecurityStatus::CompleteNeeded].contains(&result.status) {
            println!("Completing the token...");
            ntlm.complete_auth_token(&mut output_buffer)?;
        }

        write_message(&mut stream, &output_buffer[0].buffer)?;

        input_buffer[0].buffer.clear();

        if ![SecurityStatus::CompleteAndContinue, SecurityStatus::ContinueNeeded].contains(&result.status) {
            break;
        }
    }

    Ok(())
}

// By agreement, the message length is read from the first 2 bytes of the message in little-endian order.
pub fn read_message<T: io::Read, A: io::Write>(stream: &mut T, output_buffer: &mut A) -> Result<(), io::Error> {
    let msg_len = stream.read_u16::<LittleEndian>()?;

    let mut buff = vec![0u8; msg_len as usize];
    stream.read_exact(&mut buff)?;

    output_buffer.write_all(&buff)?;

    println!("Received the buffer [{} bytes]: {:?}", buff.len(), buff);

    Ok(())
}

// By agreement, the message length is written in the first 2 bytes of the message in little-endian order.
pub fn write_message<T: io::Write>(stream: &mut T, input_buffer: &[u8]) -> Result<(), io::Error> {
    if !input_buffer.is_empty() {
        println!("Sending the buffer [{} bytes]: {:?}", input_buffer.len(), input_buffer);

        stream.write_u16::<LittleEndian>(input_buffer.len() as u16)?;
        stream.write_all(input_buffer)?;
    }

    Ok(())
}

#[test]
fn buffer_read_correctly() {
    let mut msg = vec![0x3, 0x0];
    msg.append(&mut b"abc".to_vec());

    let mut buffer = Vec::new();

    read_message(&mut msg.as_slice(), &mut buffer).unwrap();

    assert_eq!(buffer, b"abc".to_vec());
}

#[test]
fn buffer_written_correctly() {
    let mut msg = vec![9, 8, 7];
    let mut stream = Vec::new();

    write_message(&mut stream, &mut msg).unwrap();

    assert_eq!(stream, vec![3, 0, 9, 8, 7]);
}


--- File: examples/kerberos.rs ---
use std::error::Error;

use base64::Engine;
use reqwest::header::{
    ACCEPT, ACCEPT_ENCODING, ACCEPT_LANGUAGE, AUTHORIZATION, CONNECTION, CONTENT_LENGTH, HOST, USER_AGENT,
    WWW_AUTHENTICATE,
};
use reqwest::StatusCode;
use sspi::{
    AcquireCredentialsHandleResult, BufferType, ClientRequestFlags, CredentialsBuffers, DataRepresentation,
    InitializeSecurityContextResult, Kerberos, KerberosConfig, SecurityBuffer, SecurityStatus, Sspi, SspiImpl,
    Username,
};
use tracing_subscriber::prelude::*;
use tracing_subscriber::{fmt, EnvFilter};

fn main() -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    let kdc_url = std::env::var("SSPI_KDC_URL").expect("missing KDC URL set in SSPI_KDC_URL"); //tcp://ad-compter-name.domain:88
    let hostname = std::env::var("SSPI_WINRM_HOST").expect("missing host name set in SSPI_WINRM_HOST"); // winrm_server_name.domain
    let username = std::env::var("SSPI_WINRM_USER").expect("missing username set in SSPI_WINRM_USER"); // username@domain
    let password = std::env::var("SSPI_WINRM_PASS").expect("missing password set in SSPI_WINRM_PASS");
    let auth_method = std::env::var("SSPI_WINRM_AUTH").expect("missing auth METHOD set in SSPI_WINRM_AUTH"); // Negotiate or Kerberos

    tracing_subscriber::registry()
        .with(fmt::layer())
        .with(EnvFilter::from_env("SSPI_LOG_LEVEL"))
        .init();

    let kerberos_config = KerberosConfig::new(&kdc_url, hostname.clone());
    let mut kerberos = Kerberos::new_client_from_config(kerberos_config).unwrap();

    let mut acq_creds_handle_result = get_cred_handle(&mut kerberos, username, password);

    let mut input_token = String::new();
    let mut client = reqwest::blocking::Client::new(); // super IMPORTANT, KEEP-ALIVE the http connection!
    loop {
        let (output_token, status) = step(
            &mut kerberos,
            &mut acq_creds_handle_result.credentials_handle,
            &input_token,
            &hostname,
        );
        if status == SecurityStatus::ContinueNeeded || status == SecurityStatus::Ok {
            let (token_from_server, status_code) =
                process_authentication(&output_token, &mut client, &auth_method, &hostname)?;
            if status_code == reqwest::StatusCode::OK {
                println!("authenticated");
                break Ok(());
            }
            input_token = token_from_server;
        } else {
            panic!("Having problem continue authentication");
        }
    }
}

pub(crate) fn get_cred_handle(
    kerberos: &mut Kerberos,
    username: String,
    password: String,
) -> AcquireCredentialsHandleResult<Option<CredentialsBuffers>> {
    let identity = sspi::AuthIdentity {
        username: Username::parse(&username).expect("username is not in the correct format"),
        password: password.into(),
    };
    let acq_creds_handle_result = kerberos
        .acquire_credentials_handle()
        .with_credential_use(sspi::CredentialUse::Outbound)
        .with_auth_data(&identity.into())
        .execute(kerberos)
        .expect("AcquireCredentialsHandle resulted in error");
    acq_creds_handle_result
}

pub(crate) fn process_authentication(
    token_neeeds_to_be_sent: &String,
    client: &mut reqwest::blocking::Client,
    auth_method: &str,
    hostname: &str,
) -> Result<(String, StatusCode), Box<dyn std::error::Error + Send + Sync>> {
    let server_result = send_http(token_neeeds_to_be_sent, client, hostname, auth_method)?;
    if server_result.status() == StatusCode::OK {
        return Ok((String::new(), StatusCode::OK));
    }
    let www_authenticate = server_result
        .headers()
        .get(WWW_AUTHENTICATE)
        .ok_or("expecting www-authentication header from server but not found")?;
    let server_token = www_authenticate
        .to_str()
        .unwrap()
        .replace(format!("{} ", auth_method).as_str(), "");
    Ok((server_token, server_result.status()))
}

pub(crate) fn send_http(
    negotiate_token: &String,
    client: &mut reqwest::blocking::Client,
    hostname: &str,
    auth_method: &str,
) -> Result<reqwest::blocking::Response, Box<dyn Error + Send + Sync>> {
    let resp = client
        .post(format!("http://{}:5985/wsman?PSVersion=7.3.8", hostname))
        .header(AUTHORIZATION, format!("{} {}", auth_method, negotiate_token))
        .header(HOST, format!("{}:5985", hostname))
        .header(CONNECTION, "keep-alive")
        .header(CONTENT_LENGTH, "0")
        .header(
            USER_AGENT,
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/118.0",
        )
        .header(ACCEPT, "*/*")
        .header(ACCEPT_ENCODING, "gzip, deflate")
        .header(ACCEPT_LANGUAGE, "en-US,en;q=0.9")
        .send()?;

    Ok(resp)
}

fn step_helper(
    kerberos: &mut Kerberos,
    cred_handle: &mut <Kerberos as SspiImpl>::CredentialsHandle,
    input_buffer: &mut [SecurityBuffer],
    output_buffer: &mut [SecurityBuffer],
    hostname: &str,
) -> Result<InitializeSecurityContextResult, Box<dyn std::error::Error>> {
    let target_name = format!("HTTP/{}", hostname);
    let mut builder = kerberos
        .initialize_security_context()
        .with_credentials_handle(cred_handle)
        .with_context_requirements(ClientRequestFlags::MUTUAL_AUTH)
        .with_target_data_representation(DataRepresentation::Native)
        .with_target_name(&target_name)
        .with_input(input_buffer)
        .with_output(output_buffer);

    let result = kerberos
        .initialize_security_context_impl(&mut builder)?
        .resolve_with_default_network_client()?;

    Ok(result)
}

pub fn step(
    kerberos: &mut Kerberos,
    cred_handle: &mut <Kerberos as SspiImpl>::CredentialsHandle,
    input_token: &String,
    hostname: &str,
) -> (String, SecurityStatus) {
    let input_buffer = base64::engine::general_purpose::STANDARD.decode(input_token).unwrap();
    let mut secure_input_buffer = vec![SecurityBuffer::new(input_buffer, BufferType::Token)];
    let mut secure_output_buffer = vec![SecurityBuffer::new(Vec::new(), BufferType::Token)];
    match step_helper(
        kerberos,
        cred_handle,
        &mut secure_input_buffer,
        &mut secure_output_buffer,
        hostname,
    ) {
        Ok(result) => {
            let output_buffer = secure_output_buffer[0].to_owned();
            (
                base64::engine::general_purpose::STANDARD.encode(output_buffer.buffer),
                result.status,
            )
        }
        Err(_) => {
            panic!("error stepping");
        }
    }
}


--- File: examples/server.rs ---
// Based on the SSPI server example from MSDN: https://docs.microsoft.com/en-us/windows/win32/secauthn/using-sspi-with-a-windows-sockets-server

// This example works with the client example using SSPI.
// It demonstrates how to connect with a client, establish a secure communication session, and send the client an encrypted message.

use std::io;
use std::net::{TcpListener, TcpStream};

use byteorder::{LittleEndian, ReadBytesExt, WriteBytesExt};
use sspi::{
    AuthIdentity, BufferType, CredentialUse, DataRepresentation, EncryptionFlags, Ntlm, SecurityBuffer,
    SecurityBufferRef, SecurityStatus, ServerRequestFlags, Sspi, SspiImpl, Username,
};

const IP: &str = "127.0.0.1:8080";

fn main() -> Result<(), io::Error> {
    let listener = TcpListener::bind(IP).expect("Unable to start the server");

    println!("Started the server.");

    let (mut stream, _client_addr) = listener.accept()?;

    let mut ntlm = Ntlm::new();

    let account_name = whoami::username();
    let computer_name = whoami::fallible::hostname().unwrap();
    let username =
        Username::new(&account_name, Some(&computer_name)).map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;

    let identity = AuthIdentity {
        username,
        password: String::from("password").into(),
    };

    do_authentication(&mut ntlm, &identity, &mut stream).expect("Failed to authenticate connection");
    println!("Authenticated!");

    println!("Sending the encrypted message...");

    let msg = "This is your server speaking!".to_string();

    // By agreement, the server encrypts and sets the size of the
    // trailer block to be just what it needed. decrypt_message
    // needs the size of the trailer block.
    //
    // By agreement, the server places the trailer at the beginning
    // of the message, and the data comes after the trailer.
    let mut token = vec![0u8; ntlm.query_context_sizes()?.security_trailer as usize];
    let mut data = msg.as_bytes().to_vec();
    let mut msg_buffer = vec![
        SecurityBufferRef::token_buf(token.as_mut_slice()),
        SecurityBufferRef::data_buf(data.as_mut_slice()),
    ];

    println!("Unencrypted message: [{}]", msg);
    println!("Encrypting...");

    let _result = ntlm.encrypt_message(EncryptionFlags::empty(), &mut msg_buffer, 0)?;

    println!("Encrypted message: {:?}", msg_buffer[1].data());

    println!("Sending the trailer...");
    write_message(&mut stream, msg_buffer[0].data())?;

    println!("Sending the data...");
    write_message(&mut stream, msg_buffer[1].data())?;

    println!("Communication successfully finished.");

    Ok(())
}

fn do_authentication(ntlm: &mut Ntlm, identity: &AuthIdentity, mut stream: &mut TcpStream) -> Result<(), sspi::Error> {
    let mut acq_cred_result = ntlm
        .acquire_credentials_handle()
        .with_credential_use(CredentialUse::Inbound)
        .with_auth_data(identity)
        .execute(ntlm)?;

    let mut input_buffer = vec![SecurityBuffer::new(Vec::new(), BufferType::Token)];
    let mut output_buffer = vec![SecurityBuffer::new(Vec::new(), BufferType::Token)];

    loop {
        read_message(&mut stream, &mut input_buffer[0].buffer)?;

        let builder = ntlm
            .accept_security_context()
            .with_credentials_handle(&mut acq_cred_result.credentials_handle)
            .with_context_requirements(ServerRequestFlags::ALLOCATE_MEMORY)
            .with_target_data_representation(DataRepresentation::Native)
            .with_input(&mut input_buffer)
            .with_output(&mut output_buffer);
        let result = ntlm.accept_security_context_impl(builder)?.resolve_to_result()?;

        if [SecurityStatus::CompleteAndContinue, SecurityStatus::CompleteNeeded].contains(&result.status) {
            println!("Completing the token...");
            ntlm.complete_auth_token(&mut output_buffer)?;
        }

        write_message(&mut stream, &output_buffer[0].buffer)?;

        output_buffer[0].buffer.clear();
        input_buffer[0].buffer.clear();

        if ![SecurityStatus::CompleteAndContinue, SecurityStatus::ContinueNeeded].contains(&result.status) {
            break;
        }
    }

    Ok(())
}

// By agreement, the message length is read from the first 2 bytes of the message in little-endian order.
pub fn read_message<T: io::Read, A: io::Write>(stream: &mut T, output_buffer: &mut A) -> Result<(), io::Error> {
    let msg_len = stream.read_u16::<LittleEndian>()?;

    let mut buff = vec![0u8; msg_len as usize];
    stream.read_exact(&mut buff)?;

    output_buffer.write_all(&buff)?;

    println!("Received the buffer [{} bytes]: {:?}", buff.len(), buff);

    Ok(())
}

// By agreement, the message length is written in the first 2 bytes of the message in little-endian order.
pub fn write_message<T: io::Write>(stream: &mut T, input_buffer: &[u8]) -> Result<(), io::Error> {
    if !input_buffer.is_empty() {
        println!("Sending the buffer [{} bytes]: {:?}", input_buffer.len(), input_buffer);

        stream.write_u16::<LittleEndian>(input_buffer.len() as u16)?;
        stream.write_all(input_buffer)?;
    }

    Ok(())
}

#[test]
fn buffer_read_correctly() {
    let mut msg = vec![0x3, 0x0];
    msg.append(&mut b"abc".to_vec());

    let mut buffer = Vec::new();

    read_message(&mut msg.as_slice(), &mut buffer).unwrap();

    assert_eq!(buffer, b"abc".to_vec());
}

#[test]
fn buffer_written_correctly() {
    let mut msg = vec![9, 8, 7];
    let mut stream = Vec::new();

    write_message(&mut stream, &mut msg).unwrap();

    assert_eq!(stream, vec![3, 0, 9, 8, 7]);
}


--- File: ffi/Cargo.toml ---
[package]
name = "sspi-ffi"
version = "0.0.0"
license = "MIT/Apache-2.0"
homepage = "https://github.com/devolutions/sspi-rs"
repository = "https://github.com/devolutions/sspi-rs"
keywords = ["ntlm", "auth", "sspi", "windows", "kerberos"]
edition = "2021"
publish = false

[lib]
name = "sspi"
crate-type = ["cdylib"]

[features]
default = ["aws-lc-rs", "scard", "dpapi"]
tsssp = ["sspi/tsssp", "dpapi/tsssp"]
scard = ["sspi/scard", "dep:ffi-types", "dep:winscard", "dep:bitflags", "dep:picky-asn1-x509", "dep:picky"]
aws-lc-rs = ["sspi/aws-lc-rs"]
ring = ["sspi/ring"]
dpapi = ["dep:dpapi", "dep:dpapi-transport", "dep:dpapi-native-transport", "dep:tokio", "dep:url", "dep:ffi-types"]

[dependencies]
cfg-if.workspace = true
num-traits = { workspace = true, default-features = true }
whoami.workspace = true
ffi-types = { workspace = true, features = ["winscard"], optional = true }
picky-asn1-der.workspace = true
uuid.workspace = true
winscard = { workspace = true, features = ["std"], optional = true }
dpapi = { workspace = true, optional = true }
dpapi-transport = { workspace = true, optional = true }
dpapi-native-transport = { workspace = true, optional = true }
url = { version = "2.5", optional = true }
tokio = { workspace = true, optional = true, features = ["rt"]}
# logging
tracing = { workspace = true, default-features = true }
tracing-subscriber = { workspace = true, features = ["std", "fmt", "local-time", "env-filter"] }

libc = "0.2"
sspi = { path = "..", default-features = false, features = ["network_client"] }

[target.'cfg(windows)'.dependencies]
symbol-rename-macro = { path = "./symbol-rename-macro" }
windows-sys = { workspace = true, features = ["Win32_Security_Cryptography", "Win32_Security_Authentication_Identity", "Win32_Security_Credentials", "Win32_Foundation", "Win32_Graphics_Gdi", "Win32_System_LibraryLoader", "Win32_Security", "Win32_System_Threading"] }

[target.'cfg(not(windows))'.dependencies]
bitflags = { workspace = true, optional = true }
picky-asn1-x509 = { workspace = true, optional = true }
picky = { workspace = true, features = ["x509"], optional = true }

[target.'cfg(not(any(target_os="macos", target_os="ios", windows)))'.dependencies]
sspi = { path = "..", default-features = false, features = ["dns_resolver"] }

[dev-dependencies]
sspi = { path = "..", features = ["__test-data"] }

[lints]
workspace = true


--- File: ffi/build.rs ---
use std::path::PathBuf;
use std::{env, fs};

fn main() {
    let target_os = env::var("CARGO_CFG_TARGET_OS").unwrap();
    let is_running_tests = env::var("SSPI_RS_IS_RUNNING_TESTS").is_ok();

    if target_os == "windows" && !is_running_tests {
        // On Windows, we provide the linker with a .def file to rename exports.
        // This module definition file is used to rename some symbols
        // and avoid linkage conflicts with secur32.dll when building the library.
        // (secur32.dll is used by `rust-tls-native-roots` crate)

        // See:
        // https://docs.microsoft.com/en-us/cpp/build/reference/module-definition-dot-def-files
        // https://docs.microsoft.com/en-us/cpp/build/reference/exports

        let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap());
        let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
        let base_def_file = manifest_dir.join("sspi_base.def");
        let merged_def_file = out_dir.join("sspi_merged.def");

        let mut merged_content = fs::read_to_string(&base_def_file).expect("Failed to read sspi_base.def");

        #[cfg(feature = "scard")]
        {
            let scard_def_file = manifest_dir.join("sspi_winscard.def");
            let scard_content = fs::read_to_string(&scard_def_file).expect("Failed to read sspi_winscard.def");
            let filtered_scard_content: String = scard_content
                .lines()
                .filter(|line| line.starts_with("    "))
                .collect::<Vec<_>>()
                .join("\n");
            merged_content.push('\n');
            merged_content.push_str(&filtered_scard_content);
        }

        #[cfg(feature = "dpapi")]
        {
            let dpapi_def_file = manifest_dir.join("sspi_dpapi.def");
            let dpapi_content = fs::read_to_string(&dpapi_def_file).expect("Failed to read sspi_dpapi.def");
            let filtered_dpapi_content: String = dpapi_content
                .lines()
                .filter(|line| line.starts_with("    "))
                .collect::<Vec<_>>()
                .join("\n");
            merged_content.push('\n');
            merged_content.push_str(&filtered_dpapi_content);
        }

        fs::write(&merged_def_file, merged_content).expect("Failed to write merged .def file");
        println!("cargo:rustc-link-arg=/DEF:{}", merged_def_file.display());
    }
}


--- File: ffi/dotnet/.gitignore ---
bin/
obj/
.vs/


--- File: ffi/dotnet/Devolutions.Sspi.sln ---
﻿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30114.105
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Devolutions.Sspi", "Devolutions.Sspi\Devolutions.Sspi.csproj", "{C26693DD-5BB5-436B-A3B8-2C0CA18E9870}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{C26693DD-5BB5-436B-A3B8-2C0CA18E9870}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{C26693DD-5BB5-436B-A3B8-2C0CA18E9870}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{C26693DD-5BB5-436B-A3B8-2C0CA18E9870}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{C26693DD-5BB5-436B-A3B8-2C0CA18E9870}.Release|Any CPU.Build.0 = Release|Any CPU
		{A3721F3C-A0C2-42BB-81AF-2A4781926C3D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{A3721F3C-A0C2-42BB-81AF-2A4781926C3D}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{A3721F3C-A0C2-42BB-81AF-2A4781926C3D}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{A3721F3C-A0C2-42BB-81AF-2A4781926C3D}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
EndGlobal


--- File: ffi/dotnet/Devolutions.Sspi/Devolutions.Sspi.csproj ---
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <Company>Devolutions</Company>
    <Description>Portable Rust SSPI library</Description>
    <TargetFrameworks>netstandard2.0</TargetFrameworks>
    <LangVersion>latest</LangVersion>
    <Version>2025.3.13.0</Version>
    <ImplicitUsings>disable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <GeneratePackageOnBuild>true</GeneratePackageOnBuild>
    <SuppressDependenciesWhenPacking>false</SuppressDependenciesWhenPacking>
  </PropertyGroup>

  <PropertyGroup>
    <RuntimesPath>../../../dependencies/runtimes</RuntimesPath>
    <NativeLibPath_win_x64>$(RuntimesPath)/win-x64/native/DevolutionsSspi.dll</NativeLibPath_win_x64>
    <NativeLibPath_win_arm64>$(RuntimesPath)/win-arm64/native/DevolutionsSspi.dll</NativeLibPath_win_arm64>
    <NativeLibPath_osx_x64>$(RuntimesPath)/osx-x64/native/libDevolutionsSspi.dylib</NativeLibPath_osx_x64>
    <NativeLibPath_osx_arm64>$(RuntimesPath)/osx-arm64/native/libDevolutionsSspi.dylib</NativeLibPath_osx_arm64>
    <NativeLibPath_osx_universal>$(RuntimesPath)/osx-universal/native/libDevolutionsSspi.dylib</NativeLibPath_osx_universal>
    <NativeLibPath_linux_x64>$(RuntimesPath)/linux-x64/native/libDevolutionsSspi.so</NativeLibPath_linux_x64>
    <NativeLibPath_linux_arm64>$(RuntimesPath)/linux-arm64/native/libDevolutionsSspi.so</NativeLibPath_linux_arm64>
    <NativeLibPath_android_x86>$(RuntimesPath)/android-x86/native/libDevolutionsSspi.so</NativeLibPath_android_x86>
    <NativeLibPath_android_x64>$(RuntimesPath)/android-x64/native/libDevolutionsSspi.so</NativeLibPath_android_x64>
    <NativeLibPath_android_arm>$(RuntimesPath)/android-arm/native/libDevolutionsSspi.so</NativeLibPath_android_arm>
    <NativeLibPath_android_arm64>$(RuntimesPath)/android-arm64/native/libDevolutionsSspi.so</NativeLibPath_android_arm64>
    <NativeLibPath_ios_framework>$(RuntimesPath)/ios-universal/native/libDevolutionsSspi.framework</NativeLibPath_ios_framework>
  </PropertyGroup>

  <ItemGroup Condition="Exists('$(NativeLibPath_win_x64)')">
    <Content Include="$(NativeLibPath_win_x64)">
      <Link>%(Filename)%(Extension)</Link>
      <PackagePath>runtimes/win-x64/native/%(Filename)%(Extension)</PackagePath>
      <Pack>true</Pack>
      <CopyToOutputDirectory>Never</CopyToOutputDirectory>
    </Content>
  </ItemGroup>

  <ItemGroup Condition="Exists('$(NativeLibPath_win_arm64)')">
    <Content Include="$(NativeLibPath_win_arm64)">
      <Link>%(Filename)%(Extension)</Link>
      <PackagePath>runtimes/win-arm64/native/%(Filename)%(Extension)</PackagePath>
      <Pack>true</Pack>
      <CopyToOutputDirectory>Never</CopyToOutputDirectory>
    </Content>
  </ItemGroup>

  <ItemGroup Condition="Exists('$(NativeLibPath_osx_x64)')">
    <Content Include="$(NativeLibPath_osx_x64)">
      <Link>%(Filename)%(Extension)</Link>
      <PackagePath>runtimes/osx-x64/native/%(Filename)%(Extension)</PackagePath>
      <Pack>true</Pack>
      <CopyToOutputDirectory>Never</CopyToOutputDirectory>
    </Content>
  </ItemGroup>

  <ItemGroup Condition="Exists('$(NativeLibPath_osx_arm64)')">
    <Content Include="$(NativeLibPath_osx_arm64)">
      <Link>%(Filename)%(Extension)</Link>
      <PackagePath>runtimes/osx-arm64/native/%(Filename)%(Extension)</PackagePath>
      <Pack>true</Pack>
      <CopyToOutputDirectory>Never</CopyToOutputDirectory>
    </Content>
  </ItemGroup>

  <ItemGroup Condition="Exists('$(NativeLibPath_osx_universal)')">
    <Content Include="$(NativeLibPath_osx_universal)">
      <Link>%(Filename)%(Extension)</Link>
      <PackagePath>runtimes/osx-universal/native/%(Filename)%(Extension)</PackagePath>
      <Pack>true</Pack>
      <CopyToOutputDirectory>Never</CopyToOutputDirectory>
    </Content>
  </ItemGroup>

  <ItemGroup Condition="Exists('$(NativeLibPath_linux_x64)')">
    <Content Include="$(NativeLibPath_linux_x64)">
      <Link>%(Filename)%(Extension)</Link>
      <PackagePath>runtimes/linux-x64/native/%(Filename)%(Extension)</PackagePath>
      <Pack>true</Pack>
      <CopyToOutputDirectory>Never</CopyToOutputDirectory>
    </Content>
  </ItemGroup>

  <ItemGroup Condition="Exists('$(NativeLibPath_linux_arm64)')">
    <Content Include="$(NativeLibPath_linux_arm64)">
      <Link>%(Filename)%(Extension)</Link>
      <PackagePath>runtimes/linux-arm64/native/%(Filename)%(Extension)</PackagePath>
      <Pack>true</Pack>
      <CopyToOutputDirectory>Never</CopyToOutputDirectory>
    </Content>
  </ItemGroup>

  <ItemGroup Condition="Exists('$(NativeLibPath_android_x86)')">
    <Content Include="$(NativeLibPath_android_x86)">
      <Link>%(Filename)%(Extension)</Link>
      <PackagePath>runtimes/android-x86/native/%(Filename)%(Extension)</PackagePath>
      <Pack>true</Pack>
      <CopyToOutputDirectory>Never</CopyToOutputDirectory>
    </Content>
  </ItemGroup>

  <ItemGroup Condition="Exists('$(NativeLibPath_android_x64)')">
    <Content Include="$(NativeLibPath_android_x64)">
      <Link>%(Filename)%(Extension)</Link>
      <PackagePath>runtimes/android-x64/native/%(Filename)%(Extension)</PackagePath>
      <Pack>true</Pack>
      <CopyToOutputDirectory>Never</CopyToOutputDirectory>
    </Content>
  </ItemGroup>

  <ItemGroup Condition="Exists('$(NativeLibPath_android_arm)')">
    <Content Include="$(NativeLibPath_android_arm)">
      <Link>%(Filename)%(Extension)</Link>
      <PackagePath>runtimes/android-arm/native/%(Filename)%(Extension)</PackagePath>
      <Pack>true</Pack>
      <CopyToOutputDirectory>Never</CopyToOutputDirectory>
    </Content>
  </ItemGroup>

  <ItemGroup Condition="Exists('$(NativeLibPath_android_arm64)')">
    <Content Include="$(NativeLibPath_android_arm64)">
      <Link>%(Filename)%(Extension)</Link>
      <PackagePath>runtimes/android-arm64/native/%(Filename)%(Extension)</PackagePath>
      <Pack>true</Pack>
      <CopyToOutputDirectory>Never</CopyToOutputDirectory>
    </Content>
  </ItemGroup>

  <ItemGroup Condition="Exists('$(NativeLibPath_ios_framework)')">
    <None Include="$(RuntimesPath)/ios-universal/native/*.framework/**">
      <PackagePath>runtimes/ios-universal/native/</PackagePath>
      <Pack>true</Pack>
      <CopyToOutputDirectory>Never</CopyToOutputDirectory>
    </None>
  </ItemGroup>

  <ItemGroup>
    <Content Include="Devolutions.Sspi.targets" PackagePath="build/Devolutions.Sspi.targets" Pack="true" />
  </ItemGroup>

</Project>


--- File: ffi/dotnet/Devolutions.Sspi/Devolutions.Sspi.targets ---
<?xml version="1.0"?>
<Project ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <IsPowerShell Condition="$(DefineConstants.Contains('__POWERSHELL__'))">true</IsPowerShell>
    <IsAndroid Condition="$(TargetFramework.ToUpper().Contains('ANDROID'))">true</IsAndroid>
    <IsIOS Condition="'$(Platform)' == 'iPhone' or '$(Platform)' == 'iPhoneSimulator' or $(TargetFramework.Contains('-ios'))">true</IsIOS>
    <IsNet6Mac Condition="$(TargetFramework.Contains('-macos'))">true</IsNet6Mac>
  </PropertyGroup>
  <Target Name="DebugMessage" BeforeTargets="Build" >
    <Message Text="PowerShell: $(IsPowerShell)" Importance="high"/>
    <Message Text="Android: $(IsAndroid)" Importance="high"/>
    <Message Text="iOS: $(IsIOS)" Importance="high"/>
    <Message Text="Net6Mac: $(IsNet6Mac)" Importance="high"/>
  </Target>
  <ItemGroup>
    <Content Condition="$([MSBuild]::IsOSPlatform('Windows')) OR '$(IsPowerShell)' == 'true'" Include="$(MSBuildThisFileDirectory)\..\runtimes\win-x64\native\DevolutionsSspi.dll">
      <Link>runtimes\win-x64\native\DevolutionsSspi.dll</Link>
      <PublishState>Included</PublishState>
      <Visible>False</Visible>
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
      <IncludeInVsix>true</IncludeInVsix>
      <Pack>false</Pack>
    </Content>
    <Content Condition="$([MSBuild]::IsOSPlatform('Windows')) OR '$(IsPowerShell)' == 'true'" Include="$(MSBuildThisFileDirectory)\..\runtimes\win-arm64\native\DevolutionsSspi.dll">
      <Link>runtimes\win-arm64\native\DevolutionsSspi.dll</Link>
      <PublishState>Included</PublishState>
      <Visible>False</Visible>
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
      <IncludeInVsix>true</IncludeInVsix>
      <Pack>false</Pack>
    </Content>
    <Content Condition="'$(IsPowerShell)' == 'true'" Include="$(MSBuildThisFileDirectory)\..\runtimes\osx-x64\native\libDevolutionsSspi.dylib">
      <Link>runtimes\osx-x64\native\libDevolutionsSspi.dylib</Link>
      <PublishState>Included</PublishState>
      <Visible>False</Visible>
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
      <IncludeInVsix>true</IncludeInVsix>
      <Pack>false</Pack>
    </Content>
    <Content Condition="'$(IsPowerShell)' == 'true'" Include="$(MSBuildThisFileDirectory)\..\runtimes\osx-arm64\native\libDevolutionsSspi.dylib">
      <Link>runtimes\osx-arm64\native\libDevolutionsSspi.dylib</Link>
      <PublishState>Included</PublishState>
      <Visible>False</Visible>
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
      <IncludeInVsix>true</IncludeInVsix>
      <Pack>false</Pack>
    </Content>
    <Content Condition="$([MSBuild]::IsOSPlatform('Linux')) OR '$(IsPowerShell)' == 'true'" Include="$(MSBuildThisFileDirectory)\..\runtimes\linux-x64\native\libDevolutionsSspi.so">
      <Link>runtimes\linux-x64\native\libDevolutionsSspi.so</Link>
      <PublishState>Included</PublishState>
      <Visible>False</Visible>
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
      <IncludeInVsix>true</IncludeInVsix>
      <Pack>false</Pack>
    </Content>
    <Content Condition="$([MSBuild]::IsOSPlatform('Linux')) OR '$(IsPowerShell)' == 'true'" Include="$(MSBuildThisFileDirectory)\..\runtimes\linux-arm64\native\libDevolutionsSspi.so">
      <Link>runtimes\linux-arm64\native\libDevolutionsSspi.so</Link>
      <PublishState>Included</PublishState>
      <Visible>False</Visible>
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
      <IncludeInVsix>true</IncludeInVsix>
      <Pack>false</Pack>
    </Content>
  </ItemGroup>
  <ItemGroup Condition="$(AndroidSupportedAbis.Contains('armeabi-v7a')) or $(RuntimeIdentifiers.Contains('android-arm'))">
      <AndroidNativeLibrary Include="$(MSBuildThisFileDirectory)\..\runtimes\android-arm\native\libDevolutionsSspi.so">
          <Link>%(Filename)%(Extension)</Link>
          <Abi>armeabi-v7a</Abi>
      </AndroidNativeLibrary>
  </ItemGroup>
    <ItemGroup Condition="$(AndroidSupportedAbis.Contains('arm64-v8a')) or $(RuntimeIdentifiers.Contains('android-arm64'))">
      <AndroidNativeLibrary Include="$(MSBuildThisFileDirectory)\..\runtimes\android-arm64\native\libDevolutionsSspi.so">
          <Link>%(Filename)%(Extension)</Link>
          <Abi>arm64-v8a</Abi>
      </AndroidNativeLibrary>
  </ItemGroup>
  <ItemGroup Condition="$(AndroidSupportedAbis.Contains('x86')) or $(RuntimeIdentifiers.Contains('android-x86'))">
      <AndroidNativeLibrary Include="$(MSBuildThisFileDirectory)\..\runtimes\android-x86\native\libDevolutionsSspi.so">
          <Link>%(Filename)%(Extension)</Link>
          <Abi>x86</Abi>
      </AndroidNativeLibrary>
  </ItemGroup>
  <ItemGroup Condition="$(AndroidSupportedAbis.Contains('x86_64')) or $(RuntimeIdentifiers.Contains('android-x64'))">
      <AndroidNativeLibrary Include="$(MSBuildThisFileDirectory)\..\runtimes\android-x64\native\libDevolutionsSspi.so">
          <Link>%(Filename)%(Extension)</Link>
          <Abi>x86_64</Abi>
      </AndroidNativeLibrary>
  </ItemGroup>
  <ItemGroup Condition="$([MSBuild]::IsOSPlatform('OSX')) AND '$(IsPowerShell)' != 'true' AND '$(IsIOS)' != 'true' AND '$(IsAndroid)' != 'true' AND '$(IsNet6Mac)' != 'true'">
    <NativeReference Include="$(MSBuildThisFileDirectory)\..\runtimes\osx-universal\native\libDevolutionsSspi.dylib">
      <Kind>Dynamic</Kind>
      <SmartLink>False</SmartLink>
    </NativeReference>
  </ItemGroup>
  <ItemGroup Condition="'$(IsIOS)' == 'true'">
    <NativeReference Include="$(MSBuildThisFileDirectory)..\runtimes\ios-universal\native\libDevolutionsSspi.framework">
      <Kind>Framework</Kind>
    </NativeReference>
  </ItemGroup>
</Project>


--- File: ffi/src/dpapi/api.rs ---
#[cfg(not(any(test, miri)))]
mod inner {
    pub use dpapi::{n_crypt_protect_secret, n_crypt_unprotect_secret};
}

#[cfg(any(test, miri))]
mod inner {
    //! We have FFI wrappers for DPAPI functions from the [dpapi] crate and we want to test them.
    //! The DPAPI implementation is complex and makes calls to the RPC and KDC servers.
    //! Implementing a mock for KDF and RPC servers is too hard and unreasonable. So, we wrote a simple
    //! high-level mock of [n_crypt_protect_secret] and [n_crypt_unprotect_secret] functions.
    //!
    //! **Note**: The goal is to test FFI functions, not the DPAPI implementation correctness.
    //! The FFI tests should not care about returned data correctness but rather check
    //! for memory corruptions and memory leaks.

    use std::ffi::CStr;
    use std::slice::from_raw_parts_mut;

    use dpapi::{CryptProtectSecretArgs, CryptUnprotectSecretArgs, Result};
    use dpapi_transport::{ProxyOptions, Transport};
    use ffi_types::{Dword, LpByte, LpCStr, LpCUuid, LpDword};
    use sspi::Secret;
    use url::Url;
    use uuid::Uuid;

    #[allow(clippy::extra_unused_type_parameters)]
    pub async fn n_crypt_unprotect_secret<T: Transport>(
        args: CryptUnprotectSecretArgs<'_, '_, '_, '_>,
    ) -> Result<Secret<Vec<u8>>> {
        if let Some(ProxyOptions {
            proxy,
            get_session_token,
        }) = args.proxy
        {
            println!("proxy: {proxy}");
            println!(
                "token: {}",
                get_session_token(Uuid::new_v4(), Url::parse("tcp://win-956cqossjtf.tbt.com:125").unwrap())
                    .await
                    .unwrap()
            );
        }

        Ok(b"secret-to-encrypt".to_vec().into())
    }

    #[allow(clippy::extra_unused_type_parameters)]
    pub async fn n_crypt_protect_secret<T: Transport>(args: CryptProtectSecretArgs<'_, '_, '_>) -> Result<Vec<u8>> {
        if let Some(ProxyOptions {
            proxy,
            get_session_token,
        }) = args.proxy
        {
            println!("proxy: {proxy}");
            println!(
                "token: {}",
                get_session_token(Uuid::new_v4(), Url::parse("tcp://win-956cqossjtf.tbt.com:125").unwrap())
                    .await
                    .unwrap()
            );
        }

        Ok(b"DPAPI_blob".to_vec())
    }

    pub unsafe extern "system" fn get_session_token(
        session_id: LpCUuid,
        destination: LpCStr,
        token_buf: LpByte,
        token_len: LpDword,
    ) -> u32 {
        check_null!(session_id);
        check_null!(destination);
        check_null!(token_buf);
        check_null!(token_len);

        // SAFETY:
        // The pointer is not null: checked above.
        // The caller must ensure the correctness of the data behind the pointer.
        let session_id = unsafe { *session_id };
        let session_id = Uuid::from_fields(session_id.data1, session_id.data2, session_id.data3, &session_id.data4);

        // SAFETY:
        // The pointer is not null: checked above.
        // The caller must ensure the correctness of the data behind the pointer.
        let destination = unsafe { CStr::from_ptr(destination as *const _) }.to_str().unwrap();

        println!("session id: {:?}. destination: {:?}.", session_id, destination);

        let session_token = b"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImN0eSI6IkFTU09DSUFUSU9OIn0.eyJkc3RfaHN0IjoidGNwOi8vMTkyLjE2OC4xLjEwMzoxMzUiLCJleHAiOjE3NDQ1MzQ5NTMsImpldF9haWQiOiIwY2I3M2Y3Yy0wZTA5LTRiNzAtYTVjMy1jMjBjY2IzMDJhYjAiLCJqZXRfYXAiOiJ1bmtub3duIiwiamV0X2NtIjoiZndkIiwiamV0X3JlYyI6Im5vbmUiLCJqdGkiOiJlYmNkNzhmMi0zMTlhLTRlM2UtOGZiOS02MjcyMTIzZTA1YWMiLCJuYmYiOjE3NDQ1MzEzNTN9.BEEaY2Mcm4ubdFBrugen7TEPW2PqxHj9Mi-DdP71C6vJ5YftpxGZns9KS4i_9ayPvpBRTyWW0YhLO1sUdGww6ePID0qP-IEYTY5rJ-pBRwX5eTtU4ci1hgxa2bcGOeWRJtX_Yg_rS49hgxYF1qMJL1CdoZbAx70656ygohQzEyeqOeto_ZpMxz2S_EMJyeXfJI-IgFrBnMvK-6iBLxc9xgc3TmGKdPefoAmlpV24OsyS9AT9U-gqlGpJ-DDAc7ZUvYyeaRG_JnEuBdvydtJyUDAvIvS73kPLAOHJfsOxXzu-izEOdaJQ8nIiSKcN_aKL_mSqSBN02zCiBuWbvAJP8EOlvqzuwRxB_zKpJNwS2fOQFhRd8L4dK034sajh3m485Zg-B5OwcmyPMAbmMpb2vyC9x5Gg9PcWN0ikHkILkNtPngsrt5r4rUTKo7h-KG4gMApfD38fmmIms01h_qh3btSDtf-ok-W8T6Sq0dJS6rhSmjhw5vJQVf_js3eRML1T5NbyGPmk6O9qKvaiGMNNgoVDawTDpCD2Sy9LTZTJajeX2vYkCI11neUkVeOxSCokOekhnVdqQVnWPfME10dtaTgDwBz-nmZg1tWAXcwouZFu2MZPLVH4xM7BqwoY8-Pmvuupr2ctOi8C9DfsKIPXmrbswdBSxKEd28HuZxDB2w8";
        // SAFETY:
        // The pointer is not null: checked above.
        // The caller must ensure the correctness of the data behind the pointer.
        unsafe { from_raw_parts_mut(token_buf, session_token.len()) }.copy_from_slice(session_token);
        // SAFETY:
        // The pointer is not null: checked above.
        unsafe {
            *token_len = Dword::try_from(session_token.len()).unwrap();
        }

        0
    }
}

pub use inner::*;


--- File: ffi/src/dpapi/macros.rs ---
macro_rules! check_null {
    ($x:expr) => {{
        if $x.is_null() {
            // https://learn.microsoft.com/en-us/windows/win32/api/ncryptprotect/nf-ncryptprotect-ncryptprotectsecret#return-value
            return crate::dpapi::NTE_INVALID_PARAMETER;
        }
    }};
}

macro_rules! try_execute {
    ($x:expr, $err_value:expr) => {{
        match $x {
            Ok(val) => val,
            Err(err) => {
                error!(%err, "an error occurred");
                return $err_value;
            }
        }
    }};
}

macro_rules! catch_panic {
    ($($tokens:tt)*) => {{
        match std::panic::catch_unwind(move || { $($tokens)* }) {
            Ok(val) => val,
            Err(_) => {
                return crate::dpapi::NTE_INTERNAL_ERROR;
            }
        }
    }};
}


--- File: ffi/src/dpapi/mod.rs ---
#[macro_use]
mod macros;
mod api;
mod network_client;
mod session_token;

use std::ffi::CStr;
use std::slice::{from_raw_parts, from_raw_parts_mut};

use dpapi::{CryptProtectSecretArgs, CryptUnprotectSecretArgs};
use dpapi_native_transport::NativeTransport;
use dpapi_transport::ProxyOptions;
use ffi_types::common::{Dword, LpByte, LpCByte, LpCStr, LpCUuid, LpDword};
use tokio::runtime::Builder;
use url::Url;
use uuid::Uuid;

use self::api::{n_crypt_protect_secret, n_crypt_unprotect_secret};

// https://learn.microsoft.com/en-us/windows/win32/api/ncryptprotect/nf-ncryptprotect-ncryptprotectsecret#return-value
const ERROR_SUCCESS: u32 = 0;
const NTE_INVALID_PARAMETER: u32 = 0x80090027;
const NTE_INTERNAL_ERROR: u32 = 0x8009002d;
const NTE_NO_MEMORY: u32 = 0x8009000e;

/// Type that represents a function for obtaining the session token.
///
/// We need it because we don't know the destination address in advance.
///
/// Parameters:
/// * `LpCUuid` is the session id.
/// * `LpCStr` is the destination of the proxied connection.
/// * `Lpbyte` is the session token buffer. It must be preallocated.
/// * `LpDword` is the session token buffer length.
type GetSessionTokenFn = unsafe extern "system" fn(LpCUuid, LpCStr, LpByte, LpDword) -> u32;

/// Encrypts the secret using the DPAPI.
///
/// This function simulated the `NCryptProtectSecret` function. Encryption requires making RPCs call to the domain.
///
/// # Safety
///
/// Input parameters must meet the following requirements:
///
/// * `secret` must be a valid pointer to the secret buffer. This parameter **cannot be NULL**.
/// * `secret_len` is a length of the `secret` buffer.
/// * `sid` must be a valid pointer to the UTF-8 SID string (with a null-terminator character). This parameter **cannot be NULL**.
/// * `root_key` is a pointer to the root key UUID. This parameter is optional and can be NULL.
/// * `server` must be a valid pointer to the UTF-8 string (with a null-terminator character) containing target server hostname.
///   Do not use IP address. This parameter **cannot be NULL**.
/// * `username` must be a valid pointer to the UTF-8 string (with a null-terminator character) containing username.
///   This parameter **cannot be NULL**. The username can be specified in FQDN (DOMAIN\username) or UPN (username@domain) format
/// * `password` must be a valid pointer to the UTF-8 string (with a null-terminator character) containing user's password.
///   This parameter **cannot be NULL**.
/// * `computer_name` must be a valid pointer to the UTF-8 string (with a null-terminator character) containing client's computer name.
///   This parameter can be NULL. If it's NULL, the current computer name will be used.
/// * `blob` is a pointer to the output buffer containing DPAPI blob. This parameter **cannot be NULL**.
///   The caller is responsible for freeing the memory using the [DpapiFree] function.
/// * `blob_len` is a length of the output `blob` buffer. This parameter **cannot be NULL**.
///
/// MSDN:
/// * [NCryptProtectSecret function (`ncryptprotect.h`)](https://learn.microsoft.com/en-us/windows/win32/api/ncryptprotect/nf-ncryptprotect-ncryptprotectsecret).
#[instrument(skip_all)]
#[no_mangle]
pub unsafe extern "system" fn DpapiProtectSecret(
    secret: LpCByte,
    secret_len: Dword,
    sid: LpCStr,
    root_key: LpCUuid,
    server: LpCStr,
    username: LpCStr,
    password: LpCStr,
    computer_name: LpCStr,
    proxy_url: LpCStr,
    get_session_token_fn: Option<GetSessionTokenFn>,
    blob: *mut LpByte,
    blob_len: *mut Dword,
) -> u32 {
    catch_panic! {
        check_null!(secret);
        check_null!(sid);
        check_null!(server);
        check_null!(username);
        check_null!(password);
        check_null!(blob);
        check_null!(blob_len);

        try_execute!(sspi::install_default_crypto_provider_if_necessary().map_err(|_| "failed to initialize default crypto provider"), NTE_INTERNAL_ERROR);

        let secret =
            // SAFETY: The `secret` pointer is not NULL (checked above). Other guarantees should be upheld by the caller.
            unsafe { from_raw_parts(secret, try_execute!(secret_len.try_into(), NTE_INVALID_PARAMETER)) }.to_owned();
        let sid = try_execute!(
            // SAFETY: The `sid` pointer is not NULL (checked above). Other guarantees should be upheld by the caller.
            unsafe { CStr::from_ptr(sid as *const _) }.to_str(),
            NTE_INVALID_PARAMETER
        )
        .to_owned();
        let root_key_id = if !root_key.is_null() {
            // SAFETY: The `root_key` pointer is not NULL (checked above).
            let id = unsafe { *root_key };
            let root_key = Uuid::from_fields(id.data1, id.data2, id.data3, &id.data4);

            Some(root_key)
        } else {
            None
        };
        let server = try_execute!(
            // SAFETY: The `server` pointer is not NULL (checked above). Other guarantees should be upheld by the caller.
            unsafe { CStr::from_ptr(server as *const _) }.to_str(),
            NTE_INVALID_PARAMETER
        );
        let username = try_execute!(
            // SAFETY: The `username` pointer is not NULL (checked above). Other guarantees should be upheld by the caller.
            unsafe { CStr::from_ptr(username as *const _) }.to_str(),
            NTE_INVALID_PARAMETER
        );
        let password = try_execute!(
            // SAFETY: The `password` pointer is not NULL (checked above). Other guarantees should be upheld by the caller.
            unsafe { CStr::from_ptr(password as *const _) }.to_str(),
            NTE_INVALID_PARAMETER
        )
        .to_owned();
        let client_computer_name = if !computer_name.is_null() {
            Some(
                try_execute!(
                    // SAFETY: The `computer_name` pointer is not NULL (checked above). Other guarantees should be upheld by the caller.
                    unsafe { CStr::from_ptr(computer_name as *const _) }.to_str(),
                    NTE_INVALID_PARAMETER
                )
                .to_owned(),
            )
        } else {
            None
        };

        let proxy = if let (false, Some(get_session_token_fn)) = (proxy_url.is_null(), get_session_token_fn) {
            info!("Proxy parameters are not empty. Proceeding with tunnelled connection.");

            let proxy_url = try_execute!(
                // SAFETY: The `proxy_url` pointer is not NULL (checked above). Other guarantees should be upheld by the caller.
                unsafe { CStr::from_ptr(proxy_url as *const _) }.to_str(),
                NTE_INVALID_PARAMETER
            );

            Some(ProxyOptions {
                proxy: try_execute!(Url::parse(proxy_url), NTE_INVALID_PARAMETER),
                // SAFETY:
                // The C function pointer must be safe to call. It's a user's responsibility to uphold its correctness.
                get_session_token: unsafe {
                    session_token::session_token_fn(get_session_token_fn)
                },
            })
        } else {
            info!("Proxy parameters are empty. Proceeding with direct connection.");

            None
        };
        let mut network_client = network_client::SyncNetworkClient;

        let runtime  = try_execute!(Builder::new_current_thread().build(), NTE_INTERNAL_ERROR);
        let blob_data = try_execute!(
            runtime.block_on(n_crypt_protect_secret::<NativeTransport>(
                CryptProtectSecretArgs {
                    data: secret.into(),
                    sid,
                    root_key_id,
                    server,
                    proxy,
                    username,
                    password: password.into(),
                    client_computer_name,
                    network_client: &mut network_client,
                    kerberos_config: None,
                }
            )),
            NTE_INTERNAL_ERROR
        );

        if blob_data.is_empty() {
            error!("Output DPAPI blob is empty");
            return NTE_INTERNAL_ERROR;
        }

        // SAFETY: Memory allocation is safe. Moreover, we check for the null value below.
        let blob_buf = unsafe { libc::malloc(blob_data.len()) as *mut u8 };
        if blob_buf.is_null() {
            error!("Failed to allocate memory for the output DPAPI blob: blob buf pointer is NULL");
            return NTE_NO_MEMORY;
        }

        // SAFETY: The `blob_buf` pointer is not NULL (checked above). The slice construction is safe because `blob_buf`
        // points to allocated, properly aligned, and not-empty bytes range.
        let buf = unsafe { from_raw_parts_mut(blob_buf, blob_data.len()) };
        buf.copy_from_slice(blob_data.as_ref());

        // SAFETY: The `blob` pointer is not NULL (checked above).
        unsafe {
            *blob = blob_buf;
            *blob_len = try_execute!(blob_data.len().try_into(), NTE_INTERNAL_ERROR);
        }

        ERROR_SUCCESS
    }
}

/// Decrypt the DPAPI blob.
///
/// This function simulated the `NCryptUnprotectSecret` function. Decryption requires making RPC calls to the domain.
///
/// # Safety
///
/// Input parameters must meet the following requirements:
///
/// * `blob` must be a valid pointer to the DPAPI blob buffer. This parameter **cannot be NULL**.
/// * `blob_len` is a length of the `blob` buffer.
/// * `server` must be a valid pointer to the UTF-8 string (with a null-terminator character) containing target server hostname.
///   Do not use IP address. This parameter **cannot be NULL**.
/// * `username` must be a valid pointer to the UTF-8 string (with a null-terminator character) containing username.
///   This parameter **cannot be NULL**. The username can be specified in FQDN (DOMAIN\username) or UPN (username@domain) format
/// * `password` must be a valid pointer to the UTF-8 string (with a null-terminator character) containing user's password.
///   This parameter **cannot be NULL**.
/// * `computer_name` must be a valid pointer to the UTF-8 string (with a null-terminator character) containing client's computer name.
///   This parameter can be NULL. If it's NULL, the current computer name will be used.
/// * `secret` is a pointer to the output buffer containing decrypted secret. This parameter **cannot be NULL**.
///   The caller is responsible for freeing the memory using the [DpapiFree] function.
/// * `secret_len` is a length of the output `secret` buffer. This parameter **cannot be NULL**.
///
/// MSDN:
/// * [NCryptUnprotectSecret function (ncryptprotect.h)](https://learn.microsoft.com/en-us/windows/win32/api/ncryptprotect/nf-ncryptprotect-ncryptunprotectsecret).
#[instrument(skip_all)]
#[no_mangle]
pub unsafe extern "system" fn DpapiUnprotectSecret(
    blob: LpCByte,
    blob_len: Dword,
    server: LpCStr,
    username: LpCStr,
    password: LpCStr,
    computer_name: LpCStr,
    proxy_url: LpCStr,
    get_session_token_fn: Option<GetSessionTokenFn>,
    secret: *mut LpByte,
    secret_len: *mut Dword,
) -> u32 {
    catch_panic! {
        check_null!(blob);
        check_null!(server);
        check_null!(username);
        check_null!(password);
        check_null!(secret);

        try_execute!(sspi::install_default_crypto_provider_if_necessary().map_err(|_| "failed to initialize default crypto provider"), NTE_INTERNAL_ERROR);

        // SAFETY: The `blob` pointer is not NULL (checked above). Other guarantees should be upheld by the caller.
        let blob = unsafe { from_raw_parts(blob, try_execute!(blob_len.try_into(), NTE_INVALID_PARAMETER)) };
        let server = try_execute!(
            // SAFETY: The `server` pointer is not NULL (checked above). Other guarantees should be upheld by the caller.
            unsafe { CStr::from_ptr(server as *const _) }.to_str(),
            NTE_INVALID_PARAMETER
        );
        let username = try_execute!(
            // SAFETY: The `username` pointer is not NULL (checked above). Other guarantees should be upheld by the caller.
            unsafe { CStr::from_ptr(username as *const _) }.to_str(),
            NTE_INVALID_PARAMETER
        );
        let password = try_execute!(
            // SAFETY: The `password` pointer is not NULL (checked above). Other guarantees should be upheld by the caller.
            unsafe { CStr::from_ptr(password as *const _) }.to_str(),
            NTE_INVALID_PARAMETER
        )
        .to_owned();
        let client_computer_name = if !computer_name.is_null() {
            Some(
                try_execute!(
                    // SAFETY: The `computer_name` pointer is not NULL (checked above). Other guarantees should be upheld by the caller.
                    unsafe { CStr::from_ptr(computer_name as *const _) }.to_str(),
                    NTE_INVALID_PARAMETER
                )
                .to_owned(),
            )
        } else {
            None
        };

        let proxy = if let (false, Some(get_session_token_fn)) = (proxy_url.is_null(), get_session_token_fn) {
            info!("Proxy parameters are not empty. Proceeding  with tunnelled connection.");

            let proxy_url = try_execute!(
                // SAFETY: The `proxy_url` pointer is not NULL (checked above). Other guarantees should be upheld by the caller.
                unsafe { CStr::from_ptr(proxy_url as *const _) }.to_str(),
                NTE_INVALID_PARAMETER
            );

            Some(ProxyOptions {
                proxy: try_execute!(Url::parse(proxy_url), NTE_INVALID_PARAMETER),
                // SAFETY:
                // The C function pointer must be safe to call. It's a user's responsibility to uphold its correctness.
                get_session_token: unsafe {
                    session_token::session_token_fn(get_session_token_fn)
                },
            })
        } else {
            info!("Proxy parameters are empty. Proceeding  with direct connection.");

            None
        };
        let mut network_client = network_client::SyncNetworkClient;

        let runtime  = try_execute!(Builder::new_current_thread().build(), NTE_INTERNAL_ERROR);
        let secret_data = try_execute!(
            runtime.block_on(n_crypt_unprotect_secret::<NativeTransport>(
                CryptUnprotectSecretArgs {
                    blob,
                    server,
                    proxy,
                    username,
                    password: password.into(),
                    client_computer_name,
                    kerberos_config: None,
                    network_client: &mut network_client
                })),
            NTE_INTERNAL_ERROR
        );

        if secret_data.as_ref().is_empty() {
            error!("Decrypted secret is empty.");
            return NTE_INTERNAL_ERROR;
        }

        // SAFETY: Memory allocation is safe. Moreover, we check for the null value below.
        let secret_buf = unsafe { libc::malloc(secret_data.as_ref().len()) as *mut u8 };
        if secret_buf.is_null() {
            error!("Failed to allocate memory for the output DPAPI blob: blob buf pointer is NULL.");
            return NTE_NO_MEMORY;
        }

        // SAFETY: The `secret_buf` pointer is not NULL (checked above). The slice construction is safe because `secret_buf`
        // points to allocated, properly aligned, and not-empty bytes range.
        let buf = unsafe { from_raw_parts_mut(secret_buf, secret_data.as_ref().len()) };
        buf.copy_from_slice(secret_data.as_ref());

        // SAFETY: The `secret` pointer is not NULL (checked above).
        unsafe {
            *secret = secret_buf;
            *secret_len = try_execute!(secret_data.as_ref().len().try_into(), NTE_INTERNAL_ERROR);
        }

        ERROR_SUCCESS
    }
}

/// Frees the memory allocated by [DpapiProtectSecret] and [DpapiUnprotectSecret] functions.
///
/// # Safety
///
/// The `data` parameter must be a valid pointer to the memory allocated by the [DpapiProtectSecret] or
/// [DpapiUnprotectSecret] functions and **cannot be NULL**.
#[instrument(skip_all)]
#[no_mangle]
pub unsafe extern "system" fn DpapiFree(buf: LpCByte) -> u32 {
    catch_panic! {
        check_null!(buf);

        // SAFETY: The user should uphold that the passed pointer is a memory allocated by an out DPAPI functions.
        unsafe {
            libc::free(buf as _);
        }

        ERROR_SUCCESS
    }
}

#[cfg(test)]
mod tests {
    //! This tests simulate `DpapiProtectSecret`, `DpapiUnprotectSecret`, and `DpapiFree` function calls.
    //! It's better to run them using Miri: https://github.com/rust-lang/miri.
    //! cargo +nightly miri test
    //!
    //! Note: this tests aim to check only the FFI functions implementation.
    //! Checking the correctness of DPAPI functions is not a goal of these tests.

    use std::ptr::{null, null_mut};

    use super::*;

    #[test]
    fn test_dpapi_protect_secret() {
        let secret = b"secret-to-encrypt";
        let secret_len = secret.len() as u32;
        let sid = "S-1-5-21-1485435871-894665558-560847465-1104\0";
        let server = "win-956cqossjtf.tbt.com\0";
        let username = "t2@tbt.com\0";
        let password = "qqqQQQ111!!!\0";
        let mut blob: LpByte = null_mut();
        let mut blob_len = 0;

        let result = unsafe {
            DpapiProtectSecret(
                secret.as_ptr(),
                secret_len,
                sid.as_ptr(),
                null(),
                server.as_ptr(),
                username.as_ptr(),
                password.as_ptr(),
                null(),
                null(),
                None,
                &mut blob,
                &mut blob_len,
            )
        };

        assert_eq!(result, ERROR_SUCCESS);
        assert!(!blob.is_null());
        assert!(blob_len > 0);

        let mut decrypted_secret: LpByte = null_mut();
        let mut secret_len = 0;

        let result = unsafe {
            DpapiUnprotectSecret(
                blob,
                blob_len,
                server.as_ptr(),
                username.as_ptr(),
                password.as_ptr(),
                null(),
                null(),
                None,
                &mut decrypted_secret,
                &mut secret_len,
            )
        };

        assert_eq!(result, ERROR_SUCCESS);
        assert!(!decrypted_secret.is_null());
        assert!(secret_len > 0);

        unsafe {
            DpapiFree(blob);
            DpapiFree(decrypted_secret);
        }
    }

    #[test]
    fn test_dpapi_protect_secret_proxied() {
        let secret = b"secret-to-encrypt";
        let secret_len = secret.len() as u32;
        let sid = "S-1-5-21-1485435871-894665558-560847465-1104\0";
        let server = "win-956cqossjtf.tbt.com\0";
        let username = "t2@tbt.com\0";
        let password = "qqqQQQ111!!!\0";
        let proxy_url = "ws://dg.tbt.com:7171/\0";
        let mut blob: LpByte = null_mut();
        let mut blob_len = 0;

        let result = unsafe {
            DpapiProtectSecret(
                secret.as_ptr(),
                secret_len,
                sid.as_ptr(),
                null(),
                server.as_ptr(),
                username.as_ptr(),
                password.as_ptr(),
                null(),
                proxy_url.as_ptr(),
                Some(api::get_session_token),
                &mut blob,
                &mut blob_len,
            )
        };

        assert_eq!(result, ERROR_SUCCESS);
        assert!(!blob.is_null());
        assert!(blob_len > 0);

        let mut decrypted_secret: LpByte = null_mut();
        let mut secret_len = 0;

        let result = unsafe {
            DpapiUnprotectSecret(
                blob,
                blob_len,
                server.as_ptr(),
                username.as_ptr(),
                password.as_ptr(),
                null(),
                proxy_url.as_ptr(),
                Some(api::get_session_token),
                &mut decrypted_secret,
                &mut secret_len,
            )
        };

        assert_eq!(result, ERROR_SUCCESS);
        assert!(!decrypted_secret.is_null());
        assert!(secret_len > 0);

        unsafe {
            DpapiFree(blob);
            DpapiFree(decrypted_secret);
        }
    }
}


--- File: ffi/src/dpapi/network_client.rs ---
use std::future::Future;
use std::pin::Pin;

use sspi::network_client::reqwest_network_client::ReqwestNetworkClient;
use sspi::network_client::{AsyncNetworkClient, NetworkClient};
use sspi::{Error, ErrorKind, NetworkRequest, Result};

#[derive(Debug)]
pub struct SyncNetworkClient;

impl AsyncNetworkClient for SyncNetworkClient {
    fn send<'a>(
        &'a mut self,
        request: &'a NetworkRequest,
    ) -> Pin<Box<dyn Future<Output = Result<Vec<u8>>> + Send + 'a>> {
        let request = request.clone();
        Box::pin(async move {
            tokio::task::spawn_blocking(move || ReqwestNetworkClient.send(&request))
                .await
                .map_err(|err| Error::new(ErrorKind::InternalError, err))?
        })
    }
}


--- File: ffi/src/dpapi/session_token.rs ---
use std::ffi::CString;
use std::io::{Error, ErrorKind};
use std::str;

use dpapi_transport::GetSessionTokenFn;
use ffi_types::Uuid as CUuid;
use url::Url;
use uuid::Uuid;

use super::GetSessionTokenFn as CGetSessionTokenFn;

/// This function wraps a C-function into a Rust closure which we can pass into the Rust API.
///
/// # Safety
///
/// The C function pointer must be safe to call provided parameters are valid.
pub unsafe fn session_token_fn(get_session_token: CGetSessionTokenFn) -> Box<GetSessionTokenFn> {
    Box::new(move |session_id: Uuid, destination: Url| {
        Box::pin(async move {
            let (data1, data2, data3, data4) = session_id.as_fields();

            let session_id = CUuid {
                data1,
                data2,
                data3,
                data4: *data4,
            };

            let destination = CString::new(destination.as_str())
                .map_err(|err| Error::new(ErrorKind::InvalidData, format!("invalid destination url: {:?}", err)))?;
            let mut token_len = 2048;
            let mut token_buf = vec![0; 2048];

            // SAFETY:
            // As per safety preconditions, the C function pointer is safe to be called with valid parameters.
            //
            // Parameters are valid because:
            // * session_id is an object on stack.
            // * destination is created (and validated) using `CString`.
            // * token_buf is a non-empty Vec.
            // * token len is a local variable.
            let status = unsafe {
                get_session_token(
                    &session_id,
                    destination.as_ptr() as *const _,
                    token_buf.as_mut_ptr(),
                    &mut token_len,
                )
            };

            if status != 0 {
                return Err(Error::other(format!(
                    "failed to get the session token. error code {:#x?}",
                    status
                )));
            }

            str::from_utf8(&token_buf[..usize::try_from(token_len).unwrap()])
                .map(|token| token.to_owned())
                .map_err(|err| {
                    Error::new(
                        ErrorKind::InvalidData,
                        format!("session token must be UTF-8 valid data but it is not: {:?}", err),
                    )
                })
        })
    })
}


--- File: ffi/src/lib.rs ---
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::print_stdout)]
#![allow(non_snake_case)]
#![deny(unsafe_op_in_unsafe_fn)]
#![warn(clippy::undocumented_unsafe_blocks)]

#[macro_use]
extern crate tracing;

#[cfg(feature = "dpapi")]
#[deny(unsafe_op_in_unsafe_fn)]
#[warn(clippy::undocumented_unsafe_blocks)]
pub mod dpapi;
pub mod logging;
pub mod sspi;
mod utils;
#[cfg(feature = "scard")]
pub mod winscard;


--- File: ffi/src/logging.rs ---
use std::fs::OpenOptions;
use std::path::PathBuf;
use std::sync::Once;

use tracing_subscriber::prelude::*;
use tracing_subscriber::EnvFilter;

static SETUP: Once = Once::new();

const SSPI_LOG_PATH_ENV: &str = "SSPI_LOG_PATH";

pub fn setup_logger() {
    SETUP.call_once(|| {
        let path = if let Ok(path) = std::env::var(SSPI_LOG_PATH_ENV) {
            println!("[SSPI-DEBUG] SSPI_LOG_PATH = {path}");
            PathBuf::from(path)
        } else {
            return;
        };

        let file = match OpenOptions::new().create(true).append(true).open(path) {
            Ok(f) => f,
            Err(e) => {
                println!("[SSPI-DEBUG] Couldn't open log file: {e}");
                return;
            }
        };

        let fmt_layer = tracing_subscriber::fmt::layer()
            .pretty()
            .with_thread_names(true)
            .with_writer(file);

        tracing_subscriber::registry()
            .with(fmt_layer)
            .with(EnvFilter::from_env("SSPI_LOG_LEVEL"))
            .init();

        std::panic::set_hook(Box::new(move |panic| {
            if let Some(location) = panic.location() {
                error!(
                    message = %panic,
                    panic.file = location.file(),
                    panic.line = location.line(),
                    panic.column = location.column(),
                );
            } else {
                error!(message = %panic);
            }
        }));
    })
}

/// FFI function to call in order to manually setup the debug logger.
///
/// Under normal circumstances, it is not required to call this function.
/// Indeed `InitSecurityInterface*` family functions will trigger the same
/// behavior. However, you can call this directly if you need to manually set up the logger
/// (maybe in order to debug `InitSecurityInterface*`).
///
/// This function can be called multiple times safely.
#[no_mangle]
pub extern "system" fn RustSspiSetupLogger() {
    setup_logger();
}


--- File: ffi/src/sspi/common.rs ---
use std::slice::{from_raw_parts, from_raw_parts_mut};

use libc::{c_ulonglong, c_void};
use num_traits::cast::{FromPrimitive, ToPrimitive};
use sspi::{
    BufferType, DataRepresentation, DecryptionFlags, EncryptionFlags, Error, ErrorKind, SecurityBuffer,
    SecurityBufferRef, SecurityBufferType, ServerRequestFlags, Sspi, SspiImpl,
};
#[cfg(windows)]
use symbol_rename_macro::rename_symbol;

use super::credentials_attributes::CredentialsAttributes;
use super::sec_buffer::{
    copy_to_c_sec_buffer, p_sec_buffers_to_security_buffers, PSecBuffer, PSecBufferDesc, SecBuffer,
};
use super::sec_handle::{p_ctxt_handle_to_sspi_context, CredentialsHandle, PCredHandle, PCtxtHandle};
use super::sspi_data_types::{PTimeStamp, SecurityStatus};
use super::utils::transform_credentials_handle;
use crate::sspi::sec_handle::SspiHandle;
use crate::utils::into_raw_ptr;

#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_FreeCredentialsHandle"))]
#[no_mangle]
pub unsafe extern "system" fn FreeCredentialsHandle(ph_credential: PCredHandle) -> SecurityStatus {
    check_null!(ph_credential);

    // SAFETY: `ph_credentials` is not null. We've checked for this above.
    let cred_handle = unsafe { (*ph_credential).dw_lower as *mut CredentialsHandle };
    check_null!(cred_handle);

    // SAFETY: `cred_handle` is not null. We've checked for this above.
    // We create and allocate credentials handles using `Box::into_raw`. Thus,
    // it is safe to deallocate them using `Box::from_raw`.
    // The user have to ensure that the credentials handle was created by us.
    let _cred_handle = unsafe { Box::from_raw(cred_handle) };

    0
}

pub type FreeCredentialsHandleFn = unsafe extern "system" fn(PCredHandle) -> SecurityStatus;

#[instrument(skip_all)]
#[allow(clippy::useless_conversion)]
#[cfg_attr(windows, rename_symbol(to = "Rust_AcceptSecurityContext"))]
#[no_mangle]
pub unsafe extern "system" fn AcceptSecurityContext(
    ph_credential: PCredHandle,
    mut ph_context: PCtxtHandle,
    p_input: PSecBufferDesc,
    f_context_req: u32,
    target_data_rep: u32,
    ph_new_context: PCtxtHandle,
    p_output: PSecBufferDesc,
    pf_context_attr: *mut u32,
    _pts_expiry: PTimeStamp,
) -> SecurityStatus {
    catch_panic! {
        // ph_context can be null on the first call
        check_null!(ph_new_context);
        check_null!(ph_credential);
        check_null!(p_input);
        check_null!(p_output);
        check_null!(pf_context_attr);

        // SAFETY: `ph_credentials` is not null. We've checked for this above.
        let credentials_handle = unsafe { (*ph_credential).dw_lower as *mut CredentialsHandle };

        // SAFETY: It's safe to call the function, because it has internal null check and proper error handling.
        let (auth_data, security_package_name, attributes) = unsafe {
            match transform_credentials_handle(credentials_handle) {
                Some(data) => data,
                None => return ErrorKind::InvalidHandle.to_u32().unwrap(),
            }
        };

        // SAFETY: It's safe to call the function, because:
        // *`ph_context` can be null;
        // * the value behind `ph_context` must be initialized by ourself: the user does not have to create the [CtxHandle] values ​​themselves.
        // * other parameters are type checked.
        let mut sspi_context_ptr = try_execute!(unsafe { p_ctxt_handle_to_sspi_context(
            &mut ph_context,
            Some(security_package_name),
            attributes,
        )});

        // SAFETY: It's safe to call the `as_mut` function, because `sspi_context_ptr` is a local pointer,
        // which is initialized by the `p_ctx_handle_to_sspi_context` function. Thus, the value behind this pointer is valid.
        let sspi_context = unsafe { sspi_context_ptr.as_mut() };

        // SAFETY: `p_input` is not null. We've checked for this above. Additionally, we check `p_buffers` for null.
        // All other guarantees must be provided by user.
        let mut input_tokens = try_execute!(unsafe {
                if (*p_input).p_buffers.is_null() {
                    Err(Error::new(ErrorKind::InvalidParameter, "p_buffers cannot be null"))
                } else {
                    Ok(p_sec_buffers_to_security_buffers(from_raw_parts((*p_input).p_buffers, (*p_input).c_buffers as usize)))
                }
        });

        let mut output_tokens = vec![SecurityBuffer::new(Vec::with_capacity(1024), BufferType::Token)];

        let mut auth_data = Some(auth_data);
        let builder = sspi_context.accept_security_context()
            .with_credentials_handle(&mut auth_data)
            .with_context_requirements(ServerRequestFlags::from_bits(f_context_req.try_into().unwrap()).unwrap())
            .with_target_data_representation(DataRepresentation::from_u32(target_data_rep.try_into().unwrap()).unwrap())
            .with_input(&mut input_tokens)
            .with_output(&mut output_tokens);
        let result_status = try_execute!(sspi_context.accept_security_context_impl(builder)).resolve_with_default_network_client();

        // SAFETY: `p_output` is not null. We've checked this above.
        try_execute!(unsafe { copy_to_c_sec_buffer((*p_output).p_buffers, &output_tokens, false) });

        // SAFETY: `ph_new_context` is not null. We've checked this above.
        let ph_new_context = unsafe { ph_new_context.as_mut() }.expect("ph_new_context should not be null");

        ph_new_context.dw_lower = sspi_context_ptr.as_ptr() as c_ulonglong;
        ph_new_context.dw_upper = into_raw_ptr(security_package_name.to_owned()) as c_ulonglong;
        // SAFETY: `pf_context_attr` is not null. We've checked this above.
        unsafe {
            *pf_context_attr = f_context_req;
        }

        let result = try_execute!(result_status);
        result.status.to_u32().unwrap()
    }
}

pub type AcceptSecurityContextFn = unsafe extern "system" fn(
    PCredHandle,
    PCtxtHandle,
    PSecBufferDesc,
    u32,
    u32,
    PCtxtHandle,
    PSecBufferDesc,
    *mut u32,
    PTimeStamp,
) -> SecurityStatus;

#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_CompleteAuthToken"))]
#[no_mangle]
pub unsafe extern "system" fn CompleteAuthToken(
    mut ph_context: PCtxtHandle,
    p_token: PSecBufferDesc,
) -> SecurityStatus {
    catch_panic! {
        check_null!(ph_context);
        check_null!(p_token);

        // SAFETY: `p_token` is not null. We've checked this above.
        unsafe { check_null!((*p_token).p_buffers); }

        // SAFETY: It's safe to call the function, because:
        // *`ph_context` can be null;
        // * the value behind `ph_context` must be initialized by ourself: the user does not have to create the [CtxHandle] values ​​themselves.
        // * other parameters are type checked.
        let mut sspi_context_ptr = try_execute!(unsafe { p_ctxt_handle_to_sspi_context(
            &mut ph_context,
            None,
            &CredentialsAttributes::default()
        )});

        // SAFETY: It's safe to call the `as_mut` function, because `sspi_context_ptr` is a local pointer,
        // which is initialized by the `p_ctx_handle_to_sspi_context` function. Thus, the value behind this pointer is valid.
        let sspi_context = unsafe { sspi_context_ptr.as_mut() };

        // SAFETY: This function is safe to call because `p_buffers` is not null. We've checked this above.
        let raw_buffers = unsafe { from_raw_parts((*p_token).p_buffers, (*p_token).c_buffers as usize) };
        // SAFETY: This function is safe to call because `raw_buffers` is type checked. All other guarantees must be provided by user.
        let mut buffers = unsafe { p_sec_buffers_to_security_buffers(raw_buffers) };

        sspi_context.complete_auth_token(&mut buffers).map_or_else(
            |err| err.error_type.to_u32().unwrap(),
            |result| result.to_u32().unwrap(),
        )
    }
}

pub type CompleteAuthTokenFn = unsafe extern "system" fn(PCtxtHandle, PSecBufferDesc) -> SecurityStatus;

#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_DeleteSecurityContext"))]
#[no_mangle]
pub unsafe extern "system" fn DeleteSecurityContext(mut ph_context: PCtxtHandle) -> SecurityStatus {
    catch_panic!(
        check_null!(ph_context);

        // SAFETY: It's safe to call the function, because:
        // * the value behind `ph_context` must be initialized by ourself: the user does not have to create the [CtxHandle] values ​​themselves.
        // * other parameters are type checked.
        let mut sspi_context_ptr = try_execute!(unsafe { p_ctxt_handle_to_sspi_context(
            &mut ph_context,
            None,
            &CredentialsAttributes::default()
        )});

        // SAFETY: It's safe to constructs a box from a raw pointer because:
        // * the `sspi_context_ptr` is not null;
        // * the value behind `sspi_context_ptr` must be initialized by ourself: the user does not have to create the [CtxHandle] values ​​themselves.
        let _context: Box<SspiHandle> = unsafe {
            Box::from_raw(sspi_context_ptr.as_mut())
        };

        // SAFETY: `ph_context` is not null. We've checked for it above.
        let dw_upper = unsafe { (*ph_context).dw_upper };
        if dw_upper != 0 {
            // SAFETY: It's safe to constructs a box from a raw pointer because:
            // * the `dw_upper` is not equal to zero;
            // * the value behind `dw_upper` pointer must be initialized by ourself: the user does not have to create the [CtxHandle] values ​​themselves.
            let _name: Box<String> = unsafe { Box::from_raw(dw_upper as *mut String) };
        }

        0
    )
}

pub type DeleteSecurityContextFn = unsafe extern "system" fn(PCtxtHandle) -> SecurityStatus;

#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_ApplyControlToken"))]
#[no_mangle]
pub extern "system" fn ApplyControlToken(_ph_context: PCtxtHandle, _p_input: PSecBufferDesc) -> SecurityStatus {
    ErrorKind::UnsupportedFunction.to_u32().unwrap()
}

pub type ApplyControlTokenFn = extern "system" fn(PCtxtHandle, PSecBufferDesc) -> SecurityStatus;

#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_ImpersonateSecurityContext"))]
#[no_mangle]
pub extern "system" fn ImpersonateSecurityContext(_ph_context: PCtxtHandle) -> SecurityStatus {
    ErrorKind::UnsupportedFunction.to_u32().unwrap()
}

pub type ImpersonateSecurityContextFn = extern "system" fn(PCtxtHandle) -> SecurityStatus;

#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_RevertSecurityContext"))]
#[no_mangle]
pub extern "system" fn RevertSecurityContext(_ph_context: PCtxtHandle) -> SecurityStatus {
    ErrorKind::UnsupportedFunction.to_u32().unwrap()
}

pub type RevertSecurityContextFn = extern "system" fn(PCtxtHandle) -> SecurityStatus;

#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_MakeSignature"))]
#[no_mangle]
pub extern "system" fn MakeSignature(
    _ph_context: PCtxtHandle,
    _f_qop: u32,
    _p_message: PSecBufferDesc,
    _message_seq_no: u32,
) -> SecurityStatus {
    ErrorKind::UnsupportedFunction.to_u32().unwrap()
}

pub type MakeSignatureFn = extern "system" fn(PCtxtHandle, u32, PSecBufferDesc, u32) -> SecurityStatus;

#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_VerifySignature"))]
#[no_mangle]
pub extern "system" fn VerifySignature(
    _ph_context: PCtxtHandle,
    _message: PSecBufferDesc,
    _message_seq_no: u32,
    _pf_qop: *mut u32,
) -> SecurityStatus {
    ErrorKind::UnsupportedFunction.to_u32().unwrap()
}

pub type VerifySignatureFn = extern "system" fn(PCtxtHandle, PSecBufferDesc, u32, *mut u32) -> SecurityStatus;

#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_FreeContextBuffer"))]
#[no_mangle]
pub unsafe extern "system" fn FreeContextBuffer(pv_context_buffer: *mut c_void) -> SecurityStatus {
    // NOTE: see https://github.com/Devolutions/sspi-rs/pull/141 for rationale behind libc usage.
    // SAFETY: Memory deallocation is safe.
    // The user must call this function to free buffers allocated by ourself. On our side, we always use `malloc`
    // to allocate buffers in in FFI.
    unsafe {
        libc::free(pv_context_buffer);
    }

    0
}

pub type FreeContextBufferFn = unsafe extern "system" fn(*mut c_void) -> SecurityStatus;

#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_ExportSecurityContext"))]
#[no_mangle]
pub extern "system" fn ExportSecurityContext(
    _ph_context: PCtxtHandle,
    _f_flags: u32,
    _p_packed_context: PSecBuffer,
    _p_token: *mut *mut c_void,
) -> SecurityStatus {
    ErrorKind::UnsupportedFunction.to_u32().unwrap()
}

pub type ExportSecurityContextFn = extern "system" fn(PCtxtHandle, u32, PSecBuffer, *mut *mut c_void) -> SecurityStatus;

#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_QuerySecurityContextToken"))]
#[no_mangle]
pub extern "system" fn QuerySecurityContextToken(_ph_context: PCtxtHandle, _token: *mut *mut c_void) -> SecurityStatus {
    ErrorKind::UnsupportedFunction.to_u32().unwrap()
}

pub type QuerySecurityContextTokenFn = extern "system" fn(PCtxtHandle, *mut *mut c_void) -> SecurityStatus;

#[allow(clippy::useless_conversion)]
#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_EncryptMessage"))]
#[no_mangle]
pub unsafe extern "system" fn EncryptMessage(
    mut ph_context: PCtxtHandle,
    f_qop: u32,
    p_message: PSecBufferDesc,
    message_seq_no: u32,
) -> SecurityStatus {
    catch_panic! {
        check_null!(ph_context);
        check_null!(p_message);

        // SAFETY: `p_message` is not null. We've checked this above.
        unsafe { check_null!((*p_message).p_buffers); }

        // SAFETY: It's safe to call the function, because:
        // *`ph_context` can be null;
        // * the value behind `ph_context` must be initialized by ourself: the user does not have to create the [CtxHandle] values ​​themselves.
        // * other parameters are type checked.
        let mut sspi_context_ptr = try_execute!(unsafe { p_ctxt_handle_to_sspi_context(
            &mut ph_context,
            None,
            &CredentialsAttributes::default()
        )});

        // SAFETY: It's safe to call the `as_mut` function, because `sspi_context_ptr` is a local pointer,
        // which is initialized by the `p_ctx_handle_to_sspi_context` function. Thus, the value behind this pointer is valid.
        let sspi_context = unsafe { sspi_context_ptr.as_mut() };

        // SAFETY: `p_message` is not null. We've checked this above.
        let len = unsafe { (*p_message).c_buffers as usize };

        // SAFETY: `p_message` is not null. We've checked this above. Moreover, we've checked `p_buffers` for null above.
        let raw_buffers = unsafe {
            from_raw_parts((*p_message).p_buffers, len)
        };

        // SAFETY: The user must provide guarantees about the correctness of buffers in `raw_buffers'.
        let mut message = try_execute!(unsafe { p_sec_buffers_to_decrypt_buffers(raw_buffers)});

        let result_status = sspi_context.encrypt_message(
            EncryptionFlags::from_bits(f_qop.try_into().unwrap()).unwrap(),
            &mut message,
            message_seq_no.try_into().unwrap(),
        );

        // SAFETY: `p_message` and `p_buffers` are not null. We've checked this above.
        // All other guarantees must be provided by user.
        try_execute!(unsafe { copy_decrypted_buffers((*p_message).p_buffers, message) });

        let result = try_execute!(result_status);
        result.to_u32().unwrap()
    }
}

pub type EncryptMessageFn = unsafe extern "system" fn(PCtxtHandle, u32, PSecBufferDesc, u32) -> SecurityStatus;

#[allow(clippy::useless_conversion)]
#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_DecryptMessage"))]
#[no_mangle]
pub unsafe extern "system" fn DecryptMessage(
    mut ph_context: PCtxtHandle,
    p_message: PSecBufferDesc,
    message_seq_no: u32,
    pf_qop: *mut u32,
) -> SecurityStatus {
    catch_panic! {
        check_null!(ph_context);
        check_null!(p_message);

        // SAFETY: `p_message` is not null. We've checked this above.
        unsafe { check_null!((*p_message).p_buffers); }

        // SAFETY: It's safe to call the function, because:
        // *`ph_context` can be null;
        // * the value behind `ph_context` must be initialized by ourself: the user does not have to create the [CtxHandle] values ​​themselves.
        // * other parameters are type checked.
        let mut sspi_context_ptr = try_execute!(unsafe { p_ctxt_handle_to_sspi_context(
            &mut ph_context,
            None,
            &CredentialsAttributes::default()
        )});

        // SAFETY: It's safe to call the `as_mut` function, because `sspi_context_ptr` is a local pointer,
        // which is initialized by the `p_ctx_handle_to_sspi_context` function. Thus, the value behind this pointer is valid.
        let sspi_context = unsafe { sspi_context_ptr.as_mut() };

        // SAFETY: `p_message` is not null. We've checked this above.
        let len = unsafe { (*p_message).c_buffers as usize };
        // SAFETY: `p_message` and `p_buffers` is not null. We've checked this above.
        let raw_buffers = unsafe { from_raw_parts((*p_message).p_buffers, len) };
        // SAFETY: The user must provide guarantees about the correctness of buffers in `raw_buffers'.
        let mut message = try_execute!(unsafe { p_sec_buffers_to_decrypt_buffers(raw_buffers) });

        let (decryption_flags, result_status) =
            match sspi_context.decrypt_message(&mut message, message_seq_no.try_into().unwrap()) {
                Ok(flags) => (flags, Ok(())),
                Err(error) => (DecryptionFlags::empty(), Err(error)),
            };

        // SAFETY: `p_message` and `p_buffers` is not null. We've checked this above.
        // All other guarantees must be provided by user.
        try_execute!(unsafe { copy_decrypted_buffers((*p_message).p_buffers, message) });
        // `pf_qop` can be null if this library is used as a CredSsp security package
        if !pf_qop.is_null() {
            let flags = try_execute!(decryption_flags.bits().try_into(), ErrorKind::InternalError);
            // SAFETY: `pf_qop` is not null. We've checked this above.
            unsafe { *pf_qop = flags };
        }

        try_execute!(result_status);

        0
    }
}

/// Creates a vector of [SecurityBufferRef]s from the input C buffers.
///
/// *Attention*: after this function call, no one should touch [raw_buffers]. Otherwise, we can get UB.
/// It's because this function creates exclusive (mutable) Rust references to the input buffers.
#[allow(clippy::useless_conversion)]
unsafe fn p_sec_buffers_to_decrypt_buffers(raw_buffers: &[SecBuffer]) -> sspi::Result<Vec<SecurityBufferRef>> {
    let mut buffers = Vec::with_capacity(raw_buffers.len());

    for raw_buffer in raw_buffers {
        let buf =
            SecurityBufferRef::with_owned_security_buffer_type(SecurityBufferType::try_from(raw_buffer.buffer_type)?)?;

        buffers.push(if BufferType::Missing == buf.buffer_type() {
            // https://learn.microsoft.com/en-us/windows/win32/api/sspi/ns-sspi-secbuffer
            // SECBUFFER_MISSING: ...The pvBuffer member is ignored in this type.
            SecurityBufferRef::missing_buf(raw_buffer.cb_buffer.try_into()?)
        } else {
            let data = if raw_buffer.pv_buffer.is_null() || raw_buffer.cb_buffer == 0 {
                &mut []
            } else {
                // SAFETY: the safety contract [raw_buffers] must be upheld by the caller.
                unsafe { from_raw_parts_mut(raw_buffer.pv_buffer as *mut u8, raw_buffer.cb_buffer.try_into()?) }
            };
            buf.with_data(data)?
        })
    }

    Ok(buffers)
}

/// Copies Rust-security-buffers into C-security-buffers.
///
/// This function accepts owned [from_buffers] to avoid UB and other errors. Rust-buffers should
/// not be used after the data is copied into C-buffers.
unsafe fn copy_decrypted_buffers(to_buffers: PSecBuffer, from_buffers: Vec<SecurityBufferRef>) -> sspi::Result<()> {
    // SAFETY: the safety contract [to_buffers] must be upheld by the caller.
    let to_buffers = unsafe { from_raw_parts_mut(to_buffers, from_buffers.len()) };

    for (to_buffer, mut from_buffer) in to_buffers.iter_mut().zip(from_buffers.into_iter()) {
        // The `SECBUFFER_STREAM` buffer is only used for the data passing during the decryption
        // when the caller doesn't know the exact `SECBUFFER_TOKEN` and `SECBUFFER_DATA` lengths.
        // After the decryption, the pointer and length of the SECBUFFER_STREAM are unchanged.
        // So, we don't need to copy any data and we skip it.
        //
        // The `SECBUFFER_STREAM` usage example: https://learn.microsoft.com/en-us/windows/win32/secauthn/sspi-kerberos-interoperability-with-gssapi
        if from_buffer.buffer_type() == BufferType::Stream {
            continue;
        }

        let from_buffer_len = from_buffer.buf_len();

        to_buffer.buffer_type = from_buffer.owned_security_buffer_type().into();
        to_buffer.cb_buffer = from_buffer_len.try_into()?;

        if from_buffer.buffer_type() != BufferType::Missing {
            // We don't need to copy the actual content of the buffer because [from_buffer] is created
            // from the C-input-buffer and all decryption is performed in-place.
            to_buffer.pv_buffer = from_buffer.take_data().as_mut_ptr() as *mut _;
        }
    }

    Ok(())
}

pub type DecryptMessageFn = unsafe extern "system" fn(PCtxtHandle, PSecBufferDesc, u32, *mut u32) -> SecurityStatus;

#[cfg(test)]
mod tests {
    use std::ptr::null_mut;
    use std::slice::from_raw_parts;

    use libc::c_ulonglong;
    use sspi::credssp::SspiContext;
    use sspi::{EncryptionFlags, Kerberos, SecurityBufferRef, Sspi};

    use crate::sspi::sec_buffer::{SecBuffer, SecBufferDesc};
    use crate::sspi::sec_handle::{SecHandle, SspiHandle};
    use crate::utils::into_raw_ptr;

    fn kerberos_sec_handle(kerberos: Kerberos) -> SecHandle {
        SecHandle {
            dw_lower: {
                let sspi_context = SspiHandle::new(SspiContext::Kerberos(kerberos));
                into_raw_ptr(sspi_context) as c_ulonglong
            },
            dw_upper: into_raw_ptr(sspi::kerberos::PACKAGE_INFO.name.to_string()) as c_ulonglong,
        }
    }

    #[test]
    fn kerberos_stream_buffer_decryption() {
        // This test simulates decryption when the `SECBUFFER_STREAM` buffer is used.
        // The expected behavior is the same as for the original Windows SSPI.
        //
        // MSDN code example: https://learn.microsoft.com/en-us/windows/win32/secauthn/sspi-kerberos-interoperability-with-gssapi
        let plain_message = b"some plain message";

        let kerberos_client = sspi::kerberos::test_data::fake_client();
        let mut kerberos_server = sspi::kerberos::test_data::fake_server();

        let mut token = [0; 1024];
        let mut data = plain_message.to_vec();
        let mut message = vec![
            SecurityBufferRef::token_buf(token.as_mut_slice()),
            SecurityBufferRef::data_buf(data.as_mut_slice()),
        ];

        kerberos_server
            .encrypt_message(EncryptionFlags::empty(), &mut message, 0)
            .unwrap();

        let mut kerberos_client_context = kerberos_sec_handle(kerberos_client);

        let mut stream_buffer_data = message[0].data().to_vec();
        stream_buffer_data.extend_from_slice(message[1].data());
        let stream_buffer_data_len = stream_buffer_data.len().try_into().unwrap();
        let mut buffers = [
            SecBuffer {
                cb_buffer: stream_buffer_data_len,
                buffer_type: 10,
                pv_buffer: stream_buffer_data.as_mut_ptr() as *mut _,
            },
            SecBuffer {
                cb_buffer: 0,
                buffer_type: 1,
                pv_buffer: null_mut(),
            },
        ];
        let mut message = SecBufferDesc {
            ul_version: 0,
            c_buffers: 2,
            p_buffers: buffers.as_mut_ptr(),
        };

        let status = unsafe { super::DecryptMessage(&mut kerberos_client_context, &mut message, 0, null_mut()) };
        assert_eq!(status, 0);

        let status = unsafe { super::DeleteSecurityContext(&mut kerberos_client_context) };
        assert_eq!(status, 0);

        // Check SECBUFFER_STREAM
        assert_eq!(buffers[0].buffer_type, 10);
        assert_eq!(buffers[0].cb_buffer, stream_buffer_data_len);

        // Check SECBUFFER_DATA
        assert_eq!(buffers[1].buffer_type, 1);
        assert_eq!(buffers[1].cb_buffer, u32::try_from(plain_message.len()).unwrap());
        // Check that the decrypted data is the same as the initial message
        assert_eq!(
            unsafe {
                from_raw_parts(
                    buffers[1].pv_buffer as *const u8,
                    buffers[1].cb_buffer.try_into().unwrap(),
                )
            },
            plain_message
        );
    }

    /// This test simulates initialize security context function call. It's better to run it using Miri
    /// https://github.com/rust-lang/miri
    /// cargo +nightly miri test
    #[test]
    fn kerberos_encryption_decryption() {
        let plain_message = b"some plain message";

        let kerberos_client = sspi::kerberos::test_data::fake_client();
        let kerberos_server = sspi::kerberos::test_data::fake_server();

        let mut kerberos_server_context = kerberos_sec_handle(kerberos_server);

        let mut token = [0_u8; 1024];
        let mut data = plain_message.to_vec();
        let mut buffers = [
            SecBuffer {
                cb_buffer: token.len().try_into().unwrap(),
                buffer_type: 2, // Token
                pv_buffer: token.as_mut_ptr() as *mut _,
            },
            SecBuffer {
                cb_buffer: data.len().try_into().unwrap(),
                buffer_type: 1, // Data
                pv_buffer: data.as_mut_ptr() as *mut _,
            },
        ];
        let mut message = SecBufferDesc {
            ul_version: 0,
            c_buffers: 2,
            p_buffers: buffers.as_mut_ptr(),
        };

        let status = unsafe { super::EncryptMessage(&mut kerberos_server_context, 0, &mut message, 0) };
        assert_eq!(status, 0);

        let status = unsafe { super::DeleteSecurityContext(&mut kerberos_server_context) };
        assert_eq!(status, 0);

        let mut kerberos_client_context = kerberos_sec_handle(kerberos_client);

        let mut token =
            unsafe { from_raw_parts(buffers[0].pv_buffer as *const u8, buffers[0].cb_buffer as usize) }.to_vec();
        let mut data =
            unsafe { from_raw_parts(buffers[1].pv_buffer as *const u8, buffers[1].cb_buffer as usize) }.to_vec();
        let mut buffers = [
            SecBuffer {
                cb_buffer: token.len().try_into().unwrap(),
                buffer_type: 2, // Token
                pv_buffer: token.as_mut_ptr() as *mut _,
            },
            SecBuffer {
                cb_buffer: data.len().try_into().unwrap(),
                buffer_type: 1, // Data
                pv_buffer: data.as_mut_ptr() as *mut _,
            },
        ];
        let mut message = SecBufferDesc {
            ul_version: 0,
            c_buffers: 2,
            p_buffers: buffers.as_mut_ptr(),
        };

        let status = unsafe { super::DecryptMessage(&mut kerberos_client_context, &mut message, 0, null_mut()) };
        assert_eq!(status, 0);

        let status = unsafe { super::DeleteSecurityContext(&mut kerberos_client_context) };
        assert_eq!(status, 0);

        // Check that the decrypted data is the same as the initial message
        assert_eq!(
            unsafe { from_raw_parts(buffers[1].pv_buffer as *const u8, buffers[1].cb_buffer as usize,) },
            plain_message
        );
    }
}


--- File: ffi/src/sspi/credentials_attributes.rs ---
use std::mem::size_of;
use std::ptr::NonNull;
use std::slice::from_raw_parts;

use libc::c_void;
use sspi::{Error, ErrorKind, Result};

use super::sspi_data_types::{SecChar, SecWChar};
use super::utils::hostname;

#[derive(Debug)]
pub struct KdcProxySettings {
    pub proxy_server: String,
    #[allow(dead_code)]
    pub client_tls_cred: Option<String>,
}

#[derive(Default, Debug)]
pub struct CredentialsAttributes {
    pub package_list: Option<String>,
    pub kdc_url: Option<String>,
    pub kdc_proxy_settings: Option<KdcProxySettings>,
    pub workstation: Option<String>,
}

impl CredentialsAttributes {
    pub fn new() -> Self {
        CredentialsAttributes::default()
    }

    pub fn new_with_package_list(package_list: Option<String>) -> Self {
        CredentialsAttributes {
            package_list,
            ..Default::default()
        }
    }

    pub fn kdc_url(&self) -> Option<String> {
        if let Some(kdc_url) = &self.kdc_url {
            Some(kdc_url.to_string())
        } else {
            self.kdc_proxy_settings
                .as_ref()
                .map(|kdc_proxy_settings| kdc_proxy_settings.proxy_server.to_string())
        }
    }

    pub fn hostname(&self) -> Result<String> {
        if let Some(hostname) = self.workstation.as_ref() {
            Ok(hostname.clone())
        } else {
            hostname()
        }
    }
}

#[repr(C)]
pub struct SecPkgCredentialsKdcProxySettingsW {
    pub version: u32,
    pub flags: u32,
    pub proxy_server_offset: u16,
    pub proxy_server_length: u16,
    pub client_tls_cred_offset: u16,
    pub client_tls_cred_length: u16,
}

/// Extracts [KdcProxySettings].
///
/// # Safety:
///
/// * The pointer value must be [SecPkgCredentialsKdcProxySettingsW].
/// * The proxy server and client TLS credentials (if any) values must be placed right after the [SecPkgCredentialsKdcProxySettingsW] value.
pub unsafe fn extract_kdc_proxy_settings(p_buffer: NonNull<c_void>) -> Result<KdcProxySettings> {
    let p_buffer = p_buffer.as_ptr();

    // SAFETY:
    // * `p_buffer` is not null: checked above;
    // * the user must all other properties of the pointer and the value behind this pointer.
    let kdc_proxy_settings = unsafe {
        p_buffer
            .cast::<SecPkgCredentialsKdcProxySettingsW>()
            .as_ref()
            .expect("p_buffer must not be null")
    };

    let SecPkgCredentialsKdcProxySettingsW {
        proxy_server_offset,
        proxy_server_length,
        client_tls_cred_offset,
        client_tls_cred_length,
        ..
    } = kdc_proxy_settings;

    // SAFETY: `p_buffer` is not null (checked above). `kdc_proxy_settings` was cast from the `p_buffer',
    // so it's not null either.
    let proxy_server = String::from_utf16_lossy(unsafe {
        from_raw_parts(
            p_buffer.add(*proxy_server_offset as usize) as *const u16,
            *proxy_server_length as usize / size_of::<SecWChar>(),
        )
    });

    let client_tls_cred = if *client_tls_cred_offset != 0 && *client_tls_cred_length != 0 {
        // SAFETY: `p_buffer` is not null (checked above).
        // The client have to ensure that the `client_tls_cred_offset` is valid.
        let client_tls_cred_ptr = unsafe { p_buffer.add(*client_tls_cred_offset as usize) } as *const u16;
        if client_tls_cred_ptr.is_null() {
            return Err(Error::new(
                ErrorKind::InvalidParameter,
                "client_tls_cred_ptr cannot be null",
            ));
        }

        // SAFETY: `client_tls_cred_ptr` is not null (checked above).
        // The client have to ensure that the `client_tls_cred_length` is valid.
        let client_tls_cred_data = unsafe { from_raw_parts(client_tls_cred_ptr, *client_tls_cred_length as usize) };
        Some(String::from_utf16_lossy(client_tls_cred_data))
    } else {
        None
    };

    Ok(KdcProxySettings {
        proxy_server,
        client_tls_cred,
    })
}

#[repr(C)]
pub struct SecPkgCredentialsKdcUrlA {
    pub kdc_url: *mut SecChar,
}

#[repr(C)]
pub struct SecPkgCredentialsKdcUrlW {
    pub kdc_url: *mut SecWChar,
}


--- File: ffi/src/sspi/macros.rs ---
macro_rules! try_execute {
    ($x:expr) => {{
        match $x {
            Ok(value) => value,
            Err(err) => {
                error!(%err, "an error occurred");
                return err.error_type.to_u32().unwrap();
            }
        }
    }};
    ($x:expr, $err_value:expr) => {{
        use num_traits::ToPrimitive;

        match $x {
            Ok(val) => val,
            Err(err) => {
                error!(%err, "an error occurred");
                return $err_value.to_u32().unwrap();
            }
        }
    }};
}

macro_rules! check_null {
    ($x:expr) => {{
        use num_traits::ToPrimitive;
        use sspi::ErrorKind;

        if $x.is_null() {
            return ErrorKind::InvalidParameter.to_u32().unwrap();
        }
    }};
}

macro_rules! catch_panic {
    ($($tokens:tt)*) => {{
        use sspi::ErrorKind;
        use num_traits::ToPrimitive;

        match std::panic::catch_unwind(move || { $($tokens)* }) {
            Ok(val) => val,
            Err(_) => {
                return ErrorKind::InternalError.to_u32().unwrap();
            }
        }
    }};
}


--- File: ffi/src/sspi/mod.rs ---
#[macro_use]
mod macros;

pub mod common;
pub mod credentials_attributes;
pub mod sec_buffer;
pub mod sec_handle;
pub mod sec_pkg_info;
pub mod sec_winnt_auth_identity;
pub mod security_tables;
pub mod sspi_data_types;
pub mod utils;


--- File: ffi/src/sspi/sec_buffer.rs ---
use std::slice::{from_raw_parts, from_raw_parts_mut};

use libc::c_char;
use sspi::{Error, ErrorKind, Result, SecurityBuffer, SecurityBufferType};

#[derive(Debug)]
#[repr(C)]
pub struct SecBuffer {
    pub cb_buffer: u32,
    pub buffer_type: u32,
    pub pv_buffer: *mut c_char,
}

pub type PSecBuffer = *mut SecBuffer;

#[derive(Debug)]
#[repr(C)]
pub struct SecBufferDesc {
    pub ul_version: u32,
    pub c_buffers: u32,
    pub p_buffers: PSecBuffer,
}

pub type PSecBufferDesc = *mut SecBufferDesc;

/// # Safety:
///
/// * The input pointer can be null.
/// * If the input pointer is not null, then it must point to the valid [SecBufferDesc] structure. Moreover,
///   the user have to ensure that the pointer is [convertible to a reference](https://doc.rust-lang.org/std/ptr/index.html#pointer-to-reference-conversion).
pub unsafe fn sec_buffer_desc_to_security_buffers(p_input: PSecBufferDesc) -> Vec<SecurityBuffer> {
    // SAFETY:
    // The user must upheld the [SecBufferDesc] validity and make sure that the pointer is convertible to a reference.
    if let Some(input) = unsafe { p_input.as_ref() } {
        let p_buffers = input.p_buffers;
        let c_buffers = input.c_buffers;

        let sec_buffers = if p_buffers.is_null() {
            &[]
        } else {
            // SAFETY: We checked above that the `p_buffers` is not null.
            // The caller must ensure all other guarantees.
            unsafe { from_raw_parts(p_buffers, c_buffers as usize) }
        };

        // SAFETY: This function is safe to call because the argument is type checked.
        unsafe { p_sec_buffers_to_security_buffers(sec_buffers) }
    } else {
        Vec::new()
    }
}

#[allow(clippy::useless_conversion)]
pub(crate) unsafe fn p_sec_buffers_to_security_buffers(raw_buffers: &[SecBuffer]) -> Vec<SecurityBuffer> {
    raw_buffers
        .iter()
        .map(|raw_buffer| SecurityBuffer {
            buffer: if raw_buffer.pv_buffer.is_null() {
                Vec::new()
            } else {
                // SAFETY: `pv_buffer` is not null (checked above). All other guarantees must be provided by the user.
                unsafe { from_raw_parts(raw_buffer.pv_buffer, raw_buffer.cb_buffer as usize) }
                    .iter()
                    .map(|v| *v as u8)
                    .collect()
            },
            buffer_type: SecurityBufferType::try_from(u32::try_from(raw_buffer.buffer_type).unwrap()).unwrap(),
        })
        .collect()
}

pub(crate) unsafe fn copy_to_c_sec_buffer(
    to_buffers: PSecBuffer,
    from_buffers: &[SecurityBuffer],
    allocate: bool,
) -> Result<()> {
    if to_buffers.is_null() {
        return Err(Error::new(ErrorKind::InvalidParameter, "to_buffers cannot be null"));
    }

    // SAFETY: `to_buffers` is not null. We've checked for this above.
    let to_buffers = unsafe { from_raw_parts_mut(to_buffers, from_buffers.len()) };
    for i in 0..from_buffers.len() {
        let buffer = &from_buffers[i];
        let buffer_size = buffer.buffer.len();
        to_buffers[i].cb_buffer = buffer_size.try_into().unwrap();
        to_buffers[i].buffer_type = buffer.buffer_type.into();
        if allocate || to_buffers[i].pv_buffer.is_null() {
            // SAFETY: Memory allocation is safe. Also, we check `pv_buffer` for the null below.
            to_buffers[i].pv_buffer = unsafe { libc::malloc(buffer_size) } as *mut c_char;

            if to_buffers[i].pv_buffer.is_null() {
                return Err(Error::new(
                    ErrorKind::InsufficientMemory,
                    format!("coudln't allocate {buffer_size} bytes"),
                ));
            }
        }

        // SAFETY: `pv_buffer` is not null. We've checked for this above.
        // The user must ensure that the `pv_buffer` size is big enough to accommodate the data.
        unsafe { (buffer.buffer.as_ptr() as *const c_char).copy_to(to_buffers[i].pv_buffer, buffer_size) }
    }

    Ok(())
}


--- File: ffi/src/sspi/sec_handle.rs ---
use std::ffi::CStr;
use std::ptr::NonNull;
use std::slice::from_raw_parts;
use std::sync::Mutex;

use libc::{c_ulonglong, c_void};
use num_traits::{FromPrimitive, ToPrimitive};
use sspi::builders::ChangePasswordBuilder;
#[cfg(feature = "tsssp")]
use sspi::credssp::sspi_cred_ssp;
#[cfg(feature = "tsssp")]
use sspi::credssp::sspi_cred_ssp::SspiCredSsp;
use sspi::credssp::SspiContext;
use sspi::kerberos::config::KerberosConfig;
use sspi::ntlm::NtlmConfig;
use sspi::{
    kerberos, negotiate, ntlm, pku2u, CertContext, ClientRequestFlags, ConnectionInfo, Credentials, CredentialsBuffers,
    DataRepresentation, Error, ErrorKind, Kerberos, Negotiate, NegotiateConfig, Ntlm, PackageInfo, Result, Secret,
    Sspi, SspiImpl, StreamSizes,
};
#[cfg(target_os = "windows")]
use windows_sys::Win32::Security::Cryptography::{
    CertAddEncodedCertificateToStore, CertOpenStore, CERT_CONTEXT, CERT_STORE_ADD_REPLACE_EXISTING,
    CERT_STORE_CREATE_NEW_FLAG, CERT_STORE_PROV_MEMORY,
};

cfg_if::cfg_if! {
    if #[cfg(target_os = "windows")] {
        use symbol_rename_macro::rename_symbol;
        use sspi::{Pku2u, Pku2uConfig};
    }
}

use super::credentials_attributes::{
    extract_kdc_proxy_settings, CredentialsAttributes, SecPkgCredentialsKdcUrlA, SecPkgCredentialsKdcUrlW,
};
use super::sec_buffer::{
    copy_to_c_sec_buffer, p_sec_buffers_to_security_buffers, sec_buffer_desc_to_security_buffers, PSecBuffer,
    PSecBufferDesc,
};
use super::sec_pkg_info::{RawSecPkgInfoA, RawSecPkgInfoW, SecNegoInfoA, SecNegoInfoW, SecPkgInfoA, SecPkgInfoW};
use super::sec_winnt_auth_identity::auth_data_to_identity_buffers;
use super::sspi_data_types::{
    CertTrustStatus, LpStr, LpcWStr, PSecurityString, PTimeStamp, SecChar, SecGetKeyFn, SecPkgContextConnectionInfo,
    SecPkgContextFlags, SecPkgContextSizes, SecPkgContextStreamSizes, SecWChar, SecurityStatus,
};
use super::utils::{hostname, transform_credentials_handle};
use crate::utils::{c_w_str_to_string, into_raw_ptr};

pub const SECPKG_NEGOTIATION_COMPLETE: u32 = 0;
pub const SECPKG_NEGOTIATION_OPTIMISTIC: u32 = 1;
pub const SECPKG_NEGOTIATION_IN_PROGRESS: u32 = 2;

// the sizes of the structures used in the per-message functions and authentication exchanges
pub const SECPKG_ATTR_SIZES: u32 = 0;
// information about the security package to be used with the negotiation process and the current state of the negotiation for the use of that package
pub const SECPKG_ATTR_NEGOTIATION_INFO: u32 = 12;
// the sizes of the various parts of a stream used in the per-message functions
pub const SECPKG_ATTR_STREAM_SIZES: u32 = 4;
// certificate context that contains the end certificate supplied by the server
pub const SECPKG_ATTR_REMOTE_CERT_CONTEXT: u32 = 0x53;
// the name of the authentication package negotiated by the Microsoft Negotiate provider
pub const SECPKG_ATTR_NEGOTIATION_PACKAGE: u32 = 0x80000081;
// information on the SSP in use
pub const SECPKG_ATTR_PACKAGE_INFO: u32 = 10;
// information about the flags in the current security context
pub const SECPKG_ATTR_SERVER_AUTH_FLAGS: u32 = 0x80000083;
// trust information about the certificate
pub const SECPKG_ATTR_CERT_TRUST_STATUS: u32 = 0x80000084;
// detailed information on the established connection
pub const SECPKG_ATTR_CONNECTION_INFO: u32 = 0x5a;

// Sets the name of a credential
// In our library, we use this attribute to set the workstation for auth identity
const SECPKG_CRED_ATTR_NAMES: u32 = 1;
// Sets the Kerberos proxy setting
const SECPKG_CRED_ATTR_KDC_PROXY_SETTINGS: u32 = 3;

const SECPKG_CRED_ATTR_KDC_URL: u32 = 501;

#[derive(Debug)]
#[repr(C)]
pub struct SecHandle {
    pub dw_lower: c_ulonglong,
    pub dw_upper: c_ulonglong,
}

pub type PCredHandle = *mut SecHandle;
pub type PCtxtHandle = *mut SecHandle;

/// Synchronized version of the [SspiContext].
///
/// All functions are synchronized by wrapping [SspiContext] in [Mutex].
pub struct SspiHandle {
    sspi_context: Mutex<SspiContext>,
}

impl SspiHandle {
    /// Creates a new [SspiHandle] based on the provided [SspiContext].
    pub fn new(sspi_context: SspiContext) -> Self {
        Self {
            sspi_context: Mutex::new(sspi_context),
        }
    }
}

impl SspiImpl for SspiHandle {
    type CredentialsHandle = Option<CredentialsBuffers>;
    type AuthenticationData = Credentials;

    fn acquire_credentials_handle_impl<'a>(
        &'a mut self,
        builder: sspi::builders::FilledAcquireCredentialsHandle<'a, Self::CredentialsHandle, Self::AuthenticationData>,
    ) -> Result<sspi::AcquireCredentialsHandleResult<Self::CredentialsHandle>> {
        let mut context = self.sspi_context.lock()?;
        context.acquire_credentials_handle_impl(builder)
    }

    fn initialize_security_context_impl<'ctx, 'b, 'g>(
        &'ctx mut self,
        builder: &'b mut sspi::builders::FilledInitializeSecurityContext<'ctx, Self::CredentialsHandle>,
    ) -> Result<sspi::generator::GeneratorInitSecurityContext<'g>>
    where
        'ctx: 'g,
        'b: 'g,
    {
        let mut context = self.sspi_context.lock()?;
        Ok(context.initialize_security_context_sync(builder).into())
    }

    fn accept_security_context_impl(
        &mut self,
        builder: sspi::builders::FilledAcceptSecurityContext<Self::CredentialsHandle>,
    ) -> Result<sspi::generator::GeneratorAcceptSecurityContext> {
        let mut context = self.sspi_context.lock()?;
        Ok(context.accept_security_context_sync(builder).into())
    }
}

impl Sspi for SspiHandle {
    fn complete_auth_token(&mut self, token: &mut [sspi::SecurityBuffer]) -> Result<sspi::SecurityStatus> {
        self.sspi_context.lock()?.complete_auth_token(token)
    }

    fn encrypt_message(
        &mut self,
        flags: sspi::EncryptionFlags,
        message: &mut [sspi::SecurityBufferRef],
        sequence_number: u32,
    ) -> Result<sspi::SecurityStatus> {
        self.sspi_context
            .lock()?
            .encrypt_message(flags, message, sequence_number)
    }

    fn decrypt_message(
        &mut self,
        message: &mut [sspi::SecurityBufferRef],
        sequence_number: u32,
    ) -> Result<sspi::DecryptionFlags> {
        self.sspi_context.lock()?.decrypt_message(message, sequence_number)
    }

    fn query_context_sizes(&mut self) -> Result<sspi::ContextSizes> {
        self.sspi_context.lock()?.query_context_sizes()
    }

    fn query_context_names(&mut self) -> Result<sspi::ContextNames> {
        self.sspi_context.lock()?.query_context_names()
    }

    fn query_context_stream_sizes(&mut self) -> Result<StreamSizes> {
        self.sspi_context.lock()?.query_context_stream_sizes()
    }

    fn query_context_package_info(&mut self) -> Result<PackageInfo> {
        self.sspi_context.lock()?.query_context_package_info()
    }

    fn query_context_cert_trust_status(&mut self) -> Result<sspi::CertTrustStatus> {
        self.sspi_context.lock()?.query_context_cert_trust_status()
    }

    fn query_context_remote_cert(&mut self) -> Result<CertContext> {
        self.sspi_context.lock()?.query_context_remote_cert()
    }

    fn query_context_negotiation_package(&mut self) -> Result<PackageInfo> {
        self.sspi_context.lock()?.query_context_negotiation_package()
    }

    fn query_context_connection_info(&mut self) -> Result<ConnectionInfo> {
        self.sspi_context.lock()?.query_context_connection_info()
    }

    fn query_context_session_key(&self) -> Result<sspi::SessionKeys> {
        self.sspi_context.lock()?.query_context_session_key()
    }

    fn change_password<'a>(
        &'a mut self,
        change_password: sspi::builders::ChangePassword<'a>,
    ) -> Result<sspi::generator::GeneratorChangePassword<'a>> {
        let mut context = self.sspi_context.lock()?;
        Ok(context.change_password_sync(change_password).into())
    }

    fn make_signature(
        &mut self,
        _flags: u32,
        _message: &mut [sspi::SecurityBufferRef],
        _sequence_number: u32,
    ) -> Result<()> {
        Err(Error::new(
            ErrorKind::UnsupportedFunction,
            "make_signature is not supported",
        ))
    }

    fn verify_signature(&mut self, _message: &mut [sspi::SecurityBufferRef], _sequence_number: u32) -> Result<u32> {
        Err(Error::new(
            ErrorKind::UnsupportedFunction,
            "verify_signature is not supported",
        ))
    }
}

pub struct CredentialsHandle {
    pub credentials: CredentialsBuffers,
    pub security_package_name: String,
    pub attributes: CredentialsAttributes,
}

fn create_negotiate_context(attributes: &CredentialsAttributes) -> Result<Negotiate> {
    let client_computer_name = attributes.hostname()?;

    let negotiate_config = if let Some(kdc_url) = attributes.kdc_url() {
        let kerberos_config = KerberosConfig::new(&kdc_url, client_computer_name.clone());

        NegotiateConfig::new(
            Box::new(kerberos_config),
            attributes.package_list.clone(),
            client_computer_name,
        )
    } else {
        NegotiateConfig {
            protocol_config: Box::new(NtlmConfig::new(client_computer_name.clone())),
            package_list: attributes.package_list.clone(),
            client_computer_name,
        }
    };

    Negotiate::new_client(negotiate_config)
}

/// Transforms [&mut PCtxtHandle] to [*mut SspiHandle].
///
/// *Note*: `*context` **can** be NULL: the function will create a new security context if [PCtxHandle] is NULL.
///
/// # Safety:
///
/// The caller have to ensure that either `*(context)` is null or the pointer is [convertible to a reference](https://doc.rust-lang.org/std/ptr/index.html#pointer-to-reference-conversion).
#[instrument(ret)]
pub(crate) unsafe fn p_ctxt_handle_to_sspi_context(
    context: &mut PCtxtHandle,
    security_package_name: Option<&str>,
    attributes: &CredentialsAttributes,
) -> Result<NonNull<SspiHandle>> {
    if (*context).is_null() {
        *context = into_raw_ptr(SecHandle {
            dw_lower: 0,
            dw_upper: 0,
        });
    }

    // SAFETY: `*context` is not null. We've checked this above.
    if unsafe { (*(*context)).dw_lower } == 0 {
        if security_package_name.is_none() {
            return Err(Error::new(
                ErrorKind::InvalidParameter,
                "Security package name is not provided",
            ));
        }
        let name = security_package_name.expect("security package name must be provided");

        info!(?name, "Creating context");

        let sspi_context = SspiHandle::new(match name {
            negotiate::PKG_NAME => SspiContext::Negotiate(create_negotiate_context(attributes)?),
            pku2u::PKG_NAME => {
                #[cfg(not(target_os = "windows"))]
                return Err(Error::new(
                    ErrorKind::InvalidParameter,
                    "PKU2U is not supported on non-Windows OS yet",
                ));
                #[cfg(target_os = "windows")]
                SspiContext::Pku2u(Pku2u::new_client_from_config(Pku2uConfig::default_client_config(
                    hostname()?,
                )?)?)
            }
            kerberos::PKG_NAME => {
                let client_computer_name = attributes.hostname()?;

                if let Some(kdc_url) = attributes.kdc_url() {
                    SspiContext::Kerberos(Kerberos::new_client_from_config(KerberosConfig::new(
                        &kdc_url,
                        client_computer_name,
                    ))?)
                } else {
                    let krb_config = KerberosConfig {
                        client_computer_name: Some(client_computer_name),
                        kdc_url: None,
                    };
                    SspiContext::Kerberos(Kerberos::new_client_from_config(krb_config)?)
                }
            }
            ntlm::PKG_NAME => {
                let hostname = attributes.hostname()?;

                SspiContext::Ntlm(Ntlm::with_config(NtlmConfig::new(hostname)))
            }
            #[cfg(feature = "tsssp")]
            sspi_cred_ssp::PKG_NAME => SspiContext::CredSsp(SspiCredSsp::new_client(SspiContext::Negotiate(
                create_negotiate_context(attributes)?,
            ))?),
            _ => {
                return Err(Error::new(
                    ErrorKind::SecurityPackageNotFound,
                    format!("security package name `{}` is not supported", name),
                ));
            }
        });

        // SAFETY: `context` and `*context` are not null. We've checked this above.
        let context = unsafe { (*context).as_mut() }.expect("context should not be null");
        context.dw_lower = into_raw_ptr(sspi_context) as c_ulonglong;
        if context.dw_upper == 0 {
            context.dw_upper = into_raw_ptr(name.to_owned()) as c_ulonglong;
        }
    }

    Ok(NonNull::new(
        // SAFETY: `context` and `*context` are not null. We've checked this above.
        unsafe { (*(*context)).dw_lower as *mut _ },
    )
    .expect("dw_lower must be initialized"))
}

fn verify_security_package(package_name: &str) -> Result<()> {
    match package_name {
        negotiate::PKG_NAME | pku2u::PKG_NAME | kerberos::PKG_NAME | ntlm::PKG_NAME => Ok(()),
        #[cfg(feature = "tsssp")]
        sspi_cred_ssp::PKG_NAME => Ok(()),
        _ => Err(Error::new(
            ErrorKind::SecurityPackageNotFound,
            format!("security package name `{}` is not supported", package_name),
        )),
    }
}

/// AcquireCredentialsHandleA function acquires a handle to preexisting credentials of a security principal.
///
/// NOTE: Although in the original Windows SSPI, `p_auth_data` parameter can be NULL, in our implementation it must be non-NULL.
/// That's because we cannot get the default credentials handle for security package, like Windows can.
#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_AcquireCredentialsHandleA"))]
#[no_mangle]
pub unsafe extern "system" fn AcquireCredentialsHandleA(
    _psz_principal: LpStr,
    psz_package: LpStr,
    _f_aredential_use: u32,
    _pv_logon_id: *const c_void,
    p_auth_data: *const c_void,
    _p_get_key_fn: SecGetKeyFn,
    _pv_get_key_argument: *const c_void,
    ph_credential: PCredHandle,
    _pts_expiry: PTimeStamp,
) -> SecurityStatus {
    catch_panic! {
        check_null!(psz_package);
        check_null!(p_auth_data);
        check_null!(ph_credential);

        let security_package_name =
            // SAFETY: `psz_package` is not null. We've checked this above.
            try_execute!(unsafe { CStr::from_ptr(psz_package) }.to_str(), ErrorKind::InvalidParameter).to_owned();
        try_execute!(verify_security_package(&security_package_name));

        debug!(?security_package_name);

        let mut package_list: Option<String> = None;

        // SAFETY: This function is safe to call because `security_package_name` is checked, `p_auth_data` is not null
        // and `package_list` is type checked.
        let credentials = try_execute!(unsafe { auth_data_to_identity_buffers(&security_package_name, p_auth_data, &mut package_list) });

        // SAFETY: `ph_credential` is not null. We've checked this above.
        unsafe {
            (*ph_credential).dw_lower = into_raw_ptr(CredentialsHandle {
                credentials,
                security_package_name,
                attributes: CredentialsAttributes::new_with_package_list(package_list),
            }) as c_ulonglong;
        }

        0
    }
}

pub type AcquireCredentialsHandleFnA = unsafe extern "system" fn(
    LpStr,
    LpStr,
    u32,
    *const c_void,
    *const c_void,
    SecGetKeyFn,
    *const c_void,
    PCredHandle,
    PTimeStamp,
) -> SecurityStatus;

/// AcquireCredentialsHandleW function acquires a handle to preexisting credentials of a security principal.
///
/// NOTE: Although in the original Windows SSPI, `p_auth_data` parameter can be NULL, in our implementation it must be non-NULL.
/// That's because we cannot get the default credentials handle for security package, like Windows can.
#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_AcquireCredentialsHandleW"))]
#[no_mangle]
pub unsafe extern "system" fn AcquireCredentialsHandleW(
    _psz_principal: LpcWStr,
    psz_package: LpcWStr,
    _f_credential_use: u32,
    _pv_logon_id: *const c_void,
    p_auth_data: *const c_void,
    _p_get_key_fn: SecGetKeyFn,
    _pv_get_key_argument: *const c_void,
    ph_credential: PCredHandle,
    _pts_expiry: PTimeStamp,
) -> SecurityStatus {
    catch_panic! {
        check_null!(psz_package);
        check_null!(p_auth_data);
        check_null!(ph_credential);

        // SAFETY: `psz_package` is not null. We've checked this above.
        let security_package_name = unsafe { c_w_str_to_string(psz_package) };
        try_execute!(verify_security_package(&security_package_name));

        debug!(?security_package_name);

        let mut package_list: Option<String> = None;

        // SAFETY: This function is safe to call because `security_package_name` is checked, `p_auth_date` is not null
        // and `package_list` is type checked.
        let credentials = try_execute!(unsafe { auth_data_to_identity_buffers(&security_package_name, p_auth_data, &mut package_list) });

        // SAFETY: `ph_credentials` is not null. We've checked this above.
        unsafe {
            (*ph_credential).dw_lower = into_raw_ptr(CredentialsHandle {
                credentials,
                security_package_name,
                attributes: CredentialsAttributes::new_with_package_list(package_list),
            }) as c_ulonglong;
        }

        0
    }
}

pub type AcquireCredentialsHandleFnW = unsafe extern "system" fn(
    LpcWStr,
    LpcWStr,
    u32,
    *const c_void,
    *const c_void,
    SecGetKeyFn,
    *const c_void,
    PCredHandle,
    PTimeStamp,
) -> SecurityStatus;

#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_QueryCredentialsAttributesA"))]
#[no_mangle]
pub extern "system" fn QueryCredentialsAttributesA(
    _ph_credential: PCredHandle,
    _ul_attribute: u32,
    _p_buffer: *mut c_void,
) -> SecurityStatus {
    ErrorKind::UnsupportedFunction.to_u32().unwrap()
}

pub type QueryCredentialsAttributesFnA = extern "system" fn(PCredHandle, u32, *mut c_void) -> SecurityStatus;

#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_QueryCredentialsAttributesW"))]
#[no_mangle]
pub extern "system" fn QueryCredentialsAttributesW(
    _ph_credential: PCredHandle,
    _ul_attribute: u32,
    _p_buffer: *mut c_void,
) -> SecurityStatus {
    ErrorKind::UnsupportedFunction.to_u32().unwrap()
}

pub type QueryCredentialsAttributesFnW = extern "system" fn(PCredHandle, u32, *mut c_void) -> SecurityStatus;

#[allow(clippy::useless_conversion)]
#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_InitializeSecurityContextA"))]
#[no_mangle]
pub unsafe extern "system" fn InitializeSecurityContextA(
    ph_credential: PCredHandle,
    mut ph_context: PCtxtHandle,
    p_target_name: *const SecChar,
    f_context_req: u32,
    _reserved1: u32,
    target_data_rep: u32,
    p_input: PSecBufferDesc,
    _reserved2: u32,
    ph_new_context: PCtxtHandle,
    p_output: PSecBufferDesc,
    pf_context_attr: *mut u32,
    _pts_expiry: PTimeStamp,
) -> SecurityStatus {
    catch_panic! {
        // ph_context can be null on the first call
        // p_input can be null on the first call
        check_null!(ph_new_context);
        check_null!(ph_credential);
        check_null!(p_output);
        check_null!(pf_context_attr);

        // SAFETY: `p_output` is not null. We've checked this above.
        unsafe { check_null!((*p_output).p_buffers); }

        let service_principal = if p_target_name.is_null() {
            ""
        } else {
            // SAFETY: `p_target_name` is not null. We've checked this above.
            try_execute!(unsafe { CStr::from_ptr(p_target_name) }.to_str(), ErrorKind::InvalidParameter)
        };
        debug!(?service_principal, "Target name (SPN)");

        // SAFETY: `ph_credentials` is not null. We've checked this above.
        let credentials_handle = unsafe { (*ph_credential).dw_lower as *mut CredentialsHandle };

        // SAFETY: This function is safe to call because it can handle `credentials_handle` null pointer.
        let (auth_data, security_package_name, attributes) = match unsafe { transform_credentials_handle(credentials_handle) } {
            Some(creds_handle) => creds_handle,
            None => return ErrorKind::InvalidHandle.to_u32().unwrap(),
        };

        // SAFETY: It's safe to call the function, because:
        // *`ph_context` can be null;
        // * the value behind `ph_context` must be initialized by ourself: the user does not have to create the [CtxHandle] values ​​themselves.
        // * other parameters are type checked.
        let mut sspi_context_ptr = try_execute!(unsafe { p_ctxt_handle_to_sspi_context(
            &mut ph_context,
            Some(security_package_name),
            attributes
        )});

        // SAFETY: It's safe to call the `as_mut` function, because `sspi_context_ptr` is a local pointer,
        // which is initialized by the `p_ctx_handle_to_sspi_context` function. Thus, the value behind this pointer is valid.
        let sspi_context = unsafe { sspi_context_ptr.as_mut() };

        // SAFETY: The pointer is allowed to be null and the user have to ensure the validity of the the pointer
        // and the data behind it.
        let mut input_tokens = unsafe { sec_buffer_desc_to_security_buffers(p_input) };

        // SAFETY: `p_output` is not null. We've checked this above.
        let len = unsafe { (*p_output).c_buffers as usize };
        // SAFETY: `p_output` and `p_buffers` are not null. We've checked this above.
        let raw_buffers = unsafe { from_raw_parts((*p_output).p_buffers, len) };
        // SAFETY: This function if safe to call because `raw_buffers` is type checked.
        let mut output_tokens = unsafe { p_sec_buffers_to_security_buffers(raw_buffers) };
        output_tokens.iter_mut().for_each(|s| s.buffer.clear());

        let mut auth_data = Some(auth_data);
        let mut builder = sspi_context.initialize_security_context()
            .with_credentials_handle(&mut auth_data)
            .with_context_requirements(ClientRequestFlags::from_bits(f_context_req.try_into().unwrap()).unwrap())
            .with_target_data_representation(DataRepresentation::from_u32(target_data_rep.try_into().unwrap()).unwrap())
            .with_target_name(service_principal)
            .with_input(&mut input_tokens)
            .with_output(&mut output_tokens);
        let result_status = try_execute!(sspi_context.initialize_security_context_impl(&mut builder)).resolve_with_default_network_client();

        let context_requirements = ClientRequestFlags::from_bits_retain(f_context_req);
        let allocate = context_requirements.contains(ClientRequestFlags::ALLOCATE_MEMORY);

        // SAFETY: This function is safe to call because `p_output` and `p_buffers` are not null,
        // `output_tokens` is local variable initialized by the `p_sec_buffers_to_security_buffers` function
        // and `allocate` is type checked.
        try_execute!(unsafe { copy_to_c_sec_buffer((*p_output).p_buffers, &output_tokens, allocate) });

        // SAFETY: `ph_new_context', `ph_context` and `pf_context_attr` are not null. We've checked this above.
        unsafe {
            (*ph_new_context).dw_lower = sspi_context_ptr.as_ptr() as c_ulonglong;
            (*ph_new_context).dw_upper = (*ph_context).dw_upper;

            *pf_context_attr = f_context_req;
        }

        let result = try_execute!(result_status);
        result.status.to_u32().unwrap()
    }
}

pub type InitializeSecurityContextFnA = unsafe extern "system" fn(
    PCredHandle,
    PCtxtHandle,
    *const SecChar,
    u32,
    u32,
    u32,
    PSecBufferDesc,
    u32,
    PCtxtHandle,
    PSecBufferDesc,
    *mut u32,
    PTimeStamp,
) -> SecurityStatus;

#[allow(clippy::useless_conversion)]
#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_InitializeSecurityContextW"))]
#[no_mangle]
pub unsafe extern "system" fn InitializeSecurityContextW(
    ph_credential: PCredHandle,
    mut ph_context: PCtxtHandle,
    p_target_name: *const SecWChar,
    f_context_req: u32,
    _reserved1: u32,
    target_data_rep: u32,
    p_input: PSecBufferDesc,
    _reserved2: u32,
    ph_new_context: PCtxtHandle,
    p_output: PSecBufferDesc,
    pf_context_attr: *mut u32,
    _pts_expiry: PTimeStamp,
) -> SecurityStatus {
    catch_panic! {
        // ph_context can be null on the first call
        // p_input can be null on the first call
        check_null!(ph_new_context);
        check_null!(ph_credential);
        check_null!(p_output);
        check_null!(pf_context_attr);

        // SAFETY: `p_output` is not null. We've checked this above.
        unsafe { check_null!((*p_output).p_buffers); }

        let service_principal = if p_target_name.is_null() {
            String::new()
        } else {
            // SAFETY: `p_target_name` is not null. We've checked this above.
            unsafe { c_w_str_to_string(p_target_name) }
        };
        debug!(?service_principal, "Target name (SPN)");

        // SAFETY: `ph_credentials` is not null. We've checked this above.
        let credentials_handle = unsafe { (*ph_credential).dw_lower as *mut CredentialsHandle };

        // SAFETY: This function is safe to call because it can handle `credentials_handle` when it's null pointer.
        let (auth_data, security_package_name, attributes) = match unsafe { transform_credentials_handle(credentials_handle) } {
            Some(creds_handle) => creds_handle,
            None => return ErrorKind::InvalidHandle.to_u32().unwrap(),
        };

        // SAFETY: It's safe to call the function, because:
        // *`ph_context` can be null;
        // * the value behind `ph_context` must be initialized by ourself: the user does not have to create the [CtxHandle] values ​​themselves.
        // * other parameters are type checked.
        let mut sspi_context_ptr = try_execute!(unsafe { p_ctxt_handle_to_sspi_context(
            &mut ph_context,
            Some(security_package_name),
            attributes,
        )});

        // SAFETY: It's safe to call the `as_mut` function, because `sspi_context_ptr` is a local pointer,
        // which is initialized by the `p_ctx_handle_to_sspi_context` function. Thus, the value behind this pointer is valid.
        let sspi_context = unsafe { sspi_context_ptr.as_mut() };

        // SAFETY: The pointer is allowed to be null and the user have to ensure the validity of the the pointer
        // and the data behind it.
        let mut input_tokens = unsafe { sec_buffer_desc_to_security_buffers(p_input) };

        // SAFETY: `p_output` and `p_buffers` are not null. We've checked this above.
        let raw_buffers = unsafe { from_raw_parts((*p_output).p_buffers, (*p_output).c_buffers as usize) };
        // SAFETY: This function is safe to call because `raw_buffers` is type checked.
        let mut output_tokens = unsafe { p_sec_buffers_to_security_buffers(raw_buffers) };
        output_tokens.iter_mut().for_each(|s| s.buffer.clear());

        let mut auth_data = Some(auth_data);
        let mut builder = sspi_context.initialize_security_context()
            .with_credentials_handle(&mut auth_data)
            .with_context_requirements(ClientRequestFlags::from_bits(f_context_req.try_into().unwrap()).unwrap())
            .with_target_data_representation(DataRepresentation::from_u32(target_data_rep.try_into().unwrap()).unwrap())
            .with_target_name(&service_principal)
            .with_input(&mut input_tokens)
            .with_output(&mut output_tokens);
        let result_status = try_execute!(sspi_context.initialize_security_context_impl(&mut builder)).resolve_with_default_network_client();

        let context_requirements = ClientRequestFlags::from_bits_retain(f_context_req);
        let allocate = context_requirements.contains(ClientRequestFlags::ALLOCATE_MEMORY);

        // SAFETY: This function is safe to call because `p_output` and `p_buffers` are not null,
        // `output_tokens` is local variable initialized by the `p_sec_buffers_to_security_buffers` function
        // and `allocate` is type checked.
        try_execute!(unsafe { copy_to_c_sec_buffer((*p_output).p_buffers, &output_tokens, allocate) });

        // SAFETY: `ph_new_context', `ph_context` and `pf_context_attr` are not null. We've checked this above.
        unsafe {
            *pf_context_attr = f_context_req;

            (*ph_new_context).dw_lower = sspi_context_ptr.as_ptr() as c_ulonglong;
            (*ph_new_context).dw_upper = (*ph_context).dw_upper;
        }

        let result = try_execute!(result_status);
        result.status.to_u32().unwrap()
    }
}

pub type InitializeSecurityContextFnW = unsafe extern "system" fn(
    PCredHandle,
    PCtxtHandle,
    *const SecWChar,
    u32,
    u32,
    u32,
    PSecBufferDesc,
    u32,
    PCtxtHandle,
    PSecBufferDesc,
    *mut u32,
    PTimeStamp,
) -> SecurityStatus;

#[allow(clippy::useless_conversion)]
unsafe fn query_context_attributes_common(
    mut ph_context: PCtxtHandle,
    ul_attribute: u32,
    p_buffer: *mut c_void,
    is_wide: bool,
) -> SecurityStatus {
    catch_panic! {
        // SAFETY: It's safe to call the function, because:
        // *`ph_context` can be null;
        // * the value behind `ph_context` must be initialized by ourself: the user does not have to create the [CtxHandle] values ​​themselves.
        // * other parameters are type checked.
        let mut sspi_context_ptr = try_execute!(unsafe { p_ctxt_handle_to_sspi_context(
            &mut ph_context,
            None,
            &CredentialsAttributes::default()
        )});

        // SAFETY: It's safe to call the `as_mut` function, because `sspi_context_ptr` is a local pointer,
        // which is initialized by the `p_ctx_handle_to_sspi_context` function. Thus, the value behind this pointer is valid.
        let sspi_context = unsafe { sspi_context_ptr.as_mut() };

        check_null!(p_buffer);

        match ul_attribute.try_into().unwrap() {
            SECPKG_ATTR_SIZES => {
                let sizes = p_buffer.cast::<SecPkgContextSizes>();

                let pkg_sizes = try_execute!(sspi_context.query_context_sizes());

                // SAFETY: `sizes` was cast from `p_buffer` which is not null. We've checked this above.
                let sizes = unsafe { sizes.as_mut() }.expect("sized pointer should not be null");

                sizes.cb_max_token = pkg_sizes.max_token;
                sizes.cb_max_signature = pkg_sizes.max_signature;
                sizes.cb_block_size = pkg_sizes.block;
                sizes.cb_security_trailer = pkg_sizes.security_trailer;

                return 0;
            }
            SECPKG_ATTR_NEGOTIATION_INFO => {
                let package_info = try_execute!(sspi_context.query_context_package_info());

                if is_wide {
                    let nego_info = p_buffer.cast::<SecNegoInfoW>();

                    // SAFETY: `nego_info` was cast from `p_buffer` which is not null. We've checked this above.
                    let nego_info = unsafe { nego_info.as_mut() }.expect("nego_info pointer should not be null");

                    nego_info.nego_state = SECPKG_NEGOTIATION_COMPLETE.try_into().unwrap();

                    let package_info: RawSecPkgInfoW = package_info.into();
                    nego_info.package_info = package_info.0;
                } else {
                    let nego_info = p_buffer.cast::<SecNegoInfoA>();

                    // SAFETY: `nego_info` was cast from `p_buffer` which is not null. We've checked this above.
                    let nego_info = unsafe { nego_info.as_mut() }.expect("nego_info pointer should not be null");

                    nego_info.nego_state = SECPKG_NEGOTIATION_COMPLETE.try_into().unwrap();

                    let package_info: RawSecPkgInfoA = package_info.into();
                    nego_info.package_info = package_info.0;
                }

                return 0;
            }
            SECPKG_ATTR_STREAM_SIZES => {
                let stream_sizes = try_execute!(sspi_context.query_context_stream_sizes());

                let stream_info = p_buffer.cast::<SecPkgContextStreamSizes>();

                // SAFETY: `stream_info` was cast from `p_buffer` which is not null. We've checked this above.
                let stream_info = unsafe { stream_info.as_mut() }.expect("stream_info pointer should not be null");

                stream_info.cb_header = stream_sizes.header;
                stream_info.cb_trailer = stream_sizes.trailer;
                stream_info.cb_maximum_message = stream_sizes.max_message;
                stream_info.c_buffers = stream_sizes.buffers;
                stream_info.cb_block_size = stream_sizes.block_size;

                return 0;
            }
            SECPKG_ATTR_REMOTE_CERT_CONTEXT => {
                cfg_if::cfg_if! {
                    if #[cfg(target_os = "windows")] {
                        use std::ptr::{null, null_mut};

                        let cert_context = try_execute!(sspi_context.query_context_remote_cert());

                        // SAFETY: This function is safe to call because all arguments are type checked.
                        let store = unsafe { CertOpenStore(CERT_STORE_PROV_MEMORY, 0, 0, CERT_STORE_CREATE_NEW_FLAG, null()) };

                        if store.is_null() {
                            return ErrorKind::InternalError.to_u32().unwrap();
                        }

                        let mut p_cert_context = null_mut();

                        // SAFETY: This function is safe to call because all arguments are type checked.
                        let result = unsafe { CertAddEncodedCertificateToStore(
                            store,
                            cert_context.encoding_type.to_u32().unwrap(),
                            cert_context.raw_cert.as_ptr(),
                            cert_context.raw_cert.len() as u32,
                            CERT_STORE_ADD_REPLACE_EXISTING,
                            &mut p_cert_context
                        )};
                        if result != 1 {
                            return std::io::Error::last_os_error().raw_os_error().unwrap_or_else(|| ErrorKind::InternalError.to_i32().unwrap()) as u32;
                        }

                        let p_cert_buffer = p_buffer.cast::<*const CERT_CONTEXT>();
                        // SAFETY: `p_cert_buffer` was cast from `p_buffer`, so it's not null either.
                        unsafe { *p_cert_buffer = p_cert_context; }

                        return 0;
                    } else {
                        return ErrorKind::UnsupportedFunction.to_u32().unwrap();
                    }
                }
            }
            SECPKG_ATTR_SERVER_AUTH_FLAGS => {
                let flags = SecPkgContextFlags {
                    flags: 0,
                };

                let sec_context_flags = p_buffer.cast::<*mut SecPkgContextFlags>();
                // SAFETY: `sec_context_flags` was cast from `p_buffer` which is not null. We've checked this above.
                unsafe { *sec_context_flags = into_raw_ptr(flags); }

                return 0;
            }
            SECPKG_ATTR_CONNECTION_INFO => {
                let connection_info = try_execute!(sspi_context.query_context_connection_info());

                let sec_pkg_context_connection_info = p_buffer.cast::<SecPkgContextConnectionInfo>();
                // SAFETY: `sec_pgk_context_connection_info` was cast from `p_buffer` which is not null.
                let sec_pkg_context_connection_info = unsafe { sec_pkg_context_connection_info.as_mut() }.expect("sec_pkg_context_connection_info should not be null");
                sec_pkg_context_connection_info.dw_protocol = connection_info.protocol.to_u32().unwrap();
                sec_pkg_context_connection_info.ai_cipher = connection_info.cipher.to_u32().unwrap();
                sec_pkg_context_connection_info.dw_cipher_strength = connection_info.cipher_strength;
                sec_pkg_context_connection_info.ai_hash = connection_info.hash.to_u32().unwrap();
                sec_pkg_context_connection_info.dw_hash_strength = connection_info.hash_strength;
                sec_pkg_context_connection_info.ai_exch = connection_info.key_exchange.to_u32().unwrap();
                sec_pkg_context_connection_info.dw_exch_strength = connection_info.exchange_strength;

                return 0;
            }
            SECPKG_ATTR_CERT_TRUST_STATUS => {
                let sspi_cert_trust_status = try_execute!(sspi_context.query_context_cert_trust_status());

                let cert_trust_status = p_buffer.cast::<CertTrustStatus>();
                // SAFETY: `cert_trust_status` was cast from `p_buffer` which is not null. We've checked this above.
                let cert_trust_status = unsafe { cert_trust_status.as_mut() }.expect("cert_trust_status pointer should not be null");

                cert_trust_status.dw_error_status = sspi_cert_trust_status.error_status.bits();
                cert_trust_status.dw_info_status = sspi_cert_trust_status.info_status.bits();

                return 0;
            }
            _ => {},
        };

        let package_info = try_execute!(match ul_attribute.try_into().unwrap() {
            SECPKG_ATTR_PACKAGE_INFO => {
                sspi_context.query_context_package_info()
            }
            SECPKG_ATTR_NEGOTIATION_PACKAGE => {
                sspi_context.query_context_negotiation_package()
            }
            unsupported => {
                Err(Error::new(ErrorKind::UnsupportedFunction, format!("Unsupported function ID {unsupported}")))
            },
        });

        if is_wide {
            let nego_info = p_buffer.cast::<*mut SecPkgInfoW>();

            let package_info: RawSecPkgInfoW = package_info.into();
            // SAFETY: `nego_info` was cast from `p_buffer` which is not null. We've checked this above.
            unsafe { *nego_info = package_info.0; }
        } else {
            let nego_info = p_buffer.cast::<*mut SecPkgInfoA>();

            let package_info: RawSecPkgInfoA = package_info.into();
            // SAFETY: `nego_info` was cast from `p_buffer` which is not null. We've checked this above.
            unsafe { *nego_info = package_info.0; }
        }

        0
    }
}

#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_QueryContextAttributesA"))]
#[no_mangle]
pub unsafe extern "system" fn QueryContextAttributesA(
    ph_context: PCtxtHandle,
    ul_attribute: u32,
    p_buffer: *mut c_void,
) -> SecurityStatus {
    check_null!(p_buffer);

    // SAFETY: This function is safe to call because `p_buffer` is not null, we've checked this above
    // and all other arguments are type checked.
    unsafe { query_context_attributes_common(ph_context, ul_attribute, p_buffer, false) }
}

pub type QueryContextAttributesFnA = unsafe extern "system" fn(PCtxtHandle, u32, *mut c_void) -> SecurityStatus;

#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_QueryContextAttributesW"))]
#[no_mangle]
pub unsafe extern "system" fn QueryContextAttributesW(
    ph_context: PCtxtHandle,
    ul_attribute: u32,
    p_buffer: *mut c_void,
) -> SecurityStatus {
    check_null!(p_buffer);

    // SAFETY: This function is safe to call because `p_buffer` is not null, we've checked this above
    // and all other arguments are type checked.
    unsafe { query_context_attributes_common(ph_context, ul_attribute, p_buffer, true) }
}

pub type QueryContextAttributesFnW = unsafe extern "system" fn(PCtxtHandle, u32, *mut c_void) -> SecurityStatus;

#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_ImportSecurityContextA"))]
#[no_mangle]
pub extern "system" fn ImportSecurityContextA(
    _psz_package: PSecurityString,
    _p_packed_context: PSecBuffer,
    _token: *mut c_void,
    _ph_context: PCtxtHandle,
) -> SecurityStatus {
    ErrorKind::UnsupportedFunction.to_u32().unwrap()
}

pub type ImportSecurityContextFnA =
    extern "system" fn(PSecurityString, PSecBuffer, *mut c_void, PCtxtHandle) -> SecurityStatus;

#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_ImportSecurityContextW"))]
#[no_mangle]
pub extern "system" fn ImportSecurityContextW(
    _psz_package: PSecurityString,
    _p_packed_context: PSecBuffer,
    _token: *mut c_void,
    _ph_context: PCtxtHandle,
) -> SecurityStatus {
    ErrorKind::UnsupportedFunction.to_u32().unwrap()
}

pub type ImportSecurityContextFnW =
    extern "system" fn(PSecurityString, PSecBuffer, *mut c_void, PCtxtHandle) -> SecurityStatus;

#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_AddCredentialsA"))]
#[no_mangle]
pub extern "system" fn AddCredentialsA(
    _ph_credential: PCredHandle,
    _s1: *mut SecChar,
    _s2: *mut SecChar,
    _n1: u32,
    _p1: *mut c_void,
    _f: SecGetKeyFn,
    _p2: *mut c_void,
    _t: PTimeStamp,
) -> SecurityStatus {
    ErrorKind::UnsupportedFunction.to_u32().unwrap()
}

pub type AddCredentialsFnA = extern "system" fn(
    PCredHandle,
    *mut SecChar,
    *mut SecChar,
    u32,
    *mut c_void,
    SecGetKeyFn,
    *mut c_void,
    PTimeStamp,
) -> SecurityStatus;

#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_AddCredentialsW"))]
#[no_mangle]
pub extern "system" fn AddCredentialsW(
    _ph_credential: PCredHandle,
    _s1: *mut SecWChar,
    _s2: *mut SecWChar,
    _n1: u32,
    _p1: *mut c_void,
    _f: SecGetKeyFn,
    _p2: *mut c_void,
    _t: PTimeStamp,
) -> SecurityStatus {
    ErrorKind::UnsupportedFunction.to_u32().unwrap()
}

pub type AddCredentialsFnW = extern "system" fn(
    PCredHandle,
    *mut SecWChar,
    *mut SecWChar,
    u32,
    *mut c_void,
    SecGetKeyFn,
    *mut c_void,
    PTimeStamp,
) -> SecurityStatus;

#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_SetContextAttributesA"))]
#[no_mangle]
pub extern "system" fn SetContextAttributesA(
    _ph_context: PCtxtHandle,
    _ul_attribute: u32,
    _p_buffer: *mut c_void,
    _cb_buffer: u32,
) -> SecurityStatus {
    ErrorKind::UnsupportedFunction.to_u32().unwrap()
}

pub type SetContextAttributesFnA = extern "system" fn(PCtxtHandle, u32, *mut c_void, u32) -> SecurityStatus;

#[cfg_attr(windows, rename_symbol(to = "Rust_SetContextAttributesW"))]
#[no_mangle]
pub extern "system" fn SetContextAttributesW(
    _ph_context: PCtxtHandle,
    _ul_attribute: u32,
    _p_buffer: *mut c_void,
    _cb_buffer: u32,
) -> SecurityStatus {
    ErrorKind::UnsupportedFunction.to_u32().unwrap()
}

pub type SetContextAttributesFnW = extern "system" fn(PCtxtHandle, u32, *mut c_void, u32) -> SecurityStatus;

#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_SetCredentialsAttributesA"))]
#[no_mangle]
pub unsafe extern "system" fn SetCredentialsAttributesA(
    ph_credential: PCtxtHandle,
    ul_attribute: u32,
    p_buffer: *mut c_void,
    _cb_buffer: u32,
) -> SecurityStatus {
    catch_panic! {
        check_null!(ph_credential);
        check_null!(p_buffer);

        // SAFETY: `ph_credentials` is not null. We've checked this above. In order for the `as_mut` function
        // to be safe to call, user must provide all guarantees regarding the correctness of the `dw_lower'.
        let credentials_handle = if let Some(credentials_handle) = unsafe { ((*ph_credential).dw_lower as *mut CredentialsHandle).as_mut() } {
            credentials_handle
        } else {
            return ErrorKind::InvalidParameter.to_u32().unwrap();
        };

        if ul_attribute == SECPKG_CRED_ATTR_NAMES {
            let workstation =
                // SAFETY: `p_buffer` is not null. We've checked this above.
                try_execute!(unsafe { CStr::from_ptr(p_buffer as *const _) }.to_str(), ErrorKind::InvalidParameter).to_owned();

            credentials_handle.attributes.workstation = Some(workstation);

            0
        } else if ul_attribute == SECPKG_CRED_ATTR_KDC_PROXY_SETTINGS {
            credentials_handle.attributes.kdc_proxy_settings =
                // SAFETY: This function is safe to call because `p_buffer` is not null. We've checked this above.
                Some(try_execute!(unsafe { extract_kdc_proxy_settings(NonNull::new(p_buffer).expect("p_buffer should not be null")) }));

            0
        } else if ul_attribute == SECPKG_CRED_ATTR_KDC_URL {
            let cred_attr = p_buffer.cast::<SecPkgCredentialsKdcUrlA>();
            // SAFETY: `cred_attr` was cast from `p_buffer` which is not null. We've checked this above.
            let kdc_url = try_execute!(unsafe { CStr::from_ptr((*cred_attr).kdc_url) }.to_str(), ErrorKind::InvalidParameter);
            credentials_handle.attributes.kdc_url = Some(kdc_url.to_string());
            0
        } else {
            ErrorKind::UnsupportedFunction.to_u32().unwrap()
        }
    }
}

pub type SetCredentialsAttributesFnA = unsafe extern "system" fn(PCtxtHandle, u32, *mut c_void, u32) -> SecurityStatus;

#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_SetCredentialsAttributesW"))]
#[no_mangle]
pub unsafe extern "system" fn SetCredentialsAttributesW(
    ph_credential: PCtxtHandle,
    ul_attribute: u32,
    p_buffer: *mut c_void,
    _cb_buffer: u32,
) -> SecurityStatus {
    catch_panic! {
        check_null!(ph_credential);
        check_null!(p_buffer);

        // SAFETY: `ph_credentials` is not null. We've checked this above. In order for the `as_mut` function
        // to be safe to call, user must provide all guarantees regarding the correctness of the `dw_lower'.
        let credentials_handle = if let Some(credentials_handle) = unsafe { ((*ph_credential).dw_lower as *mut CredentialsHandle).as_mut() } {
            credentials_handle
        } else {
            return ErrorKind::InvalidParameter.to_u32().unwrap();
        };

        if ul_attribute == SECPKG_CRED_ATTR_NAMES {
            // SAFETY: `p_buffer` is not null. We've checked this above.
            let workstation = unsafe { c_w_str_to_string(p_buffer as *const _) };

            credentials_handle.attributes.workstation = Some(workstation);

            0
        } else if ul_attribute == SECPKG_CRED_ATTR_KDC_PROXY_SETTINGS {
            credentials_handle.attributes.kdc_proxy_settings =
                // SAFETY: This function is safe to call because `p_buffer` is not null. We've checked this above.
                Some(try_execute!(unsafe { extract_kdc_proxy_settings(NonNull::new(p_buffer).expect("p_buffer should not be null")) }));

            0
        } else if ul_attribute == SECPKG_CRED_ATTR_KDC_URL {
            let cred_attr = p_buffer.cast::<SecPkgCredentialsKdcUrlW>();
            // SAFETY: `cred_attr` was cast from `p_buffer` which is not null. We've checked this above.
            let kdc_url = unsafe { c_w_str_to_string((*cred_attr).kdc_url as *const u16) };
            credentials_handle.attributes.kdc_url = Some(kdc_url);

            0
        } else {
            ErrorKind::UnsupportedFunction.to_u32().unwrap()
        }
    }
}

pub type SetCredentialsAttributesFnW = unsafe extern "system" fn(PCtxtHandle, u32, *mut c_void, u32) -> SecurityStatus;

#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_ChangeAccountPasswordA"))]
#[no_mangle]
pub unsafe extern "system" fn ChangeAccountPasswordA(
    psz_package_name: *mut SecChar,
    psz_domain_name: *mut SecChar,
    psz_account_name: *mut SecChar,
    psz_old_password: *mut SecChar,
    psz_new_password: *mut SecChar,
    _b_impersonating: bool,
    _dw_reserved: u32,
    p_output: PSecBufferDesc,
) -> SecurityStatus {
    catch_panic! {
        check_null!(psz_package_name);
        check_null!(psz_domain_name);
        check_null!(psz_account_name);
        check_null!(psz_old_password);
        check_null!(psz_new_password);
        check_null!(p_output);

        let security_package_name =
            // SAFETY: `psz_package_name` is not null. We've checked this above.
            // User must provide all other guarantees that the C string is valid.
            try_execute!(unsafe { CStr::from_ptr(psz_package_name) }.to_str(), ErrorKind::InvalidParameter);

        let domain =
            // SAFETY: `psz_domain_name` is not null. We've checked this above.
            // User must provide all other guarantees that the C string is valid.
            try_execute!(unsafe { CStr::from_ptr(psz_domain_name) }.to_str(), ErrorKind::InvalidParameter);
        let username =
            // SAFETY: `psz_account_name` is not null. We've checked this above.
            // User must provide all other guarantees that the C string is valid.
            try_execute!(unsafe { CStr::from_ptr(psz_account_name) }.to_str(), ErrorKind::InvalidParameter);
        let password =
            // SAFETY: `psz_old_password` is not null. We've checked this above.
            // User must provide all other guarantees that the C string is valid.
            try_execute!(unsafe { CStr::from_ptr(psz_old_password) }.to_str(), ErrorKind::InvalidParameter);
        let new_password =
            // SAFETY: `psz_new_password` is not null. We've checked this above.
            // User must provide all other guarantees that the C string is valid.
            try_execute!(unsafe { CStr::from_ptr(psz_new_password) }.to_str(), ErrorKind::InvalidParameter);

        // SAFETY: `p_output` is not null. We've checked this above.
        let p_output = unsafe { p_output.as_mut() }.expect("p_output pointer should not be null");
        let len = try_execute!(usize::try_from(p_output.c_buffers), ErrorKind::InvalidParameter);

        check_null!(p_output.p_buffers);

        let mut output_tokens =
            // SAFETY: `p_output` and `p_buffers` are not null. We've checked this above.
            // The `p_sec_buffers_to_security_buffers` function is safe to call if user
            // provides guarantees about the buffers.
            unsafe { p_sec_buffers_to_security_buffers(from_raw_parts(p_output.p_buffers, len)) };
        output_tokens.iter_mut().for_each(|s| s.buffer.clear());

        let change_password = ChangePasswordBuilder::new()
            .with_domain_name(domain)
            .with_account_name(username)
            .with_old_password(password)
            .with_new_password(new_password)
            .with_output(&mut output_tokens)
            .build()
            .expect("change password builder should never fail");

        let mut sspi_context = match security_package_name {
            negotiate::PKG_NAME => {
                let negotiate_config = NegotiateConfig {
                    protocol_config: Box::new(NtlmConfig::new(try_execute!(hostname()))),
                    package_list: None,
                    client_computer_name: try_execute!(hostname()),
                };
                SspiContext::Negotiate(try_execute!(Negotiate::new_client(negotiate_config)))
            },
            kerberos::PKG_NAME => {
                let krb_config = KerberosConfig{
                    client_computer_name:Some(try_execute!(hostname())),
                    kdc_url:None
                };
                SspiContext::Kerberos(try_execute!(Kerberos::new_client_from_config(
                    krb_config
                )))
            },
            ntlm::PKG_NAME => SspiContext::Ntlm(Ntlm::with_config(NtlmConfig::new(try_execute!(hostname())))),
            _ => {
                return ErrorKind::InvalidParameter.to_u32().unwrap();
            }
        };

        let result_status = try_execute!(sspi_context.change_password(change_password)).resolve_with_default_network_client();

        // SAFETY: This function is safe to call because `p_output` and `p_buffers` are not null.
        // We've checked this above. And other arguments are type checked.
        try_execute!(unsafe { copy_to_c_sec_buffer(p_output.p_buffers, &output_tokens, false) });

        try_execute!(result_status);

        0
    }
}

pub type ChangeAccountPasswordFnA = unsafe extern "system" fn(
    *mut SecChar,
    *mut SecChar,
    *mut SecChar,
    *mut SecChar,
    *mut SecChar,
    bool,
    u32,
    PSecBufferDesc,
) -> SecurityStatus;

#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_ChangeAccountPasswordW"))]
#[no_mangle]
pub unsafe extern "system" fn ChangeAccountPasswordW(
    psz_package_name: *mut SecWChar,
    psz_domain_name: *mut SecWChar,
    psz_account_name: *mut SecWChar,
    psz_old_password: *mut SecWChar,
    psz_new_password: *mut SecWChar,
    b_impersonating: bool,
    dw_reserved: u32,
    p_output: PSecBufferDesc,
) -> SecurityStatus {
    catch_panic! {
        check_null!(psz_package_name);
        check_null!(psz_domain_name);
        check_null!(psz_account_name);
        check_null!(psz_old_password);
        check_null!(psz_new_password);
        check_null!(p_output);

        // SAFETY: This function is safe to call because `psw_pacakge_name` is not null. We've checked this above.
        let mut security_package_name = unsafe { c_w_str_to_string(psz_package_name) };

        // SAFETY: This function is safe to call because `psw_domain_name` is not null. We've checked this above.
        let mut domain = unsafe { c_w_str_to_string(psz_domain_name) };
        // SAFETY: This function is safe to call because `psz_account_name` is not null. We've checked this above.
        let mut username = unsafe { c_w_str_to_string(psz_account_name) };
        // SAFETY: This function is safe to call because `psz_old_password` is not null. We've checked this above.
        let mut password = Secret::new(unsafe { c_w_str_to_string(psz_old_password) });
        // SAFETY: This function is safe to call because `psz_new_password` is not null. We've checked this above.
        let mut new_password = Secret::new(unsafe { c_w_str_to_string(psz_new_password) });

        // SAFETY: All arguments are type checked and/or validated:
        // * `security_package_name': it's a String. So it's valid string.
        // * `domain': it's a String. So it's valid string.
        // * `username': it's a String. So it's valid string.
        // * `password': it's a String. So it's valid string.
        // * `new_password': it's a String. So it's valid string.
        // * `b_impersonating`: it's a valid bool.
        // * `dw_reserved': it's a valid u32.
        // * `p_output': it's not null pointer.
        unsafe {
            ChangeAccountPasswordA(
                security_package_name.as_mut_ptr() as *mut _,
                domain.as_mut_ptr() as *mut _,
                username.as_mut_ptr() as *mut _,
                password.as_mut().as_mut_ptr() as *mut _,
                new_password.as_mut().as_mut_ptr() as *mut _,
                b_impersonating,
                dw_reserved,
                p_output,
            )
        }
    }
}

pub type ChangeAccountPasswordFnW = unsafe extern "system" fn(
    *mut SecWChar,
    *mut SecWChar,
    *mut SecWChar,
    *mut SecWChar,
    *mut SecWChar,
    bool,
    u32,
    PSecBufferDesc,
) -> SecurityStatus;

#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_QueryContextAttributesExA"))]
#[no_mangle]
pub extern "system" fn QueryContextAttributesExA(
    _ph_context: PCtxtHandle,
    _ul_attribute: u32,
    _p_buffer: *mut c_void,
    _cb_buffer: u32,
) -> SecurityStatus {
    ErrorKind::UnsupportedFunction.to_u32().unwrap()
}

pub type QueryContextAttributesExFnA = extern "system" fn(PCtxtHandle, u32, *mut c_void, u32) -> SecurityStatus;

#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_QueryContextAttributesExW"))]
#[no_mangle]
pub extern "system" fn QueryContextAttributesExW(
    _ph_context: PCtxtHandle,
    _ul_attribute: u32,
    _p_buffer: *mut c_void,
    _cb_buffer: u32,
) -> SecurityStatus {
    ErrorKind::UnsupportedFunction.to_u32().unwrap()
}

pub type QueryContextAttributesExFnW = extern "system" fn(PCtxtHandle, u32, *mut c_void, u32) -> SecurityStatus;

#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_QueryCredentialsAttributesExA"))]
#[no_mangle]
pub extern "system" fn QueryCredentialsAttributesExA(
    _ph_credential: PCredHandle,
    _ul_attribute: u32,
    _p_buffer: *mut c_void,
    _c_buffers: u32,
) -> SecurityStatus {
    ErrorKind::UnsupportedFunction.to_u32().unwrap()
}

pub type QueryCredentialsAttributesExFnA = extern "system" fn(PCredHandle, u32, *mut c_void, u32) -> SecurityStatus;

#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_QueryCredentialsAttributesExW"))]
#[no_mangle]
pub extern "system" fn QueryCredentialsAttributesExW(
    _ph_aredential: PCredHandle,
    _ul_attribute: u32,
    _p_buffer: *mut c_void,
    _c_buffers: u32,
) -> SecurityStatus {
    ErrorKind::UnsupportedFunction.to_u32().unwrap()
}

pub type QueryCredentialsAttributesExFnW = extern "system" fn(PCredHandle, u32, *mut c_void, u32) -> SecurityStatus;

#[cfg(test)]
mod tests {
    use std::ffi::CStr;
    use std::ptr::{null, null_mut};

    use libc::c_void;

    use crate::sspi::common::{DeleteSecurityContext, FreeContextBuffer, FreeCredentialsHandle};
    use crate::sspi::sec_buffer::{SecBuffer, SecBufferDesc};
    use crate::sspi::sec_handle::{
        AcquireCredentialsHandleA, AcquireCredentialsHandleW, InitializeSecurityContextA, InitializeSecurityContextW,
        SecHandle,
    };
    use crate::sspi::sec_pkg_info::{
        EnumerateSecurityPackagesA, EnumerateSecurityPackagesW, PSecPkgInfoA, PSecPkgInfoW, QuerySecurityPackageInfoA,
        QuerySecurityPackageInfoW, SecPkgInfoA, SecPkgInfoW,
    };
    use crate::sspi::sec_winnt_auth_identity::{
        SecWinntAuthIdentityA, SecWinntAuthIdentityW, SEC_WINNT_AUTH_IDENTITY_ANSI, SEC_WINNT_AUTH_IDENTITY_UNICODE,
    };
    use crate::utils::c_w_str_to_string;

    extern "system" fn dummy(_: *mut c_void, _: *mut c_void, _: u32, _: *mut *mut c_void, _: *mut i32) {}

    /// This test simulates initialize security context function call. It's better to run it using Miri
    /// https://github.com/rust-lang/miri
    /// cargo +nightly miri test
    #[test]
    fn initialize_security_context_w() {
        let pkg_name = "NTLM\0".encode_utf16().collect::<Vec<_>>();
        let mut pkg_info: PSecPkgInfoW = null_mut::<SecPkgInfoW>();

        let status = unsafe { QuerySecurityPackageInfoW(pkg_name.as_ptr(), &mut pkg_info) };
        assert_eq!(status, 0);

        // We left all `println`s on purpose:
        // to simulate any memory access to the allocated memory.
        println!("{:?}", unsafe { &*pkg_info });
        println!("{:?}", unsafe { c_w_str_to_string((*pkg_info).name) });
        println!("{:?}", unsafe { c_w_str_to_string((*pkg_info).comment) });

        let cb_max_token = unsafe { (*pkg_info).cb_max_token };

        let status = unsafe { FreeContextBuffer(pkg_info as *mut _) };
        assert_eq!(status, 0);

        let mut pc_packages = 0;
        let mut packages: PSecPkgInfoW = null_mut::<SecPkgInfoW>();

        let status = unsafe { EnumerateSecurityPackagesW(&mut pc_packages, &mut packages) };
        assert_eq!(status, 0);

        for i in 0..pc_packages as usize {
            let pkg_info = unsafe { packages.add(i) };
            println!("{:?}", unsafe { &*pkg_info });
            println!("{:?}", unsafe { c_w_str_to_string((*pkg_info).name) });
            println!("{:?}", unsafe { c_w_str_to_string((*pkg_info).comment) });
        }

        let status = unsafe { FreeContextBuffer(packages as *mut _) };
        assert_eq!(status, 0);

        let user = "user".encode_utf16().collect::<Vec<_>>();
        let domain = "domain".encode_utf16().collect::<Vec<_>>();
        let password = "password".encode_utf16().collect::<Vec<_>>();

        let credentials = SecWinntAuthIdentityW {
            user: user.as_ptr(),
            user_length: user.len() as u32,
            domain: domain.as_ptr(),
            domain_length: domain.len() as u32,
            password: password.as_ptr(),
            password_length: password.len() as u32,
            flags: 0,
        };

        let mut cred_handle = SecHandle {
            dw_lower: 0,
            dw_upper: 0,
        };

        let status = unsafe {
            AcquireCredentialsHandleW(
                null_mut(),
                pkg_name.as_ptr() as *const _,
                2, /* SECPKG_CRED_OUTBOUND */
                null::<c_void>(),
                &credentials as *const _ as *const c_void,
                dummy,
                null::<c_void>(),
                &mut cred_handle,
                null_mut(),
            )
        };
        assert_eq!(status, 0);

        let mut sec_context = SecHandle {
            dw_lower: 0,
            dw_upper: 0,
        };
        let mut new_sec_context = SecHandle {
            dw_lower: 0,
            dw_upper: 0,
        };
        let mut target_name = "TERMSRV/some@example.com\0".encode_utf16().collect::<Vec<_>>();
        let mut attrs = 0;

        let mut out_buffer = vec![0; cb_max_token as usize];
        let mut out_sec_buffer = SecBuffer {
            cb_buffer: cb_max_token,
            buffer_type: 2,
            pv_buffer: out_buffer.as_mut_ptr() as *mut _,
        };
        let mut out_buffer_desk = SecBufferDesc {
            ul_version: 0,
            c_buffers: 1,
            p_buffers: &mut out_sec_buffer,
        };

        let mut in_buffer_desk = SecBufferDesc {
            ul_version: 0,
            c_buffers: 0,
            p_buffers: null_mut::<SecBuffer>(),
        };

        let status = unsafe {
            InitializeSecurityContextW(
                &mut cred_handle,
                &mut sec_context,
                target_name.as_mut_ptr() as *mut _,
                0,
                0,
                0x10, /* SECURITY_NATIVE_DREP */
                &mut in_buffer_desk,
                0,
                &mut new_sec_context,
                &mut out_buffer_desk,
                &mut attrs,
                null_mut(),
            )
        };
        assert_eq!(status, 0x0009_0312 /* CONTINUE_NEEDED */);

        let status = unsafe { FreeCredentialsHandle(&mut cred_handle) };
        assert_eq!(status, 0);

        let status = unsafe { DeleteSecurityContext(&mut new_sec_context) };
        assert_eq!(status, 0);
    }

    /// This test simulates initialize security context function call. It's better to run it using Miri
    /// https://github.com/rust-lang/miri
    /// cargo +nightly miri test
    #[test]
    fn initialize_security_context_a() {
        let pkg_name = "NTLM\0";
        let mut pkg_info: PSecPkgInfoA = null_mut::<SecPkgInfoA>();

        let status = unsafe { QuerySecurityPackageInfoA(pkg_name.as_ptr() as *const _, &mut pkg_info) };
        assert_eq!(status, 0);

        // We left all `println`s on purpose:
        // to simulate any memory access to the allocated memory.
        println!("{:?}", unsafe { &*pkg_info });
        println!("{:?}", unsafe { CStr::from_ptr((*pkg_info).name).to_str().unwrap() });
        println!("{:?}", unsafe { CStr::from_ptr((*pkg_info).comment).to_str().unwrap() });

        let cb_max_token = unsafe { (*pkg_info).cb_max_token };

        let status = unsafe { FreeContextBuffer(pkg_info as *mut _) };
        assert_eq!(status, 0);

        let mut pc_packages = 0;
        let mut packages: PSecPkgInfoA = null_mut::<SecPkgInfoA>();

        let status = unsafe { EnumerateSecurityPackagesA(&mut pc_packages, &mut packages) };
        assert_eq!(status, 0);

        for i in 0..pc_packages as usize {
            let pkg_info = unsafe { packages.add(i) };
            println!("{:?}", unsafe { &*pkg_info });
            println!("{:?}", unsafe { CStr::from_ptr((*pkg_info).name).to_str().unwrap() });
            println!("{:?}", unsafe { CStr::from_ptr((*pkg_info).comment).to_str().unwrap() });
        }

        let status = unsafe { FreeContextBuffer(packages as *mut _) };
        assert_eq!(status, 0);

        let user = "user";
        let domain = "domain";
        let password = "password";

        let credentials = SecWinntAuthIdentityA {
            user: user.as_ptr() as *const _,
            user_length: user.len() as u32,
            domain: domain.as_ptr() as *const _,
            domain_length: domain.len() as u32,
            password: password.as_ptr() as *const _,
            password_length: password.len() as u32,
            flags: 1,
        };

        let mut cred_handle = SecHandle {
            dw_lower: 0,
            dw_upper: 0,
        };

        let status = unsafe {
            AcquireCredentialsHandleA(
                null_mut(),
                pkg_name.as_ptr() as *const _,
                2, /* SECPKG_CRED_OUTBOUND */
                null::<c_void>(),
                &credentials as *const _ as *const c_void,
                dummy,
                null::<c_void>(),
                &mut cred_handle,
                null_mut(),
            )
        };
        assert_eq!(status, 0);

        let mut sec_context = SecHandle {
            dw_lower: 0,
            dw_upper: 0,
        };
        let mut new_sec_context = SecHandle {
            dw_lower: 0,
            dw_upper: 0,
        };
        let mut target_name = String::from("TERMSRV/some@example.com\0");
        let mut attrs = 0;

        let mut out_buffer = vec![0; cb_max_token as usize];
        let mut out_sec_buffer = SecBuffer {
            cb_buffer: cb_max_token,
            buffer_type: 2,
            pv_buffer: out_buffer.as_mut_ptr() as *mut _,
        };
        let mut out_buffer_desk = SecBufferDesc {
            ul_version: 0,
            c_buffers: 1,
            p_buffers: &mut out_sec_buffer,
        };

        let mut in_buffer_desk = SecBufferDesc {
            ul_version: 0,
            c_buffers: 0,
            p_buffers: null_mut::<SecBuffer>(),
        };

        let status = unsafe {
            InitializeSecurityContextA(
                &mut cred_handle,
                &mut sec_context,
                target_name.as_mut_ptr() as *mut _,
                0,
                0,
                0x10, /* SECURITY_NATIVE_DREP */
                &mut in_buffer_desk,
                0,
                &mut new_sec_context,
                &mut out_buffer_desk,
                &mut attrs,
                null_mut(),
            )
        };
        assert_eq!(status, 0x0009_0312 /* CONTINUE_NEEDED */);

        let status = unsafe { FreeCredentialsHandle(&mut cred_handle) };
        assert_eq!(status, 0);

        let status = unsafe { DeleteSecurityContext(&mut new_sec_context) };
        assert_eq!(status, 0);
    }

    /// This test simulates initialize security context function call. It's better to run it using Miri
    /// https://github.com/rust-lang/miri
    /// cargo +nightly miri test
    #[test]
    fn acquire_credentials_handle_w_null_credentials() {
        let pkg_name = "NTLM\0".encode_utf16().collect::<Vec<_>>();

        let user = "user".encode_utf16().collect::<Vec<_>>();
        let domain = "domain".encode_utf16().collect::<Vec<_>>();
        let password = "password".encode_utf16().collect::<Vec<_>>();

        let credentials = vec![
            SecWinntAuthIdentityW {
                user: null(),
                user_length: 0,
                domain: domain.as_ptr(),
                domain_length: domain.len() as u32,
                password: password.as_ptr(),
                password_length: password.len() as u32,
                flags: SEC_WINNT_AUTH_IDENTITY_UNICODE,
            },
            SecWinntAuthIdentityW {
                user: user.as_ptr(),
                user_length: user.len() as u32,
                domain: null(),
                domain_length: 0,
                password: password.as_ptr(),
                password_length: password.len() as u32,
                flags: SEC_WINNT_AUTH_IDENTITY_UNICODE,
            },
            SecWinntAuthIdentityW {
                user: user.as_ptr(),
                user_length: user.len() as u32,
                domain: domain.as_ptr(),
                domain_length: domain.len() as u32,
                password: null(),
                password_length: 0,
                flags: SEC_WINNT_AUTH_IDENTITY_UNICODE,
            },
        ];

        for credentials in credentials {
            let mut cred_handle = SecHandle {
                dw_lower: 0,
                dw_upper: 0,
            };

            let status = unsafe {
                AcquireCredentialsHandleW(
                    null_mut(),
                    pkg_name.as_ptr() as *const _,
                    2, /* SECPKG_CRED_OUTBOUND */
                    null::<c_void>(),
                    &credentials as *const _ as *const c_void,
                    dummy,
                    null::<c_void>(),
                    &mut cred_handle,
                    null_mut(),
                )
            };
            assert_eq!(status, 0);

            let status = unsafe { FreeCredentialsHandle(&mut cred_handle) };
            assert_eq!(status, 0);
        }
    }

    /// This test simulates initialize security context function call. It's better to run it using Miri
    /// https://github.com/rust-lang/miri
    /// cargo +nightly miri test
    #[test]
    fn acquire_credentials_handle_w_empty_credentials() {
        let pkg_name = "NTLM\0".encode_utf16().collect::<Vec<_>>();

        let user = "".encode_utf16().collect::<Vec<_>>();
        let domain = "".encode_utf16().collect::<Vec<_>>();
        let password = "".encode_utf16().collect::<Vec<_>>();

        let credentials = SecWinntAuthIdentityW {
            user: user.as_ptr(),
            user_length: user.len() as u32,
            domain: domain.as_ptr(),
            domain_length: domain.len() as u32,
            password: password.as_ptr(),
            password_length: password.len() as u32,
            flags: SEC_WINNT_AUTH_IDENTITY_UNICODE,
        };

        let mut cred_handle = SecHandle {
            dw_lower: 0,
            dw_upper: 0,
        };

        let status = unsafe {
            AcquireCredentialsHandleW(
                null_mut(),
                pkg_name.as_ptr() as *const _,
                2, /* SECPKG_CRED_OUTBOUND */
                null::<c_void>(),
                &credentials as *const _ as *const c_void,
                dummy,
                null::<c_void>(),
                &mut cred_handle,
                null_mut(),
            )
        };
        assert_eq!(status, 0);

        let status = unsafe { FreeCredentialsHandle(&mut cred_handle) };
        assert_eq!(status, 0);
    }

    /// This test simulates initialize security context function call. It's better to run it using Miri
    /// https://github.com/rust-lang/miri
    /// cargo +nightly miri test
    #[test]
    fn acquire_credentials_handle_a_null_credentials() {
        let pkg_name = "NTLM\0";

        let user = "user";
        let domain = "domain";
        let password = "password";

        let credentials = vec![
            SecWinntAuthIdentityA {
                user: null(),
                user_length: 0,
                domain: domain.as_ptr() as *const _,
                domain_length: domain.len() as u32,
                password: password.as_ptr() as *const _,
                password_length: password.len() as u32,
                flags: SEC_WINNT_AUTH_IDENTITY_ANSI,
            },
            SecWinntAuthIdentityA {
                user: user.as_ptr() as *const _,
                user_length: user.len() as u32,
                domain: null(),
                domain_length: 0,
                password: password.as_ptr() as *const _,
                password_length: password.len() as u32,
                flags: SEC_WINNT_AUTH_IDENTITY_ANSI,
            },
            SecWinntAuthIdentityA {
                user: user.as_ptr() as *const _,
                user_length: user.len() as u32,
                domain: domain.as_ptr() as *const _,
                domain_length: domain.len() as u32,
                password: null(),
                password_length: 0,
                flags: SEC_WINNT_AUTH_IDENTITY_ANSI,
            },
        ];

        for credentials in credentials {
            let mut cred_handle = SecHandle {
                dw_lower: 0,
                dw_upper: 0,
            };

            let status = unsafe {
                AcquireCredentialsHandleA(
                    null_mut(),
                    pkg_name.as_ptr() as *const _,
                    2, /* SECPKG_CRED_OUTBOUND */
                    null::<c_void>(),
                    &credentials as *const _ as *const c_void,
                    dummy,
                    null::<c_void>(),
                    &mut cred_handle,
                    null_mut(),
                )
            };
            assert_eq!(status, 0);

            let status = unsafe { FreeCredentialsHandle(&mut cred_handle) };
            assert_eq!(status, 0);
        }
    }

    /// This test simulates initialize security context function call. It's better to run it using Miri
    /// https://github.com/rust-lang/miri
    /// cargo +nightly miri test
    #[test]
    fn acquire_credentials_handle_a_empty_credentials() {
        let pkg_name = "NTLM\0";

        let user = "";
        let domain = "";
        let password = "";

        let credentials = SecWinntAuthIdentityA {
            user: user.as_ptr() as *const _,
            user_length: user.len() as u32,
            domain: domain.as_ptr() as *const _,
            domain_length: domain.len() as u32,
            password: password.as_ptr() as *const _,
            password_length: password.len() as u32,
            flags: SEC_WINNT_AUTH_IDENTITY_ANSI,
        };

        let mut cred_handle = SecHandle {
            dw_lower: 0,
            dw_upper: 0,
        };

        let status = unsafe {
            AcquireCredentialsHandleA(
                null_mut(),
                pkg_name.as_ptr() as *const _,
                2, /* SECPKG_CRED_OUTBOUND */
                null::<c_void>(),
                &credentials as *const _ as *const c_void,
                dummy,
                null::<c_void>(),
                &mut cred_handle,
                null_mut(),
            )
        };
        assert_eq!(status, 0);

        let status = unsafe { FreeCredentialsHandle(&mut cred_handle) };
        assert_eq!(status, 0);
    }
}


--- File: ffi/src/sspi/sec_pkg_info.rs ---
use std::ffi::CStr;
use std::mem::size_of;
use std::ptr::copy_nonoverlapping;

use sspi::{enumerate_security_packages, PackageInfo, KERBEROS_VERSION};
#[cfg(windows)]
use symbol_rename_macro::rename_symbol;

use super::sspi_data_types::{SecChar, SecWChar, SecurityStatus};
use crate::utils::{c_w_str_to_string, str_to_w_buff};

#[derive(Debug)]
#[repr(C)]
pub struct SecPkgInfoW {
    pub f_capabilities: u32,
    pub w_version: u16,
    pub w_rpc_id: u16,
    pub cb_max_token: u32,
    pub name: *mut SecWChar,
    pub comment: *mut SecWChar,
}

pub type PSecPkgInfoW = *mut SecPkgInfoW;

pub struct RawSecPkgInfoW(pub *mut SecPkgInfoW);

#[allow(clippy::useless_conversion)]
impl From<PackageInfo> for RawSecPkgInfoW {
    fn from(pkg_info: PackageInfo) -> Self {
        let pkg_name = str_to_w_buff(pkg_info.name.as_ref());
        let name_bytes_len = pkg_name.len() * 2;

        let pkg_comment = str_to_w_buff(&pkg_info.comment);
        let comment_bytes_len = pkg_comment.len() * 2;

        let pkg_info_w_size = size_of::<SecPkgInfoW>();
        let size = pkg_info_w_size + name_bytes_len + comment_bytes_len;

        let raw_pkg_info;
        let pkg_info_w;
        // SAFETY: Memory allocation is safe.
        unsafe {
            raw_pkg_info = libc::malloc(size);
        }
        // SAFETY:
        // FIXME(safety): it is illegal to construct a reference to uninitialized data
        // Useful references:
        // - https://doc.rust-lang.org/nomicon/unchecked-uninit.html
        // - https://doc.rust-lang.org/core/mem/union.MaybeUninit.html#initializing-a-struct-field-by-field
        // NOTE: this is not the only place that needs to be fixed. An audit is required.
        unsafe {
            pkg_info_w = (raw_pkg_info as *mut SecPkgInfoW).as_mut().unwrap();
        }

        pkg_info_w.f_capabilities = pkg_info.capabilities.bits();
        pkg_info_w.w_version = KERBEROS_VERSION as u16;
        pkg_info_w.w_rpc_id = pkg_info.rpc_id;
        pkg_info_w.cb_max_token = pkg_info.max_token_len.try_into().unwrap();

        let name_ptr;
        // SAFETY: Our allocated buffer is big enough to contain package name and comment.
        unsafe {
            name_ptr = raw_pkg_info.add(pkg_info_w_size);
        }
        // SAFETY:
        // * pkg_name ptr is valid for read because it is Rust-allocated vector.
        // * name_ptr is valid for write because we took into account its length during memory allocation.
        unsafe {
            copy_nonoverlapping(pkg_name.as_ptr() as *const _, name_ptr, name_bytes_len);
        }
        pkg_info_w.name = name_ptr as *mut _;

        let comment_ptr;
        // SAFETY: Our allocated buffer is big enough to contain package name and comment.
        unsafe {
            comment_ptr = name_ptr.add(name_bytes_len);
        }
        // SAFETY:
        // * pkg_comment ptr is valid for read because it is Rust-allocated vector.
        // * pkg_comment is valid for write because we took into account its length during memory allocation.
        unsafe {
            copy_nonoverlapping(pkg_comment.as_ptr() as *const _, comment_ptr, comment_bytes_len);
        }
        pkg_info_w.comment = comment_ptr as *mut _;

        Self(raw_pkg_info as *mut SecPkgInfoW)
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct SecPkgInfoA {
    pub f_capabilities: u32,
    pub w_version: u16,
    pub w_rpc_id: u16,
    pub cb_max_token: u32,
    pub name: *mut SecChar,
    pub comment: *mut SecChar,
}

pub type PSecPkgInfoA = *mut SecPkgInfoA;

pub struct RawSecPkgInfoA(pub *mut SecPkgInfoA);

#[allow(clippy::useless_conversion)]
impl From<PackageInfo> for RawSecPkgInfoA {
    fn from(pkg_info: PackageInfo) -> Self {
        let mut pkg_name = pkg_info.name.to_string().as_bytes().to_vec();
        // We need to add the null-terminator during the conversion from Rust to C string.
        pkg_name.push(0);
        let name_bytes_len = pkg_name.len();

        let mut pkg_comment = pkg_info.comment.as_bytes().to_vec();
        // We need to add the null-terminator during the conversion from Rust to C string.
        pkg_comment.push(0);
        let comment_bytes_len = pkg_comment.len();

        let pkg_info_a_size = size_of::<SecPkgInfoA>();

        let size = pkg_info_a_size + name_bytes_len + comment_bytes_len;

        let raw_pkg_info;
        let pkg_info_a;

        // SAFETY: Memory allocation is safe.
        unsafe {
            raw_pkg_info = libc::malloc(size);
        }
        // SAFETY:
        // FIXME(safety): it is illegal to construct a reference to uninitialized data
        // Useful references:
        // - https://doc.rust-lang.org/nomicon/unchecked-uninit.html
        // - https://doc.rust-lang.org/core/mem/union.MaybeUninit.html#initializing-a-struct-field-by-field
        // NOTE: this is not the only place that needs to be fixed. An audit is required.
        unsafe {
            pkg_info_a = (raw_pkg_info as *mut SecPkgInfoA).as_mut().unwrap();
        }

        pkg_info_a.f_capabilities = pkg_info.capabilities.bits();
        pkg_info_a.w_version = KERBEROS_VERSION as u16;
        pkg_info_a.w_rpc_id = pkg_info.rpc_id;
        pkg_info_a.cb_max_token = pkg_info.max_token_len;

        let name_ptr;
        // SAFETY: Our allocated buffer is big enough to contain package name and comment.
        unsafe {
            name_ptr = raw_pkg_info.add(pkg_info_a_size);
        }
        // SAFETY:
        // * pkg_name ptr is valid for read because it is Rust-allocated vector.
        // * name_ptr is valid for write because we took into account its length during memory allocation.
        unsafe {
            copy_nonoverlapping(pkg_name.as_ptr() as *const _, name_ptr, name_bytes_len);
        }
        pkg_info_a.name = name_ptr as *mut _;

        let comment_ptr;
        // SAFETY: Our allocated buffer is big enough to contain package name and comment.
        unsafe {
            comment_ptr = name_ptr.add(name_bytes_len);
        }
        // SAFETY:
        // * pkg_comment ptr is valid for read because it is Rust-allocated vector.
        // * pkg_comment is valid for write because we took into account its length during memory allocation.
        unsafe {
            copy_nonoverlapping(pkg_comment.as_ptr() as *const _, comment_ptr, comment_bytes_len);
        }
        pkg_info_a.comment = comment_ptr as *mut _;

        Self(raw_pkg_info as *mut SecPkgInfoA)
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct SecNegoInfoW {
    pub package_info: *mut SecPkgInfoW,
    pub nego_state: u32,
}

#[derive(Debug)]
#[repr(C)]
pub struct SecNegoInfoA {
    pub package_info: *mut SecPkgInfoA,
    pub nego_state: u32,
}

#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_EnumerateSecurityPackagesA"))]
#[no_mangle]
pub unsafe extern "system" fn EnumerateSecurityPackagesA(
    pc_packages: *mut u32,
    pp_package_info: *mut PSecPkgInfoA,
) -> SecurityStatus {
    catch_panic! {
        check_null!(pc_packages);
        check_null!(pp_package_info);

        let packages = try_execute!(enumerate_security_packages());

        // SAFETY: `pc_packages` is not null. We've checked this above.
        unsafe { *pc_packages = packages.len() as u32; }

        let mut size = size_of::<SecPkgInfoA>() * packages.len();

        for package in &packages {
            size += package.name.as_ref().len() + 1 /* null byte */ + package.comment.len() + 1 /* null byte */;
        }

        // SAFETY: Memory allocation is safe.
        let raw_packages = unsafe { libc::malloc(size) };

        if raw_packages.is_null() {
            return ErrorKind::InsufficientMemory.to_u32().unwrap();
        }

        let mut package_ptr = raw_packages as *mut SecPkgInfoA;

        // SAFETY: It is safe to cast a pointer because we allocated enough memory to place package name and comment alongside SecPkgInfoA.
        let mut data_ptr = unsafe { raw_packages.add(size_of::<SecPkgInfoA>() * packages.len()) as *mut SecChar };
        for pkg_info in packages {
            // FIXME(safety): it is illegal to construct a reference to uninitialized data
            // Useful references:
            // - https://doc.rust-lang.org/nomicon/unchecked-uninit.html
            // - https://doc.rust-lang.org/core/mem/union.MaybeUninit.html#initializing-a-struct-field-by-field
            // NOTE: this is not the only place that needs to be fixed. An audit is required.
            // SAFETY: `package_ptr` is a local pointer and we've checked that it is not null above.
            let pkg_info_a = unsafe { package_ptr.as_mut().unwrap() };

            pkg_info_a.f_capabilities = pkg_info.capabilities.bits();
            pkg_info_a.w_version = KERBEROS_VERSION as u16;
            pkg_info_a.w_rpc_id = pkg_info.rpc_id;
            pkg_info_a.cb_max_token = pkg_info.max_token_len;

            let mut name = pkg_info.name.as_ref().as_bytes().to_vec();
            // We need to add the null-terminator during the conversion from Rust to C string.
            name.push(0);
            // SAFETY: This function is safe to call because `name` is valid C string and
            // `data_ptr` is a local pointer to allocated memory.
            // We precalculated and allocated enough memory to accommodate all security packages + their names and comments.
            unsafe { copy_nonoverlapping(name.as_ptr(), data_ptr as *mut _, name.len()); }
            pkg_info_a.name = data_ptr as *mut _;
            // SAFETY: Our allocated buffer is big enough to contain package name and comment.
            // We precalculated and allocated enough memory to accommodate all security packages + their names and comments.
            data_ptr = unsafe { data_ptr.add(name.len()) };

            let mut comment = pkg_info.comment.as_bytes().to_vec();
            // We need to add the null-terminator during the conversion from Rust to C string.
            comment.push(0);

            // SAFETY: This function is safe to call because `name` is valid C string and
            // `data_ptr` is a local pointer to allocated memory.
            // We precalculated and allocated enough memory to accommodate all security packages + their names and comments.
            unsafe { copy_nonoverlapping(comment.as_ptr(), data_ptr as *mut _, comment.len()); }
            pkg_info_a.comment = data_ptr as *mut _;
            // SAFETY: Our allocated buffer is big enough to contain package name and comment.
            // We precalculated and allocated enough memory to accommodate all security packages + their names and comments.
            data_ptr = unsafe { data_ptr.add(comment.len()) };

            // SAFETY: Next structure (if any) is placed right after this structure.
            // We precalculated and allocated enough memory to accommodate all security packages + their names and comments.
            package_ptr = unsafe { package_ptr.add(1) };
        }

        // SAFETY: `pp_package_into` is not null. We've checked this above.
        unsafe { *pp_package_info = raw_packages as *mut _; }

        0
    }
}

pub type EnumerateSecurityPackagesFnA = unsafe extern "system" fn(*mut u32, *mut PSecPkgInfoA) -> SecurityStatus;

#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_EnumerateSecurityPackagesW"))]
#[no_mangle]
pub unsafe extern "system" fn EnumerateSecurityPackagesW(
    pc_packages: *mut u32,
    pp_package_info: *mut *mut SecPkgInfoW,
) -> SecurityStatus {
    catch_panic! {
        check_null!(pc_packages);
        check_null!(pp_package_info);

        let packages = try_execute!(enumerate_security_packages());

        // SAFETY: `pc_packages` is not null. We've checked this above.
        unsafe { *pc_packages = packages.len() as u32; }

        let mut size = size_of::<SecPkgInfoW>() * packages.len();
        let mut names = Vec::with_capacity(packages.len());
        let mut comments = Vec::with_capacity(packages.len());

        for package in &packages {
            let name = str_to_w_buff(package.name.as_ref());
            let comment = str_to_w_buff(&package.comment);

            size += (name.len() + comment.len()) * 2;

            names.push(name);
            comments.push(comment);
        }

        // SAFETY: Memory allocation is safe.
        let raw_packages = unsafe { libc::malloc(size) };

        if raw_packages.is_null() {
            return ErrorKind::InsufficientMemory.to_u32().unwrap();
        }

        let mut package_ptr = raw_packages as *mut SecPkgInfoW;
        // SAFETY: It is safe to cast a pointer because we allocated enough memory to place package name and comment alongside SecPkgInfoA.
        let mut data_ptr = unsafe { raw_packages.add(size_of::<SecPkgInfoW>() * packages.len()) as *mut SecWChar };
        for (i, pkg_info) in packages.iter().enumerate() {
            // FIXME(safety): it is illegal to construct a reference to uninitialized data
            // Useful references:
            // - https://doc.rust-lang.org/nomicon/unchecked-uninit.html
            // - https://doc.rust-lang.org/core/mem/union.MaybeUninit.html#initializing-a-struct-field-by-field
            // NOTE: this is not the only place that needs to be fixed. An audit is required.
            // SAFETY: `package_ptr` is a local pointer and we've checked that it is not null above.
            let pkg_info_w = unsafe { package_ptr.as_mut().unwrap() };

            pkg_info_w.f_capabilities = pkg_info.capabilities.bits();
            pkg_info_w.w_version = KERBEROS_VERSION as u16;
            pkg_info_w.w_rpc_id = pkg_info.rpc_id;
            pkg_info_w.cb_max_token = pkg_info.max_token_len;

            // SAFETY: This function is safe to call because `names[i]` is valid C string and
            // `data_ptr` is a local pointer to allocated memory.
            // We precalculated and allocated enough memory to accommodate all security packages + their names and comments.
            unsafe { copy_nonoverlapping(names[i].as_ptr(), data_ptr, names[i].len()); }
            pkg_info_w.name = data_ptr as *mut _;
            // SAFETY: Our allocated buffer is big enough to contain package name and comment.
            // We precalculated and allocated enough memory to accommodate all security packages + their names and comments.
            data_ptr = unsafe { data_ptr.add(names[i].len()) };

            // SAFETY: This function is safe to call because `name` is valid C string and
            // `data_ptr` is a local pointer to allocated memory.
            // We precalculated and allocated enough memory to accommodate all security packages + their names and comments.
            unsafe { copy_nonoverlapping(comments[i].as_ptr(), data_ptr, comments[i].len()); }
            pkg_info_w.comment = data_ptr as *mut _;
            // SAFETY: Our allocated buffer is big enough to contain package name and comment.
            // We precalculated and allocated enough memory to accommodate all security packages + their names and comments.
            data_ptr = unsafe { data_ptr.add(comments[i].len()) };

            // SAFETY: Next structure (if any) is placed right after this structure.
            // We precalculated and allocated enough memory to accommodate all security packages + their names and comments.
            package_ptr = unsafe { package_ptr.add(1) };
        }

        // SAFETY: `pp_package_into` is not null. We've checked this above.
        unsafe { *pp_package_info = raw_packages as *mut _; }

        0
    }
}

pub type EnumerateSecurityPackagesFnW = unsafe extern "system" fn(*mut u32, *mut PSecPkgInfoW) -> SecurityStatus;

#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_QuerySecurityPackageInfoA"))]
#[no_mangle]
pub unsafe extern "system" fn QuerySecurityPackageInfoA(
    p_package_name: *const SecChar,
    pp_package_info: *mut PSecPkgInfoA,
) -> SecurityStatus {
    catch_panic! {
        check_null!(p_package_name);
        check_null!(pp_package_info);

        // SAFETY: This function is safe to call because `p_package_name` is not null, we've checked this above.
        // All other guarantees about validity of C string must be provided by user.
        let pkg_name = try_execute!(unsafe { CStr::from_ptr(p_package_name) }.to_str(), ErrorKind::InvalidParameter);

        let pkg_info: RawSecPkgInfoA = try_execute!(enumerate_security_packages())
            .into_iter()
            .find(|pkg| pkg.name.as_ref() == pkg_name)
            .unwrap()
            .into();
        // SAFETY: `pp_package_info` is not null. We've checked this above.
        unsafe { *pp_package_info = pkg_info.0; }

        0
    }
}

pub type QuerySecurityPackageInfoFnA = unsafe extern "system" fn(*const SecChar, *mut PSecPkgInfoA) -> SecurityStatus;

#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_QuerySecurityPackageInfoW"))]
#[no_mangle]
pub unsafe extern "system" fn QuerySecurityPackageInfoW(
    p_package_name: *const SecWChar,
    pp_package_info: *mut PSecPkgInfoW,
) -> SecurityStatus {
    catch_panic! {
        check_null!(p_package_name);
        check_null!(pp_package_info);

        // SAFETY: This function is safe to call because `p_package_name` is not null, we've checked this above.
        // All other guarantees about validity of C string must be provided by user.
        let pkg_name = unsafe { c_w_str_to_string(p_package_name) };

        let pkg_info: RawSecPkgInfoW = try_execute!(enumerate_security_packages())
            .into_iter()
            .find(|pkg| pkg.name.to_string() == pkg_name)
            .unwrap()
            .into();
        // SAFETY: `pp_package_info` is not null. We've checked this above.
        unsafe { *pp_package_info = pkg_info.0; }

        0
    }
}

pub type QuerySecurityPackageInfoFnW = unsafe extern "system" fn(*const SecWChar, *mut PSecPkgInfoW) -> SecurityStatus;

#[cfg(test)]
mod tests {
    use std::ptr::null_mut;

    use super::{EnumerateSecurityPackagesA, EnumerateSecurityPackagesW, SecPkgInfoA, SecPkgInfoW};
    use crate::sspi::common::FreeContextBuffer;

    #[test]
    fn enumerate_security_packages_a() {
        cfg_if::cfg_if!(
            if #[cfg(feature = "tsssp")] {
                let expected_packages_amount = 5;
            } else {
                let expected_packages_amount = 4;
            }
        );

        let mut packages_amount = 0;
        let mut packages = null_mut::<SecPkgInfoA>();

        unsafe {
            let status = EnumerateSecurityPackagesA(&mut packages_amount, &mut packages);

            assert_eq!(status, 0);
            assert_eq!(packages_amount, expected_packages_amount);
            assert!(!packages.is_null());

            for i in 0..(packages_amount as usize) {
                let _ = packages.add(i).as_mut().unwrap();
            }

            let status = FreeContextBuffer(packages as *mut _);
            assert_eq!(status, 0);
        }
    }

    #[test]
    fn enumerate_security_packages_w() {
        cfg_if::cfg_if!(
            if #[cfg(feature = "tsssp")] {
                let expected_packages_amount = 5;
            } else {
                let expected_packages_amount = 4;
            }
        );

        let mut packages_amount = 0;
        let mut packages = null_mut::<SecPkgInfoW>();

        unsafe {
            let status = EnumerateSecurityPackagesW(&mut packages_amount, &mut packages);

            assert_eq!(status, 0);
            assert_eq!(packages_amount, expected_packages_amount);
            assert!(!packages.is_null());

            for i in 0..(packages_amount as usize) {
                let _ = packages.add(i).as_mut().unwrap();
            }

            let status = FreeContextBuffer(packages as *mut _);
            assert_eq!(status, 0);
        }
    }
}


--- File: ffi/src/sspi/sec_winnt_auth_identity.rs ---
use std::ptr::copy_nonoverlapping;
#[cfg(windows)]
use std::ptr::null_mut;
use std::slice::from_raw_parts;

use libc::{c_char, c_void};
#[cfg(windows)]
use sspi::Secret;
#[cfg(all(feature = "scard", target_os = "windows"))]
use sspi::SmartCardIdentityBuffers;
use sspi::{AuthIdentityBuffers, CredentialsBuffers, Error, ErrorKind, Result};
#[cfg(windows)]
use symbol_rename_macro::rename_symbol;
#[cfg(all(feature = "scard", target_os = "windows"))]
use windows_sys::Win32::Security::Credentials::CredIsMarshaledCredentialW;
#[cfg(feature = "tsssp")]
use windows_sys::Win32::Security::Credentials::{CredUIPromptForWindowsCredentialsW, CREDUI_INFOW};

use super::sspi_data_types::{SecWChar, SecurityStatus};
use crate::utils::{credentials_str_into_bytes, into_raw_ptr, w_str_len};

pub const SEC_WINNT_AUTH_IDENTITY_ANSI: u32 = 0x1;
pub const SEC_WINNT_AUTH_IDENTITY_UNICODE: u32 = 0x2;

#[repr(C)]
pub struct SecWinntAuthIdentityW {
    pub user: *const u16,
    pub user_length: u32,
    pub domain: *const u16,
    pub domain_length: u32,
    pub password: *const u16,
    pub password_length: u32,
    pub flags: u32,
}

#[repr(C)]
pub struct SecWinntAuthIdentityA {
    pub user: *const c_char,
    pub user_length: u32,
    pub domain: *const c_char,
    pub domain_length: u32,
    pub password: *const c_char,
    pub password_length: u32,
    pub flags: u32,
}

pub const SEC_WINNT_AUTH_IDENTITY_VERSION: u32 = 0x200;

#[derive(Debug)]
#[repr(C)]
pub struct SecWinntAuthIdentityExW {
    pub version: u32,
    pub length: u32,
    pub user: *const u16,
    pub user_length: u32,
    pub domain: *const u16,
    pub domain_length: u32,
    pub password: *const u16,
    pub password_length: u32,
    pub flags: u32,
    pub package_list: *const u16,
    pub package_list_length: u32,
}

#[repr(C)]
pub struct SecWinntAuthIdentityExA {
    pub version: u32,
    pub length: u32,
    pub user: *const c_char,
    pub user_length: u32,
    pub domain: *const c_char,
    pub domain_length: u32,
    pub password: *const c_char,
    pub password_length: u32,
    pub flags: u32,
    pub package_list: *const c_char,
    pub package_list_length: u32,
}

pub const SEC_WINNT_AUTH_IDENTITY_VERSION_2: u32 = 0x201;

/// [SEC_WINNT_AUTH_IDENTITY_EX2](https://learn.microsoft.com/en-us/windows/win32/api/sspi/ns-sspi-sec_winnt_auth_identity_ex2)
///
/// ```not_rust
/// typedef struct _SEC_WINNT_AUTH_IDENTITY_EX2 {
///   unsigned long  Version;
///   unsigned short cbHeaderLength;
///   unsigned long  cbStructureLength;
///   unsigned long  UserOffset;
///   unsigned short UserLength;
///   unsigned long  DomainOffset;
///   unsigned short DomainLength;
///   unsigned long  PackedCredentialsOffset;
///   unsigned short PackedCredentialsLength;
///   unsigned long  Flags;
///   unsigned long  PackageListOffset;
///   unsigned short PackageListLength;
/// } SEC_WINNT_AUTH_IDENTITY_EX2, *PSEC_WINNT_AUTH_IDENTITY_EX2;
/// ```
#[derive(Debug)]
#[repr(C)]
pub struct SecWinntAuthIdentityEx2 {
    pub version: u32,
    pub cb_header_length: u16,
    pub cb_structure_length: u32,
    pub user_offset: u32,
    pub user_length: u16,
    pub domain_offset: u32,
    pub domain_length: u16,
    pub packed_credentials_offset: u32,
    pub packed_credentials_length: u16,
    pub flags: u32,
    pub package_list_offset: u32,
    pub package_list_length: u16,
}

/// [CREDSPP_SUBMIT_TYPE](https://learn.microsoft.com/en-us/windows/win32/api/credssp/ne-credssp-credspp_submit_type)
///
/// ```not_rust
/// typedef enum _CREDSSP_SUBMIT_TYPE {
///   CredsspPasswordCreds = 2,
///   CredsspSchannelCreds = 4,
///   CredsspCertificateCreds = 13,
///   CredsspSubmitBufferBoth = 50,
///   CredsspSubmitBufferBothOld = 51,
///   CredsspCredEx = 100
/// } CREDSPP_SUBMIT_TYPE;
/// ```
#[derive(Debug, Clone, Copy, Eq, PartialEq)]
#[repr(C)]
pub enum CredSspSubmitType {
    CredsspPasswordCreds = 2,
    CredsspSchannelCreds = 4,
    CredsspCertificateCreds = 13,
    CredsspSubmitBufferBoth = 50,
    CredsspSubmitBufferBothOld = 51,
    CredsspCredEx = 100,
}

/// [CREDSSP_CRED](https://learn.microsoft.com/en-us/windows/win32/api/credssp/ns-credssp-credssp_cred)
///
/// ```not_rust
/// typedef struct _CREDSSP_CRED {
///   CREDSPP_SUBMIT_TYPE Type;
///   PVOID               pSchannelCred;
///   PVOID               pSpnegoCred;
/// } CREDSSP_CRED, *PCREDSSP_CRED;
/// ```
#[derive(Debug)]
#[repr(C)]
pub struct CredSspCred {
    pub submit_type: CredSspSubmitType,
    pub p_schannel_cred: *const c_void,
    pub p_spnego_cred: *const c_void,
}

/// Returns auth identity version and flags.
///
/// # Safety:
///
/// * The auth identity pointer must not be null.
pub unsafe fn get_auth_data_identity_version_and_flags(p_auth_data: *const c_void) -> (u32, u32) {
    // SAFETY: the safety contract [p_auth_data] must be upheld by the caller.
    let auth_version = unsafe { *p_auth_data.cast::<u32>() };
    if auth_version == SEC_WINNT_AUTH_IDENTITY_VERSION {
        let auth_data = p_auth_data.cast::<SecWinntAuthIdentityExW>();
        // SAFETY: `auth_data` was cast from `p_auth_data`, so it's not null either.
        (auth_version, unsafe { (*auth_data).flags })
    } else if auth_version == SEC_WINNT_AUTH_IDENTITY_VERSION_2 {
        let auth_data = p_auth_data.cast::<SecWinntAuthIdentityEx2>();
        // SAFETY: `auth_data` was cast from `p_auth_data`, so it's not null either.
        (auth_version, unsafe { (*auth_data).flags })
    } else {
        // SEC_WINNT_AUTH_IDENTITY
        let auth_data = p_auth_data.cast::<SecWinntAuthIdentityW>();
        // SAFETY: `auth_data` was cast from `p_auth_data`, so it's not null either.
        (auth_version, unsafe { (*auth_data).flags })
    }
}

/// The only one purpose of this function is to handle CredSSP credentials passed into the AcquireCredentialsHandle function.
///
/// # Safety:
///
/// * The user must ensure that `p_auth_data` must be not null and point to the valid [CredSspCred] structure.
#[cfg(feature = "tsssp")]
unsafe fn credssp_auth_data_to_identity_buffers(p_auth_data: *const c_void) -> Result<CredentialsBuffers> {
    use sspi::string_to_utf16;
    use windows_sys::Win32::Foundation::ERROR_SUCCESS;

    // SAFETY: The `p_auth_data` pointer guarantees must be upheld by the user.
    let credssp_cred = unsafe { p_auth_data.cast::<CredSspCred>().as_ref() }.unwrap();

    if credssp_cred.submit_type == CredSspSubmitType::CredsspSubmitBufferBothOld {
        if credssp_cred.p_spnego_cred.is_null() {
            // When logging on using the saved (remembered) credentials, the mstsc sets the submit_type to CredSspSubmitType::CredsspSubmitBufferBothOld
            // and p_spnego_cred to NULL. Then the inner security package should use saved credentials in the Credentials Manager for the authentication.
            // But, unfortunately, we are unable to read those credentials because they are accessible only for Microsoft's security packages.
            //
            // [CRED_TYPE_DOMAIN_PASSWORD](https://learn.microsoft.com/en-us/windows/win32/api/wincred/ns-wincred-credentialw)
            // The NTLM, Kerberos, and Negotiate authentication packages will automatically use this credential when connecting to the named target.
            // More info: https://blog.gentilkiwi.com/tag/cred_type_domain_password
            //
            // In this case, we just asked the user to re-enter the credentials.
            let message = string_to_utf16("We're unable to load saved credentials\0");
            let caption = string_to_utf16("Enter credentials\0");
            let cred_ui_info = CREDUI_INFOW {
                cbSize: std::mem::size_of::<CREDUI_INFOW>().try_into().unwrap(),
                hwndParent: null_mut(),
                pszMessageText: message.as_ptr() as *const _,
                pszCaptionText: caption.as_ptr() as *const _,
                hbmBanner: null_mut(),
            };
            let mut auth_package_count = 0;
            let mut out_buffer_size = 1024;
            let mut out_buffer = null_mut();

            // SAFETY:
            // * all non-null values are allocated by Rust inside the current function. Thus, they are valid.
            // * all other (null and zero) values are allowed according to the function documentation.
            let result = unsafe {
                CredUIPromptForWindowsCredentialsW(
                    &cred_ui_info,
                    0,
                    &mut auth_package_count,
                    null_mut(),
                    0,
                    &mut out_buffer,
                    &mut out_buffer_size,
                    null_mut(),
                    0,
                )
            };

            if result != ERROR_SUCCESS {
                return Err(Error::new(
                    ErrorKind::NoCredentials,
                    format!("Can not get user credentials: {:0x?}", result),
                ));
            }

            // SAFETY: `out_buffer` and `out_buffer_size` are initialized and valid because
            // the `CredUIPromptForWindowsCredentialsW` function returned successful status code and
            // we've checked for errors above.
            unsafe { unpack_sec_winnt_auth_identity_ex2_w_sized(out_buffer, out_buffer_size) }
        } else {
            // When we try to pass the plain password in the `ClearTextPassword` .rdp file property,
            // the CredSSP credentials will have the type `CredsspSubmitBufferBothOld` and
            // will be packed in the `SEC_WINNT_AUTH_IDENTITY_W` structure.
            //
            // Additional info:
            // * [ClearTextPassword](https://github.com/Devolutions/MsRdpEx/blob/a7978812cb31e363f4b536316bd59e1573e69384/README.md#extended-rdp-file-options)
            // SAFETY: we've checked above that the `credssp_cred.p_spnego_cred` is not null.
            // The data correctness behind `credssp_cred.p_spnego_cred` pointer must be guaranteed by the user.
            unsafe { auth_data_to_identity_buffers_w(credssp_cred.p_spnego_cred, &mut None) }
        }
    } else {
        // SAFETY: The data correctness behind `credssp_cred.p_spnego_cred` pointer must be guaranteed by the user.
        unsafe { unpack_sec_winnt_auth_identity_ex2_w(credssp_cred.p_spnego_cred) }
    }
}

/// This function determines what format credentials have: ASCII or UNICODE,
/// and then calls an appropriate raw credentials handler function.
/// Why do we need such a function:
/// Actually, on Linux FreeRDP can pass UNICODE credentials into the AcquireCredentialsHandleA function.
/// So, we need to be able to handle any credentials format in the AcquireCredentialsHandleA/W functions.
///
/// # Safety:
///
/// * The user must ensure that `p_auth_data` must be not null and point to the valid credentials structure
///   corresponding to the security package in use.
pub unsafe fn auth_data_to_identity_buffers(
    _security_package_name: &str,
    p_auth_data: *const c_void,
    package_list: &mut Option<String>,
) -> Result<CredentialsBuffers> {
    if p_auth_data.is_null() {
        return Err(Error::new(ErrorKind::InvalidParameter, "p_auth_data cannot be null"));
    }

    #[cfg(feature = "tsssp")]
    if _security_package_name == sspi::credssp::sspi_cred_ssp::PKG_NAME {
        // SAFETY: The data correctness behind `p_auth_data` pointer must be guaranteed by the user.
        return unsafe { credssp_auth_data_to_identity_buffers(p_auth_data) };
    }

    // SAFETY: This function is safe to call because `p_auth_data` is not null. We've checked this above.
    let (_, auth_flags) = unsafe { get_auth_data_identity_version_and_flags(p_auth_data) };

    if (auth_flags & SEC_WINNT_AUTH_IDENTITY_ANSI) != 0 {
        // SAFETY: This function is safe to call because `p_auth_data` is not null, we've checked this above,
        // and `package_list` is type checked.
        unsafe { auth_data_to_identity_buffers_a(p_auth_data, package_list) }
    } else {
        // SAFETY: This function is safe to call because `p_auth_data` is not null, we've checked this above,
        // and `package_list` is type checked.
        unsafe { auth_data_to_identity_buffers_w(p_auth_data, package_list) }
    }
}

pub unsafe fn auth_data_to_identity_buffers_a(
    p_auth_data: *const c_void,
    package_list: &mut Option<String>,
) -> Result<CredentialsBuffers> {
    if p_auth_data.is_null() {
        return Err(Error::new(ErrorKind::InvalidParameter, "p_auth_data cannot be null"));
    }

    // SAFETY: This function is safe to call because `p_auth_data` is not null. We've checked this above.
    let (auth_version, _) = unsafe { get_auth_data_identity_version_and_flags(p_auth_data) };

    if auth_version == SEC_WINNT_AUTH_IDENTITY_VERSION {
        let auth_data = p_auth_data.cast::<SecWinntAuthIdentityExA>();
        // SAFETY: `auth_data` is not null. We've checked this above.
        let auth_data = unsafe { auth_data.as_ref() }.expect("auth_data pointer should not be null");

        if !auth_data.package_list.is_null() && auth_data.package_list_length > 0 {
            *package_list = Some(
                // SAFETY: This function is safe to call because `package_list` is not null. We've checked this above.
                String::from_utf8_lossy(unsafe {
                    from_raw_parts(
                        auth_data.package_list as *const _,
                        auth_data.package_list_length as usize,
                    )
                })
                .to_string(),
            );
        }

        // SAFETY: This function is safe to call because credentials pointers can be null and the caller is responsible for the data validity.
        unsafe {
            Ok(CredentialsBuffers::AuthIdentity(AuthIdentityBuffers {
                user: credentials_str_into_bytes(auth_data.user, auth_data.user_length as usize),
                domain: credentials_str_into_bytes(auth_data.domain, auth_data.domain_length as usize),
                password: credentials_str_into_bytes(auth_data.password, auth_data.password_length as usize).into(),
            }))
        }
    } else {
        let auth_data = p_auth_data.cast::<SecWinntAuthIdentityA>();

        // SAFETY: `auth_data` is not null. We've checked this above.
        let auth_data = unsafe { auth_data.as_ref() }.expect("auth_data pointer should not be null");

        // SAFETY: This function is safe to call because credentials pointers can be null and the caller is responsible for the data validity.
        unsafe {
            Ok(CredentialsBuffers::AuthIdentity(AuthIdentityBuffers {
                user: credentials_str_into_bytes(auth_data.user, auth_data.user_length as usize),
                domain: credentials_str_into_bytes(auth_data.domain, auth_data.domain_length as usize),
                password: credentials_str_into_bytes(auth_data.password, auth_data.password_length as usize).into(),
            }))
        }
    }
}

pub unsafe fn auth_data_to_identity_buffers_w(
    p_auth_data: *const c_void,
    package_list: &mut Option<String>,
) -> Result<CredentialsBuffers> {
    if p_auth_data.is_null() {
        return Err(Error::new(ErrorKind::InvalidParameter, "p_auth_data cannot be null"));
    }

    // SAFETY: This function is safe to call because `p_auth_data` is not null. We've checked this above.
    let (auth_version, _) = unsafe { get_auth_data_identity_version_and_flags(p_auth_data) };

    if auth_version == SEC_WINNT_AUTH_IDENTITY_VERSION {
        let auth_data = p_auth_data.cast::<SecWinntAuthIdentityExW>();
        // SAFETY: `auth_data` is not null. We've checked this above.
        let auth_data = unsafe { auth_data.as_ref() }.expect("auth_data pointer should not be null");

        if !auth_data.package_list.is_null() && auth_data.package_list_length > 0 {
            // SAFETY: This function is safe to call because `package_list` is not null. We've checked this above.
            *package_list = Some(String::from_utf16_lossy(unsafe {
                from_raw_parts(
                    auth_data.package_list,
                    usize::try_from(auth_data.package_list_length).unwrap(),
                )
            }));
        }

        // SAFETY: This function is safe to call because `user` can be null and the caller is responsible for the data validity.
        let user =
            unsafe { credentials_str_into_bytes(auth_data.user as *const _, auth_data.user_length as usize * 2) };
        // SAFETY: This function is safe to call because `password` can be null and the caller is responsible for the data validity.
        let password = unsafe {
            credentials_str_into_bytes(auth_data.password as *const _, auth_data.password_length as usize * 2)
        }
        .into();

        // Only marshaled smart card creds starts with '@' char.
        #[cfg(all(feature = "scard", target_os = "windows"))]
        // SAFETY: This function is safe to call because argument is validated.
        if !user.is_empty() && unsafe { CredIsMarshaledCredentialW(user.as_ptr() as *const _) } != 0 {
            return handle_smart_card_creds(user, password);
        }

        Ok(CredentialsBuffers::AuthIdentity(AuthIdentityBuffers {
            user,
            // SAFETY: This function is safe to call because `domain` can be null and the caller is responsible for the data validity.
            domain: unsafe {
                credentials_str_into_bytes(auth_data.domain as *const _, auth_data.domain_length as usize * 2)
            },
            password,
        }))
    } else {
        let auth_data = p_auth_data.cast::<SecWinntAuthIdentityW>();
        // SAFETY: `auth_data` is not null. We've checked this above.
        let auth_data = unsafe { auth_data.as_ref() }.expect("auth_data pointer should not be null");

        // SAFETY: This function is safe to call because `user` can be null and the caller is responsible for the data validity.
        let user =
            unsafe { credentials_str_into_bytes(auth_data.user as *const _, auth_data.user_length as usize * 2) };
        // SAFETY: This function is safe to call because `password` can be null and the caller is responsible for the data validity.
        let password = unsafe {
            credentials_str_into_bytes(auth_data.password as *const _, auth_data.password_length as usize * 2)
        }
        .into();

        // Only marshaled smart card creds starts with '@' char.
        #[cfg(all(feature = "scard", target_os = "windows"))]
        // SAFETY: This function is safe to call because argument is validated.
        if !user.is_empty() && unsafe { CredIsMarshaledCredentialW(user.as_ptr() as *const _) } != 0 {
            return handle_smart_card_creds(user, password);
        }

        // Try to collect credentials for the emulated smart card.
        #[cfg(all(feature = "scard", target_os = "windows"))]
        if let Ok(scard_creds) = collect_smart_card_creds(&user, password.as_ref()) {
            return Ok(CredentialsBuffers::SmartCard(scard_creds));
        }

        Ok(CredentialsBuffers::AuthIdentity(AuthIdentityBuffers {
            user,
            // SAFETY: This function is safe to call because `domain` can be null and the caller is responsible for the data validity.
            domain: unsafe {
                credentials_str_into_bytes(auth_data.domain as *const _, auth_data.domain_length as usize * 2)
            },
            password,
        }))
    }
}

#[cfg(all(feature = "scard", target_os = "windows"))]
fn collect_smart_card_creds(username: &[u8], password: &[u8]) -> Result<SmartCardIdentityBuffers> {
    if username.contains(&b'@') {
        info!("Trying to collect smart card creds...");
        use winscard::{SmartCardInfo, DEFAULT_CARD_NAME, MICROSOFT_DEFAULT_CSP};

        use crate::sspi::utils::raw_wide_str_trim_nulls;
        use crate::utils::str_encode_utf16;

        match SmartCardInfo::try_from_env() {
            Ok(smart_card_info) => {
                let mut username = username.to_vec();
                let mut pin = password.to_vec();

                raw_wide_str_trim_nulls(&mut username);
                raw_wide_str_trim_nulls(&mut pin);

                info!("Smart card credentials have been collected. Process with scard-based logon.");

                return Ok(SmartCardIdentityBuffers {
                    username,
                    certificate: smart_card_info.auth_cert_der.clone(),
                    card_name: Some(str_encode_utf16(DEFAULT_CARD_NAME)),
                    reader_name: str_encode_utf16(smart_card_info.reader.name.as_ref()),
                    container_name: str_encode_utf16(smart_card_info.container_name.as_ref()),
                    csp_name: str_encode_utf16(MICROSOFT_DEFAULT_CSP),
                    pin: pin.into(),
                    private_key_file_index: None,
                    private_key_pem: Some(str_encode_utf16(smart_card_info.auth_pk_pem.as_ref())),
                });
            }
            Err(err) => {
                warn!(?err);
            }
        }
    }

    Err(Error::new(
        ErrorKind::NoCredentials,
        "Failed to collect smart card credentials. Process with password-based logon.",
    ))
}

#[cfg(not(target_os = "windows"))]
pub fn unpack_sec_winnt_auth_identity_ex2_a(_p_auth_data: *const c_void) -> Result<AuthIdentityBuffers> {
    Err(Error::new(
        ErrorKind::UnsupportedFunction,
        "SecWinntIdentityEx2 is not supported on non Windows systems",
    ))
}

/// This function calculated the size of the credentials represented by the `SEC_WINNT_AUTH_IDENTITY_EX2`
/// structure.
///
/// # Safety:
///
/// * The `p_auth_data` pointer must be not null and point to the valid credentials represented
///   by the `SEC_WINNT_AUTH_IDENTITY_EX2` structure.
#[cfg(target_os = "windows")]
unsafe fn get_sec_winnt_auth_identity_ex2_size(p_auth_data: *const c_void) -> Result<u32> {
    // https://learn.microsoft.com/en-us/windows/win32/api/sspi/ns-sspi-sec_winnt_auth_identity_ex2
    // https://github.com/FreeRDP/FreeRDP/blob/master/winpr/libwinpr/sspi/sspi_winpr.c#L473

    // Username length is placed after the first 8 bytes.
    // SAFETY: According to the documentation, username length is placed after the first 8 bytes.
    let user_len_ptr = unsafe { (p_auth_data as *const u16).add(4) };
    if user_len_ptr.is_null() {
        return Err(Error::new(
            ErrorKind::InvalidParameter,
            "invalid credentials: username length pointer is null",
        ));
    }
    // SAFETY: `user_len_ptr` is not null: checked above.
    let user_buffer_len = unsafe { *user_len_ptr as u32 };

    // Domain length is placed after 16 bytes from the username length.
    // SAFETY: According to the documentation, domain length is placed after the first 8 bytes.
    let domain_len_ptr = unsafe { user_len_ptr.add(8) };
    if domain_len_ptr.is_null() {
        return Err(Error::new(
            ErrorKind::InvalidParameter,
            "invalid credentials: domain length pointer is null",
        ));
    }
    // SAFETY: `domain_len_ptr` is not null: checked above.
    let domain_buffer_len = unsafe { *domain_len_ptr as u32 };

    // Packet credentials length is placed after 16 bytes from the domain length.
    // SAFETY: According to the documentation, packet credentials length is placed after the first 8 bytes.
    let creds_len_ptr = unsafe { domain_len_ptr.add(8) };
    if creds_len_ptr.is_null() {
        return Err(Error::new(
            ErrorKind::InvalidParameter,
            "invalid credentials: creds length pointer is null",
        ));
    }
    // SAFETY: `creds_len_ptr` is not null: checked above.
    let creds_buffer_len = unsafe { *creds_len_ptr as u32 };

    // The resulting size is queal to header size + buffers size.
    Ok(64 /* size of the SEC_WINNT_AUTH_IDENTITY_EX2 */ + user_buffer_len + domain_buffer_len + creds_buffer_len)
}

#[cfg(target_os = "windows")]
pub unsafe fn unpack_sec_winnt_auth_identity_ex2_a(p_auth_data: *const c_void) -> Result<CredentialsBuffers> {
    use windows_sys::Win32::Security::Credentials::{CredUnPackAuthenticationBufferA, CRED_PACK_PROTECTED_CREDENTIALS};

    if p_auth_data.is_null() {
        return Err(Error::new(
            ErrorKind::InvalidParameter,
            "Cannot unpack credentials: p_auth_data is null",
        ));
    }

    // SAFETY: `p_auth_data` is not null. We've checked this above.
    let auth_data_len = unsafe { get_sec_winnt_auth_identity_ex2_size(p_auth_data) }?;

    let mut username_len = 0;
    let mut domain_len = 0;
    let mut password_len = 0;

    // The first call is just to query the username, domain, and password lengths.
    // SAFETY: This function is safe to call because all arguments are type checked.
    unsafe {
        CredUnPackAuthenticationBufferA(
            CRED_PACK_PROTECTED_CREDENTIALS,
            p_auth_data,
            auth_data_len,
            null_mut() as *mut _,
            &mut username_len,
            null_mut() as *mut _,
            &mut domain_len,
            null_mut() as *mut _,
            &mut password_len,
        )
    };

    let mut username = vec![0_u8; username_len as usize];
    let mut domain = vec![0_u8; domain_len as usize];
    let mut password = Secret::new(vec![0_u8; password_len as usize]);

    // Knowing the actual sizes, we can unpack credentials into prepared buffers.
    // SAFETY: This function is safe to call because all arguments are type checked.
    let result = unsafe {
        CredUnPackAuthenticationBufferA(
            CRED_PACK_PROTECTED_CREDENTIALS,
            p_auth_data,
            auth_data_len,
            username.as_mut_ptr() as *mut _,
            &mut username_len,
            domain.as_mut_ptr() as *mut _,
            &mut domain_len,
            password.as_mut().as_mut_ptr() as *mut _,
            &mut password_len,
        )
    };

    if result != 1 {
        return Err(Error::new(
            ErrorKind::WrongCredentialHandle,
            "Cannot unpack credentials",
        ));
    }

    let mut auth_identity_buffers = AuthIdentityBuffers::default();

    // In the `auth_identity_buffers` structure we hold credentials as raw wide string without NULL-terminator bytes.
    // The `CredUnPackAuthenticationBufferW` function always returns credentials as strings.
    // So, username data is a C string and we need to delete the NULL terminator.
    username.pop();
    auth_identity_buffers.user = username;

    if domain_len == 0 {
        // Sometimes username can be formatted as `DOMAIN\username`.
        if let Some(index) = auth_identity_buffers.user.iter().position(|b| *b == b'\\') {
            auth_identity_buffers.domain = auth_identity_buffers.user[0..index].to_vec();
            auth_identity_buffers.user = auth_identity_buffers.user[(index + 1)..].to_vec();
        }
    } else {
        // In the `auth_identity_buffers` structure we hold credentials as raw wide string without NULL-terminator bytes.
        // The `CredUnPackAuthenticationBufferW` function always returns credentials as strings.
        // So, domain data is a C string and we need to delete the NULL terminator.
        domain.pop();
        auth_identity_buffers.domain = domain;
    }

    // In the `auth_identity_buffers` structure we hold credentials as raw wide string without NULL-terminator bytes.
    // The `CredUnPackAuthenticationBufferW` function always returns credentials as strings.
    // So, password data is a C string and we need to delete the NULL terminator.
    password.as_mut().pop();
    auth_identity_buffers.password = password;

    Ok(CredentialsBuffers::AuthIdentity(auth_identity_buffers))
}

#[cfg(not(target_os = "windows"))]
pub fn unpack_sec_winnt_auth_identity_ex2_w(_p_auth_data: *const c_void) -> Result<CredentialsBuffers> {
    Err(Error::new(
        ErrorKind::UnsupportedFunction,
        "SecWinntIdentityEx2 is not supported on non Windows systems",
    ))
}

#[cfg(all(feature = "scard", target_os = "windows"))]
#[instrument(level = "trace", ret)]
fn handle_smart_card_creds(mut username: Vec<u8>, password: Secret<Vec<u8>>) -> Result<CredentialsBuffers> {
    use std::ptr::null_mut;

    use sspi::cert_utils::{finalize_smart_card_info, SmartCardInfo};
    use sspi::string_to_utf16;
    use windows_sys::Win32::Security::Credentials::{CertCredential, CredUnmarshalCredentialW, CERT_CREDENTIAL_INFO};

    let mut cred_type = 0;
    let mut credential = null_mut();

    // Win API expects the C string as the first input parameter.
    // So, we need add the NULL terminator.
    username.extend_from_slice(&[0, 0]);

    // SAFETY: This function is safe to call because the arguments are type-checked.
    if unsafe { CredUnmarshalCredentialW(username.as_ptr() as *const _, &mut cred_type, &mut credential) } == 0 {
        return Err(Error::new(
            ErrorKind::NoCredentials,
            "Cannot unmarshal smart card credentials",
        ));
    }

    if cred_type != CertCredential {
        return Err(Error::new(
            ErrorKind::NoCredentials,
            "Unmarshalled smart card credentials is not CRED_MARSHAL_TYPE::CertCredential",
        ));
    }

    let cert_credential = credential.cast::<CERT_CREDENTIAL_INFO>();

    // SAFETY: This function is safe to call because `cert_credential` is validated.
    let (raw_certificate, certificate) = sspi::cert_utils::extract_certificate_by_thumbprint(
        // SAFETY: We've checked the returned status code from `CredUnmarshalCredentialW` function and credentials type above.
        // The `cert_credential` is a valid pointer to the `CERT_CREDENTIAL_INFO` structure at this point.
        unsafe { (*cert_credential).rgbHashOfCert }.as_ref(),
    )?;

    let username = string_to_utf16(sspi::cert_utils::extract_user_name_from_certificate(&certificate)?);
    // SAFETY: This function is safe to call because argument is type-checked.
    let SmartCardInfo {
        key_container_name,
        reader_name,
        certificate: _,
        csp_name,
        private_key_file_index,
    } = finalize_smart_card_info(&certificate.tbs_certificate.serial_number.0)?;

    let creds = CredentialsBuffers::SmartCard(SmartCardIdentityBuffers {
        certificate: raw_certificate,
        reader_name: string_to_utf16(reader_name),
        pin: password,
        username,
        card_name: None,
        container_name: string_to_utf16(key_container_name),
        csp_name: string_to_utf16(csp_name),
        private_key_file_index: Some(private_key_file_index),
        private_key_pem: None,
    });

    Ok(creds)
}

/// Unpacks raw credentials.
///
/// # Safety:
///
/// * The `p_auth_data` must not be null and point to the valid packed credentials. For more details,
///   see the `pAuthBuffer` pointer requirements: [CredUnPackAuthenticationBufferW](https://learn.microsoft.com/en-us/windows/win32/api/wincred/nf-wincred-credunpackauthenticationbufferw).
#[cfg(feature = "tsssp")]
#[instrument(level = "trace", ret)]
pub unsafe fn unpack_sec_winnt_auth_identity_ex2_w(p_auth_data: *const c_void) -> Result<CredentialsBuffers> {
    if p_auth_data.is_null() {
        return Err(Error::new(
            ErrorKind::InvalidParameter,
            "Cannot unpack credentials: p_auth_data is null",
        ));
    }

    // SAFETY: The `p_auth_data` is not null (checked above). All other requirements mu be upheld by the user.
    let auth_data_len = unsafe { get_sec_winnt_auth_identity_ex2_size(p_auth_data) }?;

    // SAFETY: The `p_auth_data` is not null (checked above). All other requirements mu be upheld by the user.
    unsafe { unpack_sec_winnt_auth_identity_ex2_w_sized(p_auth_data, auth_data_len) }
}

/// Unpacks raw credentials when the `auth_data` length is known.
///
/// # Safety:
///
/// * The `p_auth_data` must not be null and point to the valid packed credentials. For more details,
///   see the `pAuthBuffer` pointer requirements: [CredUnPackAuthenticationBufferW](https://learn.microsoft.com/en-us/windows/win32/api/wincred/nf-wincred-credunpackauthenticationbufferw).
#[cfg(feature = "tsssp")]
#[instrument(level = "trace", ret)]
pub unsafe fn unpack_sec_winnt_auth_identity_ex2_w_sized(
    p_auth_data: *const c_void,
    auth_data_len: u32,
) -> Result<CredentialsBuffers> {
    use std::ptr::null_mut;

    use windows_sys::Win32::Security::Credentials::{CredUnPackAuthenticationBufferW, CRED_PACK_PROTECTED_CREDENTIALS};

    use super::utils::raw_wide_str_trim_nulls;

    if p_auth_data.is_null() {
        return Err(Error::new(
            ErrorKind::InvalidParameter,
            "Cannot unpack credentials: p_auth_data is null",
        ));
    }

    let mut username_len = 0;
    let mut domain_len = 0;
    let mut password_len = 0;

    // The first call is just to query the username, domain, and password lengths.
    // SAFETY:
    // * `p_auth_data` pointer is not null (checked above). All other requirements mu be upheld by the user.
    // * all null values are allowed by the documentation.
    // * `username/domain/password_len` are safe to use because they are local variables.
    unsafe {
        CredUnPackAuthenticationBufferW(
            CRED_PACK_PROTECTED_CREDENTIALS,
            p_auth_data,
            auth_data_len,
            null_mut() as *mut _,
            &mut username_len,
            null_mut() as *mut _,
            &mut domain_len,
            null_mut() as *mut _,
            &mut password_len,
        )
    };

    let mut username = vec![0_u8; username_len as usize * 2];
    let mut domain = vec![0_u8; domain_len as usize * 2];
    let mut password = Secret::new(vec![0_u8; password_len as usize * 2]);

    // SAFETY:
    // * `p_auth_data` pointer is not null (checked above). All other requirements mu be upheld by the user.
    // * `username/domain/password` buffers are safe to use because they are buffers allocated by Rust.
    // * `username/domain/password_len` are safe to use because they are local variables.
    let result = unsafe {
        CredUnPackAuthenticationBufferW(
            CRED_PACK_PROTECTED_CREDENTIALS,
            p_auth_data,
            auth_data_len,
            username.as_mut_ptr() as *mut _,
            &mut username_len,
            domain.as_mut_ptr() as *mut _,
            &mut domain_len,
            password.as_mut().as_mut_ptr() as *mut _,
            &mut password_len,
        )
    };

    if result != 1 {
        return Err(Error::new(
            ErrorKind::WrongCredentialHandle,
            "Cannot unpack credentials",
        ));
    }

    // Try to collect credentials for the emulated smart card.
    #[cfg(feature = "scard")]
    if let Ok(scard_creds) = collect_smart_card_creds(&username, password.as_ref()) {
        return Ok(CredentialsBuffers::SmartCard(scard_creds));
    }

    // Only marshaled smart card creds starts with '@' char.
    #[cfg(feature = "scard")]
    // SAFETY: `username` is a Rust-allocated buffer which data has been written by the `CredUnPackAuthenticationBufferW` function.
    // Thus, it is safe to pass it into the `CredIsMarshaledCredentialW` function.
    if !username.is_empty() && unsafe { CredIsMarshaledCredentialW(username.as_ptr() as *const _) } != 0 {
        // The `handle_smart_card_creds` function expects credentials in a form of raw wide strings without NULL-terminator bytes.
        // The `CredUnPackAuthenticationBufferW` function always returns credentials as strings.
        // So, password data is a wide C string and we need to delete the NULL terminator.
        let new_len = password.as_ref().len() - 2;
        password.as_mut().truncate(new_len);

        return handle_smart_card_creds(username, password);
    }

    let mut auth_identity_buffers = AuthIdentityBuffers::default();

    // In the `auth_identity_buffers` structure we hold credentials as raw wide string without NULL-terminator bytes.
    // The `CredUnPackAuthenticationBufferW` function always returns credentials as strings.
    // So, username data is a wide C string and we need to delete the NULL terminator.
    raw_wide_str_trim_nulls(&mut username);
    auth_identity_buffers.user = username;

    if domain_len == 0 {
        // Sometimes username can be formatted as `DOMAIN\username`.
        if let Some(index) = auth_identity_buffers.user.iter().position(|b| *b == b'\\') {
            auth_identity_buffers.domain = auth_identity_buffers.user[0..index].to_vec();
            auth_identity_buffers.user = auth_identity_buffers.user[(index + 2)..].to_vec();
        }
    } else {
        // In the `auth_identity_buffers` structure we hold credentials as raw wide string without NULL-terminator bytes.
        // The `CredUnPackAuthenticationBufferW` function always returns credentials as strings.
        // So, domain data is a wide C string and we need to delete the NULL terminator.
        domain.truncate(domain.len() - 2);
        auth_identity_buffers.domain = domain;
    }

    // In the `auth_identity_buffers` structure we hold credentials as raw wide string without NULL-terminator bytes.
    // The `CredUnPackAuthenticationBufferW` function always returns credentials as strings.
    // So, password data is a wide C string and we need to delete the NULL terminator.
    let new_len = password.as_ref().len() - 2;
    password.as_mut().truncate(new_len);
    auth_identity_buffers.password = password;

    Ok(CredentialsBuffers::AuthIdentity(auth_identity_buffers))
}

#[allow(clippy::missing_safety_doc)]
#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_SspiEncodeStringsAsAuthIdentity"))]
#[no_mangle]
pub unsafe extern "system" fn SspiEncodeStringsAsAuthIdentity(
    psz_user_name: *const SecWChar,
    psz_domain_name: *const SecWChar,
    psz_packed_credentials_string: *const SecWChar,
    pp_auth_identity: *mut *mut c_void,
) -> SecurityStatus {
    catch_panic! {
        check_null!(pp_auth_identity);
        check_null!(psz_user_name);
        check_null!(psz_domain_name);
        check_null!(psz_packed_credentials_string);

        // SAFETY: This function is safe to call because `psz_user_name` is not null. We've checked this above.
        let user_length = unsafe { w_str_len(psz_user_name) };
        // SAFETY: This function is safe to call because `psz_domain_name` is not null. We've checked this above.
        let domain_length = unsafe { w_str_len(psz_domain_name) };
        // SAFETY: This function is safe to call because `psz_packed_credentials_string` is not null. We've checked this above.
        let password_length = unsafe { w_str_len(psz_packed_credentials_string) };

        if user_length == 0 || domain_length == 0 || password_length == 0 {
            return ErrorKind::InvalidParameter.to_u32().unwrap();
        }

        // SAFETY: Memory allocation is safe.
        let user = unsafe { libc::malloc(user_length * 2) as *mut SecWChar };
        if user.is_null() {
            return ErrorKind::InternalError.to_u32().unwrap();
        }
        // SAFETY: This function is safe to call because `psz_user_name` and `user` are not null. We've checked this above.
        unsafe { copy_nonoverlapping(psz_user_name, user, user_length) };

        // SAFETY: Memory allocation is safe.
        let domain = unsafe { libc::malloc(domain_length * 2) as *mut SecWChar };
        if domain.is_null() {
            return ErrorKind::InternalError.to_u32().unwrap();
        }
        // SAFETY: This function is safe to call because `psz_domain_name` and `domain` are not null. We've checked this above.
        unsafe { copy_nonoverlapping(psz_domain_name, domain, domain_length) };

        // SAFETY: Memory allocation is safe.
        let password = unsafe { libc::malloc(password_length * 2) as *mut SecWChar };
        if password.is_null() {
            return ErrorKind::InternalError.to_u32().unwrap();
        }

        // SAFETY: This function is safe to call because `psz_packed_credentials_string` and `password` are not null. We've checked this above.
        unsafe { copy_nonoverlapping(psz_packed_credentials_string, password, password_length) };

        let auth_identity = SecWinntAuthIdentityW {
            user,
            user_length: user_length.try_into().unwrap(),
            domain,
            domain_length: domain_length.try_into().unwrap(),
            password,
            password_length: password_length.try_into().unwrap(),
            flags: 0,
        };

        // SAFETY: `pp_auth_identity` is not null. We've checked this above.
        unsafe { *pp_auth_identity = into_raw_ptr(auth_identity) as *mut c_void; }

        0
    }
}

#[allow(clippy::missing_safety_doc)]
#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_SspiFreeAuthIdentity"))]
#[no_mangle]
pub unsafe extern "system" fn SspiFreeAuthIdentity(auth_data: *mut c_void) -> SecurityStatus {
    catch_panic! {
        if auth_data.is_null() {
            return 0;
        }

        let auth_data = auth_data.cast::<SecWinntAuthIdentityW>();
        // SAFETY: The pointer is not null: checked above.
        // The user have to ensure that the data behind this pointer is valid.
        let auth_data = unsafe { auth_data.as_mut() }.expect("auth_data pointer should not be null");

        if !auth_data.user.is_null() {
            // SAFETY: We use malloc to allocated buffers for the user.
            // The user have to ensure that the auth identity was allocated by us.
            unsafe { libc::free(auth_data.user as *mut _); }
        }
        if !auth_data.domain.is_null() {
            // SAFETY: We use malloc to allocated buffers for the user.
            // The user have to ensure that the auth identity was allocated by us.
            unsafe { libc::free(auth_data.domain as *mut _); }
        }
        if !auth_data.password.is_null() {
            // SAFETY: We use malloc to allocated buffers for the user.
            // The user have to ensure that the auth identity was allocated by us.
            unsafe { libc::free(auth_data.password as *mut _); }
        }

        // SAFETY: `auth_data` is not null. We've checked this above.
        // We create and allocate `SecWinntAuthIdentityW` using `Box::into_raw`. Thus,
        // it is safe to deallocate them using `Box::from_raw`.
        // The user have to ensure that the auth identity was allocated by us.
        let _auth_data: Box<SecWinntAuthIdentityW> = unsafe { Box::from_raw(auth_data) };

        0
    }
}

#[cfg(test)]
mod tests {
    use std::ptr::{null, null_mut};
    use std::slice::from_raw_parts;

    use libc::c_void;
    use num_traits::ToPrimitive;
    use sspi::ErrorKind;

    use super::{SecWinntAuthIdentityW, SspiEncodeStringsAsAuthIdentity, SspiFreeAuthIdentity};

    fn get_user_credentials() -> ([u16; 5], [u16; 5], [u16; 7]) {
        // (user, pass, domain)
        (
            [0x75, 0x73, 0x65, 0x72, 0],
            [0x70, 0x61, 0x73, 0x73, 0],
            [0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0],
        )
    }

    #[test]
    fn sspi_encode_strings_as_auth_identity() {
        let (username, password, domain) = get_user_credentials();
        let mut identity = null_mut::<c_void>();

        unsafe {
            let status =
                SspiEncodeStringsAsAuthIdentity(username.as_ptr(), domain.as_ptr(), password.as_ptr(), &mut identity);

            assert_eq!(status, 0);
            assert!(!identity.is_null());

            let identity = identity.cast::<SecWinntAuthIdentityW>();

            assert_eq!(
                "user",
                String::from_utf16_lossy(from_raw_parts((*identity).user, (*identity).user_length as usize))
            );
            assert_eq!(
                "pass",
                String::from_utf16_lossy(from_raw_parts(
                    (*identity).password,
                    (*identity).password_length as usize
                ))
            );
            assert_eq!(
                "domain",
                String::from_utf16_lossy(from_raw_parts((*identity).domain, (*identity).domain_length as usize))
            );

            let status = SspiFreeAuthIdentity(identity as *mut _);
            assert_eq!(status, 0);
        }
    }

    #[test]
    fn sspi_encode_strings_as_auth_identity_on_null() {
        let mut identity = null_mut::<c_void>();

        unsafe {
            let status = SspiEncodeStringsAsAuthIdentity(null(), null(), null(), &mut identity);

            assert_eq!(status, ErrorKind::InvalidParameter.to_u32().unwrap());
            assert!(identity.is_null());
        }
    }

    #[test]
    fn sspi_encode_strings_as_auth_identity_on_empty_creds() {
        let username = [0];
        let password = [0];
        let domain = [0];
        let mut identity = null_mut::<c_void>();

        unsafe {
            let status =
                SspiEncodeStringsAsAuthIdentity(username.as_ptr(), domain.as_ptr(), password.as_ptr(), &mut identity);

            assert_eq!(status, ErrorKind::InvalidParameter.to_u32().unwrap());
            assert!(identity.is_null());
        }
    }

    #[test]
    fn sspi_free_auth_identity() {
        let (username, password, domain) = get_user_credentials();
        let mut identity = null_mut::<c_void>();

        unsafe {
            let status =
                SspiEncodeStringsAsAuthIdentity(username.as_ptr(), domain.as_ptr(), password.as_ptr(), &mut identity);
            assert_eq!(status, 0);

            let status = SspiFreeAuthIdentity(identity);
            assert_eq!(status, 0);
        }
    }

    #[test]
    fn sspi_free_auth_identity_on_null() {
        unsafe {
            let status = SspiFreeAuthIdentity(null_mut::<c_void>());

            assert_eq!(status, 0);
        }
    }
}


--- File: ffi/src/sspi/security_tables.rs ---
#![allow(non_snake_case)]

use std::ptr::null;

use libc::c_void;
use sspi::KERBEROS_VERSION;
#[cfg(windows)]
use symbol_rename_macro::rename_symbol;

use super::common::{
    AcceptSecurityContext, AcceptSecurityContextFn, ApplyControlToken, ApplyControlTokenFn, CompleteAuthToken,
    CompleteAuthTokenFn, DecryptMessage, DecryptMessageFn, DeleteSecurityContext, DeleteSecurityContextFn,
    EncryptMessage, EncryptMessageFn, ExportSecurityContext, ExportSecurityContextFn, FreeContextBuffer,
    FreeContextBufferFn, FreeCredentialsHandle, FreeCredentialsHandleFn, ImpersonateSecurityContext,
    ImpersonateSecurityContextFn, MakeSignature, MakeSignatureFn, QuerySecurityContextToken,
    QuerySecurityContextTokenFn, RevertSecurityContext, RevertSecurityContextFn, VerifySignature, VerifySignatureFn,
};
use super::sec_handle::{
    AcquireCredentialsHandleA, AcquireCredentialsHandleFnA, AcquireCredentialsHandleFnW, AcquireCredentialsHandleW,
    AddCredentialsA, AddCredentialsFnA, AddCredentialsFnW, AddCredentialsW, ChangeAccountPasswordA,
    ChangeAccountPasswordFnA, ChangeAccountPasswordFnW, ChangeAccountPasswordW, ImportSecurityContextA,
    ImportSecurityContextFnA, ImportSecurityContextFnW, ImportSecurityContextW, InitializeSecurityContextA,
    InitializeSecurityContextFnA, InitializeSecurityContextFnW, InitializeSecurityContextW, QueryContextAttributesA,
    QueryContextAttributesExA, QueryContextAttributesExFnA, QueryContextAttributesExFnW, QueryContextAttributesExW,
    QueryContextAttributesFnA, QueryContextAttributesFnW, QueryContextAttributesW, QueryCredentialsAttributesA,
    QueryCredentialsAttributesExA, QueryCredentialsAttributesExFnA, QueryCredentialsAttributesExFnW,
    QueryCredentialsAttributesExW, QueryCredentialsAttributesFnA, QueryCredentialsAttributesFnW,
    QueryCredentialsAttributesW, SetContextAttributesA, SetContextAttributesFnA, SetContextAttributesFnW,
    SetContextAttributesW, SetCredentialsAttributesA, SetCredentialsAttributesFnA, SetCredentialsAttributesFnW,
    SetCredentialsAttributesW,
};
use super::sec_pkg_info::{
    EnumerateSecurityPackagesA, EnumerateSecurityPackagesFnA, EnumerateSecurityPackagesFnW, EnumerateSecurityPackagesW,
    QuerySecurityPackageInfoA, QuerySecurityPackageInfoFnA, QuerySecurityPackageInfoFnW, QuerySecurityPackageInfoW,
};
use crate::utils::into_raw_ptr;

#[repr(C)]
pub struct SecurityFunctionTableA {
    pub dwVersion: u32,
    pub EnumerateSecurityPackagesA: EnumerateSecurityPackagesFnA,
    pub QueryCredentialsAttributesA: QueryCredentialsAttributesFnA,
    pub AcquireCredentialsHandleA: AcquireCredentialsHandleFnA,
    pub FreeCredentialsHandle: FreeCredentialsHandleFn,
    pub Reserved2: *const c_void,
    pub InitializeSecurityContextA: InitializeSecurityContextFnA,
    pub AcceptSecurityContext: AcceptSecurityContextFn,
    pub CompleteAuthToken: CompleteAuthTokenFn,
    pub DeleteSecurityContext: DeleteSecurityContextFn,
    pub ApplyControlToken: ApplyControlTokenFn,
    pub QueryContextAttributesA: QueryContextAttributesFnA,
    pub ImpersonateSecurityContext: ImpersonateSecurityContextFn,
    pub RevertSecurityContext: RevertSecurityContextFn,
    pub MakeSignature: MakeSignatureFn,
    pub VerifySignature: VerifySignatureFn,
    pub FreeContextBuffer: FreeContextBufferFn,
    pub QuerySecurityPackageInfoA: QuerySecurityPackageInfoFnA,
    // In the Windows sspicli.dll, the `Reserved3` field is used as EncryptFunction
    pub Reserved3: EncryptMessageFn,
    // In the Windows sspicli.dll, the `Reserved4` field is used as DecryptFunction
    pub Reserved4: DecryptMessageFn,
    pub ExportSecurityContext: ExportSecurityContextFn,
    pub ImportSecurityContextA: ImportSecurityContextFnA,
    pub AddCredentialsA: AddCredentialsFnA,
    pub Reserved8: *const c_void,
    pub QuerySecurityContextToken: QuerySecurityContextTokenFn,
    pub EncryptMessage: EncryptMessageFn,
    pub DecryptMessage: DecryptMessageFn,
    pub SetContextAttributesA: SetContextAttributesFnA,
    pub SetCredentialsAttributesA: SetCredentialsAttributesFnA,
    pub ChangeAccountPasswordA: ChangeAccountPasswordFnA,
    pub Reserved9: *const c_void,
    pub QueryContextAttributesExA: QueryContextAttributesExFnA,
    pub QueryCredentialsAttributesExA: QueryCredentialsAttributesExFnA,
}

pub type PSecurityFunctionTableA = *mut SecurityFunctionTableA;

#[repr(C)]
pub struct SecurityFunctionTableW {
    pub dwVersion: u32,
    pub EnumerateSecurityPackagesW: EnumerateSecurityPackagesFnW,
    pub QueryCredentialsAttributesW: QueryCredentialsAttributesFnW,
    pub AcquireCredentialsHandleW: AcquireCredentialsHandleFnW,
    pub FreeCredentialsHandle: FreeCredentialsHandleFn,
    pub Reserved2: *const c_void,
    pub InitializeSecurityContextW: InitializeSecurityContextFnW,
    pub AcceptSecurityContext: AcceptSecurityContextFn,
    pub CompleteAuthToken: CompleteAuthTokenFn,
    pub DeleteSecurityContext: DeleteSecurityContextFn,
    pub ApplyControlToken: ApplyControlTokenFn,
    pub QueryContextAttributesW: QueryContextAttributesFnW,
    pub ImpersonateSecurityContext: ImpersonateSecurityContextFn,
    pub RevertSecurityContext: RevertSecurityContextFn,
    pub MakeSignature: MakeSignatureFn,
    pub VerifySignature: VerifySignatureFn,
    pub FreeContextBuffer: FreeContextBufferFn,
    pub QuerySecurityPackageInfoW: QuerySecurityPackageInfoFnW,
    // In the Windows sspicli.dll, the `Reserved3` field is used as EncryptFunction
    pub Reserved3: EncryptMessageFn,
    // In the Windows sspicli.dll, the `Reserved4` field is used as DecryptFunction
    pub Reserved4: DecryptMessageFn,
    pub ExportSecurityContext: ExportSecurityContextFn,
    pub ImportSecurityContextW: ImportSecurityContextFnW,
    pub AddCredentialsW: AddCredentialsFnW,
    pub Reserved8: *const c_void,
    pub QuerySecurityContextToken: QuerySecurityContextTokenFn,
    pub EncryptMessage: EncryptMessageFn,
    pub DecryptMessage: DecryptMessageFn,
    pub SetContextAttributesW: SetContextAttributesFnW,
    pub SetCredentialsAttributesW: SetCredentialsAttributesFnW,
    pub ChangeAccountPasswordW: ChangeAccountPasswordFnW,
    pub Reserved9: *const c_void,
    pub QueryContextAttributesExW: QueryContextAttributesExFnW,
    pub QueryCredentialsAttributesExW: QueryCredentialsAttributesExFnW,
}

pub type PSecurityFunctionTableW = *mut SecurityFunctionTableW;

#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_InitSecurityInterfaceA"))]
#[no_mangle]
pub extern "system" fn InitSecurityInterfaceA() -> PSecurityFunctionTableA {
    crate::logging::setup_logger();

    into_raw_ptr(SecurityFunctionTableA {
        dwVersion: KERBEROS_VERSION as u32,
        EnumerateSecurityPackagesA,
        QueryCredentialsAttributesA,
        AcquireCredentialsHandleA,
        FreeCredentialsHandle,
        Reserved2: null(),
        InitializeSecurityContextA,
        AcceptSecurityContext,
        CompleteAuthToken,
        DeleteSecurityContext,
        ApplyControlToken,
        QueryContextAttributesA,
        ImpersonateSecurityContext,
        RevertSecurityContext,
        MakeSignature,
        VerifySignature,
        FreeContextBuffer,
        QuerySecurityPackageInfoA,
        Reserved3: EncryptMessage,
        Reserved4: DecryptMessage,
        ExportSecurityContext,
        ImportSecurityContextA,
        AddCredentialsA,
        Reserved8: null(),
        QuerySecurityContextToken,
        EncryptMessage,
        DecryptMessage,
        SetContextAttributesA,
        SetCredentialsAttributesA,
        ChangeAccountPasswordA,
        Reserved9: null(),
        QueryContextAttributesExA,
        QueryCredentialsAttributesExA,
    })
}

#[instrument(skip_all)]
#[cfg_attr(windows, rename_symbol(to = "Rust_InitSecurityInterfaceW"))]
#[no_mangle]
pub extern "system" fn InitSecurityInterfaceW() -> PSecurityFunctionTableW {
    crate::logging::setup_logger();

    into_raw_ptr(SecurityFunctionTableW {
        dwVersion: KERBEROS_VERSION as u32,
        EnumerateSecurityPackagesW,
        QueryCredentialsAttributesW,
        AcquireCredentialsHandleW,
        FreeCredentialsHandle,
        Reserved2: null(),
        InitializeSecurityContextW,
        AcceptSecurityContext,
        CompleteAuthToken,
        DeleteSecurityContext,
        ApplyControlToken,
        QueryContextAttributesW,
        ImpersonateSecurityContext,
        RevertSecurityContext,
        MakeSignature,
        VerifySignature,
        FreeContextBuffer,
        QuerySecurityPackageInfoW,
        Reserved3: EncryptMessage,
        Reserved4: DecryptMessage,
        ExportSecurityContext,
        ImportSecurityContextW,
        AddCredentialsW,
        Reserved8: null(),
        QuerySecurityContextToken,
        EncryptMessage,
        DecryptMessage,
        SetContextAttributesW,
        SetCredentialsAttributesW,
        ChangeAccountPasswordW,
        Reserved9: null(),
        QueryContextAttributesExW,
        QueryCredentialsAttributesExW,
    })
}


--- File: ffi/src/sspi/sspi_data_types.rs ---
use libc::{c_char, c_void};
use sspi::CertTrustStatus as SspiCertTrustStatus;

pub type SecChar = c_char;

pub type LpStr = *const SecChar;

pub type SecWChar = u16;

pub type LpcWStr = *const SecWChar;

pub type SecurityStatus = u32;

#[repr(C)]
pub struct SecurityInteger {
    pub low_part: u32,
    pub high_part: i32,
}

pub type PTimeStamp = *mut SecurityInteger;

#[repr(C)]
pub struct SecurityString {
    pub length: u16,
    pub maximum_length: u16,
    pub buffer: *mut u16,
}

pub type PSecurityString = *mut SecurityString;

#[repr(C)]
pub struct SecPkgContextSizes {
    pub cb_max_token: u32,
    pub cb_max_signature: u32,
    pub cb_block_size: u32,
    pub cb_security_trailer: u32,
}

/// [SecPkgContext_StreamSizes](https://learn.microsoft.com/en-us/windows/win32/api/sspi/ns-sspi-secpkgcontext_streamsizes)
///
/// ```not_rust
/// typedef struct _SecPkgContext_StreamSizes {
///   unsigned long cbHeader;
///   unsigned long cbTrailer;
///   unsigned long cbMaximumMessage;
///   unsigned long cBuffers;
///   unsigned long cbBlockSize;
/// } SecPkgContext_StreamSizes, *PSecPkgContext_StreamSizes;
/// ```
#[repr(C)]
pub struct SecPkgContextStreamSizes {
    pub cb_header: u32,
    pub cb_trailer: u32,
    pub cb_maximum_message: u32,
    pub c_buffers: u32,
    pub cb_block_size: u32,
}

pub type SecGetKeyFn = extern "system" fn(*mut c_void, *mut c_void, u32, *mut *mut c_void, *mut i32);

/// [_SecPkgContext_Flags](https://learn.microsoft.com/en-us/windows/win32/api/sspi/ns-sspi-secpkgcontext_flags)
///
/// ```not_rust
/// typedef struct _SecPkgContext_Flags {
///   unsigned long Flags;
/// } SecPkgContext_Flags, *PSecPkgContext_Flags;
/// ```
#[repr(C)]
pub struct SecPkgContextFlags {
    pub flags: u32,
}

/// [ALG_ID](https://learn.microsoft.com/en-us/windows/win32/seccrypto/alg-id)
/// typedef unsigned int ALG_ID;
pub type AlgId = u32;

/// [_SecPkgContext_ConnectionInfo](https://learn.microsoft.com/en-us/windows/win32/api/schannel/ns-schannel-secpkgcontext_connectioninfo)
///
/// ```not_rust
/// typedef struct _SecPkgContext_ConnectionInfo {
///   DWORD  dwProtocol;
///   ALG_ID aiCipher;
///   DWORD  dwCipherStrength;
///   ALG_ID aiHash;
///   DWORD  dwHashStrength;
///   ALG_ID aiExch;
///   DWORD  dwExchStrength;
/// } SecPkgContext_ConnectionInfo, *PSecPkgContext_ConnectionInfo;
/// ```
#[repr(C)]
pub struct SecPkgContextConnectionInfo {
    pub dw_protocol: u32,
    pub ai_cipher: AlgId,
    pub dw_cipher_strength: u32,
    pub ai_hash: AlgId,
    pub dw_hash_strength: u32,
    pub ai_exch: AlgId,
    pub dw_exch_strength: u32,
}

/// [CERT_TRUST_STATUS](https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/ns-wincrypt-cert_trust_status)
///
/// ```not_rust
/// typedef struct _CERT_TRUST_STATUS {
///   DWORD dwErrorStatus;
///   DWORD dwInfoStatus;
/// } CERT_TRUST_STATUS, *PCERT_TRUST_STATUS;
/// ```
#[repr(C)]
pub struct CertTrustStatus {
    pub dw_error_status: u32,
    pub dw_info_status: u32,
}

impl From<SspiCertTrustStatus> for CertTrustStatus {
    fn from(cert_trust_status: SspiCertTrustStatus) -> Self {
        Self {
            dw_error_status: cert_trust_status.error_status.bits(),
            dw_info_status: cert_trust_status.info_status.bits(),
        }
    }
}


--- File: ffi/src/sspi/utils.rs ---
use sspi::{CredentialsBuffers, Result};

use super::credentials_attributes::CredentialsAttributes;
use super::sec_handle::CredentialsHandle;

/// Transforms a passed pointer to the credentials handle into a triplet of [CredentialsBuffers],
/// security package name, and [CredentialsAttributes].
///
/// # Safety:
///
/// The caller have to ensure that either the pointer is null or the pointer is [convertible to a reference](https://doc.rust-lang.org/std/ptr/index.html#pointer-to-reference-conversion).
pub unsafe fn transform_credentials_handle<'a>(
    credentials_handle: *mut CredentialsHandle,
) -> Option<(CredentialsBuffers, &'a str, &'a CredentialsAttributes)> {
    // SAFETY: `credentials_handle` is not null. We've checked this above.
    unsafe { credentials_handle.as_mut() }.map(|cred_handle| {
        (
            cred_handle.credentials.clone(),
            cred_handle.security_package_name.as_str(),
            &cred_handle.attributes,
        )
    })
}

// When encoding a UTF-16 character using two code units, the 16-bit values are chosen from
// the UTF-16 surrogate range 0xD800–0xDFFF, and thus only \0 is encoded by two consecutive null bytes.
#[cfg(any(feature = "tsssp", feature = "scard"))]
pub fn raw_wide_str_trim_nulls(raw_str: &mut Vec<u8>) {
    let mut len = raw_str.len();
    while len > 2 && raw_str[len - 2..] == [0, 0] {
        raw_str.truncate(len - 2);
        len = raw_str.len();
    }
}

pub fn hostname() -> Result<String> {
    // We run tests with Miri. Miri is the Rust's mid-level intermediate representation interpreter.
    // It is unable to execute system calls. Thus, Miri cannot execute `whoami::fallible::hostname()`.
    // So, we decided to keep hardcoded hostname.
    #[cfg(miri)]
    {
        Ok("test-vm".into())
    }
    #[cfg(not(miri))]
    {
        use sspi::{Error, ErrorKind};

        whoami::fallible::hostname().map_err(|err| {
            Error::new(
                ErrorKind::InternalError,
                format!("can not query the system hostname: {:?}", err),
            )
        })
    }
}


--- File: ffi/src/utils.rs ---
use std::slice::from_raw_parts;

use libc::c_char;

pub fn into_raw_ptr<T>(value: T) -> *mut T {
    Box::into_raw(Box::new(value))
}

/// # Safety
///
/// *Note*: the resulting [String] will contain a null-terminator char at the end.
/// Behavior is undefined is any of the following conditions are violated:
///
/// * `s` must be a [valid] C string.
pub unsafe fn c_w_str_to_string(s: *const u16) -> String {
    let mut len = 0;

    // SAFETY: The user must provide guarantees that `s` is a valid C string.
    while unsafe { *(s.add(len)) } != 0 {
        len += 1;
    }

    // SAFETY: The user must provide guarantees that `s` is a valid C string.
    String::from_utf16_lossy(unsafe { from_raw_parts(s, len) })
}

/// # Safety
///
/// The returned length includes the null terminator char.
/// Behavior is undefined is any of the following conditions are violated:
///
/// * `s` must be a [valid] C string.
pub unsafe fn w_str_len(s: *const u16) -> usize {
    let mut len = 0;

    // SAFETY: The user must provide guarantees that `s` is a valid C string.
    while unsafe { *(s.add(len)) } != 0 {
        len += 1;
    }

    len
}

/// Converts raw credentials string into [Vec] of bytes.
///
/// Credentials are often represented as strings. For example, username, domain, password.
/// It is OK for Windows SSPI to accept `null` or empty credential strings. The `AcquireCredentialsHandle`
/// function will return successful status code is we pass the `null` username value. Thus, this function
/// will return an empty [Vec] in such a case. It is done on purpose to follow the Windows SSPI behaviour.
///
/// # Safety
///
/// * the `raw_buffer` pointer can be null.
/// * if `raw_buffer` is not null, then it must be valid for reads for `len` many bytes, and it must be properly aligned.
/// * The total size `len` of the slice must be no larger than `isize::MAX`, and adding that size to `data`
///   must not "wrap around" the address space.
pub unsafe fn credentials_str_into_bytes(raw_buffer: *const c_char, len: usize) -> Vec<u8> {
    if !raw_buffer.is_null() {
        // SAFETY:
        // `raw_buffer` is not null: checked above. All other guarantees should be upheld by the caller.
        unsafe { from_raw_parts(raw_buffer as *const u8, len) }.to_vec()
    } else {
        Vec::new()
    }
}

pub fn str_to_w_buff(data: &str) -> Vec<u16> {
    data.encode_utf16().chain(std::iter::once(0)).collect()
}

#[cfg(any(feature = "scard", feature = "tsssp"))]
pub fn str_encode_utf16(data: &str) -> Vec<u8> {
    data.encode_utf16().flat_map(|c| c.to_le_bytes()).collect()
}


--- File: ffi/src/winscard/buf_alloc.rs ---
use std::slice::from_raw_parts_mut;

use ffi_types::{LpByte, LpDword, LpWStr};
use winscard::{Error, ErrorKind, WinScardResult};

use super::scard_handle::{OutBuffer, RequestedBufferType};

pub const SCARD_AUTOALLOCATE: u32 = 0xffffffff;

/// This function decides how to treat the provided buffer by the user and how to return the requested data.
///
/// When the user requests some data from the smart card using the WinSCard API, we have three ways
/// how to handle it:
/// * write data in the provided buffer.
/// * write data length of the requested data in the provided length pointer.
/// * allocate data by ourselves and write data pointer in the provided buffer.
#[instrument(level = "debug", ret)]
pub unsafe fn build_buf_request_type<'data>(
    p_buf: LpByte,
    pcb_buf: LpDword,
) -> WinScardResult<RequestedBufferType<'data>> {
    if pcb_buf.is_null() {
        return Err(Error::new(ErrorKind::InvalidParameter, "pcb_buf cannot be null"));
    }

    if p_buf.is_null() {
        // If this value is NULL, we ignore the buffer length, writes the length of the buffer that
        // would have been returned if this parameter had not been NULL, and returns a success code.
        return Ok(RequestedBufferType::Length);
    }
    // SAFETY: The `pcb_buf` parameter cannot be null. We've checked for it above.
    if unsafe { *pcb_buf } == SCARD_AUTOALLOCATE {
        // If the buffer length is specified as SCARD_AUTOALLOCATE, then data pointer is
        // converted to a pointer to a byte pointer, and receives the address of a block of memory
        // containing the attribute.
        Ok(RequestedBufferType::Allocate)
    } else {
        // SAFETY: `p_buf` and `pcb_buf` parameters can't be null. We've checked for it above.
        Ok(RequestedBufferType::Buf(unsafe {
            from_raw_parts_mut(p_buf, (*pcb_buf).try_into()?)
        }))
    }
}

/// This function behaves as the [build_buf_request_type] but here it expects a pointer
/// to the `u16` buffer instead of `u8`. So, the buffer length is multiplied by two.
#[instrument(level = "debug", ret)]
pub unsafe fn build_buf_request_type_wide<'data>(
    p_buf: LpWStr,
    pcb_buf: LpDword,
) -> WinScardResult<RequestedBufferType<'data>> {
    if pcb_buf.is_null() {
        return Err(Error::new(ErrorKind::InvalidParameter, "pcb_buf cannot be null"));
    }

    Ok(if p_buf.is_null() {
        // If this value is NULL, SCardGetAttrib ignores the buffer length supplied in pcbAttrLen,
        // writes the length of the buffer that would have been returned if this parameter had not been NULL
        // to pcbAttrLen, and returns a success code.
        RequestedBufferType::Length
    } else if
    // SAFETY: The `pcb_buf` parameter cannot be null. We've checked for it above.
    unsafe { *pcb_buf } == SCARD_AUTOALLOCATE {
        // https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardgetattrib
        //
        // If the buffer length is specified as SCARD_AUTOALLOCATE, then pbAttr is converted to a pointer
        // to a byte pointer, and receives the address of a block of memory containing the attribute.
        RequestedBufferType::Allocate
    } else {
        // SAFETY: `p_buf` and `pcb_buf` parameters can't be null. We've checked for it above.
        RequestedBufferType::Buf(unsafe { from_raw_parts_mut(p_buf as *mut u8, usize::try_from(*pcb_buf)? * 2) })
    })
}

/// Saves the resulting data after the [RequestedBufferType] processing.
pub unsafe fn save_out_buf(out_buf: OutBuffer, p_buf: LpByte, pcb_buf: LpDword) -> WinScardResult<()> {
    if pcb_buf.is_null() {
        return Err(Error::new(ErrorKind::InvalidParameter, "pcb_buf cannot be null"));
    }

    match out_buf {
        // SAFETY: We've checked for null above.
        OutBuffer::Written(len) => unsafe {
            // We already wrote the requested data in the provided buffer, so we only need to write the data length.
            *pcb_buf = len.try_into()?
        },
        // SAFETY: We've checked for null above.
        OutBuffer::DataLen(len) => unsafe {
            // The user requested only the requested data length, so we just return it.
            *pcb_buf = len.try_into()?
        },
        OutBuffer::Allocated(data) => {
            if p_buf.is_null() {
                return Err(Error::new(ErrorKind::InvalidParameter, "p_buf cannot be null"));
            }

            // SAFETY: We've checked for null above.
            unsafe {
                // We allocated a new memory for the requested data, so we need to save the buffer and buffer length.
                *(p_buf as *mut *mut u8) = data.as_mut_ptr();
                *pcb_buf = data.len().try_into()?;
            }
        }
    }

    Ok(())
}

/// This function behaves as the [save_out_buf] but here it expects a pointer
/// to the `u16` buffer instead of `u8`. So, the buffer length is divided by two.
#[instrument(level = "debug", ret)]
pub unsafe fn save_out_buf_wide(out_buf: OutBuffer, p_buf: LpWStr, pcb_buf: LpDword) -> WinScardResult<()> {
    if pcb_buf.is_null() {
        return Err(Error::new(ErrorKind::InvalidParameter, "pcb_buf cannot be null"));
    }

    match out_buf {
        // SAFETY: We've checked for null above.
        OutBuffer::Written(len) => unsafe { *pcb_buf = u32::try_from(len)? / 2 },
        // SAFETY: We've checked for null above.
        OutBuffer::DataLen(len) => unsafe { *pcb_buf = u32::try_from(len)? / 2 },
        OutBuffer::Allocated(data) => {
            if p_buf.is_null() {
                return Err(Error::new(ErrorKind::InvalidParameter, "p_buf cannot be null"));
            }

            // SAFETY: We've checked for null above.
            unsafe {
                *(p_buf as *mut *mut u8) = data.as_mut_ptr();
                *pcb_buf = u32::try_from(data.len())? / 2;
            }
        }
    }

    Ok(())
}


--- File: ffi/src/winscard/macros.rs ---
macro_rules! check_handle {
    ($x:expr) => {{
        if $x == 0 {
            return u32::from(winscard::ErrorKind::InvalidHandle);
        }
    }};
    ($x:expr, $name:expr) => {{
        use winscard::{Error, ErrorKind};

        if $x == 0 {
            return Err(Error::new(ErrorKind::InvalidHandle, $name));
        }
    }};
}

macro_rules! try_execute {
    ($x:expr) => {{
        match $x {
            Ok(value) => value,
            Err(err) => {
                error!(%err, "an error occurred");
                return u32::from(err.error_kind);
            }
        }
    }};
    ($x:expr, $err_value:expr) => {{
        match $x {
            Ok(val) => val,
            Err(err) => {
                error!(%err, "an error occurred");
                return $err_value.into();
            }
        }
    }};
}

macro_rules! check_null {
    ($x:expr) => {{
        if $x.is_null() {
            return u32::from(winscard::ErrorKind::InvalidParameter);
        }
    }};
    ($x:expr, $name:expr) => {{
        use winscard::{Error, ErrorKind};

        if $x.is_null() {
            return Err(Error::new(ErrorKind::InvalidParameter, $name));
        }
    }};
}


--- File: ffi/src/winscard/mod.rs ---
use ffi_types::winscard::functions::{PSCardApiFunctionTable, SCardApiFunctionTable};
use ffi_types::winscard::ScardIoRequest;
use winscard::winscard::Protocol;

use self::scard::*;
use self::scard_context::*;
use crate::utils::into_raw_ptr;

#[macro_use]
mod macros;
mod buf_alloc;
pub mod pcsc_lite;
pub mod scard;
pub mod scard_context;
mod scard_handle;
mod system_scard;

// The constants below are not documented anywhere and were discovered during debugging.
// Related example: https://github.com/bluetech/pcsc-rust/blob/b397cc8e3834a1dc791631105f37f34d321c8696/pcsc/src/lib.rs#L605-L613
#[no_mangle]
pub static Rust_g_rgSCardT1Pci: ScardIoRequest = ScardIoRequest {
    dw_protocol: Protocol::T1.bits(),
    cb_pci_length: 8,
};

#[no_mangle]
pub static Rust_g_rgSCardT0Pci: ScardIoRequest = ScardIoRequest {
    dw_protocol: Protocol::T0.bits(),
    cb_pci_length: 8,
};

#[no_mangle]
pub static Rust_g_rgSCardRawPci: ScardIoRequest = ScardIoRequest {
    dw_protocol: Protocol::Raw.bits(),
    cb_pci_length: 8,
};

pub extern "system" fn GetSCardApiFunctionTable() -> PSCardApiFunctionTable {
    crate::logging::setup_logger();

    into_raw_ptr(SCardApiFunctionTable {
        dw_version: 0,
        dw_flags: 0,

        SCardEstablishContext,
        SCardReleaseContext,
        SCardIsValidContext,
        SCardListReaderGroupsA,
        SCardListReaderGroupsW,
        SCardListReadersA,
        SCardListReadersW,
        SCardListCardsA,
        SCardListCardsW,
        SCardListInterfacesA,
        SCardListInterfacesW,
        SCardGetProviderIdA,
        SCardGetProviderIdW,
        SCardGetCardTypeProviderNameA,
        SCardGetCardTypeProviderNameW,
        SCardIntroduceReaderGroupA,
        SCardIntroduceReaderGroupW,
        SCardForgetReaderGroupA,
        SCardForgetReaderGroupW,
        SCardIntroduceReaderA,
        SCardIntroduceReaderW,
        SCardForgetReaderA,
        SCardForgetReaderW,
        SCardAddReaderToGroupA,
        SCardAddReaderToGroupW,
        SCardRemoveReaderFromGroupA,
        SCardRemoveReaderFromGroupW,
        SCardIntroduceCardTypeA,
        SCardIntroduceCardTypeW,
        SCardSetCardTypeProviderNameA,
        SCardSetCardTypeProviderNameW,
        SCardFreeMemory,
        SCardAccessStartedEvent,
        SCardReleaseStartedEvent,
        SCardLocateCardsA,
        SCardLocateCardsW,
        SCardLocateCardsByATRA,
        SCardLocateCardsByATRW,
        SCardGetStatusChangeA,
        SCardGetStatusChangeW,
        SCardCancel,
        SCardConnectA,
        SCardConnectW,
        SCardReconnect,
        SCardDisconnect,
        SCardBeginTransaction,
        SCardEndTransaction,
        SCardCancelTransaction,
        SCardState,
        SCardStatusA,
        SCardStatusW,
        SCardTransmit,
        SCardGetTransmitCount,
        SCardControl,
        SCardGetAttrib,
        SCardSetAttrib,
        SCardUIDlgSelectCardA,
        SCardUIDlgSelectCardW,
        GetOpenCardNameA,
        GetOpenCardNameW,
        SCardReadCacheA,
        SCardReadCacheW,
        SCardWriteCacheA,
        SCardWriteCacheW,
        SCardGetReaderIconA,
        SCardGetReaderIconW,
        SCardGetDeviceTypeIdA,
        SCardGetDeviceTypeIdW,
        SCardGetReaderDeviceInstanceIdA,
        SCardGetReaderDeviceInstanceIdW,
        SCardListReadersWithDeviceInstanceIdA,
        SCardListReadersWithDeviceInstanceIdW,
        SCardAudit,

        g_rgSCardT0Pci: &Rust_g_rgSCardT0Pci,
        g_rgSCardT1Pci: &Rust_g_rgSCardT1Pci,
        g_rgSCardRawPci: &Rust_g_rgSCardRawPci,
    })
}


--- File: ffi/src/winscard/pcsc_lite/functions.rs ---
use ffi_types::{LpByte, LpCByte, LpCStr, LpCVoid, LpStr, LpVoid};

use super::{
    Dword, LpDword, LpScardContext, LpScardHandle, ScardContext, ScardHandle, ScardIoRequest, ScardReaderState,
    ScardStatus,
};

/// Creates an Application Context to the PC/SC Resource Manager.
///
/// [SCardEstablishContext](https://pcsclite.apdu.fr/api/group__API.html#gaa1b8970169fd4883a6dc4a8f43f19b67)
/// This must be the first WinSCard function called in a PC/SC application. Each thread of an application shall use its own `SCARDCONTEXT`,
/// unless calling `SCardCancel()`, which MUST be called with the same context as the context used to call `SCardGetStatusChange()`.
pub type SCardEstablishContextFn = unsafe extern "system" fn(Dword, LpVoid, LpVoid, LpScardContext) -> ScardStatus;

/// Destroys a communication context to the PC/SC Resource Manager.
///
/// [SCardReleaseContext](https://pcsclite.apdu.fr/api/group__API.html#ga6aabcba7744c5c9419fdd6404f73a934)
/// This must be the last function called in a PC/SC application.
pub type SCardReleaseContextFn = unsafe extern "system" fn(h_context: ScardContext) -> ScardStatus;

/// Establishes a connection to the reader specified in * szReader.
///
/// [SCardConnect](https://pcsclite.apdu.fr/api/group__API.html#ga4e515829752e0a8dbc4d630696a8d6a5)
pub type SCardConnectFn = unsafe extern "system" fn(
    h_context: ScardContext,
    sz_reader: LpCStr,
    dw_share_mode: Dword,
    dw_preferred_protocols: Dword,
    ph_card: LpScardHandle,
    pdw_active_protocol: LpDword,
) -> ScardStatus;

/// Reestablishes a connection to a reader that was previously connected to using `SCardConnect()`.
///
/// [SCardReconnect](https://pcsclite.apdu.fr/api/group__API.html#gad5d4393ca8c470112ad9468c44ed8940)
/// In a multi application environment it is possible for an application to reset the card in shared mode.
/// When this occurs any other application trying to access certain commands will be returned the value `SCARD_W_RESET_CARD`.
/// When this occurs `SCardReconnect()` must be called in order to acknowledge that the card was reset and allow it to change its state accordingly.
pub type SCardReconnectFn = unsafe extern "system" fn(
    h_card: ScardHandle,
    dw_share_mode: Dword,
    dw_preferred_protocols: Dword,
    dw_initialization: Dword,
    pdw_active_protocol: LpDword,
) -> ScardStatus;

/// Terminates a connection made through SCardConnect().
///
/// [SCardDisconnect](https://pcsclite.apdu.fr/api/group__API.html#ga4be198045c73ec0deb79e66c0ca1738a)
pub type SCardDisconnectFn = unsafe extern "system" fn(h_card: ScardHandle, dw_disposition: Dword) -> ScardStatus;

/// Establishes a temporary exclusive access mode for doing a series of commands in a transaction.
///
/// [SCardBeginTransaction](https://pcsclite.apdu.fr/api/group__API.html#gaddb835dce01a0da1d6ca02d33ee7d861)
/// You might want to use this when you are selecting a few files and then writing a large file,
/// so you can make sure that another application will not change the current file. If another application has a lock on this reader
/// or this application is in `SCARD_SHARE_EXCLUSIVE` the function will block until it can continue.
pub type SCardBeginTransactionFn = unsafe extern "system" fn(h_card: ScardHandle) -> ScardStatus;

/// Ends a previously begun transaction.
///
/// [SCardEndTransaction](https://pcsclite.apdu.fr/api/group__API.html#gae8742473b404363e5c587f570d7e2f3b)
/// The calling application must be the owner of the previously begun transaction or an error will occur.
pub type SCardEndTransactionFn = unsafe extern "system" fn(h_card: ScardHandle, dw_disposition: Dword) -> ScardStatus;

/// Returns the current status of the reader connected to by hCard.
///
/// [SCardStatus](https://pcsclite.apdu.fr/api/group__API.html#gae49c3c894ad7ac12a5b896bde70d0382)
pub type SCardStatusFn = unsafe extern "system" fn(
    h_card: ScardHandle,
    sz_reader_name: LpStr,
    pcch_reader_len: LpDword,
    pdw_state: LpDword,
    pdw_protocol: LpDword,
    pb_atr: LpByte,
    pcb_atr_len: LpDword,
) -> ScardStatus;

/// Blocks execution until the current availability of the cards in a specific set of readers changes.
///
/// [SCardGetStatusChange](https://pcsclite.apdu.fr/api/group__API.html#ga33247d5d1257d59e55647c3bb717db24)
pub type SCardGetStatusChangeFn = unsafe extern "system" fn(
    h_context: ScardContext,
    dw_timeout: Dword,
    rg_reader_states: *mut ScardReaderState,
    c_readers: Dword,
) -> ScardStatus;

/// Sends a command directly to the IFD Handler (reader driver) to be processed by the reader.
///
/// [SCardControl](https://pcsclite.apdu.fr/api/group__API.html#gac3454d4657110fd7f753b2d3d8f4e32f)
/// This is useful for creating client side reader drivers for functions like PIN pads, biometrics,
/// or other extensions to the normal smart card reader that are not normally handled by PC/SC.
pub type SCardControlFn = unsafe extern "system" fn(
    h_card: ScardHandle,
    dw_control_code: Dword,
    pb_send_buffer: LpCVoid,
    cb_send_length: Dword,
    pb_recv_buffer: LpVoid,
    cb_recv_length: Dword,
    lp_bytes_returned: LpDword,
) -> ScardStatus;

/// Get an attribute from the IFD Handler (reader driver).
///
/// [SCardGetAttrib](https://pcsclite.apdu.fr/api/group__API.html#gaacfec51917255b7a25b94c5104961602)
pub type SCardGetAttribFn = unsafe extern "system" fn(
    h_card: ScardHandle,
    dw_attr_id: Dword,
    pb_attr: LpByte,
    pcb_atr_len: LpDword,
) -> ScardStatus;

/// Set an attribute of the IFD Handler.
///
/// [SCardSetAttrib](https://pcsclite.apdu.fr/api/group__API.html#ga060f0038a4ddfd5dd2b8fadf3c3a2e4f)
pub type SCardSetAttribFn = unsafe extern "system" fn(
    h_card: ScardHandle,
    dw_attr_id: Dword,
    pb_attr: LpCByte,
    cb_attr_len: Dword,
) -> ScardStatus;

/// Sends an APDU to the smart card contained in the reader connected to by `SCardConnect()`.
///
/// [SCardTransmit](https://pcsclite.apdu.fr/api/group__API.html#ga9a2d77242a271310269065e64633ab99)
pub type SCardTransmitFn = unsafe extern "system" fn(
    h_card: ScardHandle,
    poi_send_pci: *const ScardIoRequest,
    pb_send_buffer: LpCByte,
    cb_send_length: Dword,
    poi_recv_pci: *mut ScardIoRequest,
    pb_recv_buffer: LpByte,
    pcb_recv_length: LpDword,
) -> ScardStatus;

/// Returns a list of currently available readers on the system.
///
/// [SCardListReaders](https://pcsclite.apdu.fr/api/group__API.html#ga93b07815789b3cf2629d439ecf20f0d9)
pub type SCardListReadersFn = unsafe extern "system" fn(
    h_context: ScardContext,
    msz_groups: LpCStr,
    msc_reader: LpStr,
    pcch_readers: LpDword,
) -> ScardStatus;

/// Releases memory that has been returned from the resource manager using the `SCARD_AUTOALLOCATE` length designator.
///
/// [SCardFreeMemory](https://pcsclite.apdu.fr/api/group__API.html#ga0522241e3180cb05dfd166e28930e961)
pub type SCardFreeMemoryFn = unsafe extern "system" fn(h_context: ScardContext, pv_mem: LpCVoid) -> ScardStatus;

/// Returns a list of currently available reader groups on the system.
///
/// [SCardListReaderGroups](https://pcsclite.apdu.fr/api/group__API.html#ga9d970d086d5218e080d0079d63f9d496)
pub type SCardListReaderGroupsFn =
    unsafe extern "system" fn(h_context: ScardContext, msz_groups: LpStr, pcch_groups: LpDword) -> ScardStatus;

/// Cancels a specific blocking `SCardGetStatusChange()` function.
///
/// [SCardCancel](https://pcsclite.apdu.fr/api/group__API.html#gaacbbc0c6d6c0cbbeb4f4debf6fbeeee6)
/// MUST be called with the same `SCARDCONTEXT` as `SCardGetStatusChange()`.
pub type SCardCancelFn = unsafe extern "system" fn(h_context: ScardContext) -> ScardStatus;

/// Check if a [ScardContext] is valid.
///
/// [SCardIsValidContext](https://pcsclite.apdu.fr/api/group__API.html#ga722eb66bcc44d391f700ff9065cc080b).
/// Call this function to determine whether a smart card context handle is still valid. After a smart card context handle
/// has been returned by `SCardEstablishContext()`, it may become invalid if the resource manager service has been shut down.
pub type SCardIsValidContextFn = unsafe extern "system" fn(h_context: ScardContext) -> ScardStatus;

/// This structure contains all pcsc-lite API functions.
#[repr(C)]
#[allow(non_snake_case)]
pub struct PcscLiteApiFunctionTable {
    pub SCardEstablishContext: SCardEstablishContextFn,
    pub SCardReleaseContext: SCardReleaseContextFn,
    pub SCardConnect: SCardConnectFn,
    pub SCardReconnect: SCardReconnectFn,
    pub SCardDisconnect: SCardDisconnectFn,
    pub SCardBeginTransaction: SCardBeginTransactionFn,
    pub SCardEndTransaction: SCardEndTransactionFn,
    pub SCardStatus: SCardStatusFn,
    pub SCardGetStatusChange: SCardGetStatusChangeFn,
    pub SCardControl: SCardControlFn,
    pub SCardGetAttrib: SCardGetAttribFn,
    pub SCardSetAttrib: SCardSetAttribFn,
    pub SCardTransmit: SCardTransmitFn,
    pub SCardListReaders: SCardListReadersFn,
    pub SCardFreeMemory: SCardFreeMemoryFn,
    pub SCardListReaderGroups: SCardListReaderGroupsFn,
    pub SCardCancel: SCardCancelFn,
    pub SCardIsValidContext: SCardIsValidContextFn,

    pub g_rgSCardT0Pci: *const ScardIoRequest,
    pub g_rgSCardT1Pci: *const ScardIoRequest,
    pub g_rgSCardRawPci: *const ScardIoRequest,
}


--- File: ffi/src/winscard/pcsc_lite/mod.rs ---
#![cfg(not(target_os = "windows"))]

pub mod functions;

#[cfg(not(target_os = "macos"))]
use core::ffi::{c_long, c_ulong};
use std::borrow::Cow;
use std::env;
use std::ffi::CString;

use ffi_types::{LpCStr, LpVoid};
use libc::{dlopen, dlsym, RTLD_LAZY, RTLD_LOCAL};
use winscard::{Error, ErrorKind, WinScardResult};

use crate::winscard::pcsc_lite::functions::PcscLiteApiFunctionTable;

/// [SCARD_IO_REQUEST Struct Reference](https://pcsclite.apdu.fr/api/structSCARD__IO__REQUEST.html)
///
/// Protocol Control Information (PCI).
#[cfg_attr(not(target_os = "macos"), repr(C))]
#[cfg_attr(target_os = "macos", repr(C, packed))]
pub struct ScardIoRequest {
    /// Protocol identifier.
    pub dw_protocol: u32,
    /// Protocol Control Inf Length.
    pub cb_pci_length: u32,
}

/// [SCARD_READERSTATE Struct Reference](https://pcsclite.apdu.fr/api/structSCARD__READERSTATE.html)
#[cfg_attr(not(target_os = "macos"), repr(C))]
#[cfg_attr(target_os = "macos", repr(C, packed))]
pub struct ScardReaderState {
    pub sz_reader: LpCStr,
    pub pv_user_data: LpVoid,
    pub dw_current_state: u32,
    pub dw_event_state: u32,
    pub cb_atr: u32,
    pub rgb_atr: [u8; 36],
}

#[cfg(not(target_os = "macos"))]
pub type ScardStatus = c_long;
#[cfg(target_os = "macos")]
pub type ScardStatus = u32;

#[cfg(target_os = "macos")]
pub type Dword = u32;
#[cfg(not(target_os = "macos"))]
pub type Dword = c_ulong;

pub type LpDword = *mut Dword;

pub const SCARD_AUTOALLOCATE: Dword = Dword::MAX;

/// `hContext` returned by `SCardEstablishContext()`.
///
/// https://pcsclite.apdu.fr/api/pcsclite_8h.html#a22530ffaff18b5d3e32260a5f1ce4abd
#[cfg(target_os = "macos")]
pub type ScardContext = i32;
#[cfg(not(target_os = "macos"))]
pub type ScardContext = c_long;

/// Pointer to the [ScardContext].
pub type LpScardContext = *mut ScardContext;

/// `hCard` returned by `SCardConnect()`.
///
/// https://pcsclite.apdu.fr/api/pcsclite_8h.html#af328aca3e11de737ecd771bcf1f75fb5
#[cfg(target_os = "macos")]
pub type ScardHandle = i32;
#[cfg(not(target_os = "macos"))]
pub type ScardHandle = c_long;

/// Pointer to the [ScardHandle].
pub type LpScardHandle = *mut ScardHandle;

// We have already defined `State` flags in the `winscard` crate but we need a separate one for the pcsc-lite because of
// differences between Windows WinSCard API and pcsc-lite.
//
// https://pcsclite.apdu.fr/api/group__API.html#differences
// > SCardStatus() returns a bit field on pcsc-lite but a enumeration on Windows.
bitflags::bitflags! {
    /// [SCardStatus](https://pcsclite.apdu.fr/api/group__API.html#gae49c3c894ad7ac12a5b896bde70d0382)
    ///
    /// Current state of this reader: is a DWORD possibly OR'd with the following values:
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Default)]
    pub struct State: Dword {
        /// There is no card in the reader.
        const Absent = 0x0002;
        /// There is a card in the reader, but it has not been moved into position for use.
        const Present = 0x0004;
        /// There is a card in the reader in position for use. The card is not powered.
        const Swallowed = 0x0008;
        /// Power is being provided to the card, but the reader driver is unaware of the mode of the card.
        const Powered = 0x0010;
        /// The card has been reset and is awaiting PTS negotiation.
        const Negotiable = 0x0020;
        /// The card has been reset and specific communication protocols have been established.
        const Specific = 0x0040;
    }
}

impl From<State> for winscard::winscard::State {
    fn from(value: State) -> Self {
        #[allow(clippy::useless_conversion)]
        let bits: u32 = value.bits().try_into().expect("Card state value should fit in u32");
        if let Ok(state) = Self::try_from(bits) {
            // If the pcsc-lite card state has only one bit set, then we can safely convert it to the Windows WinSCard state.
            state
        } else {
            // If the pcsc-lite card state has more then one bit set, then we just return the `State::Specific` state. The Windows
            // WinSCard usually returns this state for the working inserted smart card. We do the same for the emulated smart cards
            // and for the system scards in the case of state uncertainty.
            Self::Specific
        }
    }
}

/// Path to the `pcsc-lite` library.
///
/// The user can use this environment variable to customize the `pcsc-lite` library loading.
const PCSC_LITE_LIB_PATH_ENV: &str = "PCSC_LITE_LIB_PATH";

pub fn initialize_pcsc_lite_api() -> WinScardResult<PcscLiteApiFunctionTable> {
    let pcsc_lite_path = if let Ok(lib_path) = env::var(PCSC_LITE_LIB_PATH_ENV) {
        Cow::Owned(lib_path)
    } else {
        #[cfg(target_os = "macos")]
        {
            Cow::Borrowed("/System/Library/Frameworks/PCSC.framework/PCSC")
        }
        #[cfg(not(target_os = "macos"))]
        {
            Cow::Borrowed("libpcsclite.so")
        }
    };
    debug!(?pcsc_lite_path);

    let pcsc_lite_path = CString::new(pcsc_lite_path.as_ref())?;

    // SAFETY: The library path is type checked.
    let handle = unsafe { dlopen(pcsc_lite_path.as_ptr(), RTLD_LOCAL | RTLD_LAZY) };
    if handle.is_null() {
        return Err(Error::new(
            ErrorKind::InternalError,
            format!("Can not load pcsc-lite library: {}", pcsc_lite_path.to_str().unwrap()),
        ));
    }

    macro_rules! load_fn {
        ($func_name:literal) => {{
            let fn_name = CString::new($func_name).expect("CString creation should not fail");

            // SAFETY:
            // - We've checked the `handle` above.
            // - `fn_name` is correct and hardcoded in the code.
            let fn_ptr = unsafe { dlsym(handle, fn_name.as_ptr()) };
            debug!(?fn_ptr, $func_name);

            // SAFETY:
            // - `*mut c_void` and target transmute type are both C pointers. They have the same layout.
            //   Thus, we can safely transmute the C pointer to the C function pointer.
            // - The target transmute type is our defined PCSC-lite C function which is correct.
            //   We are responsible for the function signature correctness.
            unsafe {
                // Not great to silent, but mostly fine in this context.
                #[expect(clippy::missing_transmute_annotations)]
                std::mem::transmute::<*mut libc::c_void, _>(fn_ptr)
            }
        }};
    }

    macro_rules! load_io_request {
        ($req_name:literal) => {{
            let req_name = CString::new($req_name).expect("CString creation should not fail");

            // SAFETY:
            // - We've checked the `handle` above.
            // - `req_name` is correct and hardcoded in the code.
            let io_request_ptr = unsafe { dlsym(handle, req_name.as_ptr()) };
            debug!(?io_request_ptr, $req_name);

            // SAFETY:
            // - `*mut c_void` and `*const ScardIoRequest` are both C pointers. They have the same layout.
            //   Thus, we can safely transmute one C pointer to another C pointer.
            // - The `*const ScardIoRequest` type is our defined PCSC-lite C structure and it is correct.
            //   We are responsible for the structure correctness.
            unsafe { std::mem::transmute::<*mut libc::c_void, *const ScardIoRequest>(io_request_ptr) }
        }};
    }

    Ok(PcscLiteApiFunctionTable {
        SCardEstablishContext: load_fn!("SCardEstablishContext"),
        SCardReleaseContext: load_fn!("SCardReleaseContext"),
        SCardConnect: load_fn!("SCardConnect"),
        SCardReconnect: load_fn!("SCardReconnect"),
        SCardDisconnect: load_fn!("SCardDisconnect"),
        SCardBeginTransaction: load_fn!("SCardBeginTransaction"),
        SCardEndTransaction: load_fn!("SCardEndTransaction"),
        SCardStatus: load_fn!("SCardStatus"),
        SCardGetStatusChange: load_fn!("SCardGetStatusChange"),
        SCardControl: load_fn!("SCardControl"),
        SCardGetAttrib: load_fn!("SCardGetAttrib"),
        SCardSetAttrib: load_fn!("SCardSetAttrib"),
        SCardTransmit: load_fn!("SCardTransmit"),
        SCardListReaders: load_fn!("SCardListReaders"),
        SCardFreeMemory: load_fn!("SCardFreeMemory"),
        SCardListReaderGroups: load_fn!("SCardListReaderGroups"),
        SCardCancel: load_fn!("SCardCancel"),
        SCardIsValidContext: load_fn!("SCardIsValidContext"),

        g_rgSCardT0Pci: load_io_request!("g_rgSCardT0Pci"),
        g_rgSCardT1Pci: load_io_request!("g_rgSCardT1Pci"),
        g_rgSCardRawPci: load_io_request!("g_rgSCardRawPci"),
    })
}


--- File: ffi/src/winscard/scard.rs ---
use std::ffi::CStr;
use std::slice::{from_raw_parts, from_raw_parts_mut};

use ffi_types::winscard::{
    LpCScardIoRequest, LpOpenCardNameA, LpOpenCardNameExA, LpOpenCardNameExW, LpOpenCardNameW, LpScardHandle,
    LpScardIoRequest, ScardContext, ScardHandle, ScardStatus,
};
use ffi_types::{LpByte, LpCByte, LpCStr, LpCVoid, LpCWStr, LpDword, LpStr, LpVoid, LpWStr};
use num_traits::FromPrimitive;
#[cfg(target_os = "windows")]
use symbol_rename_macro::rename_symbol;
use winscard::winscard::{AttributeId, Protocol, ScardConnectData, ShareMode};
use winscard::{Error, ErrorKind, WinScardResult};

use super::buf_alloc::{build_buf_request_type, build_buf_request_type_wide, save_out_buf, save_out_buf_wide};
use crate::utils::{c_w_str_to_string, into_raw_ptr};
use crate::winscard::scard_handle::{
    copy_io_request_to_scard_io_request, raw_scard_context_handle_to_scard_context_handle,
    raw_scard_handle_to_scard_handle, scard_context_to_winscard_context, scard_handle_to_winscard, WinScardHandle,
};

unsafe fn connect(
    context: ScardContext,
    reader_name: &str,
    dw_share_mode: u32,
    dw_preferred_protocols: u32,
    ph_card: LpScardHandle,
    pdw_active_protocol: LpDword,
) -> WinScardResult<()> {
    if ph_card.is_null() {
        return Err(Error::new(ErrorKind::InvalidParameter, "ph_card cannot be null"));
    }
    if pdw_active_protocol.is_null() {
        return Err(Error::new(
            ErrorKind::InvalidParameter,
            "pdw_active_protocol cannot be null",
        ));
    }

    let share_mode = dw_share_mode.try_into()?;
    let protocol = Protocol::from_bits(dw_preferred_protocols);

    // SAFETY: The user should provide a valid context handle. If it's equal to zero, then
    // the `scard_context_to_winscard_context` will return an error.
    let scard_context = unsafe { scard_context_to_winscard_context(context)? };
    let ScardConnectData { handle, protocol } = scard_context.connect(reader_name, share_mode, protocol)?;

    let scard = WinScardHandle::new(handle, context);

    let raw_card_handle = into_raw_ptr(scard) as ScardHandle;

    // SAFETY: The user should provide a valid context handle. The `context` can't be a zero, because
    // the `scard_context_to_winscard_context` function didn't return an error.
    let context = unsafe { raw_scard_context_handle_to_scard_context_handle(context) }?;
    context.add_scard(raw_card_handle)?;

    // SAFETY: We've checked for null above.
    unsafe {
        *ph_card = raw_card_handle;
        *pdw_active_protocol = protocol.bits();
    }

    Ok(())
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardConnectA"))]
#[instrument(ret)]
#[no_mangle]
pub unsafe extern "system" fn SCardConnectA(
    context: ScardContext,
    sz_reader: LpCStr,
    dw_share_mode: u32,
    dw_preferred_protocols: u32,
    ph_card: LpScardHandle,
    pdw_active_protocol: LpDword,
) -> ScardStatus {
    check_handle!(context);
    check_null!(sz_reader);
    check_null!(ph_card);
    check_null!(pdw_active_protocol);

    let reader_name = try_execute!(
        // SAFETY: The `sz_reader` parameter is not null (checked above).
        unsafe { CStr::from_ptr(sz_reader as *const _) }.to_str(),
        ErrorKind::InvalidParameter
    );

    try_execute!(
        // SAFETY: All parameters are validated and/or type checked:
        // * `context`: it's not a zero. All other guarantees should be provided by the user.
        // * `reader_name`: it's a `&str`. So, it's a valid string slice.
        // * `dw_share_mode`: we just pass it. I'll be validated later when transforming into a concrete Rust-type.
        // * `dw_preferred_protocols`: the sme situation as for `dw_share_mode`.
        // * `ph_card`: We've checked that it's not null. That's enough. We only write a value to it. Never read.
        // * `pdw_active_protocol`: We've checked that it's not null. That's enough. We only write a value to it. Never read.
        unsafe {
            connect(
                context,
                reader_name,
                dw_share_mode,
                dw_preferred_protocols,
                ph_card,
                pdw_active_protocol,
            )
        }
    );

    ErrorKind::Success.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardConnectW"))]
#[instrument(ret)]
#[no_mangle]
pub unsafe extern "system" fn SCardConnectW(
    context: ScardContext,
    sz_reader: LpCWStr,
    dw_share_mode: u32,
    dw_preferred_protocols: u32,
    ph_card: LpScardHandle,
    pdw_active_protocol: LpDword,
) -> ScardStatus {
    check_handle!(context);
    check_null!(sz_reader);
    check_null!(ph_card);
    check_null!(pdw_active_protocol);

    // SAFETY: The `sz_reader` parameter is not null (checked above).
    let reader_name = unsafe { c_w_str_to_string(sz_reader) };

    try_execute!(
        // SAFETY: All parameters are validated and/or type checked:
        // * `context`: it's not a zero. All other guarantees should be provided by the user.
        // * `reader_name`: it's a `String`. So, it's a valid string.
        // * `dw_share_mode`: we just pass it. I'll be validated later when transforming into a concrete Rust-type.
        // * `dw_preferred_protocols`: the sme situation as for `dw_share_mode`.
        // * `ph_card`: We've checked that it's not null. That's enough. We only write a value to it. Never read.
        // * `pdw_active_protocol`: We've checked that it's not null. That's enough. We only write a value to it. Never read.
        unsafe {
            connect(
                context,
                &reader_name,
                dw_share_mode,
                dw_preferred_protocols,
                ph_card,
                pdw_active_protocol,
            )
        }
    );

    ErrorKind::Success.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardReconnect"))]
#[instrument(ret)]
#[no_mangle]
pub unsafe extern "system" fn SCardReconnect(
    handle: ScardHandle,
    dw_share_mode: u32,
    dw_preferred_protocols: u32,
    dw_initialization: u32,
    pdw_active_protocol: LpDword,
) -> ScardStatus {
    check_handle!(handle);
    check_null!(pdw_active_protocol);

    let share_mode = try_execute!(ShareMode::try_from(dw_share_mode));
    let protocol = Protocol::from_bits(dw_preferred_protocols);
    let initialization = try_execute!(dw_initialization.try_into(), ErrorKind::InvalidParameter);

    let scard = try_execute!(
        // SAFETY: The `handle` is not equal to zero (checked above). All other guarantees should be provided by the user.
        unsafe { scard_handle_to_winscard(handle) }
    );
    let active_protocol = try_execute!(scard.reconnect(share_mode, protocol, initialization));

    // SAFETY: `pdw_active_protocol` is checked above, so it is guaranteed not NULL.
    unsafe {
        *pdw_active_protocol = active_protocol.bits();
    }

    ErrorKind::Success.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardDisconnect"))]
#[instrument(ret)]
#[no_mangle]
pub unsafe extern "system" fn SCardDisconnect(handle: ScardHandle, dw_disposition: u32) -> ScardStatus {
    check_handle!(handle);

    let scard = try_execute!(
        // SAFETY: The `handle` is not equal to zero (checked above).
        unsafe { raw_scard_handle_to_scard_handle(handle) }
    );
    try_execute!(scard
        .scard_mut()
        .disconnect(try_execute!(dw_disposition.try_into(), ErrorKind::InvalidParameter)));

    if let Ok(context) = scard.context() {
        if context.remove_scard(handle) {
            info!(?handle, "Successfully disconnected");
        } else {
            warn!("ScardHandle does not belong to the specified context")
        }
    }

    ErrorKind::Success.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardBeginTransaction"))]
#[instrument(ret)]
#[no_mangle]
pub unsafe extern "system" fn SCardBeginTransaction(handle: ScardHandle) -> ScardStatus {
    check_handle!(handle);

    // SAFETY: The `handle` is not equal to zero (checked above).
    let scard = try_execute!(unsafe { scard_handle_to_winscard(handle) });

    try_execute!(scard.begin_transaction());

    ErrorKind::Success.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardEndTransaction"))]
#[instrument(ret)]
#[no_mangle]
pub unsafe extern "system" fn SCardEndTransaction(handle: ScardHandle, dw_disposition: u32) -> ScardStatus {
    check_handle!(handle);

    // SAFETY: The `handle` is not equal to zero (checked above).
    let scard = try_execute!(unsafe { scard_handle_to_winscard(handle) });

    try_execute!(scard.end_transaction(try_execute!(dw_disposition.try_into())));

    ErrorKind::Success.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardCancelTransaction"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn SCardCancelTransaction(_handle: ScardHandle) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardState"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn SCardState(
    _handle: ScardHandle,
    _pdw_state: LpDword,
    _pdw_protocol: LpDword,
    _pb_atr: LpByte,
    _pcb_atr_len: LpDword,
) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardStatusA"))]
#[instrument(ret)]
#[no_mangle]
pub unsafe extern "system" fn SCardStatusA(
    handle: ScardHandle,
    msz_reader_names: LpStr,
    pcch_reader_len: LpDword,
    pdw_state: LpDword,
    pdw_protocol: LpDword,
    pb_atr: LpByte,
    pcb_atr_len: LpDword,
) -> ScardStatus {
    check_handle!(handle);
    check_null!(msz_reader_names);
    check_null!(pcch_reader_len);
    check_null!(pdw_state);
    check_null!(pdw_protocol);
    // pb_atr can be null.
    // it's not specified in a docs, but `msclmd.dll` can invoke this function with pb_atr = 0.
    check_null!(pcb_atr_len);

    // SAFETY: The `handle` is not zero. All other guarantees should be provided by the user.
    let scard = try_execute!(unsafe { raw_scard_handle_to_scard_handle(handle) });
    // SAFETY: The `msz_reader_names` and `pcch_reader_len` parameters are not null (cheked above).
    let readers_buf_type = try_execute!(unsafe { build_buf_request_type(msz_reader_names, pcch_reader_len) });
    // SAFETY: It's safe to call this function because the `pb_atr` parameter is allowed to be null
    // and the `pcb_atr_len` parameter cannot be null (checked above).
    let atr_buf_type = try_execute!(unsafe { build_buf_request_type(pb_atr, pcb_atr_len) });

    let status = try_execute!(scard.status(readers_buf_type, atr_buf_type));

    // SAFETY: It's safe to deref because `pdw_state` and `pdw_protocol` parameters are not null (checked above).
    unsafe {
        *pdw_state = status.state.into();
        *pdw_protocol = status.protocol.bits();
    }

    // SAFETY: The `msz_reader_names` and `pcch_reader_len` parameters are not null (cheked above).
    try_execute!(unsafe { save_out_buf(status.readers, msz_reader_names, pcch_reader_len) });

    // SAFETY: `pb_atr` can be null. `pcb_atr_len` can not be null and checked above.
    try_execute!(unsafe { save_out_buf(status.atr, pb_atr, pcb_atr_len) });

    ErrorKind::Success.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardStatusW"))]
#[instrument(ret)]
#[no_mangle]
pub unsafe extern "system" fn SCardStatusW(
    handle: ScardHandle,
    msz_reader_names: LpWStr,
    pcch_reader_len: LpDword,
    pdw_state: LpDword,
    pdw_protocol: LpDword,
    pb_atr: LpByte,
    pcb_atr_len: LpDword,
) -> ScardStatus {
    check_handle!(handle);
    check_null!(msz_reader_names);
    check_null!(pcch_reader_len);
    check_null!(pdw_state);
    check_null!(pdw_protocol);
    // pb_atr can be null.
    // it's not specified in a docs, but `msclmd.dll` can invoke this function with pb_atr = 0.
    check_null!(pcb_atr_len);

    // SAFETY: The `handle` is not zero. All other guarantees should be provided by the user.
    let scard = try_execute!(unsafe { raw_scard_handle_to_scard_handle(handle) });
    // SAFETY: The `msz_reader_names` and `pcch_reader_len` parameters are not null (cheked above).
    let readers_buf_type = try_execute!(unsafe { build_buf_request_type_wide(msz_reader_names, pcch_reader_len) });
    // SAFETY: It's safe to call this function because the `pb_atr` parameter is allowed to be null
    // and the `pcb_atr_len` parameter cannot be null (checked above).
    let atr_buf_type = try_execute!(unsafe { build_buf_request_type(pb_atr, pcb_atr_len) });

    let status = try_execute!(scard.status_wide(readers_buf_type, atr_buf_type));

    // SAFETY: It's safe to deref because `pdw_state` and `pdw_protocol` parameters are not null (checked above).
    unsafe {
        *pdw_state = status.state.into();
        *pdw_protocol = status.protocol.bits();
    }

    // SAFETY: The `msz_reader_names` and `pcch_reader_len` parameters are not null (cheked above).
    try_execute!(unsafe { save_out_buf_wide(status.readers, msz_reader_names, pcch_reader_len) });

    // SAFETY: `pb_atr` can be null. `pcb_atr_len` can not be null and checked above.
    try_execute!(unsafe { save_out_buf(status.atr, pb_atr, pcb_atr_len) });

    ErrorKind::Success.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardTransmit"))]
#[instrument(ret)]
#[no_mangle]
pub unsafe extern "system" fn SCardTransmit(
    handle: ScardHandle,
    pio_send_pci: LpCScardIoRequest,
    pb_send_buffer: LpCByte,
    cb_send_length: u32,
    pio_recv_pci: LpScardIoRequest,
    pb_recv_buffer: LpByte,
    pcb_recv_length: LpDword,
) -> ScardStatus {
    check_handle!(handle);
    check_null!(pio_send_pci);
    check_null!(pb_send_buffer);
    check_null!(pcb_recv_length);

    // SAFETY: The `handle` is not null. All other guarantees should be provided by the user.
    let scard = try_execute!(unsafe { scard_handle_to_winscard(handle) });

    // SAFETY: The `pb_send_buffer` parameter cannot be null (checked above).
    let input_apdu = unsafe {
        from_raw_parts(
            pb_send_buffer,
            try_execute!(cb_send_length.try_into(), ErrorKind::InsufficientBuffer),
        )
    };

    let out_data = try_execute!(scard.transmit(input_apdu));

    let out_apdu_len = out_data.output_apdu.len();
    if out_apdu_len
        > try_execute!(
            // SAFETY: The `pcb_recv_length` parameter cannot be null (checked above). So, it's safe to deref.
            usize::try_from(unsafe { *pcb_recv_length }),
            ErrorKind::InsufficientBuffer
        )
        || pb_recv_buffer.is_null()
    {
        return ErrorKind::InsufficientBuffer.into();
    }

    // SAFETY: The `pb_recv_buffer` parameter cannot be null (checked above).
    let recv_buffer = unsafe { from_raw_parts_mut(pb_recv_buffer, out_apdu_len) };
    recv_buffer.copy_from_slice(&out_data.output_apdu);

    if !pio_recv_pci.is_null() && out_data.receive_pci.is_some() {
        try_execute!(
            // SAFETY: The `pio_recv_pci` parameter cannot be null (checked above).
            unsafe {
                copy_io_request_to_scard_io_request(
                    out_data
                        .receive_pci
                        .as_ref()
                        .expect("Should not panic: the receive_pci value is checked above"),
                    pio_recv_pci,
                )
            }
        );
    }

    // SAFETY: The `pcb_recv_length` parameter cannot be null (checked above).
    unsafe {
        *pcb_recv_length = try_execute!(out_apdu_len.try_into(), ErrorKind::InsufficientBuffer);
    }

    ErrorKind::Success.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardGetTransmitCount"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn SCardGetTransmitCount(_handle: ScardHandle, pc_transmit_count: LpDword) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardControl"))]
#[instrument(ret)]
#[no_mangle]
pub unsafe extern "system" fn SCardControl(
    handle: ScardHandle,
    dw_control_code: u32,
    lp_in_buffer: LpCVoid,
    cb_in_buffer_size: u32,
    lp_out_buffer: LpVoid,
    cb_out_buffer_size: u32,
    lp_bytes_returned: LpDword,
) -> ScardStatus {
    check_handle!(handle);

    let scard = try_execute!(
        // SAFETY: The `handle` is not equal to zero (checked above).
        unsafe { scard_handle_to_winscard(handle) }
    );

    let in_buffer = if !lp_in_buffer.is_null() {
        // SAFETY: The `lp_in_buffer` parameter cannot be null (checked above).
        unsafe {
            from_raw_parts(
                lp_in_buffer as *const u8,
                try_execute!(cb_in_buffer_size.try_into(), ErrorKind::InsufficientBuffer),
            )
        }
    } else {
        &[]
    };

    if !lp_out_buffer.is_null() {
        // SAFETY: The `lp_out_buffer` parameter cannot be null (checked above).
        let lp_out_buffer = unsafe {
            from_raw_parts_mut(
                lp_out_buffer as *mut u8,
                try_execute!(cb_out_buffer_size.try_into(), ErrorKind::InvalidParameter),
            )
        };

        let out_bytes_count = try_execute!(scard.control_with_output(dw_control_code, in_buffer, lp_out_buffer));
        if !lp_bytes_returned.is_null() {
            // SAFETY: The `lp_bytes_returned` parameter cannot be null (checked above).
            unsafe {
                *lp_bytes_returned = try_execute!(out_bytes_count.try_into(), ErrorKind::InternalError);
            }
        }
    } else {
        try_execute!(scard.control(dw_control_code, in_buffer));
    }

    ErrorKind::Success.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardGetAttrib"))]
#[instrument(ret)]
#[no_mangle]
pub unsafe extern "system" fn SCardGetAttrib(
    handle: ScardHandle,
    dw_attr_id: u32,
    pb_attr: LpByte,
    pcb_attr_len: LpDword,
) -> ScardStatus {
    check_handle!(handle);
    check_null!(pcb_attr_len);

    let attr_id = try_execute!(AttributeId::from_u32(dw_attr_id).ok_or_else(|| Error::new(
        ErrorKind::InvalidParameter,
        format!("invalid attribute id: {}", dw_attr_id)
    )));

    // SAFETY: The `handle` is not zero. All other guarantees should be provided by the user.
    let scard = try_execute!(unsafe { raw_scard_handle_to_scard_handle(handle) });
    // SAFETY: It's safe to call this function because the `pb_atr` parameter is allowed to be null
    // and the `pcb_atr_len` parameter cannot be null (checked above).
    let buffer_type = try_execute!(unsafe { build_buf_request_type(pb_attr, pcb_attr_len) });

    let out_buf = try_execute!(scard.get_attribute(attr_id, buffer_type));

    // SAFETY: It's safe to call this function because the `pb_atr` parameter is allowed to be null
    // and the `pcb_atr_len` parameter cannot be null (checked above).
    try_execute!(unsafe { save_out_buf(out_buf, pb_attr, pcb_attr_len) });

    ErrorKind::Success.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardSetAttrib"))]
#[instrument(ret)]
#[no_mangle]
pub unsafe extern "system" fn SCardSetAttrib(
    handle: ScardHandle,
    dw_attr_id: u32,
    pb_attr: LpCByte,
    cb_attr_len: u32,
) -> ScardStatus {
    check_handle!(handle);
    check_null!(pb_attr);

    // SAFETY: The `pb_attr` parameter is not null (checked above).
    let attr_data = unsafe { from_raw_parts(pb_attr, cb_attr_len.try_into().unwrap()) };
    let attr_id = try_execute!(AttributeId::from_u32(dw_attr_id).ok_or_else(|| Error::new(
        ErrorKind::InvalidParameter,
        format!("Invalid attribute id: {}", dw_attr_id)
    )));
    // SAFETY: The `handle` is not zero (checked above). All other guarantees should be provided by the user.
    let scard = try_execute!(unsafe { scard_handle_to_winscard(handle) });

    try_execute!(scard.set_attribute(attr_id, attr_data));

    ErrorKind::Success.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardUIDlgSelectCardA"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn SCardUIDlgSelectCardA(_p: LpOpenCardNameExA) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardUIDlgSelectCardW"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn SCardUIDlgSelectCardW(_p: LpOpenCardNameExW) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_GetOpenCardNameA"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn GetOpenCardNameA(_p: LpOpenCardNameA) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_GetOpenCardNameW"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn GetOpenCardNameW(_p: LpOpenCardNameW) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}


--- File: ffi/src/winscard/scard_context.rs ---
use std::borrow::Cow;
use std::ffi::CStr;
use std::slice::{from_raw_parts, from_raw_parts_mut};
use std::sync::{LazyLock, Mutex};

#[cfg(target_os = "windows")]
use ffi_types::winscard::functions::SCardApiFunctionTable;
use ffi_types::winscard::{
    LpScardAtrMask, LpScardContext, LpScardReaderStateA, LpScardReaderStateW, ScardContext, ScardStatus,
};
use ffi_types::{Handle, LpByte, LpCByte, LpCGuid, LpCStr, LpCVoid, LpCWStr, LpDword, LpGuid, LpStr, LpUuid, LpWStr};
use libc::c_void;
#[cfg(target_os = "windows")]
use symbol_rename_macro::rename_symbol;
use uuid::Uuid;
use winscard::winscard::{CurrentState, ReaderState, WinScardContext};
use winscard::{ErrorKind, ScardContext as PivCardContext, SmartCardInfo, WinScardResult};

use super::buf_alloc::{build_buf_request_type, build_buf_request_type_wide, save_out_buf, save_out_buf_wide};
use crate::utils::{c_w_str_to_string, into_raw_ptr, str_encode_utf16};
use crate::winscard::scard_handle::{
    raw_scard_context_handle_to_scard_context_handle, scard_context_to_winscard_context, WinScardContextHandle,
};
use crate::winscard::system_scard::SystemScardContext;

const ERROR_INVALID_HANDLE: u32 = 6;

// Environment variable that indicates what smart card type use. It can have the following values:
// `true` - use a system-provided smart card.
// `false` (or unset) - use an emulated smart card.
const SMART_CARD_TYPE: &str = "WINSCARD_USE_SYSTEM_SCARD";

// We need to store all active smart card contexts in one collection.
// The `SCardIsValidContext` function can be called with already released context. So, with the help
// of `SCARD_CONTEXTS` we can track all active contexts and correctly check is the passed context is valid.
// The same applies to the `SCardReleaseContext`. We need to ensure that the passed context handle was not
// released before.
static SCARD_CONTEXTS: LazyLock<Mutex<Vec<ScardContext>>> = LazyLock::new(|| Mutex::new(Vec::new()));
// This API table instance is only needed for the `SCardAccessStartedEvent` function. This function
// doesn't accept any parameters, so we need a separate initialized API table to call the system API.
#[cfg(target_os = "windows")]
static WINSCARD_API: LazyLock<SCardApiFunctionTable> = LazyLock::new(|| {
    crate::winscard::system_scard::init_scard_api_table().expect("winscard module loading should not fail")
});

fn save_context(context: ScardContext) {
    SCARD_CONTEXTS
        .lock()
        .expect("SCARD_CONTEXTS mutex locking should not fail")
        .push(context)
}

fn is_present(context: ScardContext) -> bool {
    SCARD_CONTEXTS
        .lock()
        .expect("SCARD_CONTEXTS mutex locking should not fail")
        .iter()
        .any(|ctx| *ctx == context)
}

fn release_context(context: ScardContext) {
    SCARD_CONTEXTS
        .lock()
        .expect("SCARD_CONTEXTS mutex locking should not fail")
        .retain(|ctx| *ctx != context)
}

fn create_emulated_smart_card_context() -> WinScardResult<Box<dyn WinScardContext>> {
    Ok(Box::new(PivCardContext::new(SmartCardInfo::try_from_env()?)?))
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardEstablishContext"))]
#[instrument(ret)]
#[no_mangle]
pub unsafe extern "system" fn SCardEstablishContext(
    dw_scope: u32,
    _r1: *const c_void,
    _r2: *const c_void,
    context: LpScardContext,
) -> ScardStatus {
    crate::logging::setup_logger();

    check_null!(context);

    let scard_context = if let Ok(use_system_card) = std::env::var(SMART_CARD_TYPE) {
        if use_system_card == "true" {
            info!("Creating system-provided smart card context");
            Box::new(try_execute!(SystemScardContext::establish(try_execute!(
                dw_scope.try_into()
            ))))
        } else {
            info!("Creating emulated smart card context");
            try_execute!(create_emulated_smart_card_context())
        }
    } else {
        info!("Creating emulated smart card context");
        try_execute!(create_emulated_smart_card_context())
    };

    let scard_context = WinScardContextHandle::with_scard_context(scard_context);

    let raw_ptr = into_raw_ptr(scard_context) as ScardContext;
    info!(new_established_context = ?raw_ptr);
    // SAFETY: The `context` is not null (checked above).
    unsafe {
        *context = raw_ptr;
    }
    save_context(raw_ptr);

    ErrorKind::Success.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardReleaseContext"))]
#[instrument(ret)]
#[no_mangle]
pub unsafe extern "system" fn SCardReleaseContext(context: ScardContext) -> ScardStatus {
    check_handle!(context);

    if is_present(context) {
        // SAFETY: The `context` is not zero (checked above). All other guarantees should be provided by the user.
        let _ = unsafe { Box::from_raw(context as *mut WinScardContextHandle) };
        release_context(context);

        info!("Scard context has been successfully released");

        ErrorKind::Success.into()
    } else {
        warn!(context, "Scard context is invalid or has been released");

        ERROR_INVALID_HANDLE
    }
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardIsValidContext"))]
#[no_mangle]
pub unsafe extern "system" fn SCardIsValidContext(context: ScardContext) -> ScardStatus {
    if is_present(context) {
        check_handle!(context);

        let context = try_execute!(
            // SAFETY: The `context` is not zero (checked above). All other guarantees should be provided by the user.
            unsafe { scard_context_to_winscard_context(context) }
        );

        if context.is_valid() {
            ErrorKind::Success.into()
        } else {
            ERROR_INVALID_HANDLE
        }
    } else {
        debug!(context, "Provided context is not present in active contexts");

        ERROR_INVALID_HANDLE
    }
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardListReaderGroupsA"))]
#[no_mangle]
pub extern "system" fn SCardListReaderGroupsA(
    _context: ScardContext,
    _gmsz_groups: LpStr,
    _pcch_groups: LpDword,
) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardListReaderGroupsW"))]
#[no_mangle]
pub extern "system" fn SCardListReaderGroupsW(
    _context: ScardContext,
    _gmsz_groups: LpWStr,
    _pcch_groups: LpDword,
) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardListReadersA"))]
#[no_mangle]
pub unsafe extern "system" fn SCardListReadersA(
    context: ScardContext,
    _msz_groups: LpCStr,
    msz_readers: LpStr,
    pcch_readers: LpDword,
) -> ScardStatus {
    check_handle!(context);
    check_null!(msz_readers);
    check_null!(pcch_readers);

    // SAFETY: The `context` value is not zero (checked above).
    let context = try_execute!(unsafe { raw_scard_context_handle_to_scard_context_handle(context) });
    // SAFETY: The `msz_readers` and `pcch_readers` parameters are not null (checked above).
    let buffer_type = try_execute!(unsafe { build_buf_request_type(msz_readers, pcch_readers) });

    let out_buf = try_execute!(context.list_readers(buffer_type));

    // SAFETY: The `msz_readers` and `pcch_readers` parameters are not null (checked above).
    try_execute!(unsafe { save_out_buf(out_buf, msz_readers, pcch_readers) });

    ErrorKind::Success.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardListReadersW"))]
#[instrument(ret)]
#[no_mangle]
pub unsafe extern "system" fn SCardListReadersW(
    context: ScardContext,
    _msz_groups: LpCWStr,
    msz_readers: LpWStr,
    pcch_readers: LpDword,
) -> ScardStatus {
    check_handle!(context);
    check_null!(msz_readers);
    check_null!(pcch_readers);

    // SAFETY: The `context` value is not zero (checked above).
    let context = try_execute!(unsafe { raw_scard_context_handle_to_scard_context_handle(context) });
    // SAFETY: The `msz_readers` and `pcch_readers` parameters are not null (checked above).
    let buffer_type = try_execute!(unsafe { build_buf_request_type_wide(msz_readers, pcch_readers) });

    let out_buf = try_execute!(context.list_readers_wide(buffer_type));

    // SAFETY: The `msz_readers` and `pcch_readers` parameters are not null (checked above).
    try_execute!(unsafe { save_out_buf_wide(out_buf, msz_readers, pcch_readers) });

    ErrorKind::Success.into()
}

unsafe fn guids_to_uuids(guids: LpCGuid, len: u32) -> WinScardResult<Option<Vec<Uuid>>> {
    Ok(if guids.is_null() {
        None
    } else {
        Some(
            // SAFETY: The `guids` parameter is not null (checked above).
            unsafe { from_raw_parts(guids, len.try_into()?) }
                .iter()
                .map(|id| Uuid::from_fields(id.data1, id.data2, id.data3, &id.data4))
                .collect::<Vec<_>>(),
        )
    })
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardListCardsA"))]
#[instrument(ret)]
#[no_mangle]
pub unsafe extern "system" fn SCardListCardsA(
    context: ScardContext,
    pb_atr: LpCByte,
    rgquid_nterfaces: LpCGuid,
    cguid_interface_count: u32,
    msz_cards: *mut u8,
    pcch_cards: LpDword,
) -> ScardStatus {
    use std::slice::from_raw_parts;

    check_handle!(context);
    check_null!(msz_cards);
    check_null!(pcch_cards);

    // SAFETY: The `context` value is not zero (checked above).
    let context = try_execute!(unsafe { raw_scard_context_handle_to_scard_context_handle(context) });
    // SAFETY: The `msz_cards` and `pcch_cards` parameters are not null (checked above).
    let buffer_type = try_execute!(unsafe { build_buf_request_type(msz_cards, pcch_cards) });
    let atr = if pb_atr.is_null() {
        None
    } else {
        // SAFETY: The `pb_atr` parameter is not null (checked above).
        Some(unsafe { from_raw_parts(pb_atr, 32) })
    };
    let required_interfaces = try_execute!(
        // SAFETY: The `rgquid_nterfaces` parameter is checked inside the function.
        // All other guarantees should be provided by the user.
        unsafe { guids_to_uuids(rgquid_nterfaces, cguid_interface_count) }
    );

    let out_buf = try_execute!(context.list_cards(atr, required_interfaces.as_deref(), buffer_type));

    // SAFETY: The `msz_cards` and `pcch_cards` parameters are not null (checked above).
    try_execute!(unsafe { save_out_buf(out_buf, msz_cards, pcch_cards) });

    ErrorKind::UnsupportedFeature.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardListCardsW"))]
#[instrument(ret)]
#[no_mangle]
pub unsafe extern "system" fn SCardListCardsW(
    context: ScardContext,
    pb_atr: LpCByte,
    rgquid_nterfaces: LpCGuid,
    cguid_interface_count: u32,
    msz_cards: *mut u16,
    pcch_cards: LpDword,
) -> ScardStatus {
    use std::slice::from_raw_parts;

    check_handle!(context);
    check_null!(msz_cards);
    check_null!(pcch_cards);

    // SAFETY: The `context` value is not zero (checked above).
    let context = try_execute!(unsafe { raw_scard_context_handle_to_scard_context_handle(context) });
    // SAFETY: The `msz_cards` and `pcch_cards` parameters are not null (checked above).
    let buffer_type = try_execute!(unsafe { build_buf_request_type_wide(msz_cards, pcch_cards) });
    let atr = if pb_atr.is_null() {
        None
    } else {
        // SAFETY: The `pb_atr` parameter is not null (checked above).
        Some(unsafe { from_raw_parts(pb_atr, 32) })
    };
    let required_interfaces = try_execute!(
        // SAFETY: The `rgquid_nterfaces` parameter is checked inside the function.
        // All other guarantees should be provided by the user.
        unsafe { guids_to_uuids(rgquid_nterfaces, cguid_interface_count) }
    );

    let out_buf = try_execute!(context.list_cards_wide(atr, required_interfaces.as_deref(), buffer_type));

    // SAFETY: The `msz_cards` and `pcch_cards` parameters are not null (checked above).
    try_execute!(unsafe { save_out_buf_wide(out_buf, msz_cards, pcch_cards) });

    ErrorKind::Success.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardListInterfacesA"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn SCardListInterfacesA(
    _context: ScardContext,
    _sz_scard: LpCStr,
    _pguid_interfaces: LpGuid,
    _pcguid_interfaces: LpDword,
) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardListInterfacesW"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn SCardListInterfacesW(
    _context: ScardContext,
    _sz_scard: LpCWStr,
    _pguid_interfaces: LpGuid,
    _pcguid_interfaces: LpDword,
) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardGetProviderIdA"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn SCardGetProviderIdA(
    _context: ScardContext,
    _sz_card: LpCStr,
    _pguid_provider_id: LpGuid,
) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardGetProviderIdW"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn SCardGetProviderIdW(
    _context: ScardContext,
    _sz_card: LpCWStr,
    _pguid_provider_id: LpGuid,
) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardGetCardTypeProviderNameA"))]
#[instrument(ret)]
#[no_mangle]
pub unsafe extern "system" fn SCardGetCardTypeProviderNameA(
    context: ScardContext,
    sz_card_name: LpCStr,
    dw_provide_id: u32,
    szProvider: *mut u8,
    pcch_provider: LpDword,
) -> ScardStatus {
    check_handle!(context);
    check_null!(sz_card_name);
    check_null!(szProvider);
    check_null!(pcch_provider);

    let card_name = try_execute!(
        // SAFETY: It's safe to construct a slice because the `sz_card_name` is not null (checked above).
        // All other guarantees should be provided by the user.
        unsafe { CStr::from_ptr(sz_card_name as *const _) }.to_str(),
        ErrorKind::InvalidParameter
    );

    // SAFETY: The `context` value is not zero (checked above).
    let context_handle = try_execute!(unsafe { raw_scard_context_handle_to_scard_context_handle(context) });

    let context = context_handle.scard_context();
    let provider_name =
        try_execute!(context.get_card_type_provider_name(card_name, try_execute!(dw_provide_id.try_into())))
            .to_string();

    // SAFETY: The `szProvider` and `pcch_provider` parameters are not null (checked above).
    let buffer_type = try_execute!(unsafe { build_buf_request_type(szProvider, pcch_provider) });
    let out_buf = try_execute!(context_handle.write_to_out_buf(provider_name.as_bytes(), buffer_type));

    // SAFETY: The `szProvider` and `pcch_provider` parameters are not null (checked above).
    try_execute!(unsafe { save_out_buf(out_buf, szProvider, pcch_provider) });

    ErrorKind::Success.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardGetCardTypeProviderNameW"))]
#[instrument(ret)]
#[no_mangle]
pub unsafe extern "system" fn SCardGetCardTypeProviderNameW(
    context: ScardContext,
    sz_card_name: LpCWStr,
    dw_provide_id: u32,
    szProvider: *mut u16,
    pcch_provider: LpDword,
) -> ScardStatus {
    check_handle!(context);
    check_null!(sz_card_name);
    check_null!(szProvider);
    check_null!(pcch_provider);

    // SAFETY: The `sz_card_name` parameter is not null (checked above).
    let card_name = unsafe { c_w_str_to_string(sz_card_name) };

    // SAFETY: The `context` value is not zero (checked above).
    let context_handle = try_execute!(unsafe { raw_scard_context_handle_to_scard_context_handle(context) });

    let context = context_handle.scard_context();
    let provider_name =
        try_execute!(context.get_card_type_provider_name(&card_name, try_execute!(dw_provide_id.try_into())));
    let wide_provider_name = str_encode_utf16(provider_name.as_ref());

    // SAFETY: The `szProvider` and `pcch_provider` parameters are not null (checked above).
    let buffer_type = try_execute!(unsafe { build_buf_request_type_wide(szProvider, pcch_provider) });
    let out_buf = try_execute!(context_handle.write_to_out_buf(&wide_provider_name, buffer_type));

    // SAFETY: The `szProvider` and `pcch_provider` parameters are not null (checked above).
    try_execute!(unsafe { save_out_buf_wide(out_buf, szProvider, pcch_provider) });

    ErrorKind::Success.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardIntroduceReaderGroupA"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn SCardIntroduceReaderGroupA(_context: ScardContext, _sz_group_name: LpCStr) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardIntroduceReaderGroupW"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn SCardIntroduceReaderGroupW(_context: ScardContext, _sz_group_name: LpCWStr) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardForgetReaderGroupA"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn SCardForgetReaderGroupA(_context: ScardContext, _sz_group_name: LpCStr) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardForgetReaderGroupW"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn SCardForgetReaderGroupW(_context: ScardContext, _sz_group_name: LpCWStr) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardIntroduceReaderA"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn SCardIntroduceReaderA(
    _context: ScardContext,
    _sz_reader_name: LpCStr,
    _sz_device_name: LpCStr,
) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardIntroduceReaderW"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn SCardIntroduceReaderW(
    _context: ScardContext,
    _sz_reader_name: LpCWStr,
    _sz_device_name: LpCWStr,
) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardForgetReaderA"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn SCardForgetReaderA(_context: ScardContext, _sz_reader_name: LpCStr) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardForgetReaderW"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn SCardForgetReaderW(_context: ScardContext, _sz_reader_name: LpCWStr) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardAddReaderToGroupA"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn SCardAddReaderToGroupA(
    _context: ScardContext,
    _sz_reader_name: LpCStr,
    _sz_group_name: LpCStr,
) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardAddReaderToGroupW"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn SCardAddReaderToGroupW(
    _context: ScardContext,
    _sz_reader_name: LpCWStr,
    _sz_group_name: LpCWStr,
) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardRemoveReaderFromGroupA"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn SCardRemoveReaderFromGroupA(
    _context: ScardContext,
    _sz_reader_name: LpCStr,
    _sz_group_name: LpCStr,
) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardRemoveReaderFromGroupW"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn SCardRemoveReaderFromGroupW(
    _context: ScardContext,
    _sz_reader_name: LpCWStr,
    _sz_group_name: LpCWStr,
) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardIntroduceCardTypeA"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn SCardIntroduceCardTypeA(
    _context: ScardContext,
    _sz_card_name: LpCStr,
    _pguid_primary_provider: LpCGuid,
    _rgguid_interfaces: LpCGuid,
    _dw_interface_count: u32,
    _pb_atr: LpCByte,
    _pb_atr_mask: LpCByte,
    _cb_atr_len: u32,
) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardIntroduceCardTypeW"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn SCardIntroduceCardTypeW(
    _context: ScardContext,
    _sz_card_name: LpCWStr,
    _pguid_primary_provider: LpCGuid,
    _rgguid_interfaces: LpCGuid,
    _dw_interface_count: u32,
    _pb_atr: LpCByte,
    _pb_atr_mask: LpCByte,
    _cb_atr_len: u32,
) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardSetCardTypeProviderNameA"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn SCardSetCardTypeProviderNameA(
    _context: ScardContext,
    _sz_card_name: LpCStr,
    _dw_provider_id: u32,
    _sz_provider: LpCStr,
) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardSetCardTypeProviderNameW"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn SCardSetCardTypeProviderNameW(
    _context: ScardContext,
    _sz_card_name: LpCWStr,
    _dw_provider_id: u32,
    _sz_provider: LpCWStr,
) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardForgetCardTypeA"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn SCardForgetCardTypeA(_context: ScardContext, _sz_card_name: LpCStr) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardForgetCardTypeW"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn SCardForgetCardTypeW(_context: ScardContext, _sz_card_name: LpCWStr) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardFreeMemory"))]
#[instrument(ret)]
#[no_mangle]
pub unsafe extern "system" fn SCardFreeMemory(context: ScardContext, pv_mem: LpCVoid) -> ScardStatus {
    check_handle!(context);

    // SAFETY: The `context` value is not zero (checked above).
    if let Ok(context) = unsafe { raw_scard_context_handle_to_scard_context_handle(context) } {
        if context.free_buffer(pv_mem) {
            info!("Allocated buffer successfully freed");
        } else {
            warn!(?pv_mem, "Attempt to free unknown buffer");
        }

        ErrorKind::Success.into()
    } else {
        ErrorKind::InvalidHandle.into()
    }
}

// This handle exists up to the end of the program and never freed.
// We use created event to return its handle from the `SCardAccessStartedEvent` function.
// Note. If the `SCardAccessStartedEvent` frunction is not be called, the event will not be created.
#[cfg(target_os = "windows")]
static START_EVENT_HANDLE: LazyLock<Handle> = LazyLock::new(|| {
    use std::ptr::null;

    use windows_sys::Win32::Foundation::GetLastError;
    use windows_sys::Win32::System::Threading::CreateEventA;

    // SAFETY: All parameters are correct.
    let handle = unsafe { CreateEventA(null(), 1, 1, null()) };
    if handle.is_null() {
        error!(
            "Unable to create event: returned event handle is null. Last error: {}",
            // SAFETY: it's safe to call this function.
            unsafe { GetLastError() }
        );
    }
    handle as _
});

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardAccessStartedEvent"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn SCardAccessStartedEvent() -> Handle {
    #[cfg(target_os = "windows")]
    {
        // https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardaccessstartedevent
        // The `SCardAccessStartedEvent` function returns an event handle when an event signals that
        // the smart card resource manager is started. The event-object handle can be specified in a call
        // to one of the wait functions.

        if std::env::var(SMART_CARD_TYPE)
            .and_then(|use_system_card| Ok(use_system_card == "true"))
            .unwrap_or_default()
        {
            // Use system-provided smart card.
            //
            // SAFETY: The `WINSCARD_API` is lazily initialized, so it's safe to call this function.
            unsafe { (WINSCARD_API.SCardAccessStartedEvent)() }
        } else {
            // Use emulated smart card.
            //
            // We create the event once for the entire process and keep it like a singleton in the "signaled" state.
            // We assume we're always ready for our virtual smart cards. Moreover, we don't use reference counters
            // because we are always in a ready (signaled) state and have only one handle for the entire process.
            *START_EVENT_HANDLE
        }
    }
    #[cfg(not(target_os = "windows"))]
    {
        // We support the `SCardAccessStartedEvent` function only on Windows OS. Reason:
        // On non-Windows OS we use pcsc-lite API that doesn't have the `SCardAccessStartedEvent` function.
        // Thus, we don't need it there.
        //
        // The function returns an event HANDLE if it succeeds or NULL if it fails.
        0
    }
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardReleaseStartedEvent"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn SCardReleaseStartedEvent() {
    #[cfg(target_os = "windows")]
    {
        if std::env::var(SMART_CARD_TYPE)
            .and_then(|use_system_card| Ok(use_system_card == "true"))
            .unwrap_or_default()
        {
            // Use system-provided smart card.
            //
            // SAFETY: The `WINSDCARD_API` is lazily initialized, so it's safe to call this function.
            unsafe { (WINSCARD_API.SCardReleaseStartedEvent)() }
        } else {
            use windows_sys::Win32::Foundation::{CloseHandle, GetLastError};

            // Use emulated smart card.
            //
            // We create the event once for the entire process and keep it like a singleton in the "signaled" state.
            // We assume we're always ready for our virtual smart cards. Moreover, we don't use reference counters
            // because we are always in a ready (signaled) state and have only one handle for the entire process.
            //
            // SAFETY: It's safe to close the handle.
            if unsafe { CloseHandle(*START_EVENT_HANDLE as *mut c_void) } == 0 {
                error!(
                    "Cannot close the event handle. List error: {}",
                    // SAFETY: it's safe to call this function.
                    unsafe { GetLastError() }
                );
            }
        }
    }
    #[cfg(not(target_os = "windows"))]
    {
        // We support the `SCardReleaseStartedEvent` function only on Windows OS. Reason:
        // On non-Windows OS we use pcsc-lite API that doesn't have the `SCardReleaseStartedEvent` function.
        // Thus, we don't need it there.
    }
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardLocateCardsA"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn SCardLocateCardsA(
    _context: ScardContext,
    _msz_cards: LpCStr,
    _rg_reader_states: LpScardReaderStateA,
    _c_readers: u32,
) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardLocateCardsW"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn SCardLocateCardsW(
    _context: ScardContext,
    _msz_cards: LpCWStr,
    _rg_reader_states: LpScardReaderStateW,
    _c_readers: u32,
) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardLocateCardsByATRA"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn SCardLocateCardsByATRA(
    _context: ScardContext,
    _rg_atr_masks: LpScardAtrMask,
    _c_atrs: u32,
    _rg_reader_states: LpScardReaderStateA,
    _c_readers: u32,
) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardLocateCardsByATRW"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn SCardLocateCardsByATRW(
    _context: ScardContext,
    _rg_atr_masks: LpScardAtrMask,
    _c_atrs: u32,
    _rg_reader_states: LpScardReaderStateW,
    _c_readers: u32,
) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardGetStatusChangeA"))]
#[instrument(ret)]
#[no_mangle]
pub unsafe extern "system" fn SCardGetStatusChangeA(
    context: ScardContext,
    dw_timeout: u32,
    rg_reader_states: LpScardReaderStateA,
    c_readers: u32,
) -> ScardStatus {
    check_handle!(context);
    check_null!(rg_reader_states);

    // SAFETY: The `context` value is not zero (checked above).
    let context = try_execute!(unsafe { scard_context_to_winscard_context(context) });

    // SAFETY: The `rg_reader_states` parameter is not null (checked above).
    let c_reader_states = unsafe {
        from_raw_parts_mut(
            rg_reader_states,
            try_execute!(c_readers.try_into(), ErrorKind::InsufficientBuffer),
        )
    };
    let mut reader_states = try_execute!(c_reader_states
        .iter()
        .map(|c_reader| {
            check_null!(c_reader.sz_reader, "reader name in reader state");

            Ok(ReaderState {
                // SAFETY: The reader name should not be null (checked above). All other guarantees
                // should be provided by the user.
                reader_name: unsafe { CStr::from_ptr(c_reader.sz_reader as *const _) }.to_string_lossy(),
                user_data: c_reader.pv_user_data as usize,
                current_state: CurrentState::from_bits(c_reader.dw_current_state).unwrap_or_default(),
                event_state: CurrentState::from_bits(c_reader.dw_event_state).unwrap_or_default(),
                atr_len: c_reader.cb_atr.try_into()?,
                atr: c_reader.rgb_atr,
            })
        })
        .collect::<Result<Vec<_>, winscard::Error>>());
    try_execute!(context.get_status_change(dw_timeout, &mut reader_states));

    for (reader_state, c_reader_state) in reader_states.iter().zip(c_reader_states.iter_mut()) {
        c_reader_state.dw_event_state = reader_state.event_state.bits();
        c_reader_state.cb_atr = try_execute!(reader_state.atr_len.try_into(), ErrorKind::InternalError);
        c_reader_state.rgb_atr.copy_from_slice(&reader_state.atr);
    }

    ErrorKind::Success.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardGetStatusChangeW"))]
#[instrument(ret)]
#[no_mangle]
pub unsafe extern "system" fn SCardGetStatusChangeW(
    context: ScardContext,
    dw_timeout: u32,
    rg_reader_states: LpScardReaderStateW,
    c_readers: u32,
) -> ScardStatus {
    check_handle!(context);
    check_null!(rg_reader_states);

    // SAFETY: The `context` value is not zero (checked above).
    let context = try_execute!(unsafe { scard_context_to_winscard_context(context) });

    // SAFETY: The `rg_reader_states` parameter is not null (checked above).
    let c_reader_states = unsafe {
        from_raw_parts_mut(
            rg_reader_states,
            try_execute!(c_readers.try_into(), ErrorKind::InsufficientBuffer),
        )
    };
    let mut reader_states = try_execute!(c_reader_states
        .iter()
        .map(|c_reader| {
            check_null!(c_reader.sz_reader, "reader name in reader state");

            Ok(ReaderState {
                // SAFETY: The reader name should not be null (checked above). All other guarantees
                // should be provided by the user.
                reader_name: Cow::Owned(unsafe { c_w_str_to_string(c_reader.sz_reader) }),
                user_data: c_reader.pv_user_data as usize,
                current_state: CurrentState::from_bits(c_reader.dw_current_state).unwrap_or_default(),
                event_state: CurrentState::from_bits(c_reader.dw_event_state).unwrap_or_default(),
                atr_len: c_reader.cb_atr.try_into()?,
                atr: c_reader.rgb_atr,
            })
        })
        .collect::<Result<Vec<_>, winscard::Error>>());
    try_execute!(context.get_status_change(dw_timeout, &mut reader_states));

    for (reader_state, c_reader_state) in reader_states.iter().zip(c_reader_states.iter_mut()) {
        c_reader_state.dw_event_state = reader_state.event_state.bits();
        c_reader_state.cb_atr = try_execute!(reader_state.atr_len.try_into(), ErrorKind::InternalError);
        c_reader_state.rgb_atr.copy_from_slice(&reader_state.atr);
    }

    ErrorKind::Success.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardCancel"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn SCardCancel(context: ScardContext) -> ScardStatus {
    check_handle!(context);

    // SAFETY: The `context` value is not zero (checked above). All other guarantees should be provided by the user.
    let context = try_execute!(unsafe { scard_context_to_winscard_context(context) });
    try_execute!(context.cancel());

    ErrorKind::Success.into()
}

unsafe fn read_cache(
    context: ScardContext,
    card_identifier: LpUuid,
    freshness_counter: u32,
    lookup_name: &str,
    data: LpByte,
    data_len: LpDword,
) -> WinScardResult<()> {
    check_handle!(context, "scard context handle");
    check_null!(card_identifier, "scard card identifier");
    check_null!(data_len, "data buffer length");

    // SAFETY: The `context` value is not zero (checked above).
    let context = unsafe { raw_scard_context_handle_to_scard_context_handle(context) }?;

    // SAFETY: The `card_identifier` parameter is not null (checked above).
    let card_id = unsafe {
        Uuid::from_fields(
            (*card_identifier).data1,
            (*card_identifier).data2,
            (*card_identifier).data3,
            &(*card_identifier).data4,
        )
    };
    // SAFETY: It's safe to call this function because the `data` parameter is allowed to be null
    // and the `data_len` parameter cannot be null (checked above).
    let buffer_type = unsafe { build_buf_request_type(data, data_len) }?;

    let out_buf = context.read_cache(card_id, freshness_counter, lookup_name, buffer_type)?;

    // SAFETY: It's safe to call this function because all parameters are checked above.
    unsafe { save_out_buf(out_buf, data, data_len) }
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardReadCacheA"))]
#[instrument(ret)]
#[no_mangle]
pub unsafe extern "system" fn SCardReadCacheA(
    context: ScardContext,
    card_identifier: LpUuid,
    freshness_counter: u32,
    lookup_name: LpStr,
    data: LpByte,
    data_len: LpDword,
) -> ScardStatus {
    check_null!(lookup_name);

    let lookup_name = try_execute!(
        // SAFETY: The `lookup_name` parameter is not null (checked above).
        unsafe { CStr::from_ptr(lookup_name as *const _) }.to_str(),
        ErrorKind::InvalidParameter
    );
    // SAFETY: The `lookup_name` parameter is type checked. All other parameters are checked inside the function.
    try_execute!(unsafe { read_cache(context, card_identifier, freshness_counter, lookup_name, data, data_len,) });

    ErrorKind::Success.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardReadCacheW"))]
#[instrument(ret)]
#[no_mangle]
pub unsafe extern "system" fn SCardReadCacheW(
    context: ScardContext,
    card_identifier: LpUuid,
    freshness_counter: u32,
    lookup_name: LpWStr,
    data: LpByte,
    data_len: LpDword,
) -> ScardStatus {
    check_null!(lookup_name);

    // SAFETY: The `lookup_name` parameter is not null (checked above).
    let lookup_name = unsafe { c_w_str_to_string(lookup_name) };
    try_execute!(
        // SAFETY: The `lookup_name` parameter is type checked. All other parameters are checked inside the function.
        unsafe {
            read_cache(
                context,
                card_identifier,
                freshness_counter,
                &lookup_name,
                data,
                data_len,
            )
        }
    );

    ErrorKind::Success.into()
}

unsafe fn write_cache(
    context: ScardContext,
    card_identifier: LpUuid,
    freshness_counter: u32,
    lookup_name: &str,
    data: LpCByte,
    data_len: u32,
) -> WinScardResult<()> {
    check_handle!(context, "scard context handle");
    check_null!(card_identifier, "card identified");
    check_null!(data, "cache data buffer");

    // SAFETY: The `card_identifier` parameter is not null (checked above).
    let card_id = unsafe {
        Uuid::from_fields(
            (*card_identifier).data1,
            (*card_identifier).data2,
            (*card_identifier).data3,
            &(*card_identifier).data4,
        )
    };

    // SAFETY: The `context` value is not zero (checked above).
    let context = unsafe { scard_context_to_winscard_context(context) }?;
    // SAFETY: The `data` parameter is not null (checked above).
    let data = unsafe { from_raw_parts(data, data_len.try_into()?) }.to_vec();

    context.write_cache(card_id, freshness_counter, lookup_name.to_owned(), data)
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardWriteCacheA"))]
#[instrument(ret)]
#[no_mangle]
pub unsafe extern "system" fn SCardWriteCacheA(
    context: ScardContext,
    card_identifier: LpUuid,
    freshness_counter: u32,
    lookup_name: LpStr,
    data: LpCByte,
    data_len: u32,
) -> ScardStatus {
    check_null!(lookup_name);

    let lookup_name = try_execute!(
        // SAFETY: The `lookup_name` parameter is not null (checked above).
        unsafe { CStr::from_ptr(lookup_name as *const _) }.to_str(),
        ErrorKind::InvalidParameter
    );
    // SAFETY: The `lookup_name` parameter is type checked. All other parameters are checked inside the function
    try_execute!(unsafe { write_cache(context, card_identifier, freshness_counter, lookup_name, data, data_len,) });

    ErrorKind::Success.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardWriteCacheW"))]
#[instrument(ret)]
#[no_mangle]
pub unsafe extern "system" fn SCardWriteCacheW(
    context: ScardContext,
    card_identifier: LpUuid,
    freshness_counter: u32,
    lookup_name: LpWStr,
    data: LpCByte,
    data_len: u32,
) -> ScardStatus {
    check_null!(lookup_name);

    // SAFETY: The `lookup_name` parameter is not null (checked above).
    let lookup_name = unsafe { c_w_str_to_string(lookup_name) };
    // SAFETY: The `lookup_name` parameter is type checked. All other parameters are checked inside the function
    try_execute!(unsafe {
        write_cache(
            context,
            card_identifier,
            freshness_counter,
            &lookup_name,
            data,
            data_len,
        )
    });

    ErrorKind::Success.into()
}

unsafe fn get_reader_icon(
    context: ScardContext,
    reader_name: &str,
    pb_icon: LpByte,
    pcb_icon: LpDword,
) -> WinScardResult<()> {
    check_handle!(context, "scard context handle");
    // `pb_icon` can be null.
    check_null!(pcb_icon, "pcb_icon");

    // SAFETY: The `context` value is not zero (checked above). All other guarantees should be provided by the user.
    let context = unsafe { raw_scard_context_handle_to_scard_context_handle(context) }?;

    // SAFETY: It's safe to call this function because the `pb_icon` parameter is allowed to be null
    // and the `pcb_icon` parameter cannot be null (checked above).
    let buffer_type = unsafe { build_buf_request_type(pb_icon, pcb_icon) }?;

    let out_buf = context.get_reader_icon(reader_name, buffer_type)?;

    // SAFETY: It's safe to call this function because all parameters are checked above.
    unsafe { save_out_buf(out_buf, pb_icon, pcb_icon) }?;

    Ok(())
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardGetReaderIconA"))]
#[instrument(ret)]
#[no_mangle]
pub unsafe extern "system" fn SCardGetReaderIconA(
    context: ScardContext,
    sz_reader_name: LpCStr,
    pb_icon: LpByte,
    pcb_icon: LpDword,
) -> ScardStatus {
    check_null!(sz_reader_name);

    let reader_name = try_execute!(
        // SAFETY: The `sz_reader_name` parameter is not null (checked above).
        unsafe { CStr::from_ptr(sz_reader_name as *const _) }.to_str(),
        ErrorKind::InvalidParameter
    );

    try_execute!(
        // SAFETY: The `reader_name` parameter is type checked. All other parameters are checked inside the function
        unsafe { get_reader_icon(context, reader_name, pb_icon, pcb_icon) }
    );

    ErrorKind::Success.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardGetReaderIconW"))]
#[instrument(ret)]
#[no_mangle]
pub unsafe extern "system" fn SCardGetReaderIconW(
    context: ScardContext,
    sz_reader_name: LpCWStr,
    pb_icon: LpByte,
    pcb_icon: LpDword,
) -> ScardStatus {
    check_null!(sz_reader_name);

    // SAFETY: The `sz_reader_name` parameter is not null (checked above).
    let reader_name = unsafe { c_w_str_to_string(sz_reader_name) };

    try_execute!(
        // SAFETY: The `reader_name` parameter is type checked. All other parameters are checked inside the function.
        unsafe { get_reader_icon(context, &reader_name, pb_icon, pcb_icon) }
    );

    ErrorKind::Success.into()
}

unsafe fn get_device_type_id(
    context: ScardContext,
    reader_name: &str,
    pdw_device_type_id: LpDword,
) -> WinScardResult<()> {
    check_handle!(context, "scard context handle");
    check_null!(pdw_device_type_id, "pdw_device_type_id");

    // SAFETY: The `context` value is not zero (checked above).
    let context = unsafe { scard_context_to_winscard_context(context) }?;

    // SAFETY: The `pdw_device_type_id` parameter is not null (checked above).
    unsafe {
        *pdw_device_type_id = context.device_type_id(reader_name)?.into();
    }

    Ok(())
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardGetDeviceTypeIdA"))]
#[instrument(ret)]
#[no_mangle]
pub unsafe extern "system" fn SCardGetDeviceTypeIdA(
    context: ScardContext,
    sz_reader_name: LpCStr,
    pdw_device_type_id: LpDword,
) -> ScardStatus {
    check_null!(sz_reader_name);

    let reader_name = try_execute!(
        // SAFETY: The `sz_reader_name` parameter is not null (checked above).
        unsafe { CStr::from_ptr(sz_reader_name as *const _) }.to_str(),
        ErrorKind::InvalidParameter
    );

    try_execute!(
        // SAFETY: `context` and `pdw_device_type_id` parameters are checked inside the function.
        // `reader_name` is type checked.
        unsafe { get_device_type_id(context, reader_name, pdw_device_type_id) }
    );

    ErrorKind::Success.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardGetDeviceTypeIdW"))]
#[instrument(ret)]
#[no_mangle]
pub unsafe extern "system" fn SCardGetDeviceTypeIdW(
    context: ScardContext,
    sz_reader_name: LpCWStr,
    pdw_device_type_id: LpDword,
) -> ScardStatus {
    check_null!(sz_reader_name);

    // SAFETY: The `sz_reader_name` parameter is not null (checked above).
    let reader_name = unsafe { c_w_str_to_string(sz_reader_name) };

    try_execute!(
        // SAFETY: `context` and `pdw_device_type_id` parameters are checked inside the function.
        // `reader_name` is type checked.
        unsafe { get_device_type_id(context, &reader_name, pdw_device_type_id) }
    );

    ErrorKind::Success.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardGetReaderDeviceInstanceIdA"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn SCardGetReaderDeviceInstanceIdA(
    _context: ScardContext,
    _sz_reader_name: LpCStr,
    _sz_device_instance_id: LpStr,
    _pcch_device_instance_id: LpDword,
) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardGetReaderDeviceInstanceIdW"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn SCardGetReaderDeviceInstanceIdW(
    _context: ScardContext,
    _sz_reader_name: LpCWStr,
    _sz_device_instance_id: LpWStr,
    _pcch_device_instance_id: LpDword,
) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardListReadersWithDeviceInstanceIdA"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn SCardListReadersWithDeviceInstanceIdA(
    _context: ScardContext,
    _sz_device_instance_id: LpCStr,
    _msz_readers: LpStr,
    _pcch_readers: LpDword,
) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardListReadersWithDeviceInstanceIdW"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn SCardListReadersWithDeviceInstanceIdW(
    _context: ScardContext,
    _sz_device_instance_id: LpCWStr,
    _msz_readers: LpWStr,
    _pcch_readers: LpDword,
) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}

#[cfg_attr(windows, rename_symbol(to = "Rust_SCardAudit"))]
#[instrument(ret)]
#[no_mangle]
pub extern "system" fn SCardAudit(_context: ScardContext, _dw_event: u32) -> ScardStatus {
    ErrorKind::UnsupportedFeature.into()
}


--- File: ffi/src/winscard/scard_handle.rs ---
use std::fmt;
use std::iter::once;
use std::mem::size_of;
use std::slice::from_raw_parts_mut;

use ffi_types::winscard::{LpScardIoRequest, ScardContext, ScardHandle, ScardIoRequest};
use ffi_types::LpCVoid;
use uuid::Uuid;
use winscard::winscard::{AttributeId, IoRequest, Protocol, State, WinScard, WinScardContext};
use winscard::{Error, ErrorKind, WinScardResult};

/// Scard context handle representation.
///
/// Additionally, it holds allocated buffers and created smart card handles.
/// We need them because during the smart card context deletion, we need to free all allcated resources.
pub struct WinScardContextHandle {
    /// Context of the emulated smart card.
    scard_context: Box<dyn WinScardContext>,
    /// Created smart card handles during the API usage.
    scards: Vec<ScardHandle>,
    /// Allocated buffers in our smart card context.
    /// All buffers are `[u8]`, so we need only pointer and don't need to remember its type.
    allocations: Vec<usize>,
}

impl fmt::Debug for WinScardContextHandle {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("WinScardContextHandle")
            .field("scards", &self.scards)
            .field("allocations", &self.allocations)
            .field("scard_context", &"<scard context obj>")
            .finish()
    }
}

impl WinScardContextHandle {
    /// Creates a new [WinScardContextHandle] based on the provided inner scard context.
    pub fn with_scard_context(scard_context: Box<dyn WinScardContext>) -> Self {
        Self {
            scard_context,
            scards: Vec::new(),
            allocations: Vec::new(),
        }
    }

    /// Returns the shared reference to the inner [WinScardContext].
    pub fn scard_context(&self) -> &dyn WinScardContext {
        self.scard_context.as_ref()
    }

    /// Adds a new [ScardHandle] to the context handles.
    pub fn add_scard(&mut self, scard: ScardHandle) -> WinScardResult<()> {
        if scard == 0 {
            return Err(Error::new(ErrorKind::InvalidHandle, "ScardHandle can not be NULL"));
        }

        self.scards.push(scard);

        Ok(())
    }

    /// Removes the [ScardHandle] from the scard context.
    #[instrument(level = "debug", ret)]
    pub fn remove_scard(&mut self, scard: ScardHandle) -> bool {
        if let Some(index) = self.scards.iter().position(|x| *x == scard) {
            self.scards.remove(index);

            true
        } else {
            false
        }
    }

    /// Allocated a new buffer inside the scard context.
    #[instrument(level = "debug", ret)]
    pub fn allocate_buffer(&mut self, size: usize) -> WinScardResult<*mut u8> {
        // SAFETY: Memory allocation is safe. Moreover, we check for the null value below.
        let buff = unsafe { libc::malloc(size) as *mut u8 };
        if buff.is_null() {
            return Err(Error::new(
                ErrorKind::NoMemory,
                format!("cannot allocate {} bytes", size),
            ));
        }
        self.allocations.push(buff as usize);

        Ok(buff)
    }

    /// Deletes the buffer inside the scard context.
    #[instrument(level = "debug", ret)]
    pub fn free_buffer(&mut self, buff: LpCVoid) -> bool {
        let buff = buff as usize;

        if let Some(index) = self.allocations.iter().position(|x| *x == buff) {
            self.allocations.remove(index);

            // SAFETY: The `allocations` collection contains only allocated memory pointers, so it's
            // safe to deallocate them using the `libc::free` function.
            unsafe {
                libc::free(buff as _);
            }

            true
        } else {
            false
        }
    }

    /// Returns the icon of the specified reader.
    pub fn get_reader_icon(&mut self, reader: &str, buffer_type: RequestedBufferType) -> WinScardResult<OutBuffer> {
        let reader_icon = self.scard_context.reader_icon(reader)?.as_ref().to_vec();

        self.write_to_out_buf(&reader_icon, buffer_type)
    }

    /// Lists readers.
    #[instrument(level = "debug", ret)]
    pub fn list_readers(&mut self, buffer_type: RequestedBufferType) -> WinScardResult<OutBuffer> {
        let readers: Vec<_> = self
            .scard_context()
            .list_readers()?
            .into_iter()
            .map(|i| i.to_string())
            .collect();

        self.write_multi_string(&readers, buffer_type)
    }

    /// Lists readers but the resulting buffers contain wide strings.
    #[instrument(level = "debug", ret)]
    pub fn list_readers_wide(&mut self, buffer_type: RequestedBufferType) -> WinScardResult<OutBuffer> {
        let readers: Vec<_> = self
            .scard_context()
            .list_readers()?
            .into_iter()
            .map(|i| i.to_string())
            .collect();

        self.write_multi_string_wide(&readers, buffer_type)
    }

    /// Lists cards.
    #[instrument(level = "debug", ret)]
    pub fn list_cards(
        &mut self,
        atr: Option<&[u8]>,
        required_interfaces: Option<&[Uuid]>,
        buffer_type: RequestedBufferType,
    ) -> WinScardResult<OutBuffer> {
        let cards: Vec<_> = self
            .scard_context()
            .list_cards(atr, required_interfaces)?
            .into_iter()
            .map(|i| i.to_string())
            .collect();

        self.write_multi_string(&cards, buffer_type)
    }

    /// Lists readers but the resulting buffers contain wide strings.
    #[instrument(level = "debug", ret)]
    pub fn list_cards_wide(
        &mut self,
        atr: Option<&[u8]>,
        required_interfaces: Option<&[Uuid]>,
        buffer_type: RequestedBufferType,
    ) -> WinScardResult<OutBuffer> {
        let cards: Vec<_> = self
            .scard_context()
            .list_cards(atr, required_interfaces)?
            .into_iter()
            .map(|i| i.to_string())
            .collect();

        self.write_multi_string_wide(&cards, buffer_type)
    }

    /// Reads smart card cache.
    #[instrument(level = "debug", ret)]
    pub fn read_cache(
        &mut self,
        card_id: Uuid,
        freshness_counter: u32,
        key: &str,
        buffer_type: RequestedBufferType,
    ) -> WinScardResult<OutBuffer> {
        let cached_value = self
            .scard_context()
            .read_cache(card_id, freshness_counter, key)?
            .to_vec();

        self.write_to_out_buf(cached_value.as_ref(), buffer_type)
    }

    /// Converts provided strings to the C-multi-string and saves it.
    #[instrument(level = "debug", ret)]
    pub fn write_multi_string(
        &mut self,
        values: &[String],
        buffer_type: RequestedBufferType,
    ) -> WinScardResult<OutBuffer<'static>> {
        let data: Vec<_> = values
            .iter()
            .flat_map(|reader| reader.as_bytes().iter().cloned().chain(once(0)))
            .chain(once(0))
            .collect();

        self.write_to_out_buf(&data, buffer_type)
    }

    /// Converts provided strings to the C-multi-string and saves it but the resulting buffers contain
    /// wide strings.
    #[instrument(level = "debug", ret)]
    pub fn write_multi_string_wide(
        &mut self,
        values: &[String],
        buffer_type: RequestedBufferType,
    ) -> WinScardResult<OutBuffer<'static>> {
        let data: Vec<_> = values
            .iter()
            .flat_map(|reader| reader.encode_utf16().chain(once(0)).flat_map(|i| i.to_le_bytes()))
            .chain([0, 0])
            .collect();

        self.write_to_out_buf(&data, buffer_type)
    }

    /// Saves the provided data in the [OutBuffer] based on the [RequestedBufferType].
    pub fn write_to_out_buf(
        &mut self,
        data: &[u8],
        buffer_type: RequestedBufferType,
    ) -> WinScardResult<OutBuffer<'static>> {
        Ok(match buffer_type {
            RequestedBufferType::Buf(buf) => {
                if buf.len() < data.len() {
                    return Err(
                        Error::new(
                            ErrorKind::InsufficientBuffer, format!(
                                "provided buffer is too small to fill the requested attribute into: buffer len: {}, attribute data len: {}.",
                                buf.len(),
                                data.len()
                            )
                        )
                    );
                }

                buf[0..data.len()].copy_from_slice(data);

                OutBuffer::Written(data.len())
            }
            RequestedBufferType::Length => OutBuffer::DataLen(data.len()),
            RequestedBufferType::Allocate => {
                let allocated = self.allocate_buffer(data.len())?;
                // SAFETY: The `allocated` pointer has been returned from the [WinScarfdContextHandle]
                // internal method, so it's safe to create a slice.
                let buf = unsafe { from_raw_parts_mut(allocated, data.len()) };

                buf.copy_from_slice(data);

                OutBuffer::Allocated(buf)
            }
        })
    }
}

impl Drop for WinScardContextHandle {
    fn drop(&mut self) {
        // [SCardReleaseContext](https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardreleasecontext)
        // ...freeing any resources allocated under that context, including SCARDHANDLE objects
        for scard in &self.scards {
            // SAFETY: The `WinScardContextHandle` contains only valid scard handles, and it should
            // be safe to cast them to `WinScardHandle` pointer.
            let _ = unsafe { Box::from_raw(*scard as *mut WinScardHandle) };
        }
        // ...and memory allocated using the SCARD_AUTOALLOCATE length designator.
        for buff in &self.allocations {
            // SAFETY: It's safe to call the `free` function because the `WinScardContextHandle`
            // contains only allocated memory pointers.
            unsafe {
                libc::free(*buff as _);
            }
        }
    }
}

/// Represents how and what data the user want to extract.
#[derive(Debug)]
pub enum RequestedBufferType<'data> {
    /// This means the user wants the data filled in the provided buffer.
    Buf(&'data mut [u8]),
    /// The user want to query only the data length.
    Length,
    /// The user wants the data to be allocated by the library and returned from the function.
    Allocate,
}

/// Represent the requested data buffer from the smart card.
///
/// The user can request some data from the smart card. For example, `SCardReadCache` or `SCardGetAttrib` functions.
/// However, buffer handling can be tricky in such situations. The user may want to allocate the memory
/// or ask us to do it. This enum aimed to solve this complexity.
#[derive(Debug)]
pub enum OutBuffer<'data> {
    /// The data has been written into provided buffer by [RequestedBufferType::Buf].
    Written(usize),
    /// The user wants to know the requested data length to allocate the corresponding buffer in the future.
    DataLen(usize),
    /// Allocated buffer.
    ///
    /// The inner buffer is leaked and the user should free it using the `SCardFreeMemory` function.
    Allocated(&'data mut [u8]),
}

/// Represents the smart card status.
///
/// This structure is aimed to represent smart card status data on the FFI layer.
#[derive(Debug)]
pub struct FfiScardStatus<'data> {
    /// List of display names (multi-string) by which the currently connected reader is known.
    pub readers: OutBuffer<'data>,
    /// Buffer that receives the ATR string from the currently inserted card, if available.
    ///
    /// [ATR string](https://learn.microsoft.com/en-us/windows/win32/secgloss/a-gly).
    pub atr: OutBuffer<'data>,
    /// Current state of the smart card in the reader.
    pub state: State,
    /// Current protocol, if any. The returned value is meaningful only if the returned value of pdwState is SCARD_SPECIFICMODE.
    pub protocol: Protocol,
}

/// Scard handle representation.
///
/// It also holds a pointer to the smart card context to which it belongs.
pub struct WinScardHandle {
    /// The emulated smart card.
    scard: Box<dyn WinScard>,
    /// Pointer to the smart card context to which it belongs.
    context: ScardContext,
}

impl fmt::Debug for WinScardHandle {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("WinScardContextHandle")
            .field("context", &self.context)
            .field("scard", &"<scard obj>")
            .finish()
    }
}

impl WinScardHandle {
    /// Creates a new [WinSCardHandle] based on the provided data.
    pub fn new(scard: Box<dyn WinScard>, context: ScardContext) -> Self {
        Self { scard, context }
    }

    /// Returns the [WinScard] handle.
    pub fn scard(&self) -> &dyn WinScard {
        self.scard.as_ref()
    }

    /// Returns the mutable [WinScard] handle.
    pub fn scard_mut(&mut self) -> &mut dyn WinScard {
        self.scard.as_mut()
    }

    /// Returns mutable reference to the parent [WinScardContextHandle].
    pub fn context<'context>(&self) -> WinScardResult<&'context mut WinScardContextHandle> {
        // SAFETY: The WinScardHandle should not contain an invalid context handle.
        unsafe { raw_scard_context_handle_to_scard_context_handle(self.context) }
    }

    /// Returns the requested smart card attribute.
    #[instrument(level = "debug", ret)]
    pub fn get_attribute(
        &self,
        attribute_id: AttributeId,
        buffer_type: RequestedBufferType,
    ) -> WinScardResult<OutBuffer> {
        let data = self.scard().get_attribute(attribute_id)?;

        self.context()?.write_to_out_buf(data.as_ref(), buffer_type)
    }

    /// Returns smart card status.
    #[instrument(level = "debug", ret)]
    pub fn status(
        &mut self,
        readers_buf_type: RequestedBufferType,
        atr_but_type: RequestedBufferType,
    ) -> WinScardResult<FfiScardStatus> {
        let status = self.scard().status()?;
        let readers: Vec<_> = status.readers.into_iter().map(|r| r.to_string()).collect();
        let context = self.context()?;

        let readers = context.write_multi_string(&readers, readers_buf_type)?;
        let atr = context.write_to_out_buf(status.atr.as_ref(), atr_but_type)?;

        Ok(FfiScardStatus {
            readers,
            atr,
            state: status.state,
            protocol: status.protocol,
        })
    }

    /// Returns smart card status but all strings are wide.
    #[instrument(level = "debug", ret)]
    pub fn status_wide(
        &mut self,
        readers_buf_type: RequestedBufferType,
        atr_but_type: RequestedBufferType,
    ) -> WinScardResult<FfiScardStatus> {
        let status = self.scard().status()?;
        let readers: Vec<_> = status.readers.into_iter().map(|r| r.to_string()).collect();
        let context = self.context()?;

        let readers = context.write_multi_string_wide(&readers, readers_buf_type)?;
        let atr = context.write_to_out_buf(status.atr.as_ref(), atr_but_type)?;

        Ok(FfiScardStatus {
            readers,
            atr,
            state: status.state,
            protocol: status.protocol,
        })
    }
}

/// Tries to convert the raw scard handle to the `&mut dyn WinScard`.
pub unsafe fn scard_handle_to_winscard<'a>(handle: ScardHandle) -> WinScardResult<&'a mut dyn WinScard> {
    if handle == 0 {
        return Err(Error::new(ErrorKind::InvalidHandle, "scard handle cannot be zero"));
    }

    // SAFETY: We've checked above that the scard handle is not a zero. All other guarantees are provided by the user.
    if let Some(scard) = unsafe { (handle as *mut WinScardHandle).as_mut() } {
        Ok(scard.scard.as_mut())
    } else {
        Err(Error::new(
            ErrorKind::InvalidHandle,
            "invalid smart card context handle",
        ))
    }
}

/// Tries to convert the raw scard handle to the [&mut WinScardHandle].
pub unsafe fn raw_scard_handle_to_scard_handle<'a>(h_card: ScardHandle) -> WinScardResult<&'a mut WinScardHandle> {
    if h_card == 0 {
        return Err(Error::new(
            ErrorKind::InvalidHandle,
            "scard context handle cannot be zero",
        ));
    }

    // SAFETY: It should be safe to cast the value. The `h_card` is not null (checked above).
    // All other guarantees should be provided by the user.
    unsafe { (h_card as *mut WinScardHandle).as_mut() }
        .ok_or_else(|| Error::new(ErrorKind::InvalidHandle, "raw scard context handle is invalid"))
}

/// Tries to convert the raw scard context handle to the [&mut WinScardContextHandle].
pub unsafe fn raw_scard_context_handle_to_scard_context_handle<'a>(
    h_context: ScardContext,
) -> WinScardResult<&'a mut WinScardContextHandle> {
    if h_context == 0 {
        return Err(Error::new(
            ErrorKind::InvalidHandle,
            "scard context handle cannot be zero",
        ));
    }

    // SAFETY: It should be safe to cast the value. The `h_context` is not null (checked above).
    // All other guarantees should be provided by the user.
    unsafe { (h_context as *mut WinScardContextHandle).as_mut() }
        .ok_or_else(|| Error::new(ErrorKind::InvalidHandle, "raw scard context handle is invalid"))
}

/// Tries to convert the raw scard context handle to the `&mut dyn WinScardContext`.
pub unsafe fn scard_context_to_winscard_context<'a>(
    handle: ScardContext,
) -> WinScardResult<&'a mut dyn WinScardContext> {
    if handle == 0 {
        return Err(Error::new(
            ErrorKind::InvalidHandle,
            "scard context handle cannot be zero",
        ));
    }

    // SAFETY: We've checked above that the scard context handle is not a zero. All other guarantees are provided by the user.
    if let Some(context) = unsafe { (handle as *mut WinScardContextHandle).as_mut() } {
        Ok(context.scard_context.as_mut())
    } else {
        Err(Error::new(
            ErrorKind::InvalidHandle,
            "invalid smart card context handle",
        ))
    }
}

/// Copies data from the Rust [IoRequest] to the C `SCARD_IO_REQUEST` ([LpScardIoRequest]).
pub unsafe fn copy_io_request_to_scard_io_request(
    io_request: &IoRequest,
    scard_io_request: LpScardIoRequest,
) -> WinScardResult<()> {
    if scard_io_request.is_null() {
        return Err(Error::new(
            ErrorKind::InvalidParameter,
            "scard_io_request cannot be null",
        ));
    }

    let pci_info_len = io_request.pci_info.len();
    // SAFETY: it's safe to deref because we've checked for null value above.
    let cb_pci_length = unsafe { (*scard_io_request).cb_pci_length };
    let scard_pci_info_len = usize::try_from(cb_pci_length)?;

    if pci_info_len > scard_pci_info_len {
        return Err(Error::new(
            ErrorKind::InsufficientBuffer,
            format!(
                "ScardIoRequest::cb_pci_length is too small. Expected at least {} but got {}",
                pci_info_len, scard_pci_info_len
            ),
        ));
    }

    // SAFETY: it's safe to deref because we check for null value above.
    unsafe {
        (*scard_io_request).dw_protocol = io_request.protocol.bits();
        (*scard_io_request).cb_pci_length = pci_info_len.try_into()?;
    }

    // SAFETY: it should be safe to cast a pointer. According to the documentation, the `pci_buffer` data
    // is placed right after the `ScardIoRequest` structure.
    let pci_buffer_ptr = unsafe { (scard_io_request as *mut u8).add(size_of::<ScardIoRequest>()) };
    // SAFETY: According to the documentation, it's safe to create a slice of the pci data.
    let pci_buffer = unsafe { from_raw_parts_mut(pci_buffer_ptr, pci_info_len) };
    pci_buffer.copy_from_slice(&io_request.pci_info);

    Ok(())
}


--- File: ffi/src/winscard/system_scard/card.rs ---
use std::borrow::Cow;
use std::fmt;
use std::ptr::null_mut;

#[cfg(target_os = "windows")]
use ffi_types::winscard::functions::SCardApiFunctionTable;
#[cfg(target_os = "windows")]
use ffi_types::winscard::{ScardContext, ScardHandle};
use num_traits::ToPrimitive;
use winscard::winscard::{
    AttributeId, ControlCode, Protocol, ReaderAction, ShareMode, Status, TransmitOutData, WinScard,
};
use winscard::{Error, ErrorKind, WinScardResult};

use super::parse_multi_string_owned;
#[cfg(not(target_os = "windows"))]
use crate::winscard::pcsc_lite::functions::PcscLiteApiFunctionTable;
#[cfg(not(target_os = "windows"))]
use crate::winscard::pcsc_lite::{initialize_pcsc_lite_api, ScardContext, ScardHandle};

/// Represents a state of the current `SystemScard`.
#[derive(Copy, Clone, Debug)]
enum HandleState {
    /// The card is not connected or has been disconnected.
    Disconnected,
    /// The card is connected and ready to use.
    Connected(ScardHandle),
}

/// Represents a system-provided smart card.
///
/// _Hint:_ It's **always better** to explicitly disconnect the card using the [SystemScard::disconnect] method.
/// Otherwise, the card will be disconnected automatically on the drop. But in such a case,
/// the user is unable to pass the custom `dwDisposition` parameter in `SCardDisconnect` function.
pub struct SystemScard {
    h_card: HandleState,
    h_card_context: ScardContext,
    active_protocol: Protocol,

    #[cfg(target_os = "windows")]
    api: SCardApiFunctionTable,
    #[cfg(not(target_os = "windows"))]
    api: PcscLiteApiFunctionTable,
}

impl SystemScard {
    /// Creates a new instance of the [SystemScard].
    ///
    /// _Note._ `h_card` and `h_card_context` parameters (handles) must be initialized using
    /// the corresponding methods.
    pub fn new(h_card: ScardHandle, active_protocol: Protocol, h_card_context: ScardContext) -> WinScardResult<Self> {
        if h_card == 0 {
            return Err(Error::new(
                ErrorKind::InvalidParameter,
                "scard handle can not be a zero",
            ));
        }

        if h_card_context == 0 {
            return Err(Error::new(
                ErrorKind::InvalidParameter,
                "scard context handle can not be a zero",
            ));
        }

        Ok(Self {
            h_card: HandleState::Connected(h_card),
            h_card_context,
            active_protocol,

            #[cfg(target_os = "windows")]
            api: super::init_scard_api_table()?,
            #[cfg(not(target_os = "windows"))]
            api: initialize_pcsc_lite_api()?,
        })
    }

    fn h_card(&self) -> WinScardResult<ScardHandle> {
        if let HandleState::Connected(handle) = self.h_card {
            Ok(handle)
        } else {
            Err(Error::new(
                ErrorKind::InvalidHandle,
                "smart card is not connected or has been disconnected",
            ))
        }
    }
}

impl Drop for SystemScard {
    fn drop(&mut self) {
        if let HandleState::Connected(handle) = self.h_card {
            if let Err(err) = try_execute!(
                // SAFETY: This function is safe to call because the `handle` is valid.
                unsafe { (self.api.SCardDisconnect)(handle, 0) }
            ) {
                error!(?err, "Failed to disconnect the card");
            }
        }
    }
}

impl fmt::Debug for SystemScard {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("SystemScard")
            .field("h_card", &self.h_card)
            .field("h_card_context", &self.h_card_context)
            .finish()
    }
}

impl WinScard for SystemScard {
    #[instrument(ret)]
    fn status(&self) -> WinScardResult<Status> {
        // macOS PC/SC framework doesn't support `SCARD_AUTOALLOCATE` option, so we use preallocated buffer for reader name.
        let mut reader_name = vec![0; 1024];
        let mut reader_name_len = 1024;

        let mut state = 0;
        let mut protocol = 0;
        // https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardstatusw
        //
        // `pbAtr`: Pointer to a 32-byte buffer that receives the ATR string from the currently
        // inserted card, if available.
        //
        // PCSC-lite docs do not specify that ATR buf should be 32 bytes long, but actually,
        // the ATR string can not be longer than 32 bytes.
        let mut atr = vec![0; 32];
        let mut atr_len = 32;

        #[cfg(not(target_os = "windows"))]
        {
            // https://pcsclite.apdu.fr/api/group__API.html#gae49c3c894ad7ac12a5b896bde70d0382
            try_execute!(
                // SAFETY: This function is safe to call because `self.h_card` is checked
                // and all other values is type checked.
                unsafe {
                    (self.api.SCardStatus)(
                        self.h_card()?,
                        reader_name.as_mut_ptr(),
                        &mut reader_name_len,
                        &mut state,
                        &mut protocol,
                        atr.as_mut_ptr(),
                        &mut atr_len,
                    )
                },
                "SCardStatus failed"
            )?;
        }
        #[cfg(target_os = "windows")]
        {
            // https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardstatusa
            try_execute!(
                // SAFETY: This function is safe to call because `self.h_card` is checked
                // and all other values is type checked.
                unsafe {
                    (self.api.SCardStatusA)(
                        self.h_card()?,
                        reader_name.as_mut_ptr(),
                        &mut reader_name_len,
                        &mut state,
                        &mut protocol,
                        atr.as_mut_ptr(),
                        &mut atr_len,
                    )
                },
                "SCardStatusA failed"
            )?;
        }

        let multi_string_buffer = &reader_name[0..reader_name_len.try_into()?];

        let readers = if let Ok(readers) = parse_multi_string_owned(multi_string_buffer) {
            readers
        } else {
            return Err(Error::new(
                ErrorKind::InternalError,
                "returned reader is not valid UTF-8",
            ));
        };

        atr.truncate(atr_len.try_into()?);

        let status = Status {
            readers,
            #[cfg(not(target_os = "windows"))]
            state: crate::winscard::pcsc_lite::State::from_bits(state)
                .unwrap_or(crate::winscard::pcsc_lite::State::Specific)
                .into(),
            #[cfg(target_os = "windows")]
            state: state.try_into()?,
            protocol: Protocol::from_bits(
                #[allow(clippy::useless_conversion)]
                protocol.try_into()?,
            )
            .ok_or_else(|| {
                Error::new(
                    ErrorKind::InternalError,
                    format!("Invalid protocol value: {}", protocol),
                )
            })?,
            atr: atr.into(),
        };

        Ok(status)
    }

    fn control(&mut self, code: ControlCode, input: &[u8]) -> WinScardResult<()> {
        try_execute!(
            // SAFETY: This function is safe to call because `self.h_card` is checked
            // and other function parameters are type checked.
            unsafe {
                (self.api.SCardControl)(
                    self.h_card()?,
                    code.into(),
                    input.as_ptr() as *const _,
                    input.len().try_into()?,
                    null_mut(),
                    0,
                    null_mut(),
                )
            },
            "SCardControl failed"
        )?;

        Ok(())
    }

    fn control_with_output(&mut self, code: ControlCode, input: &[u8], output: &mut [u8]) -> WinScardResult<usize> {
        let mut receive_len = 0;
        let output_buf_len = output.len().try_into()?;

        try_execute!(
            // SAFETY: This function is safe to call because `self.h_card` is checked
            // and other function parameters are type checked.
            unsafe {
                (self.api.SCardControl)(
                    self.h_card()?,
                    code.into(),
                    input.as_ptr() as *const _,
                    input.len().try_into()?,
                    output.as_mut_ptr() as *mut _,
                    output_buf_len,
                    &mut receive_len,
                )
            },
            "SCardControl failed"
        )?;

        Ok(receive_len.try_into()?)
    }

    fn transmit(&mut self, input_apdu: &[u8]) -> WinScardResult<TransmitOutData> {
        // The SCardTransmit function doesn't support SCARD_AUTOALLOCATE attribute. So, we need to allocate
        // the buffer for the output APDU by ourselves.
        // The `msclmd.dll` has `I_ClmdCmdExtendedTransmit` and `I_ClmdCmdShortTransmit` functions.
        // The first one uses 65538-bytes long buffer for output APDU, and the second one uses 258-bytes long buffer.
        // We decided to always use the larger one.
        const OUT_APDU_BUF_LEN: usize = 65538;

        let mut output_apdu_len = OUT_APDU_BUF_LEN.try_into()?;
        let mut output_apdu = [0; OUT_APDU_BUF_LEN];

        let send_pci = match self.active_protocol {
            Protocol::T0 => self.api.g_rgSCardT0Pci,
            Protocol::T1 => self.api.g_rgSCardT1Pci,
            Protocol::Raw => self.api.g_rgSCardRawPci,
            _ => {
                return Err(Error::new(
                    ErrorKind::InvalidValue,
                    format!(
                        "failed to extract container name: smart card selected invalid ({:?}) connection protocol",
                        self.active_protocol
                    ),
                ))
            }
        };

        try_execute!(
            // SAFETY: This function is safe to call because `self.h_card` is checked
            // and other function parameters are type checked.
            unsafe {
                (self.api.SCardTransmit)(
                    self.h_card()?,
                    send_pci,
                    input_apdu.as_ptr(),
                    input_apdu.len().try_into()?,
                    // https://pcsclite.apdu.fr/api/group__API.html#ga9a2d77242a271310269065e64633ab99
                    // https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardtransmit
                    //
                    // pioRecvPci: This parameter can be NULL if no PCI is returned.
                    null_mut(),
                    output_apdu.as_mut_ptr(),
                    &mut output_apdu_len,
                )
            },
            "SCardTransmit failed"
        )?;

        Ok(TransmitOutData {
            output_apdu: output_apdu[0..output_apdu_len.try_into()?].to_vec(),
            receive_pci: None,
        })
    }

    fn begin_transaction(&mut self) -> WinScardResult<()> {
        try_execute!(
            // SAFETY: This function is safe to call because `self.h_card` is checked.
            unsafe { (self.api.SCardBeginTransaction)(self.h_card()?) },
            "SCardBeginTransaction failed"
        )
    }

    fn end_transaction(&mut self, disposition: ReaderAction) -> WinScardResult<()> {
        try_execute!(
            // SAFETY: This function is safe to call because `self.h_card` is checked
            // and the `disposition` parameter is type checked.
            unsafe { (self.api.SCardEndTransaction)(self.h_card()?, disposition.into()) },
            "SCardEndTransaction failed"
        )
    }

    fn reconnect(
        &mut self,
        share_mode: ShareMode,
        preferred_protocol: Option<Protocol>,
        initialization: ReaderAction,
    ) -> WinScardResult<Protocol> {
        let dw_preferred_protocols = preferred_protocol.unwrap_or_default().bits();
        let mut active_protocol = 0;

        try_execute!(
            // SAFETY: This function is safe to call because `self.h_card` is checked
            // and other function parameters are type checked.
            unsafe {
                (self.api.SCardReconnect)(
                    self.h_card()?,
                    share_mode.into(),
                    dw_preferred_protocols.into(),
                    initialization.into(),
                    &mut active_protocol,
                )
            },
            "SCardReconnect failed"
        )?;

        Ok(Protocol::from_bits(
            #[allow(clippy::useless_conversion)]
            active_protocol.try_into()?,
        )
        .unwrap_or_default())
    }

    fn get_attribute(&self, attribute_id: AttributeId) -> WinScardResult<Cow<[u8]>> {
        let attr_id = attribute_id
            .to_u32()
            .ok_or_else(|| Error::new(ErrorKind::InternalError, "cannot convert AttributeId -> u32"))?;
        let mut data_len = 0;

        // https://pcsclite.apdu.fr/api/group__API.html#gaacfec51917255b7a25b94c5104961602
        // If this value is NULL, SCardGetAttrib() ignores the buffer length supplied in pcbAttrLen, writes the length of the buffer
        // that would have been returned if this parameter had not been NULL to pcbAttrLen, and returns a success code.
        //
        // https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardgetattrib
        // If this value is NULL, SCardGetAttrib ignores the buffer length supplied in pcbAttrLen,
        // writes the length of the buffer that would have been returned if this parameter
        // had not been NULL to pcbAttrLen, and returns a success code.
        try_execute!(
            // SAFETY: This function is safe to call because `self.h_card` is checked
            // and other function parameters are type checked.
            unsafe { (self.api.SCardGetAttrib)(self.h_card()?, attr_id.into(), null_mut(), &mut data_len) },
            "SCardGetAttrib failed"
        )?;

        let mut data = vec![0; data_len.try_into()?];

        try_execute!(
            // SAFETY: This function is safe to call because `self.h_card` is checked
            // and other function parameters are type checked.
            unsafe { (self.api.SCardGetAttrib)(self.h_card()?, attr_id.into(), data.as_mut_ptr(), &mut data_len) },
            "SCardGetAttrib failed"
        )?;

        Ok(Cow::Owned(data))
    }

    fn set_attribute(&mut self, attribute_id: AttributeId, attribute_data: &[u8]) -> WinScardResult<()> {
        let attr_id = attribute_id
            .to_u32()
            .ok_or_else(|| Error::new(ErrorKind::InternalError, "cannot convert AttributeId -> u32"))?;

        let len = attribute_data.len().try_into()?;

        try_execute!(
            // SAFETY: This function is safe to call because `self.h_card` is checked
            // and other function parameters are type checked.
            unsafe { (self.api.SCardSetAttrib)(self.h_card()?, attr_id.into(), attribute_data.as_ptr(), len) },
            "SCardSetAttrib failed"
        )
    }

    fn disconnect(&mut self, disposition: ReaderAction) -> WinScardResult<()> {
        try_execute!(
            // SAFETY: This function is safe to call because `self.h_card` is always a valid handle
            // and the `disposition` parameter is type checked.
            unsafe { (self.api.SCardDisconnect)(self.h_card()?, disposition.into()) },
            "SCardDisconnect failed"
        )?;

        // Mark the current card handle as disconnected.
        self.h_card = HandleState::Disconnected;

        Ok(())
    }
}


--- File: ffi/src/winscard/system_scard/context.rs ---
use std::borrow::Cow;
#[cfg(not(target_os = "windows"))]
use std::collections::BTreeMap;
use std::ffi::CString;
use std::fmt;
use std::ptr::{null, null_mut};
#[cfg(target_os = "windows")]
use std::slice::from_raw_parts;

#[cfg(target_os = "windows")]
use ffi_types::winscard::functions::SCardApiFunctionTable;
#[cfg(target_os = "windows")]
use ffi_types::winscard::{ScardContext, ScardHandle};
use uuid::Uuid;
use winscard::winscard::{
    DeviceTypeId, Icon, Protocol, ProviderId, ReaderState, ScardConnectData, ScardScope, ShareMode, WinScardContext,
};
use winscard::{Error, ErrorKind, WinScardResult};

use super::{parse_multi_string_owned, SystemScard};
#[cfg(not(target_os = "windows"))]
use crate::winscard::pcsc_lite::functions::PcscLiteApiFunctionTable;
#[cfg(not(target_os = "windows"))]
use crate::winscard::pcsc_lite::{initialize_pcsc_lite_api, ScardContext, ScardHandle};

/// Default name of the system provided smart card.
/// pcsc-lite and PC/SC framework don't have method for querying scard name, so we use predefined value. It doesn't affect the auth process.
#[cfg(not(target_os = "windows"))]
const DEFAULT_CARD_NAME: &str = "Sspi-rs system provided scard";

pub struct SystemScardContext {
    h_context: ScardContext,

    #[cfg(target_os = "windows")]
    api: SCardApiFunctionTable,
    #[cfg(not(target_os = "windows"))]
    api: PcscLiteApiFunctionTable,

    // pcsc-lite API does not have function for the cache reading/writing. So, we emulate the smart card cache by ourselves.
    #[cfg(not(target_os = "windows"))]
    cache: BTreeMap<String, Vec<u8>>,
}

impl fmt::Debug for SystemScardContext {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("SystemScardContext")
            .field("h_context", &self.h_context)
            .finish()
    }
}

impl SystemScardContext {
    #[instrument(ret)]
    pub fn establish(scope: ScardScope) -> WinScardResult<Self> {
        let mut h_context = 0;

        #[cfg(target_os = "windows")]
        let api = super::init_scard_api_table()?;
        #[cfg(not(target_os = "windows"))]
        let api = initialize_pcsc_lite_api()?;

        try_execute!(
            // SAFETY: This function is safe to call because the `scope` parameter value is type checked
            // and `*mut h_context` can't be `null`.
            unsafe { (api.SCardEstablishContext)(scope.into(), null_mut(), null_mut(), &mut h_context) },
            "SCardEstablishContext failed"
        )?;

        if h_context == 0 {
            return Err(Error::new(
                ErrorKind::InternalError,
                "can not establish context: SCardEstablishContext did not set the context handle",
            ));
        }

        Ok(Self {
            h_context,
            api,
            #[cfg(not(target_os = "windows"))]
            cache: {
                let auth_cert = winscard::env::auth_cert_from_env()?;
                let auth_cert_der = auth_cert.to_der()?;

                init_scard_cache(&winscard::env::container_name()?, auth_cert, &auth_cert_der)?
            },
        })
    }
}

#[cfg(not(target_os = "windows"))]
fn init_scard_cache(
    container_name: &str,
    auth_cert: picky::x509::Cert,
    auth_cert_der: &[u8],
) -> WinScardResult<BTreeMap<String, Vec<u8>>> {
    use picky_asn1_x509::{PublicKey, SubjectPublicKeyInfo};

    // https://github.com/selfrender/Windows-Server-2003/blob/5c6fe3db626b63a384230a1aa6b92ac416b0765f/ds/security/csps/wfsccsp/inc/basecsp.h#L86-L93
    const MAX_CONTAINER_NAME_LEN: usize = 40;

    let mut cache = BTreeMap::new();

    // Freshness values are not supported, so we set all values to zero.
    const PIN_FRESHNESS: [u8; 2] = [0x00, 0x00];
    const CONTAINER_FRESHNESS: [u8; 2] = [0x00, 0x00];
    const FILE_FRESHNESS: [u8; 2] = [0x00, 0x00];

    // The following header is formed based on the extracted information during the debugging and troubleshooting.
    // Do not change it unless you know what you are doing. A broken cache will break the entire authentication.
    const CACHE_ITEM_HEADER: [u8; 6] = {
        let mut header = [0; 6];

        header[0] = 1;
        header[1] = PIN_FRESHNESS[1];
        header[2] = CONTAINER_FRESHNESS[0] + 1;
        header[3] = CONTAINER_FRESHNESS[1];
        header[4] = FILE_FRESHNESS[0] + 1;
        header[5] = FILE_FRESHNESS[1];

        header
    };

    cache.insert("Cached_CardProperty_Read Only Mode_0".into(), {
        let mut value = CACHE_ITEM_HEADER.to_vec();
        // unkown flags
        value.extend_from_slice(&[0, 0, 0, 0, 0, 0]);
        // actual data len
        value.extend_from_slice(&4_u32.to_le_bytes());
        // true
        value.extend_from_slice(&1_u32.to_le_bytes());

        value
    });
    cache.insert("Cached_CardProperty_Cache Mode_0".into(), {
        let mut value = CACHE_ITEM_HEADER.to_vec();
        // unkown flags
        value.extend_from_slice(&[0, 0, 0, 0, 0, 0]);
        // actual data len
        value.extend_from_slice(&4_u32.to_le_bytes());
        // true
        value.extend_from_slice(&1_u32.to_le_bytes());

        value
    });
    cache.insert("Cached_CardProperty_Supports Windows x.509 Enrollment_0".into(), {
        let mut value = CACHE_ITEM_HEADER.to_vec();
        // unkown flags
        value.extend_from_slice(&[0, 0, 0, 0, 0, 0]);
        // actual data len
        value.extend_from_slice(&4_u32.to_le_bytes());
        // false
        value.extend_from_slice(&0_u32.to_le_bytes());

        value
    });
    cache.insert("Cached_GeneralFile/mscp/cmapfile".into(), {
        use std::mem::size_of;

        use ffi_types::WChar;

        let mut value = CACHE_ITEM_HEADER.to_vec();
        // unkown flags
        value.extend_from_slice(&[0, 0, 0, 0, 0, 0]);
        // actual data len: size_of<CONTAINER_MAP_RECORD>()
        // https://github.com/selfrender/Windows-Server-2003/blob/5c6fe3db626b63a384230a1aa6b92ac416b0765f/ds/security/csps/wfsccsp/inc/basecsp.h#L104-L110
        value.extend_from_slice(&86_u32.to_le_bytes());
        // CONTAINER_MAP_RECORD:
        let mut wsz_guid = container_name
            .encode_utf16()
            .chain(core::iter::once(0))
            .flat_map(|v| v.to_le_bytes())
            .collect::<Vec<_>>();
        // `wszGuid` has type `WCHAR [MAX_CONTAINER_NAME_LEN]`,
        // so we need to resize the data if it contains less then `size_of() * MAX_CONTAINER_NAME_LEN` bytes.
        let container_name_bytes_len = size_of::<WChar>() * MAX_CONTAINER_NAME_LEN;
        debug_assert_eq!(container_name_bytes_len, 80);

        wsz_guid.resize(container_name_bytes_len, 0);
        debug!(?wsz_guid);

        value.extend_from_slice(&wsz_guid); // wszGuid
        value.extend_from_slice(&[3, 0]); // bFlags
        value.extend_from_slice(&[0, 0]); // wSigKeySizeBits
        value.extend_from_slice(&[0, 8]); // wKeyExchangeKeySizeBits

        value
    });
    cache.insert("Cached_ContainerProperty_PIN Identifier_0".into(), {
        let mut value = CACHE_ITEM_HEADER.to_vec();
        // unkown flags
        value.extend_from_slice(&[0, 0, 0, 0, 0, 0]);
        // actual data len
        value.extend_from_slice(&4_u32.to_le_bytes());
        // PIN identifier
        value.extend_from_slice(&1_u32.to_le_bytes());

        value
    });
    cache.insert("Cached_ContainerInfo_00".into(), {
        // Note. We can hardcode lengths values in this cache item because we support only 2048 RSA keys.
        // RSA 4096 is not defined in the specification so we don't support it.
        // https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-73-4.pdf#page=34
        // 5.3 Cryptographic Mechanism Identifiers
        // '07' - RSA 2048

        let mut value = CACHE_ITEM_HEADER.to_vec();
        // unkown flags
        value.extend_from_slice(&[0, 0, 0, 0, 0, 0]);
        // actual data len (precalculated)
        value.extend_from_slice(&292_u32.to_le_bytes());

        value.extend_from_slice(&[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x14, 0x01, 0x00, 0x00]); // container info header

        // https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/ns-wincrypt-publickeystruc
        // PUBLICKEYSTRUC
        value.push(0x06); // bType = PUBLICKEYBLOB
        value.push(0x02); // bVersion = 0x2
        value.extend_from_slice(&[0x00, 0x00]); // reserved
        value.extend_from_slice(&[0x00, 0xa4, 0x00, 0x00]); // aiKeyAlg = CALG_RSA_KEYX

        // https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/ns-wincrypt-rsapubkey
        // RSAPUBKEY
        value.extend_from_slice(b"RSA1"); // magic = RSA1
        value.extend_from_slice(&2048_u32.to_le_bytes()); // bitlen = 2048

        let public_key = auth_cert.public_key();
        let public_key: &SubjectPublicKeyInfo = public_key.as_ref();
        let (modulus, public_exponent) = match &public_key.subject_public_key {
            PublicKey::Rsa(rsa) => (
                {
                    let mut modulus = rsa.0.modulus.to_vec();
                    modulus.reverse();
                    modulus.resize(256, 0);
                    modulus
                },
                {
                    let mut pub_exp = rsa.0.public_exponent.to_vec();
                    pub_exp.reverse();
                    pub_exp.resize(4, 0);
                    pub_exp
                },
            ),
            _ => {
                return Err(Error::new(
                    ErrorKind::UnsupportedFeature,
                    "only RSA 2048 keys are supported",
                ))
            }
        };

        value.extend_from_slice(&public_exponent); // pubexp
        value.extend_from_slice(&modulus); // public key

        value
    });
    cache.insert("Cached_GeneralFile/mscp/kxc00".into(), {
        let mut value = CACHE_ITEM_HEADER.to_vec();
        // unkown flags
        value.extend_from_slice(&[0, 0, 0, 0, 0, 0]);

        value.extend_from_slice(&(u16::try_from(auth_cert_der.len())?.to_le_bytes())); // uncompressed certificate data len
        value.extend_from_slice(&[0x00, 0x00]); // flags that specify that the certificate is not compressed
        value.extend_from_slice(auth_cert_der);

        value
    });
    cache.insert("Cached_CardProperty_Capabilities_0".into(), {
        let mut value = CACHE_ITEM_HEADER.to_vec();
        // unkown flags
        value.extend_from_slice(&[0, 0, 0, 0, 0, 0]);
        // actual data len
        value.extend_from_slice(&12_u32.to_le_bytes());
        // Here should be the CARD_CAPABILITIES struct but the actual extracted data is different.
        // So, we just insert the extracted data from a real smart card.
        // Card capabilities:
        value.extend_from_slice(&[1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]);

        value
    });

    Ok(cache)
}

impl Drop for SystemScardContext {
    fn drop(&mut self) {
        if let Err(err) = try_execute!(
            // SAFETY: This function is safe to call because the `self.h_context` is always a valid handle.
            unsafe { (self.api.SCardReleaseContext)(self.h_context) },
            "SCardReleaseContext failed"
        ) {
            error!(?err, "Can not release the scard context");
        }
    }
}

impl WinScardContext for SystemScardContext {
    #[instrument]
    fn connect(
        &self,
        reader_name: &str,
        share_mode: ShareMode,
        protocol: Option<Protocol>,
    ) -> WinScardResult<ScardConnectData> {
        let c_string = CString::new(reader_name)?;

        let mut scard: ScardHandle = 0;
        let mut active_protocol = 0;

        #[cfg(not(target_os = "windows"))]
        {
            try_execute!(
                // SAFETY: This function is safe to call because the `self.h_context` is always a valid handle
                // and other parameters are type checked.
                unsafe {
                    (self.api.SCardConnect)(
                        self.h_context,
                        c_string.as_ptr() as *const _,
                        share_mode.into(),
                        protocol.unwrap_or_default().bits().into(),
                        &mut scard,
                        &mut active_protocol,
                    )
                },
                "SCardConnect failed"
            )?;
        }
        #[cfg(target_os = "windows")]
        {
            try_execute!(
                // SAFETY: This function is safe to call because the `self.h_context` is always a valid handle
                // and other parameters are type checked.
                unsafe {
                    (self.api.SCardConnectA)(
                        self.h_context,
                        c_string.as_ptr() as *const _,
                        share_mode.into(),
                        protocol.unwrap_or_default().bits(),
                        &mut scard,
                        &mut active_protocol,
                    )
                },
                "SCardConnectA failed"
            )?;
        }

        // `DWORD` is aliased to `c_ulong` for Linux targets. In turn, `c_ulong` is aliased to `u64` on some targets.
        // Thus, depending on the compilation target, *sometimes* we need to convert `u64` to `u32`.
        #[allow(clippy::useless_conversion)]
        let active_protocol = active_protocol.try_into()?;
        let protocol = Protocol::from_bits(active_protocol).unwrap_or_default();
        let handle = Box::new(SystemScard::new(scard, protocol, self.h_context)?);

        Ok(ScardConnectData { handle, protocol })
    }

    fn list_readers(&self) -> WinScardResult<Vec<Cow<str>>> {
        let mut readers_buf_len = 0;

        #[cfg(not(target_os = "windows"))]
        {
            // https://pcsclite.apdu.fr/api/group__API.html#ga93b07815789b3cf2629d439ecf20f0d9
            //
            // If the application sends mszGroups and mszReaders as NULL then this function will return the size of the buffer needed to allocate in pcchReaders.
            // `mszGroups`: List of groups to list readers (not used).
            try_execute!(
                // SAFETY: This function is safe to call because the `self.h_context` is always a valid handle
                // and other parameters are type checked.
                unsafe { (self.api.SCardListReaders)(self.h_context, null(), null_mut(), &mut readers_buf_len) },
                "SCardListReaders failed"
            )?;
        }
        #[cfg(target_os = "windows")]
        {
            // https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardlistreadersa
            //
            //  If this value is NULL, SCardListReaders ignores the buffer length supplied in pcchReaders,
            //  writes the length of the buffer that would have been returned if this parameter
            //  had not been NULL to pcchReaders, and returns a success code.
            try_execute!(
                // SAFETY: This function is safe to call because the `self.h_context` is always a valid handle
                // and other parameters are type checked.
                unsafe { (self.api.SCardListReadersA)(self.h_context, null(), null_mut(), &mut readers_buf_len) },
                "SCardListReadersA failed"
            )?;
        }

        let mut readers = vec![0; readers_buf_len.try_into()?];

        #[cfg(not(target_os = "windows"))]
        {
            try_execute!(
                // SAFETY: This function is safe to call because the `self.h_context` is always a valid handle
                // and other parameters are type checked.
                unsafe {
                    (self.api.SCardListReaders)(self.h_context, null(), readers.as_mut_ptr(), &mut readers_buf_len)
                },
                "SCardListReaders failed"
            )?;
        }
        #[cfg(target_os = "windows")]
        {
            try_execute!(
                // SAFETY: This function is safe to call because the `self.h_context` is always a valid handle
                // and other parameters are type checked.
                unsafe {
                    (self.api.SCardListReadersA)(self.h_context, null(), readers.as_mut_ptr(), &mut readers_buf_len)
                },
                "SCardListReadersA failed"
            )?;
        }

        parse_multi_string_owned(&readers)
    }

    fn device_type_id(&self, _reader_name: &str) -> WinScardResult<DeviceTypeId> {
        #[cfg(not(target_os = "windows"))]
        {
            Ok(DeviceTypeId::Usb)
        }
        #[cfg(target_os = "windows")]
        {
            use num_traits::FromPrimitive;

            let mut device_type_id = 0;

            let c_reader_name = CString::new(_reader_name)?;

            try_execute!(
                // SAFETY: This function is safe to call because the `self.h_context` is always a valid handle
                // and other parameters are type checked.
                unsafe {
                    (self.api.SCardGetDeviceTypeIdA)(
                        self.h_context,
                        c_reader_name.as_ptr() as *const _,
                        &mut device_type_id,
                    )
                },
                "SCardGetDeviceTypeIdA failed"
            )?;

            DeviceTypeId::from_u32(device_type_id).ok_or_else(|| {
                Error::new(
                    ErrorKind::InternalError,
                    format!("WinSCard has returned invalid device type id: {}", device_type_id),
                )
            })
        }
    }

    fn reader_icon(&self, _reader_name: &str) -> WinScardResult<Icon> {
        #[cfg(not(target_os = "windows"))]
        {
            use winscard::SmartCardInfo;

            Ok(Icon::from(SmartCardInfo::reader_icon()))
        }
        #[cfg(target_os = "windows")]
        {
            let c_reader_name = CString::new(_reader_name)?;

            let mut icon_buf_len = 0;

            // https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardgetreadericona
            //
            // If this value is NULL, the function ignores the buffer length supplied in the pcbIcon parameter,
            // writes the length of the buffer that would have been returned to pcbIcon if this parameter
            // had not been NULL, and returns a success code.
            try_execute!(
                // SAFETY: This function is safe to call because the `self.h_context` is always a valid handle
                // and other parameters are type checked.
                unsafe {
                    (self.api.SCardGetReaderIconA)(
                        self.h_context,
                        c_reader_name.as_ptr() as *const _,
                        null_mut(),
                        &mut icon_buf_len,
                    )
                },
                "SCardGetReaderIconA failed"
            )?;

            let mut icon_buf = vec![0; icon_buf_len.try_into()?];

            try_execute!(
                // SAFETY: This function is safe to call because the `self.h_context` is always a valid handle
                // and other parameters are type checked.
                unsafe {
                    (self.api.SCardGetReaderIconA)(
                        self.h_context,
                        c_reader_name.as_ptr() as *const _,
                        icon_buf.as_mut_ptr(),
                        &mut icon_buf_len,
                    )
                },
                "SCardGetReaderIconA failed"
            )?;

            Ok(icon_buf.into())
        }
    }

    fn is_valid(&self) -> bool {
        try_execute!(
            // SAFETY: This function is safe to call because we are allowed to pass any value.
            unsafe { (self.api.SCardIsValidContext)(self.h_context) },
            "SCardIsValidContext failed"
        )
        .is_ok()
    }

    #[instrument(ret)]
    fn read_cache(&self, _card_id: Uuid, _freshness_counter: u32, key: &str) -> WinScardResult<Cow<[u8]>> {
        #[cfg(not(target_os = "windows"))]
        {
            self.cache
                .get(key)
                .map(|item| Cow::Borrowed(item.as_slice()))
                .ok_or_else(|| Error::new(ErrorKind::CacheItemNotFound, format!("Cache item '{}' not found", key)))
        }
        #[cfg(target_os = "windows")]
        {
            use super::uuid_to_c_guid;
            use crate::winscard::buf_alloc::SCARD_AUTOALLOCATE;

            let mut data_len = SCARD_AUTOALLOCATE;

            let c_cache_key = CString::new(key)?;
            let mut card_id = uuid_to_c_guid(_card_id);

            let mut data: *mut u8 = null_mut();

            // It's not specified in the `SCardReadCacheA` function documentation, but after some
            // `msclmd.dll` reversing, we found out that this function supports the `SCARD_AUTOALLOCATE`.
            try_execute!(
                // SAFETY: This function is safe to call because the `self.h_context` is always a valid handle
                // and other parameters are type checked.
                unsafe {
                    (self.api.SCardReadCacheA)(
                        self.h_context,
                        &mut card_id,
                        _freshness_counter,
                        c_cache_key.into_raw() as *mut _,
                        ((&mut data) as *mut *mut u8) as *mut _,
                        &mut data_len,
                    )
                },
                "SCardReadCacheA failed"
            )?;

            let data_len: usize = if let Ok(len) = data_len.try_into() {
                len
            } else {
                try_execute!(
                    // SAFETY: This function is safe to call because the `self.h_context` is always a valid handle.
                    unsafe { (self.api.SCardFreeMemory)(self.h_context, data as *const _) },
                    "SCardFreeMemory failed"
                )?;

                return Err(Error::new(ErrorKind::InternalError, "u32 to usize conversion error"));
            };

            let mut cache_item = vec![0; data_len];
            cache_item.copy_from_slice(
                // SAFETY: A slice creation is safe here because the `data` pointer is a local pointer and
                // was initialized by `SCardReadCacheA` function.
                unsafe { from_raw_parts(data, data_len) },
            );

            try_execute!(
                // SAFETY: This function is safe to call because the `self.h_context` is always a valid handle.
                unsafe { (self.api.SCardFreeMemory)(self.h_context, data as *const _) },
                "SCardFreeMemory failed"
            )?;

            Ok(Cow::Owned(cache_item))
        }
    }

    fn write_cache(
        &mut self,
        _card_id: Uuid,
        _freshness_counter: u32,
        key: String,
        value: Vec<u8>,
    ) -> WinScardResult<()> {
        #[cfg(not(target_os = "windows"))]
        {
            self.cache.insert(key, value);

            Ok(())
        }
        #[cfg(target_os = "windows")]
        {
            use super::uuid_to_c_guid;

            let c_cache_key = CString::new(key.as_str())?;
            let mut card_id = uuid_to_c_guid(_card_id);

            try_execute!(
                // SAFETY: This function is safe to call because the `self.h_context` is always a valid handle
                // and other parameters are type checked.
                unsafe {
                    (self.api.SCardWriteCacheA)(
                        self.h_context,
                        &mut card_id,
                        _freshness_counter,
                        c_cache_key.into_raw() as *mut _,
                        value.as_ptr(),
                        value.len().try_into()?,
                    )
                },
                "SCardWriteCacheA failed"
            )
        }
    }

    fn list_reader_groups(&self) -> WinScardResult<Vec<Cow<str>>> {
        let mut reader_groups_buf_len = 0;

        #[cfg(not(target_os = "windows"))]
        {
            // https://pcsclite.apdu.fr/api/group__API.html#ga9d970d086d5218e080d0079d63f9d496
            //
            // If the application sends mszGroups as NULL then this function will return the size of the buffer needed to allocate in pcchGroups.
            try_execute!(
                // SAFETY: This function is safe to call because the `self.h_context` is always a valid handle
                // and other parameters are type checked.
                unsafe { (self.api.SCardListReaderGroups)(self.h_context, null_mut(), &mut reader_groups_buf_len) },
                "SCardListReaderGroups failed"
            )?;
        }
        #[cfg(target_os = "windows")]
        {
            // https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardlistreadergroupsw
            //
            // If this value is NULL, SCardListReaderGroups ignores the buffer length supplied in pcchGroups,
            // writes the length of the buffer that would have been returned if this parameter had not been
            // NULL to pcchGroups, and returns a success code.
            try_execute!(
                // SAFETY: This function is safe to call because the `self.h_context` is always a valid handle
                // and other parameters are type checked.
                unsafe { (self.api.SCardListReaderGroupsA)(self.h_context, null_mut(), &mut reader_groups_buf_len) },
                "SCardListReaderGroupsA failed"
            )?;
        }

        let mut reader_groups = vec![0; reader_groups_buf_len.try_into()?];

        #[cfg(not(target_os = "windows"))]
        {
            try_execute!(
                // SAFETY: This function is safe to call because the `self.h_context` is always a valid handle
                // and other parameters are type checked.
                unsafe {
                    (self.api.SCardListReaderGroups)(
                        self.h_context,
                        reader_groups.as_mut_ptr(),
                        &mut reader_groups_buf_len,
                    )
                },
                "SCardListReaderGroups failed"
            )?;
        }
        #[cfg(target_os = "windows")]
        {
            try_execute!(
                // SAFETY: This function is safe to call because the `self.h_context` is always a valid handle
                // and other parameters are type checked.
                unsafe {
                    (self.api.SCardListReaderGroupsA)(
                        self.h_context,
                        reader_groups.as_mut_ptr(),
                        &mut reader_groups_buf_len,
                    )
                },
                "SCardListReaderGroupsA failed"
            )?;
        }

        parse_multi_string_owned(&reader_groups)
    }

    fn cancel(&mut self) -> WinScardResult<()> {
        // SAFETY: This function is safe to call because the `self.h_context` is always a valid handle.
        try_execute!(unsafe { (self.api.SCardCancel)(self.h_context) }, "SCardCancel failed")
    }

    #[instrument(ret)]
    fn get_status_change(&mut self, timeout: u32, reader_states: &mut [ReaderState]) -> WinScardResult<()> {
        use std::ffi::NulError;

        #[cfg(target_os = "windows")]
        use ffi_types::winscard::ScardReaderStateA as ScardReaderState;
        use winscard::winscard::CurrentState;

        #[cfg(not(target_os = "windows"))]
        use crate::winscard::pcsc_lite::ScardReaderState;

        let mut states = Vec::with_capacity(reader_states.len());
        let c_readers = reader_states
            .iter()
            .map(|reader_state| CString::new(reader_state.reader_name.as_ref()))
            .collect::<Result<Vec<CString>, NulError>>()?;

        for (reader_state, c_reader) in reader_states.iter_mut().zip(c_readers.iter()) {
            states.push(ScardReaderState {
                sz_reader: c_reader.as_ptr() as *const _,
                pv_user_data: reader_state.user_data as _,
                dw_current_state: reader_state.current_state.bits(),
                dw_event_state: reader_state.event_state.bits(),
                cb_atr: reader_state.atr_len.try_into()?,
                rgb_atr: reader_state.atr,
            });
        }

        #[cfg(not(target_os = "windows"))]
        {
            try_execute!(
                // SAFETY: This function is safe to call because the `self.h_context` is always a valid handle
                // and other parameters are type checked.
                unsafe {
                    (self.api.SCardGetStatusChange)(
                        self.h_context,
                        #[allow(clippy::useless_conversion)]
                        timeout.into(),
                        states.as_mut_ptr(),
                        reader_states.len().try_into()?,
                    )
                },
                "SCardGetStatusChange failed"
            )?;
        }
        #[cfg(target_os = "windows")]
        {
            try_execute!(
                // SAFETY: This function is safe to call because the `self.h_context` is always a valid handle
                // and other parameters are type checked.
                unsafe {
                    (self.api.SCardGetStatusChangeA)(
                        self.h_context,
                        timeout,
                        states.as_mut_ptr(),
                        reader_states.len().try_into()?,
                    )
                },
                "SCardGetStatusChangeA failed"
            )?;
        }

        // We do not need to change all fields. Only event state and atr values can be changed.
        for (state, reader_state) in states.iter().zip(reader_states.iter_mut()) {
            reader_state.event_state = CurrentState::from_bits(state.dw_event_state)
                .ok_or_else(|| Error::new(ErrorKind::InternalError, "invalid dwEventState"))?;
            reader_state.atr_len = state.cb_atr.try_into()?;
            reader_state.atr = state.rgb_atr;
        }

        Ok(())
    }

    fn list_cards(&self, _atr: Option<&[u8]>, _required_interfaces: Option<&[Uuid]>) -> WinScardResult<Vec<Cow<str>>> {
        #[cfg(not(target_os = "windows"))]
        {
            Ok(vec![Cow::Borrowed(DEFAULT_CARD_NAME)])
        }
        #[cfg(target_os = "windows")]
        {
            use crate::winscard::system_scard::uuid_to_c_guid;

            let mut cards_buf_len = 0;
            let atr = _atr.map(|a| a.as_ptr()).unwrap_or(null());
            let uuids = _required_interfaces
                .into_iter()
                .flatten()
                .cloned()
                .map(uuid_to_c_guid)
                .collect::<Vec<ffi_types::Uuid>>();
            let uuids_len = uuids.len().try_into()?;
            let c_uuids = if uuids.is_empty() { null() } else { uuids.as_ptr() };

            // https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardlistcardsw
            //
            // mszCards: If this value is NULL, SCardListCards ignores the buffer length supplied in
            // pcchCards, returning the length of the buffer that would have been returned if this
            // parameter had not been NULL to pcchCards and a success code.
            try_execute!(
                // SAFETY: This function is safe to call because the `self.h_context` is always a valid handle
                // and other parameters are type checked.
                unsafe {
                    (self.api.SCardListCardsA)(self.h_context, atr, c_uuids, uuids_len, null_mut(), &mut cards_buf_len)
                },
                "SCardListCardsA failed"
            )?;

            let mut cards = vec![0; cards_buf_len.try_into()?];

            try_execute!(
                // SAFETY: This function is safe to call because the `self.h_context` is always a valid handle
                // and other parameters are type checked.
                unsafe {
                    (self.api.SCardListCardsA)(
                        self.h_context,
                        atr,
                        c_uuids,
                        uuids_len,
                        cards.as_mut_ptr(),
                        &mut cards_buf_len,
                    )
                },
                "SCardListCardsA failed"
            )?;

            parse_multi_string_owned(&cards)
        }
    }

    fn get_card_type_provider_name(&self, _card_name: &str, provider_id: ProviderId) -> WinScardResult<Cow<str>> {
        #[cfg(not(target_os = "windows"))]
        {
            Ok(match provider_id {
                ProviderId::Primary => {
                    return Err(Error::new(
                        ErrorKind::UnsupportedFeature,
                        "ProviderId::Primary is not supported for emulated smart card",
                    ))
                }
                ProviderId::Csp => winscard::MICROSOFT_DEFAULT_CSP.into(),
                ProviderId::Ksp => winscard::MICROSOFT_DEFAULT_KSP.into(),
                ProviderId::CardModule => winscard::MICROSOFT_SCARD_DRIVER_LOCATION.into(),
            })
        }
        #[cfg(target_os = "windows")]
        {
            use crate::winscard::buf_alloc::SCARD_AUTOALLOCATE;

            let mut data_len = SCARD_AUTOALLOCATE;
            let mut data: *mut u8 = null_mut();

            let c_card_name = CString::new(_card_name)?;

            try_execute!(
                // SAFETY: This function is safe to call because the `self.h_context` is always a valid handle
                // and other parameters are type checked.
                unsafe {
                    (self.api.SCardGetCardTypeProviderNameA)(
                        self.h_context,
                        c_card_name.as_ptr() as *const _,
                        provider_id.into(),
                        ((&mut data) as *mut *mut u8) as *mut _,
                        &mut data_len,
                    )
                },
                "SCardGetCardTypeProviderNameA failed"
            )?;

            let data_len: usize = if let Ok(len) = data_len.try_into() {
                len
            } else {
                try_execute!(
                    // SAFETY: This function is safe to call because the `self.h_context` is always a valid handle.
                    unsafe { (self.api.SCardFreeMemory)(self.h_context, data as *const _) },
                    "SCardFreeMemory failed"
                )?;

                return Err(Error::new(ErrorKind::InternalError, "u32 to usize conversion error"));
            };

            let name = if let Ok(name) = String::from_utf8(
                // SAFETY: A slice create is safe because the `data` pointer is a local pointer and
                // was initialized by `SCardGetCardTypeProviderNameA` function.
                unsafe { from_raw_parts(data, data_len) }.to_vec(),
            ) {
                name
            } else {
                try_execute!(
                    // SAFETY: This function is safe to call because the `self.h_context` is always a valid handle.
                    unsafe { (self.api.SCardFreeMemory)(self.h_context, data as *const _) },
                    "SCardFreeMemory failed"
                )?;

                return Err(Error::new(ErrorKind::InternalError, "u32 to usize conversion error"));
            };

            Ok(Cow::Owned(name))
        }
    }
}


--- File: ffi/src/winscard/system_scard/macros.rs ---
macro_rules! try_execute {
    ($x:expr, $msg:expr) => {{
        use num_traits::FromPrimitive;
        use winscard::{Error, ErrorKind};

        let error_kind = ErrorKind::from_u32(
            // In pcsc-lite API, the status code has 8-byte width. But the Windows WinSCard uses 4-byte width status code.
            #[allow(clippy::useless_conversion)]
            // `pcsc-lite` status codes has 8-byte width, but the values always fit 4-byte number:
            // https://pcsclite.apdu.fr/api/group__ErrorCodes.html#details
            // This `.unwrap` will never panic.
            $x.try_into().unwrap()
        ).unwrap_or(ErrorKind::InternalError);
        if error_kind == ErrorKind::Success {
            Ok(())
        } else {
            Err(Error::new(error_kind, $msg))
        }
    }};
    ($x:expr) => {
        try_execute!($x, "")
    };
}


--- File: ffi/src/winscard/system_scard/mod.rs ---
#![cfg(feature = "scard")]

#[macro_use]
mod macros;

mod card;
mod context;

use std::borrow::Cow;

pub use card::SystemScard;
pub use context::SystemScardContext;
#[cfg(target_os = "windows")]
use ffi_types::winscard::functions::SCardApiFunctionTable;
#[cfg(target_os = "windows")]
use ffi_types::winscard::LpCScardIoRequest;
use winscard::WinScardResult;

fn parse_multi_string(buf: &[u8]) -> WinScardResult<Vec<&str>> {
    let res: Result<Vec<&str>, _> = buf
        .split(|&c| c == 0)
        .filter(|v| !v.is_empty())
        .map(std::str::from_utf8)
        .collect();

    Ok(res?)
}

fn parse_multi_string_owned(buf: &[u8]) -> WinScardResult<Vec<Cow<'static, str>>> {
    Ok(parse_multi_string(buf)?
        .into_iter()
        .map(|r| Cow::Owned(r.to_owned()))
        .collect())
}

#[cfg(target_os = "windows")]
fn uuid_to_c_guid(id: uuid::Uuid) -> ffi_types::Uuid {
    let (data1, data2, data3, data4) = id.as_fields();

    ffi_types::Uuid {
        data1,
        data2,
        data3,
        data4: *data4,
    }
}

#[cfg(target_os = "windows")]
pub fn init_scard_api_table() -> WinScardResult<SCardApiFunctionTable> {
    use std::env;
    use std::ffi::CString;
    use std::mem::transmute;

    use windows_sys::s;
    use windows_sys::Win32::System::LibraryLoader::{GetProcAddress, LoadLibraryA};
    use winscard::{Error, ErrorKind};

    /// Path to the `winscard` module.
    ///
    /// The user can use this environment variable to customize the `winscard` library loading.
    const WINSCARD_LIB_PATH_ENV: &str = "WINSCARD_LIB_PATH";

    let file_name = CString::new(if let Ok(lib_path) = env::var(WINSCARD_LIB_PATH_ENV) {
        lib_path.into_bytes()
    } else {
        "WinSCard.dll".as_bytes().to_vec()
    })?;

    // SAFETY: This function is safe to call because the `file_name.as_ptr()` is guaranteed to be
    // the null-terminated C string by `CString` type.
    let winscard_module = unsafe { LoadLibraryA(file_name.as_ptr() as *const _) };

    if winscard_module.is_null() {
        return Err(Error::new(
            ErrorKind::InternalError,
            "can not load the winscard module: LoadLibrary function has returned NULL",
        ));
    } else {
        info!("The winscard module has been loaded");
    }

    macro_rules! load_fn {
        ($func_name:literal) => {{
            // SAFETY:
            // - We've checked the `winscard_module` handle above.
            // - `$func_name` is correct and hardcoded in the code.
            let fn_handle = unsafe { GetProcAddress(winscard_module, s!($func_name)) };
            // SAFETY:
            // - FARPROC is a C-function pointer. It has the same layout as other C function pointers.
            //   Thus, we can safely transmute it to another C function pointer.
            // - FARPROC will never be `None` in this context, because all function names are hardcoded in the code and are valid.
            unsafe {
                // Not great to silent, but mostly fine in this context.
                #[expect(clippy::missing_transmute_annotations)]
                transmute::<windows_sys::Win32::Foundation::FARPROC, _>(fn_handle)
            }
        }};
    }

    macro_rules! load_io_request {
        ($req_name:literal) => {{
            // SAFETY:
            // - We've checked the `winscard_module` handle above.
            // - `$req_name` is correct and hardcoded in the code.
            let req_handle = unsafe { GetProcAddress(winscard_module, s!($req_name)) };
            // SAFETY:
            // - FARPROC is a C-function pointer. But it can also mean variable pointer. [GetProcAddress](https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress):
            //   > If the function succeeds, the return value is the address of the exported function or variable.
            //   Thus, we can safely transmute it to another C structure pointer.
            // - FARPROC will never be `None` in this context, because all names are hardcoded in the code and are valid.
            let send_pci = unsafe {
                transmute::<windows_sys::Win32::Foundation::FARPROC, LpCScardIoRequest>(req_handle)
            };
            // SAFETY:
            // - `send_pci` is not NULL and valid, because its initial handle is valid, because library variable names are valid and hardcoded in the code.
            // - We never call the `FreeLibrary` function, so the pointer will remain valid for the `'static` lifetime.
            unsafe { &*send_pci }
        }};
    }

    Ok(SCardApiFunctionTable {
        dw_version: 0,
        dw_flags: 0,
        SCardEstablishContext: load_fn!("SCardEstablishContext"),
        SCardReleaseContext: load_fn!("SCardReleaseContext"),
        SCardIsValidContext: load_fn!("SCardIsValidContext"),
        SCardListReaderGroupsA: load_fn!("SCardListReaderGroupsA"),
        SCardListReaderGroupsW: load_fn!("SCardListReaderGroupsW"),
        SCardListReadersA: load_fn!("SCardListReadersA"),
        SCardListReadersW: load_fn!("SCardListReadersW"),
        SCardListCardsA: load_fn!("SCardListCardsA"),
        SCardListCardsW: load_fn!("SCardListCardsW"),
        SCardListInterfacesA: load_fn!("SCardListInterfacesA"),
        SCardListInterfacesW: load_fn!("SCardListInterfacesW"),
        SCardGetProviderIdA: load_fn!("SCardGetProviderIdA"),
        SCardGetProviderIdW: load_fn!("SCardGetProviderIdW"),
        SCardGetCardTypeProviderNameA: load_fn!("SCardGetCardTypeProviderNameA"),
        SCardGetCardTypeProviderNameW: load_fn!("SCardGetCardTypeProviderNameW"),
        SCardIntroduceReaderGroupA: load_fn!("SCardIntroduceReaderGroupA"),
        SCardIntroduceReaderGroupW: load_fn!("SCardIntroduceReaderGroupW"),
        SCardForgetReaderGroupA: load_fn!("SCardForgetReaderGroupA"),
        SCardForgetReaderGroupW: load_fn!("SCardForgetReaderGroupW"),
        SCardIntroduceReaderA: load_fn!("SCardIntroduceReaderA"),
        SCardIntroduceReaderW: load_fn!("SCardIntroduceReaderW"),
        SCardForgetReaderA: load_fn!("SCardForgetReaderA"),
        SCardForgetReaderW: load_fn!("SCardForgetReaderW"),
        SCardAddReaderToGroupA: load_fn!("SCardAddReaderToGroupA"),
        SCardAddReaderToGroupW: load_fn!("SCardAddReaderToGroupW"),
        SCardRemoveReaderFromGroupA: load_fn!("SCardRemoveReaderFromGroupA"),
        SCardRemoveReaderFromGroupW: load_fn!("SCardRemoveReaderFromGroupW"),
        SCardIntroduceCardTypeA: load_fn!("SCardIntroduceCardTypeA"),
        SCardIntroduceCardTypeW: load_fn!("SCardIntroduceCardTypeW"),
        SCardSetCardTypeProviderNameA: load_fn!("SCardSetCardTypeProviderNameA"),
        SCardSetCardTypeProviderNameW: load_fn!("SCardSetCardTypeProviderNameW"),
        SCardFreeMemory: load_fn!("SCardFreeMemory"),
        SCardAccessStartedEvent: load_fn!("SCardAccessStartedEvent"),
        SCardReleaseStartedEvent: load_fn!("SCardReleaseStartedEvent"),
        SCardLocateCardsA: load_fn!("SCardLocateCardsA"),
        SCardLocateCardsW: load_fn!("SCardLocateCardsW"),
        SCardLocateCardsByATRA: load_fn!("SCardLocateCardsByATRA"),
        SCardLocateCardsByATRW: load_fn!("SCardLocateCardsByATRW"),
        SCardGetStatusChangeA: load_fn!("SCardGetStatusChangeA"),
        SCardGetStatusChangeW: load_fn!("SCardGetStatusChangeW"),
        SCardCancel: load_fn!("SCardCancel"),
        SCardConnectA: load_fn!("SCardConnectA"),
        SCardConnectW: load_fn!("SCardConnectW"),
        SCardReconnect: load_fn!("SCardReconnect"),
        SCardDisconnect: load_fn!("SCardDisconnect"),
        SCardBeginTransaction: load_fn!("SCardBeginTransaction"),
        SCardEndTransaction: load_fn!("SCardEndTransaction"),
        SCardCancelTransaction: load_fn!("SCardCancelTransaction"),
        SCardState: load_fn!("SCardState"),
        SCardStatusA: load_fn!("SCardStatusA"),
        SCardStatusW: load_fn!("SCardStatusW"),
        SCardTransmit: load_fn!("SCardTransmit"),
        SCardGetTransmitCount: load_fn!("SCardGetTransmitCount"),
        SCardControl: load_fn!("SCardControl"),
        SCardGetAttrib: load_fn!("SCardGetAttrib"),
        SCardSetAttrib: load_fn!("SCardSetAttrib"),
        SCardUIDlgSelectCardA: load_fn!("SCardUIDlgSelectCardA"),
        SCardUIDlgSelectCardW: load_fn!("SCardUIDlgSelectCardW"),
        GetOpenCardNameA: load_fn!("GetOpenCardNameA"),
        GetOpenCardNameW: load_fn!("GetOpenCardNameW"),
        SCardReadCacheA: load_fn!("SCardReadCacheA"),
        SCardReadCacheW: load_fn!("SCardReadCacheW"),
        SCardWriteCacheA: load_fn!("SCardWriteCacheA"),
        SCardWriteCacheW: load_fn!("SCardWriteCacheW"),
        SCardGetReaderIconA: load_fn!("SCardGetReaderIconA"),
        SCardGetReaderIconW: load_fn!("SCardGetReaderIconW"),
        SCardGetDeviceTypeIdA: load_fn!("SCardGetDeviceTypeIdA"),
        SCardGetDeviceTypeIdW: load_fn!("SCardGetDeviceTypeIdW"),
        SCardGetReaderDeviceInstanceIdA: load_fn!("SCardGetReaderDeviceInstanceIdA"),
        SCardGetReaderDeviceInstanceIdW: load_fn!("SCardGetReaderDeviceInstanceIdW"),
        SCardListReadersWithDeviceInstanceIdA: load_fn!("SCardListReadersWithDeviceInstanceIdA"),
        SCardListReadersWithDeviceInstanceIdW: load_fn!("SCardListReadersWithDeviceInstanceIdW"),
        SCardAudit: load_fn!("SCardAudit"),

        g_rgSCardT0Pci: load_io_request!("g_rgSCardT0Pci"),
        g_rgSCardT1Pci: load_io_request!("g_rgSCardT1Pci"),
        g_rgSCardRawPci: load_io_request!("g_rgSCardRawPci"),
    })
}


--- File: ffi/sspi_base.def ---
LIBRARY			"sspi"
EXPORTS
    InitSecurityInterfaceA=Rust_InitSecurityInterfaceA
    InitSecurityInterfaceW=Rust_InitSecurityInterfaceW
    EnumerateSecurityPackagesA=Rust_EnumerateSecurityPackagesA
    EnumerateSecurityPackagesW=Rust_EnumerateSecurityPackagesW
    QueryCredentialsAttributesA=Rust_QueryCredentialsAttributesA
    QueryCredentialsAttributesW=Rust_QueryCredentialsAttributesW
    AcquireCredentialsHandleA=Rust_AcquireCredentialsHandleA
    AcquireCredentialsHandleW=Rust_AcquireCredentialsHandleW
    FreeCredentialsHandle=Rust_FreeCredentialsHandle
    InitializeSecurityContextA=Rust_InitializeSecurityContextA
    InitializeSecurityContextW=Rust_InitializeSecurityContextW
    AcceptSecurityContext=Rust_AcceptSecurityContext
    CompleteAuthToken=Rust_CompleteAuthToken
    DeleteSecurityContext=Rust_DeleteSecurityContext
    ApplyControlToken=Rust_ApplyControlToken
    QueryContextAttributesA=Rust_QueryContextAttributesA
    QueryContextAttributesW=Rust_QueryContextAttributesW
    ImpersonateSecurityContext=Rust_ImpersonateSecurityContext
    RevertSecurityContext=Rust_RevertSecurityContext
    RustSspiSetupLogger=RustSspiSetupLogger
    MakeSignature=Rust_MakeSignature
    VerifySignature=Rust_VerifySignature
    FreeContextBuffer=Rust_FreeContextBuffer
    QuerySecurityPackageInfoA=Rust_QuerySecurityPackageInfoA
    QuerySecurityPackageInfoW=Rust_QuerySecurityPackageInfoW
    ExportSecurityContext=Rust_ExportSecurityContext
    ImportSecurityContextA=Rust_ImportSecurityContextA
    ImportSecurityContextW=Rust_ImportSecurityContextW
    AddCredentialsA=Rust_AddCredentialsA
    AddCredentialsW=Rust_AddCredentialsW
    QuerySecurityContextToken=Rust_QuerySecurityContextToken
    EncryptMessage=Rust_EncryptMessage
    DecryptMessage=Rust_DecryptMessage
    SetContextAttributesA=Rust_SetContextAttributesA
    SetContextAttributesW=Rust_SetContextAttributesW
    SetCredentialsAttributesA=Rust_SetCredentialsAttributesA
    SetCredentialsAttributesW=Rust_SetCredentialsAttributesW
    ChangeAccountPasswordA=Rust_ChangeAccountPasswordA
    ChangeAccountPasswordW=Rust_ChangeAccountPasswordW
    QueryContextAttributesExA=Rust_QueryContextAttributesExA
    QueryContextAttributesExW=Rust_QueryContextAttributesExW
    QueryCredentialsAttributesExA=Rust_QueryCredentialsAttributesExA
    QueryCredentialsAttributesExW=Rust_QueryCredentialsAttributesExW
    SspiEncodeStringsAsAuthIdentity=Rust_SspiEncodeStringsAsAuthIdentity
    SspiFreeAuthIdentity=Rust_SspiFreeAuthIdentity

--- File: ffi/sspi_dpapi.def ---
LIBRARY			"sspi"
EXPORTS
    DpapiProtectSecret
    DpapiUnprotectSecret
    DpapiFree

--- File: ffi/sspi_winscard.def ---
LIBRARY			"sspi"
EXPORTS
    SCardEstablishContext=Rust_SCardEstablishContext
    SCardReleaseContext=Rust_SCardReleaseContext
    SCardIsValidContext=Rust_SCardIsValidContext
    SCardListReaderGroupsA=Rust_SCardListReaderGroupsA
    SCardListReaderGroupsW=Rust_SCardListReaderGroupsW
    SCardListReadersA=Rust_SCardListReadersA
    SCardListReadersW=Rust_SCardListReadersW
    SCardListCardsA=Rust_SCardListCardsA
    SCardListCardsW=Rust_SCardListCardsW
    SCardListInterfacesA=Rust_SCardListInterfacesA
    SCardListInterfacesW=Rust_SCardListInterfacesW
    SCardGetProviderIdA=Rust_SCardGetProviderIdA
    SCardGetProviderIdW=Rust_SCardGetProviderIdW
    SCardGetCardTypeProviderNameA=Rust_SCardGetCardTypeProviderNameA
    SCardGetCardTypeProviderNameW=Rust_SCardGetCardTypeProviderNameW
    SCardIntroduceReaderGroupA=Rust_SCardIntroduceReaderGroupA
    SCardIntroduceReaderGroupW=Rust_SCardIntroduceReaderGroupW
    SCardForgetReaderGroupA=Rust_SCardForgetReaderGroupA
    SCardForgetReaderGroupW=Rust_SCardForgetReaderGroupW
    SCardIntroduceReaderA=Rust_SCardIntroduceReaderA
    SCardIntroduceReaderW=Rust_SCardIntroduceReaderW
    SCardForgetReaderA=Rust_SCardForgetReaderA
    SCardForgetReaderW=Rust_SCardForgetReaderW
    SCardAddReaderToGroupA=Rust_SCardAddReaderToGroupA
    SCardAddReaderToGroupW=Rust_SCardAddReaderToGroupW
    SCardRemoveReaderFromGroupA=Rust_SCardRemoveReaderFromGroupA
    SCardRemoveReaderFromGroupW=Rust_SCardRemoveReaderFromGroupW
    SCardIntroduceCardTypeA=Rust_SCardIntroduceCardTypeA
    SCardIntroduceCardTypeW=Rust_SCardIntroduceCardTypeW
    SCardSetCardTypeProviderNameA=Rust_SCardSetCardTypeProviderNameA
    SCardSetCardTypeProviderNameW=Rust_SCardSetCardTypeProviderNameW
    SCardForgetCardTypeA=Rust_SCardForgetCardTypeA
    SCardForgetCardTypeW=Rust_SCardForgetCardTypeW
    SCardFreeMemory=Rust_SCardFreeMemory
    SCardAccessStartedEvent=Rust_SCardAccessStartedEvent
    SCardReleaseStartedEvent=Rust_SCardReleaseStartedEvent
    SCardLocateCardsA=Rust_SCardLocateCardsA
    SCardLocateCardsW=Rust_SCardLocateCardsW
    SCardLocateCardsByATRA=Rust_SCardLocateCardsByATRA
    SCardLocateCardsByATRW=Rust_SCardLocateCardsByATRW
    SCardGetStatusChangeA=Rust_SCardGetStatusChangeA
    SCardGetStatusChangeW=Rust_SCardGetStatusChangeW
    SCardCancel=Rust_SCardCancel
    SCardConnectA=Rust_SCardConnectA
    SCardConnectW=Rust_SCardConnectW
    SCardReconnect=Rust_SCardReconnect
    SCardDisconnect=Rust_SCardDisconnect
    SCardBeginTransaction=Rust_SCardBeginTransaction
    SCardEndTransaction=Rust_SCardEndTransaction
    SCardCancelTransaction=Rust_SCardCancelTransaction
    SCardState=Rust_SCardState
    SCardStatusA=Rust_SCardStatusA
    SCardStatusW=Rust_SCardStatusW
    SCardTransmit=Rust_SCardTransmit
    SCardGetTransmitCount=Rust_SCardGetTransmitCount
    SCardControl=Rust_SCardControl
    SCardGetAttrib=Rust_SCardGetAttrib
    SCardSetAttrib=Rust_SCardSetAttrib
    SCardUIDlgSelectCardA=Rust_SCardUIDlgSelectCardA
    SCardUIDlgSelectCardW=Rust_SCardUIDlgSelectCardW
    GetOpenCardNameA=Rust_GetOpenCardNameA
    GetOpenCardNameW=Rust_GetOpenCardNameW
    SCardReadCacheA=Rust_SCardReadCacheA
    SCardReadCacheW=Rust_SCardReadCacheW
    SCardWriteCacheA=Rust_SCardWriteCacheA
    SCardWriteCacheW=Rust_SCardWriteCacheW
    SCardGetReaderIconA=Rust_SCardGetReaderIconA
    SCardGetReaderIconW=Rust_SCardGetReaderIconW
    SCardGetReaderDeviceInstanceIdA=Rust_SCardGetReaderDeviceInstanceIdA
    SCardGetReaderDeviceInstanceIdW=Rust_SCardGetReaderDeviceInstanceIdW
    SCardListReadersWithDeviceInstanceIdA=Rust_SCardListReadersWithDeviceInstanceIdA
    SCardListReadersWithDeviceInstanceIdW=Rust_SCardListReadersWithDeviceInstanceIdW
    SCardAudit=Rust_SCardAudit
    SCardGetDeviceTypeIdA=Rust_SCardGetDeviceTypeIdA
    SCardGetDeviceTypeIdW=Rust_SCardGetDeviceTypeIdW
    g_rgSCardT1Pci=Rust_g_rgSCardT1Pci
    g_rgSCardT0Pci=Rust_g_rgSCardT0Pci
    g_rgSCardRawPci=Rust_g_rgSCardRawPci

--- File: ffi/symbol-rename-macro/Cargo.toml ---
[package]
name = "symbol-rename-macro"
version = "0.0.0"
license = "MIT/Apache-2.0"
edition = "2021"
publish = false

[lib]
proc-macro = true

[lints]
workspace = true


--- File: ffi/symbol-rename-macro/src/lib.rs ---
extern crate proc_macro;

type AnyErr = Box<dyn std::error::Error>;

#[derive(Debug)]
struct Error {
    desc: String,
}

impl std::error::Error for Error {}

impl core::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        self.desc.fmt(f)
    }
}

impl Error {
    fn msg(s: impl Into<String>) -> Self {
        Self { desc: s.into() }
    }
}

#[proc_macro_attribute]
pub fn rename_symbol(attr: proc_macro::TokenStream, item: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let attr = attr.to_string();
    let item = item.to_string();
    match rename_symbol_impl(&attr, &item) {
        Ok(output) => output.parse().expect("invalid output token stream"),
        Err(e) => format!(r####"compile_error!(r###"{}"###); {}"####, e, item)
            .parse()
            .unwrap(),
    }
}

const ATTR_NO_MANGLE: &str = "#[no_mangle]";

fn rename_symbol_impl(attr: &str, item: &str) -> Result<String, AnyErr> {
    use std::fmt::Write as _;

    let new_symbol = attr
        .strip_prefix(r#"to = ""#)
        .ok_or_else(|| Error::msg(r#"attribute must match `to = "<new symbol>"`"#))?
        .strip_suffix('"')
        .ok_or_else(|| Error::msg(r#"missing closing `"`"#))?;

    let fn_symbol = find_fn_symbol(item)?;
    let call_conv = find_calling_conv(item)?;
    let fn_token_idx = find_fn_token(item)?;
    let fn_signature = find_fn_signature(item)?;
    let fn_args = find_args(fn_signature)?;

    let mut out = String::new();

    {
        // Rewrite original implementation (without #[no_mangle] attribute)

        let pre = item[..fn_token_idx].replace(ATTR_NO_MANGLE, "");
        let rest = &item[fn_token_idx..];
        writeln!(out, "{pre}{rest} ")?;
    };

    {
        // Stub function with the new name

        writeln!(
            out,
            r#"#[no_mangle] pub unsafe extern "{call_conv}" fn {new_symbol}{fn_signature} {{"#
        )?;
        writeln!(out, "\t{fn_symbol}(")?;
        for arg in fn_args {
            writeln!(out, "\t\t{arg},")?;
        }
        writeln!(out, "\t)")?;
        writeln!(out, "}}")?;
    }

    Ok(out)
}

fn find_fn_token(item: &str) -> Result<usize, AnyErr> {
    let fn_token_idx = item.find("fn").ok_or_else(|| Error::msg("expected a function"))?;
    Ok(fn_token_idx)
}

fn find_fn_symbol(item: &str) -> Result<&str, AnyErr> {
    let fn_token_idx = find_fn_token(item)?;

    let open_parenth_idx = item[fn_token_idx..]
        .find('(')
        .map(|idx| idx + fn_token_idx)
        .ok_or_else(|| Error::msg("expected opening delimiter `(`"))?;
    let end_idx = item[fn_token_idx..open_parenth_idx]
        .find('<')
        .map(|idx| idx + fn_token_idx)
        .unwrap_or(open_parenth_idx);

    Ok(&item[fn_token_idx + 3..end_idx])
}

fn find_fn_signature(item: &str) -> Result<&str, AnyErr> {
    let fn_token_idx = find_fn_token(item)?;

    let open_parenth_idx = item[fn_token_idx..]
        .find('(')
        .map(|idx| idx + fn_token_idx)
        .ok_or_else(|| Error::msg("expected opening delimiter `(`"))?;
    let fn_symbol_end_idx = item[fn_token_idx..open_parenth_idx]
        .find('<')
        .map(|idx| idx + fn_token_idx)
        .unwrap_or(open_parenth_idx);

    let opening_curly_brace_idx = item[fn_symbol_end_idx..]
        .find('{')
        .map(|idx| idx + fn_symbol_end_idx)
        .ok_or_else(|| Error::msg("expected opening delimiter `{`"))?;

    Ok(&item[fn_symbol_end_idx..opening_curly_brace_idx])
}

fn find_calling_conv(item: &str) -> Result<&str, AnyErr> {
    let fn_token_idx = find_fn_token(item)?;

    let extern_keyword_idx = item[..fn_token_idx]
        .find("extern")
        .ok_or_else(|| Error::msg("expected `extern` keyword"))?;

    let call_conv_start_idx = extern_keyword_idx + 8;
    let call_conv_end_idx = item[call_conv_start_idx..]
        .find('"')
        .map(|idx| idx + call_conv_start_idx)
        .ok_or_else(|| Error::msg(r#"expected closing delimiter `"`"#))?;

    Ok(&item[call_conv_start_idx..call_conv_end_idx])
}

fn find_args(signature: &str) -> Result<Vec<&str>, AnyErr> {
    let open_parenth_idx = signature
        .find('(')
        .ok_or_else(|| Error::msg("expected opening delimiter `(`"))?;
    let close_parenth_idx = signature
        .find(')')
        .ok_or_else(|| Error::msg("expected closing delimiter `)`"))?;
    let parameters = &signature[open_parenth_idx + 1..close_parenth_idx];

    let parameters = parameters
        .split(',')
        .filter_map(|param| {
            let end_idx = param.find(':')?;
            Some(param[..end_idx].trim().trim_start_matches("mut "))
        })
        .collect();

    Ok(parameters)
}


--- File: fuzz/.gitignore ---

target
corpus
artifacts
Cargo.lock


--- File: fuzz/Cargo.toml ---
[package]
name = "sspi-fuzz"
version = "0.0.0"
authors = ["Automatically generated"]
publish = false
edition = "2021"

[package.metadata]
cargo-fuzz = true

[dependencies]
dpapi-fuzzing.path = "../crates/dpapi-fuzzing"
libfuzzer-sys = "0.4"
sspi.path = ".."

# Prevent this from interfering with workspaces
[workspace]
members = ["."]

[[bin]]
name = "fuzz_ts_request"
path = "fuzz_targets/fuzz_ts_request.rs"

[[bin]]
name = "dpapi_round_trip"
path = "fuzz_targets/dpapi_round_trip.rs"
test = false
doc = false
bench = false

[[bin]]
name = "dpapi_decoding"
path = "fuzz_targets/dpapi_decoding.rs"
test = false
doc = false
bench = false

--- File: fuzz/fuzz_targets/dpapi_decoding.rs ---
#![no_main]

extern crate dpapi_fuzzing;
extern crate libfuzzer_sys;

use dpapi_fuzzing::oracles::structure_decoding;

libfuzzer_sys::fuzz_target!(|data: &[u8]| {
    structure_decoding(data);
});


--- File: fuzz/fuzz_targets/dpapi_round_trip.rs ---
#![no_main]

extern crate dpapi_fuzzing;
extern crate libfuzzer_sys;

use dpapi_fuzzing::generator::AnyStruct;
use dpapi_fuzzing::oracles::round_trip;

libfuzzer_sys::fuzz_target!(|any: AnyStruct| {
    round_trip(any);
});


--- File: fuzz/fuzz_targets/fuzz_ts_request.rs ---
#![no_main]
#[macro_use]
extern crate libfuzzer_sys;
extern crate sspi;

use sspi::credssp::TsRequest;

fuzz_target!(|data: &[u8]| {
    if let Ok(req) = TsRequest::from_buffer(data) {
        let _req_len = req.buffer_len();
        let _result = req.check_error();
    }

    let _creds = sspi::credssp::read_ts_credentials(data);
});


--- File: proptest-regressions/auth_identity.txt ---
# Seeds for failure cases proptest has generated in the past. It is
# automatically read and these particular cases re-run before any
# novel cases are generated.
#
# It is recommended to check this file in to source control so that
# everyone who runs the test benefits from these saved cases.
cc 22a32450b3cada4bb46952cb5109e3b305e8c756d58d37136a195c3bc3dee4cb # shrinks to account_name = "@", domain_name = "A"
cc 7f7cdbd18aad0a1d970b6ff9ce7fbfaa7e4dabeb0b55cca0c7f7610f8f0e3cbf # shrinks to value = "A@\\.a"
cc f946f1001aacc60322cba7ba063fa386f4e0c6d9497d8144e300f8b4652e378e # shrinks to value = "A\\a\\a"
cc 033e00adafc5d7bc9402013f261b9f7de65938d4ce9f66f2ea4ec1419a0ae286 # shrinks to value = "A@0@a"


--- File: release-plz.toml ---
[workspace]
dependencies_update = true
git_release_enable = false
semver_check = true
pr_branch_prefix = "release-plz/"
pr_name = "chore(release): prepare for publishing"
changelog_config = "cliff.toml"
release_commits = "^(feat|docs|fix|build|perf)"


--- File: rust-toolchain.toml ---
[toolchain]
channel = "1.85.0"
components = [ "rustfmt", "clippy" ]


--- File: rustfmt.toml ---
max_width = 120
reorder_imports = true
imports_granularity = "Module"
group_imports = "StdExternalCrate"

--- File: src/auth_identity.rs ---
use std::fmt;

use crate::{utils, Error, Secret};

#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum UsernameError {
    MixedFormat,
}

impl std::error::Error for UsernameError {}

impl fmt::Display for UsernameError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            UsernameError::MixedFormat => write!(f, "mixed username format"),
        }
    }
}

/// Enumeration of the supported [User Name Formats].
///
/// [User Name Formats]: https://learn.microsoft.com/en-us/windows/win32/secauthn/user-name-formats
#[derive(Debug, Clone, Copy, Eq, PartialEq)]
pub enum UserNameFormat {
    /// [User principal name] (UPN) format is used to specify an Internet-style name, such as UserName@Example.Microsoft.com.
    ///
    /// [User principal name]: https://learn.microsoft.com/en-us/windows/win32/secauthn/user-name-formats#user-principal-name
    UserPrincipalName,
    /// The [down-level logon name] format is used to specify a domain and a user account in that domain, for example, DOMAIN\UserName.
    ///
    /// [down-level logon name]: https://learn.microsoft.com/en-us/windows/win32/secauthn/user-name-formats#down-level-logon-name
    DownLevelLogonName,
}

/// A username formatted as either UPN or Down-Level Logon Name
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct Username {
    value: String,
    format: UserNameFormat,
    sep_idx: Option<usize>,
}

impl Username {
    /// Builds a user principal name from an account name and an UPN suffix
    pub fn new_upn(account_name: &str, upn_suffix: &str) -> Result<Self, UsernameError> {
        // NOTE: AD usernames may contain `@`
        if account_name.contains(['\\']) {
            return Err(UsernameError::MixedFormat);
        }

        if upn_suffix.contains(['\\', '@']) {
            return Err(UsernameError::MixedFormat);
        }

        Ok(Self {
            value: format!("{account_name}@{upn_suffix}"),
            format: UserNameFormat::UserPrincipalName,
            sep_idx: Some(account_name.len()),
        })
    }

    /// Builds a down-level logon name from an account name and a NetBIOS domain name
    pub fn new_down_level_logon_name(account_name: &str, netbios_domain_name: &str) -> Result<Self, UsernameError> {
        if account_name.contains(['\\', '@']) {
            return Err(UsernameError::MixedFormat);
        }

        if netbios_domain_name.contains(['\\', '@']) {
            return Err(UsernameError::MixedFormat);
        }

        Ok(Self {
            value: format!("{netbios_domain_name}\\{account_name}"),
            format: UserNameFormat::DownLevelLogonName,
            sep_idx: Some(netbios_domain_name.len()),
        })
    }

    /// Attempts to guess the right name format for the account name/domain combo
    ///
    /// If no netbios domain name is provided, or if it is an empty string, the username will
    /// be parsed as either a user principal name or a down-level logon name.
    ///
    /// It falls back to a down-level logon name when the format can’t be guessed.
    pub fn new(account_name: &str, netbios_domain_name: Option<&str>) -> Result<Self, UsernameError> {
        match netbios_domain_name {
            Some(netbios_domain_name) if !netbios_domain_name.is_empty() => {
                Self::new_down_level_logon_name(account_name, netbios_domain_name)
            }
            _ => Self::parse(account_name),
        }
    }

    /// Parses the value in order to find if the value is a user principal name or a down-level logon name
    ///
    /// If there is no `\` or `@` separator, the value is considered to be a down-level logon name with
    /// an empty NetBIOS domain.
    pub fn parse(value: &str) -> Result<Self, UsernameError> {
        match (value.split_once('\\'), value.rsplit_once('@')) {
            (None, None) => Ok(Self {
                value: value.to_owned(),
                format: UserNameFormat::DownLevelLogonName,
                sep_idx: None,
            }),
            (Some((netbios_domain_name, account_name)), _) => {
                Self::new_down_level_logon_name(account_name, netbios_domain_name)
            }
            (_, Some((account_name, upn_suffix))) => Self::new_upn(account_name, upn_suffix),
        }
    }

    /// Returns the internal representation, as-is
    pub fn inner(&self) -> &str {
        &self.value
    }

    /// Returns the [`UserNameFormat`] for this username
    pub fn format(&self) -> UserNameFormat {
        self.format
    }

    /// May return an UPN suffix or NetBIOS domain name depending on the internal format
    pub fn domain_name(&self) -> Option<&str> {
        self.sep_idx.map(|idx| match self.format {
            UserNameFormat::UserPrincipalName => &self.value[idx + 1..],
            UserNameFormat::DownLevelLogonName => &self.value[..idx],
        })
    }

    /// Returns the account name
    pub fn account_name(&self) -> &str {
        if let Some(idx) = self.sep_idx {
            match self.format {
                UserNameFormat::UserPrincipalName => &self.value[..idx],
                UserNameFormat::DownLevelLogonName => &self.value[idx + 1..],
            }
        } else {
            &self.value
        }
    }
}

/// Allows you to pass a particular user name and password to the run-time library for the purpose of authentication
///
/// # MSDN
///
/// * [SEC_WINNT_AUTH_IDENTITY_W structure](https://docs.microsoft.com/en-us/windows/win32/api/sspi/ns-sspi-sec_winnt_auth_identity_w)
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct AuthIdentity {
    pub username: Username,
    pub password: Secret<String>,
}

#[derive(Clone, Eq, PartialEq, Default)]
pub struct AuthIdentityBuffers {
    pub user: Vec<u8>,
    pub domain: Vec<u8>,
    pub password: Secret<Vec<u8>>,
}

impl AuthIdentityBuffers {
    pub fn new(user: Vec<u8>, domain: Vec<u8>, password: Vec<u8>) -> Self {
        Self {
            user,
            domain,
            password: password.into(),
        }
    }

    pub fn is_empty(&self) -> bool {
        self.user.is_empty()
    }

    pub fn from_utf8(user: &str, domain: &str, password: &str) -> Self {
        Self {
            user: utils::string_to_utf16(user),
            domain: utils::string_to_utf16(domain),
            password: utils::string_to_utf16(password).into(),
        }
    }
}

impl fmt::Debug for AuthIdentityBuffers {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "AuthIdentityBuffers {{ user: 0x")?;
        self.user.iter().try_for_each(|byte| write!(f, "{byte:02X}"))?;
        write!(f, ", domain: 0x")?;
        self.domain.iter().try_for_each(|byte| write!(f, "{byte:02X}"))?;
        write!(f, ", password: {:?} }}", self.password)?;

        Ok(())
    }
}

impl From<AuthIdentity> for AuthIdentityBuffers {
    fn from(credentials: AuthIdentity) -> Self {
        Self {
            user: utils::string_to_utf16(credentials.username.account_name()),
            domain: credentials
                .username
                .domain_name()
                .map(utils::string_to_utf16)
                .unwrap_or_default(),
            password: utils::string_to_utf16(credentials.password.as_ref()).into(),
        }
    }
}

impl TryFrom<&AuthIdentityBuffers> for AuthIdentity {
    type Error = UsernameError;

    fn try_from(credentials_buffers: &AuthIdentityBuffers) -> Result<Self, Self::Error> {
        let account_name = utils::bytes_to_utf16_string(&credentials_buffers.user);
        let domain_name = if !credentials_buffers.domain.is_empty() {
            Some(utils::bytes_to_utf16_string(&credentials_buffers.domain))
        } else {
            None
        };

        let username = Username::new(&account_name, domain_name.as_deref())?;
        let password = utils::bytes_to_utf16_string(credentials_buffers.password.as_ref()).into();

        Ok(Self { username, password })
    }
}

impl TryFrom<AuthIdentityBuffers> for AuthIdentity {
    type Error = UsernameError;

    fn try_from(credentials_buffers: AuthIdentityBuffers) -> Result<Self, Self::Error> {
        AuthIdentity::try_from(&credentials_buffers)
    }
}

mod scard_credentials {
    use picky::key::PrivateKey;
    use picky_asn1_x509::Certificate;

    use crate::secret::SecretPrivateKey;
    use crate::{utils, Error, ErrorKind, Secret};

    /// Represents raw data needed for smart card authentication
    #[derive(Clone, Eq, PartialEq, Debug)]
    pub struct SmartCardIdentityBuffers {
        /// UTF-16 encoded username
        pub username: Vec<u8>,
        /// DER-encoded X509 certificate
        pub certificate: Vec<u8>,
        /// UTF-16 encoded smart card name
        pub card_name: Option<Vec<u8>>,
        /// UTF-16 encoded smart card reader name
        pub reader_name: Vec<u8>,
        /// UTF-16 encoded smart card key container name
        pub container_name: Vec<u8>,
        /// UTF-16 encoded smart card CSP name
        pub csp_name: Vec<u8>,
        /// UTF-16 encoded smart card PIN code
        pub pin: Secret<Vec<u8>>,
        /// Private key file index
        /// This value is used for the APDU message generation
        pub private_key_file_index: Option<u8>,
        /// UTF-16 string with PEM-encoded RSA 2048-bit private key
        pub private_key_pem: Option<Vec<u8>>,
    }

    /// Represents data needed for smart card authentication
    #[derive(Debug, Clone, PartialEq)]
    pub struct SmartCardIdentity {
        /// Username
        pub username: String,
        /// X509 certificate
        pub certificate: Certificate,
        /// Smart card reader name
        pub reader_name: String,
        /// Smart card name
        pub card_name: Option<String>,
        /// Smart card key container name
        pub container_name: String,
        /// Smart card CSP name
        pub csp_name: String,
        /// ASCII encoded mart card PIN code
        pub pin: Secret<Vec<u8>>,
        /// Private key file index
        /// This value is used for the APDU message generation
        pub private_key_file_index: Option<u8>,
        /// RSA 2048-bit private key
        pub private_key: Option<SecretPrivateKey>,
    }

    impl TryFrom<SmartCardIdentity> for SmartCardIdentityBuffers {
        type Error = Error;

        fn try_from(value: SmartCardIdentity) -> Result<Self, Self::Error> {
            let private_key = if let Some(key) = value.private_key {
                Some(utils::string_to_utf16(key.as_ref().to_pem_str().map_err(|e| {
                    Error::new(
                        ErrorKind::InternalError,
                        format!("Unable to serialize a smart card private key: {}", e),
                    )
                })?))
            } else {
                None
            };
            Ok(Self {
                certificate: picky_asn1_der::to_vec(&value.certificate)?,
                reader_name: utils::string_to_utf16(value.reader_name),
                pin: utils::string_to_utf16(String::from_utf8_lossy(value.pin.as_ref())).into(),
                username: utils::string_to_utf16(value.username),
                card_name: value.card_name.map(utils::string_to_utf16),
                container_name: utils::string_to_utf16(value.container_name),
                csp_name: utils::string_to_utf16(value.csp_name),
                private_key_file_index: value.private_key_file_index,
                private_key_pem: private_key,
            })
        }
    }

    impl TryFrom<SmartCardIdentityBuffers> for SmartCardIdentity {
        type Error = Error;

        fn try_from(value: SmartCardIdentityBuffers) -> Result<Self, Self::Error> {
            let private_key = if let Some(key) = value.private_key_pem {
                Some(SecretPrivateKey::new(
                    PrivateKey::from_pem_str(&utils::bytes_to_utf16_string(&key)).map_err(|e| {
                        Error::new(
                            ErrorKind::InternalError,
                            format!("Unable to create a PrivateKey from a PEM string: {}", e),
                        )
                    })?,
                ))
            } else {
                None
            };
            Ok(Self {
                certificate: picky_asn1_der::from_bytes(&value.certificate)?,
                reader_name: utils::bytes_to_utf16_string(&value.reader_name),
                pin: utils::bytes_to_utf16_string(value.pin.as_ref()).into_bytes().into(),
                username: utils::bytes_to_utf16_string(&value.username),
                card_name: value.card_name.map(|name| utils::bytes_to_utf16_string(&name)),
                container_name: utils::bytes_to_utf16_string(&value.container_name),
                csp_name: utils::bytes_to_utf16_string(&value.csp_name),
                private_key_file_index: value.private_key_file_index,
                private_key,
            })
        }
    }
}

pub use self::scard_credentials::{SmartCardIdentity, SmartCardIdentityBuffers};

/// Generic enum that encapsulates raw credentials for any type of authentication
#[derive(Clone, Eq, PartialEq, Debug)]
pub enum CredentialsBuffers {
    /// Raw auth identity buffers for the password based authentication
    AuthIdentity(AuthIdentityBuffers),
    /// Raw smart card identity buffers for the smart card based authentication
    SmartCard(SmartCardIdentityBuffers),
}

#[allow(unreachable_patterns)]
impl CredentialsBuffers {
    pub fn auth_identity(self) -> Option<AuthIdentityBuffers> {
        match self {
            CredentialsBuffers::AuthIdentity(identity) => Some(identity),
            _ => None,
        }
    }

    pub fn as_auth_identity(&self) -> Option<&AuthIdentityBuffers> {
        match self {
            CredentialsBuffers::AuthIdentity(identity) => Some(identity),
            _ => None,
        }
    }

    pub fn as_mut_auth_identity(&mut self) -> Option<&mut AuthIdentityBuffers> {
        match self {
            CredentialsBuffers::AuthIdentity(identity) => Some(identity),
            _ => None,
        }
    }
}

/// Generic enum that encapsulates credentials for any type of authentication
#[derive(Clone, PartialEq, Debug)]
pub enum Credentials {
    /// Auth identity for the password based authentication
    AuthIdentity(AuthIdentity),
    /// Smart card identity for the smart card based authentication
    SmartCard(Box<SmartCardIdentity>),
}

impl Credentials {
    #[allow(unreachable_patterns)]
    pub fn auth_identity(self) -> Option<AuthIdentity> {
        match self {
            Credentials::AuthIdentity(identity) => Some(identity),
            _ => None,
        }
    }
}

impl From<SmartCardIdentity> for Credentials {
    fn from(value: SmartCardIdentity) -> Self {
        Self::SmartCard(Box::new(value))
    }
}

impl From<AuthIdentity> for Credentials {
    fn from(value: AuthIdentity) -> Self {
        Self::AuthIdentity(value)
    }
}

impl TryFrom<Credentials> for CredentialsBuffers {
    type Error = Error;

    fn try_from(value: Credentials) -> Result<Self, Self::Error> {
        Ok(match value {
            Credentials::AuthIdentity(identity) => Self::AuthIdentity(identity.into()),
            Credentials::SmartCard(identity) => Self::SmartCard((*identity).try_into()?),
        })
    }
}

#[cfg(test)]
mod tests {
    use proptest::prelude::*;

    use super::*;

    #[test]
    fn username_format_conversion() {
        proptest!(|(value in "[a-zA-Z0-9.]{1,3}@?\\\\?[a-zA-Z0-9.]{1,3}@?\\\\?[a-zA-Z0-9.]{1,3}")| {
            let res = Username::parse(&value);
            prop_assume!(res.is_ok());
            let initial_username = res.unwrap();
            assert_eq!(initial_username.inner(), value);

            if let Some(domain_name) = initial_username.domain_name() {
                let upn = Username::new_upn(initial_username.account_name(), domain_name).expect("UPN");
                assert_eq!(upn.account_name(), initial_username.account_name());
                assert_eq!(upn.domain_name(), initial_username.domain_name());
            }

            // A down-level user name can’t contain a @ in the account name
            if !initial_username.account_name().contains('@') {
                let netbios_name = Username::new(initial_username.account_name(), initial_username.domain_name()).expect("NetBIOS");
                assert_eq!(netbios_name.format(), UserNameFormat::DownLevelLogonName);
                assert_eq!(netbios_name.account_name(), initial_username.account_name());
                assert_eq!(netbios_name.domain_name(), initial_username.domain_name());
            }
        })
    }

    fn check_round_trip_property(username: &Username) {
        let round_trip = Username::parse(username.inner()).expect("round-trip parse");
        assert_eq!(*username, round_trip);
    }

    #[test]
    fn upn_round_trip() {
        proptest!(|(account_name in "[a-zA-Z0-9@.]{1,3}", domain_name in "[a-z0-9.]{1,3}")| {
            let username = Username::new_upn(&account_name, &domain_name).expect("UPN");

            assert_eq!(username.account_name(), account_name);
            assert_eq!(username.domain_name(), Some(domain_name.as_str()));
            assert_eq!(username.format(), UserNameFormat::UserPrincipalName);

            check_round_trip_property(&username);
        })
    }

    #[test]
    fn down_level_logon_name_round_trip() {
        proptest!(|(account_name in "[a-zA-Z0-9.]{1,3}", domain_name in "[A-Z0-9.]{1,3}")| {
            let username = Username::new_down_level_logon_name(&account_name, &domain_name).expect("down-level logon name");

            assert_eq!(username.account_name(), account_name);
            assert_eq!(username.domain_name(), Some(domain_name.as_str()));
            assert_eq!(username.format(), UserNameFormat::DownLevelLogonName);

            check_round_trip_property(&username);
        })
    }
}


--- File: src/ber/mod.rs ---
#[cfg(test)]
mod tests;

use std::io;

use byteorder::{BigEndian, ReadBytesExt, WriteBytesExt};

#[repr(u8)]
#[allow(unused)]
pub enum Pc {
    Primitive = 0x00,
    Construct = 0x20,
}

#[repr(u8)]
#[allow(unused)]
enum Class {
    Universal = 0x00,
    Application = 0x40,
    ContextSpecific = 0x80,
    Private = 0xC0,
}

#[repr(u8)]
#[allow(unused)]
enum Tag {
    Mask = 0x1F,
    Boolean = 0x01,
    Integer = 0x02,
    BitString = 0x03,
    OctetString = 0x04,
    ObjectIdentifier = 0x06,
    Enumerated = 0x0A,
    Sequence = 0x10,
}

const TAG_MASK: u8 = 0x1F;

pub fn sizeof_sequence(length: u16) -> u16 {
    1 + sizeof_length(length) + length
}

pub fn sizeof_sequence_tag(length: u16) -> u16 {
    1 + sizeof_length(length)
}

pub fn sizeof_contextual_tag(length: u16) -> u16 {
    1 + sizeof_length(length)
}

pub fn sizeof_octet_string(length: u16) -> u16 {
    1 + sizeof_length(length) + length
}

pub fn sizeof_sequence_octet_string(length: u16) -> u16 {
    sizeof_contextual_tag(sizeof_octet_string(length)) + sizeof_octet_string(length)
}

pub fn sizeof_integer(value: u32) -> u16 {
    if value < 0x80 {
        3
    } else if value < 0x8000 {
        4
    } else if value < 0x0080_0000 {
        5
    } else {
        6
    }
}

pub fn write_sequence_tag(mut stream: impl io::Write, length: u16) -> io::Result<usize> {
    write_universal_tag(&mut stream, Tag::Sequence, Pc::Construct)?;
    write_length(stream, length).map(|length| length + 1)
}

pub fn read_sequence_tag(mut stream: impl io::Read) -> io::Result<u16> {
    let identifier = stream.read_u8()?;

    if identifier != Class::Universal as u8 | Pc::Construct as u8 | (TAG_MASK & Tag::Sequence as u8) {
        Err(io::Error::new(
            io::ErrorKind::InvalidData,
            "invalid sequence tag identifier",
        ))
    } else {
        read_length(stream)
    }
}

pub fn write_contextual_tag(mut stream: impl io::Write, tagnum: u8, length: u16, pc: Pc) -> io::Result<usize> {
    let identifier = Class::ContextSpecific as u8 | pc as u8 | (TAG_MASK & tagnum);
    stream.write_u8(identifier)?;

    write_length(stream, length).map(|length| length + 1)
}

pub fn read_contextual_tag(mut stream: impl io::Read, tagnum: u8, pc: Pc) -> io::Result<u16> {
    let identifier = stream.read_u8()?;

    if identifier != Class::ContextSpecific as u8 | pc as u8 | (TAG_MASK & tagnum) {
        Err(io::Error::new(
            io::ErrorKind::InvalidData,
            "invalid contextual tag identifier",
        ))
    } else {
        read_length(stream)
    }
}

pub fn read_contextual_tag_or_unwind(
    mut stream: impl io::Read + io::Seek,
    tagnum: u8,
    pc: Pc,
) -> io::Result<Option<u16>> {
    match read_contextual_tag(&mut stream, tagnum, pc) {
        Ok(contextual_tag_len) => Ok(Some(contextual_tag_len)),
        Err(_) => {
            stream.seek(io::SeekFrom::Current(-1))?;

            Ok(None)
        }
    }
}

pub fn write_integer(mut stream: impl io::Write, value: u32) -> io::Result<usize> {
    write_universal_tag(&mut stream, Tag::Integer, Pc::Primitive)?;

    if value < 0x80 {
        write_length(&mut stream, 1)?;
        stream.write_u8(value as u8)?;

        Ok(3)
    } else if value < 0x8000 {
        write_length(&mut stream, 2)?;
        stream.write_u16::<BigEndian>(value as u16)?;

        Ok(4)
    } else if value < 0x0080_0000 {
        write_length(&mut stream, 3)?;
        stream.write_u8((value >> 16) as u8)?;
        stream.write_u16::<BigEndian>((value & 0xFFFF) as u16)?;

        Ok(5)
    } else {
        write_length(&mut stream, 4)?;
        stream.write_u32::<BigEndian>(value)?;

        Ok(6)
    }
}

pub fn read_integer(mut stream: impl io::Read) -> io::Result<u64> {
    read_universal_tag(&mut stream, Tag::Integer, Pc::Primitive)?;
    let length = read_length(&mut stream)?;

    if length == 1 {
        stream.read_u8().map(u64::from)
    } else if length == 2 {
        stream.read_u16::<BigEndian>().map(u64::from)
    } else if length == 3 {
        let a = stream.read_u8()?;
        let b = stream.read_u16::<BigEndian>()?;

        Ok(u64::from(b) + (u64::from(a) << 16))
    } else if length == 4 {
        stream.read_u32::<BigEndian>().map(u64::from)
    } else if length == 8 {
        stream.read_u64::<BigEndian>()
    } else {
        Err(io::Error::new(io::ErrorKind::InvalidData, "invalid integer len"))
    }
}

pub fn write_sequence_octet_string(mut stream: impl io::Write, tagnum: u8, value: &[u8]) -> io::Result<usize> {
    let tag_len = write_contextual_tag(
        &mut stream,
        tagnum,
        sizeof_octet_string(value.len() as u16),
        Pc::Construct,
    )?;
    let string_len = write_octet_string(&mut stream, value)?;

    Ok(tag_len + string_len)
}

pub fn write_octet_string(mut stream: impl io::Write, value: &[u8]) -> io::Result<usize> {
    let tag_size = write_octet_string_tag(&mut stream, value.len() as u16)?;
    stream.write_all(value)?;
    Ok(tag_size + value.len())
}

pub fn write_octet_string_tag(mut stream: impl io::Write, length: u16) -> io::Result<usize> {
    write_universal_tag(&mut stream, Tag::OctetString, Pc::Primitive)?;
    write_length(&mut stream, length).map(|length| length + 1)
}

pub fn read_octet_string_tag(mut stream: impl io::Read) -> io::Result<u16> {
    read_universal_tag(&mut stream, Tag::OctetString, Pc::Primitive)?;
    read_length(stream)
}

fn write_universal_tag(mut stream: impl io::Write, tag: Tag, pc: Pc) -> io::Result<usize> {
    let identifier = Class::Universal as u8 | pc as u8 | (TAG_MASK & tag as u8);
    stream.write_u8(identifier)?;

    Ok(1)
}

fn read_universal_tag(mut stream: impl io::Read, tag: Tag, pc: Pc) -> io::Result<()> {
    let identifier = stream.read_u8()?;

    if identifier != Class::Universal as u8 | pc as u8 | (TAG_MASK & tag as u8) {
        Err(io::Error::new(
            io::ErrorKind::InvalidData,
            "invalid universal tag identifier",
        ))
    } else {
        Ok(())
    }
}

fn write_length(mut stream: impl io::Write, length: u16) -> io::Result<usize> {
    if length > 0xFF {
        stream.write_u8(0x80 ^ 0x2)?;
        stream.write_u16::<BigEndian>(length)?;

        Ok(3)
    } else if length > 0x7F {
        stream.write_u8(0x80 ^ 0x1)?;
        stream.write_u8(length as u8)?;

        Ok(2)
    } else {
        stream.write_u8(length as u8)?;

        Ok(1)
    }
}

fn read_length(mut stream: impl io::Read) -> io::Result<u16> {
    let byte = stream.read_u8()?;

    if byte & 0x80 != 0 {
        let len = byte & !0x80;

        if len == 1 {
            stream.read_u8().map(u16::from)
        } else if len == 2 {
            let length = stream.read_u16::<BigEndian>()?;

            // u16 should be capable to hold the ASN1 structure length
            // this condition checks that length is not too big for the u16 type
            if length > u16::MAX - 1 /* tag byte */ - sizeof_length(length) {
                return Err(io::Error::new(io::ErrorKind::InvalidData, "the length is too big"));
            }

            Ok(length)
        } else {
            Err(io::Error::new(
                io::ErrorKind::InvalidData,
                "invalid length of the length",
            ))
        }
    } else {
        Ok(u16::from(byte))
    }
}

fn sizeof_length(length: u16) -> u16 {
    if length > 0xff {
        3
    } else if length > 0x7f {
        2
    } else {
        1
    }
}


--- File: src/ber/tests.rs ---
use super::*;

#[test]
fn write_sequence_tag_is_correct() {
    let mut buf = Vec::new();
    assert_eq!(write_sequence_tag(&mut buf, 0x100).unwrap(), 4);
    assert_eq!(buf, vec![0x30, 0x82, 0x01, 0x00]);
}

#[test]
fn read_sequence_tag_returns_correct_length() {
    let buf = vec![0x30, 0x82, 0x01, 0x00];
    assert_eq!(read_sequence_tag(&mut buf.as_slice()).unwrap(), 0x100);
}

#[test]
fn read_sequence_tag_returns_error_on_invalid_tag() {
    let buf = vec![0x3a, 0x82, 0x01, 0x00];
    assert_eq!(
        read_sequence_tag(&mut buf.as_slice()).unwrap_err().kind(),
        io::ErrorKind::InvalidData
    );
}

#[test]
fn write_contextual_tag_constuct_is_correct() {
    let mut buf = Vec::new();
    assert_eq!(write_contextual_tag(&mut buf, 0x3, 0x100, Pc::Construct).unwrap(), 4);
    assert_eq!(buf, vec![0xA3, 0x82, 0x01, 0x00]);
}

#[test]
fn write_contextual_tag_primitive_is_correct() {
    let mut buf = Vec::new();
    assert_eq!(write_contextual_tag(&mut buf, 0x4, 0xF0, Pc::Primitive).unwrap(), 3);
    assert_eq!(buf, vec![0x84, 0x81, 0xF0]);
}

#[test]
fn read_contextual_tag_returns_correct_length() {
    let buf = vec![0xA3, 0x82, 0x01, 0x00];
    assert_eq!(
        read_contextual_tag(&mut buf.as_slice(), 0x3, Pc::Construct).unwrap(),
        0x100
    );
}

#[test]
fn read_contextual_tag_returns_error_on_invalid_tag() {
    let buf = vec![0xA3, 0x82, 0x01, 0x00];
    assert_eq!(
        read_contextual_tag(&mut buf.as_slice(), 0x2, Pc::Construct)
            .unwrap_err()
            .kind(),
        io::ErrorKind::InvalidData
    );
}

#[test]
fn write_octet_string_tag_is_correct() {
    let mut buf = Vec::new();
    assert_eq!(write_octet_string_tag(&mut buf, 0x0F).unwrap(), 2);
    assert_eq!(buf, vec![0x04, 0x0F]);
}

#[test]
fn read_octet_string_tag_is_correct() {
    let buf = vec![0x04, 0x0F];
    assert_eq!(read_octet_string_tag(&mut buf.as_slice()).unwrap(), 0x0F);
}

#[test]
fn read_octet_string_tag_returns_error_on_wrong_tag() {
    let buf = vec![0x05, 0x0F];
    assert_eq!(
        read_octet_string_tag(&mut buf.as_slice()).unwrap_err().kind(),
        io::ErrorKind::InvalidData
    );
}

#[test]
fn write_octet_string_is_correct() {
    let mut buf = Vec::new();
    let string = [0x68, 0x65, 0x6c, 0x6c, 0x6f];
    let expected: Vec<_> = [0x04, 0x05].iter().chain(string.iter()).cloned().collect();
    assert_eq!(write_octet_string(&mut buf, &string).unwrap(), 7);
    assert_eq!(buf, expected);
}

#[test]
fn write_sequence_octet_string_is_correct() {
    let mut buf = Vec::new();
    let string = [0x68, 0x65, 0x6c, 0x6c, 0x6f];
    let expected: Vec<_> = [0xA3, 0x07, 0x04, 0x05].iter().chain(string.iter()).cloned().collect();
    assert_eq!(write_sequence_octet_string(&mut buf, 0x03, &string).unwrap(), 9);
    assert_eq!(buf, expected);
}

#[test]
fn write_length_is_correct_with_3_byte_length() {
    let mut buf = Vec::new();
    assert_eq!(write_length(&mut buf, 0x100).unwrap(), 3);
    assert_eq!(buf, vec![0x82, 0x01, 0x00]);
}

#[test]
fn write_length_is_correct_with_2_byte_length() {
    let mut buf = Vec::new();
    assert_eq!(write_length(&mut buf, 0xFA).unwrap(), 2);
    assert_eq!(buf, vec![0x81, 0xFA]);
}

#[test]
fn write_length_is_correct_with_1_byte_length() {
    let mut buf = Vec::new();
    assert_eq!(write_length(&mut buf, 0x70).unwrap(), 1);
    assert_eq!(buf, vec![0x70]);
}

#[test]
fn read_length_is_correct_with_3_byte_length() {
    let buf = vec![0x82, 0x01, 0x00];
    assert_eq!(read_length(&mut buf.as_slice()).unwrap(), 0x100);
}

#[test]
fn read_length_is_correct_with_2_byte_length() {
    let buf = vec![0x81, 0xFA];
    assert_eq!(read_length(&mut buf.as_slice()).unwrap(), 0xFA);
}

#[test]
fn read_length_is_correct_with_1_byte_length() {
    let buf = vec![0x70];
    assert_eq!(read_length(&mut buf.as_slice()).unwrap(), 0x70);
}

#[test]
fn read_length_returns_error_on_invalid_length() {
    let buf = vec![0x8a, 0x1];
    assert_eq!(
        read_length(&mut buf.as_slice()).unwrap_err().kind(),
        io::ErrorKind::InvalidData
    );
}

#[test]
fn write_integer_is_correct_with_4_byte_integer() {
    let mut buf = Vec::new();
    assert_eq!(write_integer(&mut buf, 0x0080_0000).unwrap(), 6);
    assert_eq!(buf, vec![0x02, 0x04, 0x00, 0x80, 0x00, 0x00]);
}

#[test]
fn write_integer_is_correct_with_3_byte_integer() {
    let mut buf = Vec::new();
    assert_eq!(write_integer(&mut buf, 0x80000).unwrap(), 5);
    assert_eq!(buf, vec![0x02, 0x03, 0x08, 0x00, 0x00]);
}

#[test]
fn write_integer_is_correct_with_2_byte_integer() {
    let mut buf = Vec::new();
    assert_eq!(write_integer(&mut buf, 0x800).unwrap(), 4);
    assert_eq!(buf, vec![0x02, 0x02, 0x08, 0x00]);
}

#[test]
fn write_integer_is_correct_with_1_byte_integer() {
    let mut buf = Vec::new();
    assert_eq!(write_integer(&mut buf, 0x79).unwrap(), 3);
    assert_eq!(buf, vec![0x02, 0x01, 0x79]);
}

#[test]
fn read_integer_is_correct_with_8_byte_integer() {
    let buf = vec![0x02, 0x08, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    assert_eq!(read_integer(&mut buf.as_slice()).unwrap(), 0x0080_0000_0000_0000);
}

#[test]
fn read_integer_is_correct_with_4_byte_integer() {
    let buf = vec![0x02, 0x04, 0x00, 0x80, 0x00, 0x00];
    assert_eq!(read_integer(&mut buf.as_slice()).unwrap(), 0x0080_0000);
}

#[test]
fn read_integer_is_correct_with_3_byte_integer() {
    let buf = vec![0x02, 0x03, 0x08, 0x00, 0x00];
    assert_eq!(read_integer(&mut buf.as_slice()).unwrap(), 0x80000);
}

#[test]
fn read_integer_is_correct_with_2_byte_integer() {
    let buf = vec![0x02, 0x02, 0x08, 0x00];
    assert_eq!(read_integer(&mut buf.as_slice()).unwrap(), 0x800);
}

#[test]
fn read_integer_is_correct_with_1_byte_integer() {
    let buf = vec![0x02, 0x01, 0x79];
    assert_eq!(read_integer(&mut buf.as_slice()).unwrap(), 0x79);
}

#[test]
fn read_integer_returns_error_on_incorrect_len() {
    let buf = vec![0x02, 0x06, 0x79];
    assert_eq!(
        read_integer(&mut buf.as_slice()).unwrap_err().kind(),
        io::ErrorKind::InvalidData
    );
}

#[test]
fn write_universal_tag_primitive_integer_is_correct() {
    let mut buf = Vec::new();
    assert_eq!(write_universal_tag(&mut buf, Tag::Integer, Pc::Primitive).unwrap(), 1);
    assert_eq!(buf, vec![0x02]);
}

#[test]
fn write_universal_tag_construct_enumerated_is_correct() {
    let mut buf = Vec::new();
    assert_eq!(
        write_universal_tag(&mut buf, Tag::Enumerated, Pc::Construct).unwrap(),
        1
    );
    assert_eq!(buf, vec![0x2A]);
}

#[test]
fn sizeof_length_with_long_len() {
    let len = 625;
    let expected = 3;
    assert_eq!(sizeof_length(len), expected);
}


--- File: src/builders/accept_sec_context.rs ---
use std::marker::PhantomData;

use time::OffsetDateTime;

use super::{
    ToAssign, WithContextRequirements, WithCredentialsHandle, WithOutput, WithTargetDataRepresentation,
    WithoutContextRequirements, WithoutCredentialsHandle, WithoutOutput, WithoutTargetDataRepresentation,
};
use crate::generator::GeneratorAcceptSecurityContext;
use crate::{DataRepresentation, SecurityBuffer, SecurityStatus, ServerRequestFlags, ServerResponseFlags, SspiPackage};

pub type EmptyAcceptSecurityContext<'a, C> = AcceptSecurityContext<
    'a,
    C,
    WithoutCredentialsHandle,
    WithoutContextRequirements,
    WithoutTargetDataRepresentation,
    WithoutOutput,
>;
pub type FilledAcceptSecurityContext<'a, C> = AcceptSecurityContext<
    'a,
    C,
    WithCredentialsHandle,
    WithContextRequirements,
    WithTargetDataRepresentation,
    WithOutput,
>;

/// Contains data returned by calling the `execute` method of
/// the `AcceptSecurityContextBuilder` structure. The builder is returned by calling
/// the `accept_security_context` method.
#[derive(Debug, Clone)]
pub struct AcceptSecurityContextResult {
    pub status: SecurityStatus,
    pub flags: ServerResponseFlags,
    pub expiry: Option<OffsetDateTime>,
}

/// A builder to execute one of the SSPI functions. Returned by the `accept_security_context` method.
///
/// # Requirements for execution
///
/// These methods are required to be called before calling the `execute` method
/// * [`with_credentials_handle`](struct.AcceptSecurityContext.html#method.with_credentials_handle)
/// * [`with_context_requirements`](struct.AcceptSecurityContext.html#method.with_context_requirements)
/// * [`with_target_data_representation`](struct.AcceptSecurityContext.html#method.with_target_data_representation)
/// * [`with_output`](struct.AcceptSecurityContext.html#method.with_output)
pub struct AcceptSecurityContext<
    'a,
    CredsHandle,
    CredsHandleSet,
    ContextRequirementsSet,
    TargetDataRepresentationSet,
    OutputSet,
> where
    CredsHandleSet: ToAssign,
    ContextRequirementsSet: ToAssign,
    TargetDataRepresentationSet: ToAssign,
    OutputSet: ToAssign,
{
    phantom_creds_use_set: PhantomData<CredsHandleSet>,
    phantom_context_req_set: PhantomData<ContextRequirementsSet>,
    phantom_data_repr_set: PhantomData<TargetDataRepresentationSet>,
    phantom_output_set: PhantomData<OutputSet>,

    pub credentials_handle: Option<&'a mut CredsHandle>,
    pub context_requirements: ServerRequestFlags,
    pub target_data_representation: DataRepresentation,
    pub output: &'a mut [SecurityBuffer],

    pub input: Option<&'a mut [SecurityBuffer]>,
}

impl<
        'a,
        CredsHandle,
        CredsHandleSet: ToAssign,
        ContextRequirementsSet: ToAssign,
        TargetDataRepresentationSet: ToAssign,
        OutputSet: ToAssign,
    >
    AcceptSecurityContext<
        'a,
        CredsHandle,
        CredsHandleSet,
        ContextRequirementsSet,
        TargetDataRepresentationSet,
        OutputSet,
    >
{
    pub(crate) fn new() -> Self {
        AcceptSecurityContext {
            phantom_creds_use_set: PhantomData,
            phantom_context_req_set: PhantomData,
            phantom_data_repr_set: PhantomData,
            phantom_output_set: PhantomData,

            credentials_handle: None,
            context_requirements: ServerRequestFlags::empty(),
            target_data_representation: DataRepresentation::Network,

            output: &mut [],
            input: None,
        }
    }

    /// Specifies the server credentials. To retrieve this handle, the server calls the `acquire_credentials_handle`
    /// method with either the `CredentialUse::Inbound` or `CredentialUse::Outbound` flag set.
    pub fn with_credentials_handle(
        self,
        credentials_handle: &'a mut CredsHandle,
    ) -> AcceptSecurityContext<
        'a,
        CredsHandle,
        WithCredentialsHandle,
        ContextRequirementsSet,
        TargetDataRepresentationSet,
        OutputSet,
    > {
        AcceptSecurityContext {
            phantom_creds_use_set: PhantomData,
            phantom_context_req_set: PhantomData,
            phantom_data_repr_set: PhantomData,
            phantom_output_set: PhantomData,

            credentials_handle: Some(credentials_handle),
            context_requirements: self.context_requirements,
            target_data_representation: self.target_data_representation,
            output: self.output,

            input: self.input,
        }
    }

    /// Specifies bit flags that specify the attributes required by the server to establish the context.
    pub fn with_context_requirements(
        self,
        context_requirements: ServerRequestFlags,
    ) -> AcceptSecurityContext<
        'a,
        CredsHandle,
        CredsHandleSet,
        WithContextRequirements,
        TargetDataRepresentationSet,
        OutputSet,
    > {
        AcceptSecurityContext {
            phantom_creds_use_set: PhantomData,
            phantom_context_req_set: PhantomData,
            phantom_data_repr_set: PhantomData,
            phantom_output_set: PhantomData,

            credentials_handle: self.credentials_handle,
            context_requirements,
            target_data_representation: self.target_data_representation,
            output: self.output,

            input: self.input,
        }
    }

    /// Specifies the data representation, such as byte ordering, on the target.
    pub fn with_target_data_representation(
        self,
        target_data_representation: DataRepresentation,
    ) -> AcceptSecurityContext<
        'a,
        CredsHandle,
        CredsHandleSet,
        ContextRequirementsSet,
        WithTargetDataRepresentation,
        OutputSet,
    > {
        AcceptSecurityContext {
            phantom_creds_use_set: PhantomData,
            phantom_context_req_set: PhantomData,
            phantom_data_repr_set: PhantomData,
            phantom_output_set: PhantomData,

            credentials_handle: self.credentials_handle,
            context_requirements: self.context_requirements,
            target_data_representation,
            output: self.output,

            input: self.input,
        }
    }

    /// Specifies a mutable reference to a buffer with [SecurityBuffer] that contains the output buffer descriptor.
    /// This buffer is sent to the client for input into additional calls to `initialize_security_context`. An output
    /// buffer may be generated even if the function returns `SecurityStatus::Ok`. Any buffer generated must be sent
    /// back to the client application.
    pub fn with_output(
        self,
        output: &'a mut [SecurityBuffer],
    ) -> AcceptSecurityContext<
        'a,
        CredsHandle,
        CredsHandleSet,
        ContextRequirementsSet,
        TargetDataRepresentationSet,
        WithOutput,
    > {
        AcceptSecurityContext {
            phantom_creds_use_set: PhantomData,
            phantom_context_req_set: PhantomData,
            phantom_data_repr_set: PhantomData,
            phantom_output_set: PhantomData,

            credentials_handle: self.credentials_handle,
            context_requirements: self.context_requirements,
            target_data_representation: self.target_data_representation,
            output,

            input: self.input,
        }
    }

    /// Specifies a mutable reference to an [SecurityBuffer] generated by a client call to `initialize_security_context`.
    /// The structure contains the input buffer descriptor.
    pub fn with_input(self, input: &'a mut [SecurityBuffer]) -> Self {
        Self {
            input: Some(input),
            ..self
        }
    }
}

impl<'b, 'a: 'b, CredsHandle> FilledAcceptSecurityContext<'a, CredsHandle> {
    /// Transforms the builder into new one with the other `AuthData` and `CredsHandle` types.
    /// Useful when we need to pass the builder into the security package with other `AuthData` and `CredsHandle` types.
    pub(crate) fn full_transform<CredsHandle2>(
        self,
        credentials_handle: Option<&'b mut CredsHandle2>,
    ) -> FilledAcceptSecurityContext<'b, CredsHandle2> {
        AcceptSecurityContext {
            phantom_creds_use_set: PhantomData,
            phantom_context_req_set: PhantomData,
            phantom_data_repr_set: PhantomData,
            phantom_output_set: PhantomData,

            credentials_handle,
            context_requirements: self.context_requirements,
            target_data_representation: self.target_data_representation,

            output: self.output,
            input: self.input,
        }
    }
}

impl<'a, CredsHandle> FilledAcceptSecurityContext<'a, CredsHandle> {
    /// Executes the SSPI function that the builder represents.
    pub fn execute<AuthData>(
        self,
        inner: SspiPackage<'a, CredsHandle, AuthData>,
    ) -> crate::Result<GeneratorAcceptSecurityContext<'a>> {
        inner.accept_security_context_impl(self)
    }
}


--- File: src/builders/acq_cred_handle.rs ---
use std::fmt::Debug;
use std::marker::PhantomData;

use time::OffsetDateTime;

use super::{Assigned, NotAssigned, ToAssign};
use crate::{CredentialUse, Luid, SspiPackage};

pub type EmptyAcquireCredentialsHandle<'a, C, A> = AcquireCredentialsHandle<'a, C, A, WithoutCredentialUse>;
pub type FilledAcquireCredentialsHandle<'a, C, A> = AcquireCredentialsHandle<'a, C, A, WithCredentialUse>;

/// Contains data returned by calling the `execute` method of
/// the `AcquireCredentialsHandleBuilder` structure. The builder is returned by calling
/// the `acquire_credentials_handle` method.
#[derive(Debug, Clone)]
pub struct AcquireCredentialsHandleResult<C> {
    pub credentials_handle: C,
    pub expiry: Option<OffsetDateTime>,
}

// we cannot replace it with the `From` trait implementation due to conflict with blanked impl in the std
impl<T> AcquireCredentialsHandleResult<T> {
    pub fn transform_credentials_handle<T2>(self, transformer: &dyn Fn(T) -> T2) -> AcquireCredentialsHandleResult<T2> {
        let Self {
            credentials_handle,
            expiry,
        } = self;
        AcquireCredentialsHandleResult {
            credentials_handle: transformer(credentials_handle),
            expiry,
        }
    }
}

/// A builder to execute one of the SSPI functions. Returned by the `acquire_credentials_handle` method.
///
/// # Requirements for execution
///
/// These methods are required to be called before calling the `execute` method
/// * [`with_credential_use`](struct.AcquireCredentialsHandle.html#method.with_credential_use)
pub struct AcquireCredentialsHandle<'a, CredsHandle, AuthData, CredentialUseSet>
where
    CredentialUseSet: ToAssign,
{
    pub(crate) phantom_cred_handle: PhantomData<CredsHandle>,
    pub(crate) phantom_cred_use_set: PhantomData<CredentialUseSet>,

    pub credential_use: CredentialUse,

    pub principal_name: Option<&'a str>,
    pub logon_id: Option<Luid>,
    pub auth_data: Option<&'a AuthData>,
}

impl<CredsHandle, AuthData, CredentialUseSet> Debug
    for AcquireCredentialsHandle<'_, CredsHandle, AuthData, CredentialUseSet>
where
    CredentialUseSet: ToAssign,
    AuthData: Debug,
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("AcquireCredentialsHandle")
            .field("phantom_cred_handle", &self.phantom_cred_handle)
            .field("phantom_cred_use_set", &self.phantom_cred_use_set)
            .field("credential_use", &self.credential_use)
            .field("principal_name", &self.principal_name)
            .field("logon_id", &self.logon_id)
            .field("auth_data", &self.auth_data)
            .finish()
    }
}

impl<'a, CredsHandle, AuthData, CredentialUseSet> AcquireCredentialsHandle<'a, CredsHandle, AuthData, CredentialUseSet>
where
    CredentialUseSet: ToAssign,
{
    pub fn new() -> Self {
        Self {
            phantom_cred_handle: PhantomData,
            phantom_cred_use_set: PhantomData,

            principal_name: None,
            credential_use: CredentialUse::Inbound,
            logon_id: None,
            auth_data: None,
        }
    }

    /// Specifies a flag that indicates how these credentials will be used.
    pub fn with_credential_use(
        self,
        credential_use: CredentialUse,
    ) -> AcquireCredentialsHandle<'a, CredsHandle, AuthData, WithCredentialUse> {
        AcquireCredentialsHandle {
            phantom_cred_handle: PhantomData,
            phantom_cred_use_set: PhantomData,

            principal_name: self.principal_name,
            credential_use,
            logon_id: self.logon_id,
            auth_data: self.auth_data,
        }
    }

    /// Specifies a string that specifies the name of the principal whose credentials the handle will reference.
    pub fn with_principal_name(self, principal_name: &'a str) -> Self {
        Self {
            principal_name: Some(principal_name),
            ..self
        }
    }

    /// Specifies a LUID that identifies the user. This parameter is provided for file-system processes such as network
    /// redirectors.
    pub fn with_logon_id(self, logon_id: Luid) -> Self {
        Self {
            logon_id: Some(logon_id),
            ..self
        }
    }

    /// Specifies a reference to the structure that specifies authentication data for both Schannel and Negotiate packages.
    pub fn with_auth_data(self, auth_data: &'a AuthData) -> Self {
        Self {
            auth_data: Some(auth_data),
            ..self
        }
    }
}

impl<CredsHandle, AuthData, CredentialUseSet> Default
    for AcquireCredentialsHandle<'_, CredsHandle, AuthData, CredentialUseSet>
where
    CredentialUseSet: ToAssign,
{
    fn default() -> Self {
        Self::new()
    }
}

impl<'b, 'a: 'b, CredsHandle, AuthData> FilledAcquireCredentialsHandle<'a, CredsHandle, AuthData> {
    /// Transforms the builder into new one with the other `AuthData` and `CredsHandle` types.
    /// Useful when we need to pass the builder into the security package with other `AuthData` and `CredsHandle` types.
    pub(crate) fn full_transform<NewCredsHandle, NewAuthData>(
        self,
        auth_data: Option<&'b NewAuthData>,
    ) -> FilledAcquireCredentialsHandle<'b, NewCredsHandle, NewAuthData> {
        AcquireCredentialsHandle {
            phantom_cred_handle: PhantomData,
            phantom_cred_use_set: PhantomData,

            principal_name: self.principal_name,
            credential_use: self.credential_use,
            logon_id: self.logon_id,
            auth_data,
        }
    }
}

impl<CredsHandle, AuthData> FilledAcquireCredentialsHandle<'_, CredsHandle, AuthData> {
    /// Executes the SSPI function that the builder represents.
    pub fn execute(
        self,
        inner: SspiPackage<'_, CredsHandle, AuthData>,
    ) -> crate::Result<AcquireCredentialsHandleResult<CredsHandle>> {
        inner.acquire_credentials_handle_impl(self)
    }
}

/// Simulates the presence of the `credential_use` value of the
/// `AcquireCredentialsHandle` builder.
#[derive(Debug)]
pub struct WithCredentialUse;
impl ToAssign for WithCredentialUse {}
impl Assigned for WithCredentialUse {}

/// Simulates the absence of the `credential_use` value of the
/// `AcquireCredentialsHandle` builder.
#[derive(Debug)]
pub struct WithoutCredentialUse;
impl ToAssign for WithoutCredentialUse {}
impl NotAssigned for WithoutCredentialUse {}


--- File: src/builders/change_password.rs ---
use std::cell::RefCell;
use std::ops::DerefMut;

use crate::{Error, ErrorKind, Result, Secret, SecurityBuffer};

pub struct ChangePassword<'a> {
    pub domain_name: String,
    pub account_name: String,
    pub old_password: Secret<String>,
    pub new_password: Secret<String>,
    pub impersonating: bool,
    pub output: &'a mut [SecurityBuffer],
}

#[derive(Default)]
struct ChangePasswordBuilderInner<'a> {
    domain_name: Option<String>,
    account_name: Option<String>,
    old_password: Option<Secret<String>>,
    new_password: Option<Secret<String>>,
    impersonating: bool,
    output: Option<&'a mut [SecurityBuffer]>,
}

pub struct ChangePasswordBuilder<'a> {
    inner: RefCell<ChangePasswordBuilderInner<'a>>,
}

impl<'a> ChangePasswordBuilder<'a> {
    pub fn new() -> Self {
        Self {
            inner: RefCell::new(ChangePasswordBuilderInner::default()),
        }
    }

    /// Required
    pub fn with_domain_name(&self, domain_name: impl Into<String>) -> &Self {
        self.inner.borrow_mut().domain_name = Some(domain_name.into());
        self
    }

    /// Required
    pub fn with_account_name(&self, account_name: impl Into<String>) -> &Self {
        self.inner.borrow_mut().account_name = Some(account_name.into());
        self
    }

    /// Required
    pub fn with_old_password(&self, old_password: impl Into<String>) -> &Self {
        self.inner.borrow_mut().old_password = Some(old_password.into().into());
        self
    }

    /// Required
    pub fn with_new_password(&self, new_password: impl Into<String>) -> &Self {
        self.inner.borrow_mut().new_password = Some(new_password.into().into());
        self
    }

    /// Optional(default to false if not set)
    pub fn with_impersonating(&self, impersonating: bool) -> &Self {
        self.inner.borrow_mut().impersonating = impersonating;
        self
    }

    /// Required
    pub fn with_output(&self, output: &'a mut [SecurityBuffer]) -> &Self {
        self.inner.borrow_mut().output = Some(output);
        self
    }

    pub fn build(&self) -> Result<ChangePassword<'a>> {
        let mut inner = self.inner.borrow_mut();

        let ChangePasswordBuilderInner {
            domain_name,
            account_name,
            old_password,
            new_password,
            impersonating,
            output,
        } = inner.deref_mut();

        Ok(ChangePassword {
            domain_name: domain_name
                .take()
                .ok_or_else(|| Error::new(ErrorKind::InvalidParameter, "Missing domain_name parameter"))?,
            account_name: account_name
                .take()
                .ok_or_else(|| Error::new(ErrorKind::InvalidParameter, "Missing account_name parameter"))?,
            old_password: old_password
                .take()
                .ok_or_else(|| Error::new(ErrorKind::InvalidParameter, "Missing old_password parameter"))?,
            new_password: new_password
                .take()
                .ok_or_else(|| Error::new(ErrorKind::InvalidParameter, "Missing new_password parameter"))?,
            impersonating: *impersonating,
            output: output
                .take()
                .ok_or_else(|| Error::new(ErrorKind::InvalidParameter, "Missing output parameter"))?,
        })
    }
}

impl Default for ChangePasswordBuilder<'_> {
    fn default() -> Self {
        Self::new()
    }
}


--- File: src/builders/init_sec_context.rs ---
use std::marker::PhantomData;
use std::mem;

use time::OffsetDateTime;

use super::{
    ToAssign, WithContextRequirements, WithCredentialsHandle, WithOutput, WithTargetDataRepresentation,
    WithoutContextRequirements, WithoutCredentialsHandle, WithoutOutput, WithoutTargetDataRepresentation,
};
use crate::{ClientRequestFlags, ClientResponseFlags, DataRepresentation, SecurityBuffer, SecurityStatus};

pub type EmptyInitializeSecurityContext<'a, C> = InitializeSecurityContext<
    'a,
    C,
    WithoutCredentialsHandle,
    WithoutContextRequirements,
    WithoutTargetDataRepresentation,
    WithoutOutput,
>;
pub type FilledInitializeSecurityContext<'a, C> = InitializeSecurityContext<
    'a,
    C,
    WithCredentialsHandle,
    WithContextRequirements,
    WithTargetDataRepresentation,
    WithOutput,
>;

/// Contains data returned by calling the `execute` method of
/// the `InitializeSecurityContextBuilder` structure. The builder is returned by calling
/// the `initialize_security_context` method.
#[derive(Debug, Clone)]
pub struct InitializeSecurityContextResult {
    pub status: SecurityStatus,
    pub flags: ClientResponseFlags,
    pub expiry: Option<OffsetDateTime>,
}

/// A builder to execute one of the SSPI functions. Returned by the `initialize_security_context` method.
///
/// # Requirements for execution
///
/// These methods are required to be called before calling the `execute` method
/// * [`with_credentials_handle`](struct.InitializeSecurityContext.html#method.with_credentials_handle)
/// * [`with_context_requirements`](struct.InitializeSecurityContext.html#method.with_context_requirements)
/// * [`with_target_data_representation`](struct.InitializeSecurityContext.html#method.with_target_data_representation)
/// * [`with_output`](struct.InitializeSecurityContext.html#method.with_output)
#[derive(Debug)]
pub struct InitializeSecurityContext<
    'a,
    CredsHandle,
    CredsHandleSet,
    ContextRequirementsSet,
    TargetDataRepresentationSet,
    OutputSet,
> where
    CredsHandleSet: ToAssign,
    ContextRequirementsSet: ToAssign,
    TargetDataRepresentationSet: ToAssign,
    OutputSet: ToAssign,
{
    phantom_creds_use_set: PhantomData<CredsHandleSet>,
    phantom_context_req_set: PhantomData<ContextRequirementsSet>,
    phantom_data_repr_set: PhantomData<TargetDataRepresentationSet>,
    phantom_output_set: PhantomData<OutputSet>,

    pub credentials_handle: Option<&'a mut CredsHandle>,
    pub context_requirements: ClientRequestFlags,
    pub target_data_representation: DataRepresentation,
    pub output: &'a mut [SecurityBuffer],

    pub target_name: Option<&'a str>,
    pub input: Option<&'a mut [SecurityBuffer]>,
}

impl<
        'b,
        'a: 'b,
        CredsHandle,
        CredsHandleSet: ToAssign,
        ContextRequirementsSet: ToAssign,
        TargetDataRepresentationSet: ToAssign,
        OutputSet: ToAssign,
    >
    InitializeSecurityContext<
        'a,
        CredsHandle,
        CredsHandleSet,
        ContextRequirementsSet,
        TargetDataRepresentationSet,
        OutputSet,
    >
{
    /// Creates a new builder with the other `AuthData` and `CredsHandle` types.
    /// References to the input and output buffers will be moved to the created builder leaving the `None` instead.
    pub fn full_transform<CredsHandle2, CredHandleSet2: ToAssign>(
        &mut self,
        credentials_handle: Option<&'b mut CredsHandle2>,
    ) -> InitializeSecurityContext<
        'b,
        CredsHandle2,
        CredHandleSet2,
        ContextRequirementsSet,
        TargetDataRepresentationSet,
        OutputSet,
    > {
        InitializeSecurityContext {
            phantom_creds_use_set: PhantomData,
            phantom_context_req_set: PhantomData,
            phantom_data_repr_set: PhantomData,
            phantom_output_set: PhantomData,

            credentials_handle,
            context_requirements: self.context_requirements,
            target_data_representation: self.target_data_representation,
            output: mem::take(&mut self.output),
            target_name: self.target_name,
            input: mem::take(&mut self.input),
        }
    }
}

impl<
        'a,
        CredsHandle,
        CredsHandleSet: ToAssign,
        ContextRequirementsSet: ToAssign,
        TargetDataRepresentationSet: ToAssign,
        OutputSet: ToAssign,
    >
    InitializeSecurityContext<
        'a,
        CredsHandle,
        CredsHandleSet,
        ContextRequirementsSet,
        TargetDataRepresentationSet,
        OutputSet,
    >
{
    pub fn credentials_handle_mut(&mut self) -> &mut Option<&'a mut CredsHandle> {
        &mut self.credentials_handle
    }

    pub fn credentials_handle(&mut self) -> &Option<&'a mut CredsHandle> {
        &self.credentials_handle
    }

    pub(crate) fn new() -> Self {
        Self {
            phantom_creds_use_set: PhantomData,
            phantom_context_req_set: PhantomData,
            phantom_data_repr_set: PhantomData,
            phantom_output_set: PhantomData,

            credentials_handle: None,
            context_requirements: ClientRequestFlags::empty(),
            target_data_representation: DataRepresentation::Network,
            output: &mut [],

            target_name: None,
            input: None,
        }
    }

    /// Specifies a handle to the credentials returned by `acquire_credentials_handle`. This handle is used
    /// to build the security context. The builder requires at least `CredentialUse::Outbound` credentials.
    pub fn with_credentials_handle(
        self,
        credentials_handle: &'a mut CredsHandle,
    ) -> InitializeSecurityContext<
        'a,
        CredsHandle,
        WithCredentialsHandle,
        ContextRequirementsSet,
        TargetDataRepresentationSet,
        OutputSet,
    > {
        InitializeSecurityContext {
            phantom_creds_use_set: PhantomData,
            phantom_context_req_set: PhantomData,
            phantom_data_repr_set: PhantomData,
            phantom_output_set: PhantomData,

            credentials_handle: Some(credentials_handle),
            context_requirements: self.context_requirements,
            target_data_representation: self.target_data_representation,
            output: self.output,

            target_name: self.target_name,
            input: self.input,
        }
    }

    /// Specifies bit flags that indicate requests for the context. Not all packages can support all requirements.
    pub fn with_context_requirements(
        self,
        context_requirements: ClientRequestFlags,
    ) -> InitializeSecurityContext<
        'a,
        CredsHandle,
        CredsHandleSet,
        WithContextRequirements,
        TargetDataRepresentationSet,
        OutputSet,
    > {
        InitializeSecurityContext {
            phantom_creds_use_set: PhantomData,
            phantom_context_req_set: PhantomData,
            phantom_data_repr_set: PhantomData,
            phantom_output_set: PhantomData,

            credentials_handle: self.credentials_handle,
            context_requirements,
            target_data_representation: self.target_data_representation,
            output: self.output,

            target_name: self.target_name,
            input: self.input,
        }
    }

    /// Specifies the data representation, such as byte ordering, on the target.
    pub fn with_target_data_representation(
        self,
        target_data_representation: DataRepresentation,
    ) -> InitializeSecurityContext<
        'a,
        CredsHandle,
        CredsHandleSet,
        ContextRequirementsSet,
        WithTargetDataRepresentation,
        OutputSet,
    > {
        InitializeSecurityContext {
            phantom_creds_use_set: PhantomData,
            phantom_context_req_set: PhantomData,
            phantom_data_repr_set: PhantomData,
            phantom_output_set: PhantomData,

            credentials_handle: self.credentials_handle,
            context_requirements: self.context_requirements,
            target_data_representation,
            output: self.output,

            target_name: self.target_name,
            input: self.input,
        }
    }

    /// Specifies a mutable reference to a buffer with [SecurityBuffer] that receives the output data.
    pub fn with_output(
        self,
        output: &'a mut [SecurityBuffer],
    ) -> InitializeSecurityContext<
        'a,
        CredsHandle,
        CredsHandleSet,
        ContextRequirementsSet,
        TargetDataRepresentationSet,
        WithOutput,
    > {
        InitializeSecurityContext {
            phantom_creds_use_set: PhantomData,
            phantom_context_req_set: PhantomData,
            phantom_data_repr_set: PhantomData,
            phantom_output_set: PhantomData,

            credentials_handle: self.credentials_handle,
            context_requirements: self.context_requirements,
            target_data_representation: self.target_data_representation,
            output,

            target_name: self.target_name,
            input: self.input,
        }
    }

    pub fn with_target_name(self, target_name: &'a str) -> Self {
        Self {
            target_name: Some(target_name),
            ..self
        }
    }

    /// Specifies a mutable reference to a buffer with [SecurityBuffer] structures. Don't call this method on during
    /// the first execution of the builder. On the second execution, this parameter is a reference to the partially
    /// formed context returned during the first call.
    pub fn with_input(self, input: &'a mut [SecurityBuffer]) -> Self {
        Self {
            input: Some(input),
            ..self
        }
    }
}

impl<
        CredsHandle,
        CredsHandleSet: ToAssign,
        ContextRequirementsSet: ToAssign,
        TargetDataRepresentationSet: ToAssign,
        OutputSet: ToAssign,
    > Default
    for InitializeSecurityContext<
        '_,
        CredsHandle,
        CredsHandleSet,
        ContextRequirementsSet,
        TargetDataRepresentationSet,
        OutputSet,
    >
{
    fn default() -> Self {
        Self::new()
    }
}


--- File: src/builders/mod.rs ---
//! The builders are required to compose and execute some of the `Sspi` methods.

mod accept_sec_context;
mod acq_cred_handle;
mod change_password;
mod init_sec_context;

use std::fmt;

pub use self::accept_sec_context::{
    AcceptSecurityContext, AcceptSecurityContextResult, EmptyAcceptSecurityContext, FilledAcceptSecurityContext,
};
pub use self::acq_cred_handle::{
    AcquireCredentialsHandle, AcquireCredentialsHandleResult, EmptyAcquireCredentialsHandle,
    FilledAcquireCredentialsHandle, WithCredentialUse, WithoutCredentialUse,
};
pub use self::change_password::{ChangePassword, ChangePasswordBuilder};
pub use self::init_sec_context::{
    EmptyInitializeSecurityContext, FilledInitializeSecurityContext, InitializeSecurityContext,
    InitializeSecurityContextResult,
};

/// Allows to represent a value of a builder that is mandatory to be specified (during implementation
/// of the builder).
pub trait ToAssign: fmt::Debug {}
/// Allows to represent a mandatory value of a builder that is already specified (during implementation
/// of the builder).
pub trait Assigned: ToAssign {}
/// Allows to represent a mandatory value that is yet to be specified (during implementation
/// of the builder).
pub trait NotAssigned: ToAssign {}

/// Simulates the presence of a value
///
/// Simulates the presence of the `credentials_handle` value of the
/// `AcceptSecurityContext` and
/// `InitializeSecurityContext` builders.
#[derive(Debug)]
pub struct WithCredentialsHandle;
impl ToAssign for WithCredentialsHandle {}
impl Assigned for WithCredentialsHandle {}

/// Simulates the absence of a value
///
/// Simulates the absence of the `credentials_handle` value of the
/// `AcceptSecurityContext` and
/// `InitializeSecurityContext` builders.
#[derive(Debug)]
pub struct WithoutCredentialsHandle;
impl ToAssign for WithoutCredentialsHandle {}
impl NotAssigned for WithoutCredentialsHandle {}

/// Simulates the presence of a value
///
/// Simulates the presence of the `context_requirements` value of the
/// `AcceptSecurityContext` and
/// `InitializeSecurityContext` builders.
#[derive(Debug)]
pub struct WithContextRequirements;
impl ToAssign for WithContextRequirements {}
impl Assigned for WithContextRequirements {}

/// Simulates the absence of a value
///
/// Simulates the absence of the `context_requirements` value of the
/// `AcceptSecurityContext` and
/// `InitializeSecurityContext` builders.
#[derive(Debug)]
pub struct WithoutContextRequirements;
impl ToAssign for WithoutContextRequirements {}
impl NotAssigned for WithoutContextRequirements {}

/// Simulates the presence of a value
///
/// Simulates the presence of the `target_data_representation` value of the
/// `AcceptSecurityContext` and
/// `InitializeSecurityContext` builders.
#[derive(Debug)]
pub struct WithTargetDataRepresentation;
impl ToAssign for WithTargetDataRepresentation {}
impl Assigned for WithTargetDataRepresentation {}

/// Simulates the absence of a value
///
/// Simulates the absence of the `target_data_representation` value of the
/// `AcceptSecurityContext` and
/// `InitializeSecurityContext` builders.
#[derive(Debug)]
pub struct WithoutTargetDataRepresentation;
impl ToAssign for WithoutTargetDataRepresentation {}
impl NotAssigned for WithoutTargetDataRepresentation {}

/// Simulates the presence of a value
///
/// Simulates the presence of the `output` value of the
/// `AcceptSecurityContext` and
/// `InitializeSecurityContext` builders.
#[derive(Debug)]
pub struct WithOutput;
impl ToAssign for WithOutput {}
impl Assigned for WithOutput {}

/// Simulates the absence of a value
///
/// Simulates the absence of the `output` value of the
/// `AcceptSecurityContext` and
/// `InitializeSecurityContext` builders.
#[derive(Debug)]
pub struct WithoutOutput;
impl ToAssign for WithoutOutput {}
impl NotAssigned for WithoutOutput {}


--- File: src/cert_utils.rs ---
#![cfg(all(feature = "scard", target_os = "windows"))]
#![expect(clippy::missing_safety_doc)]

use std::ffi::c_void;
use std::ptr::{null, null_mut};
use std::slice::from_raw_parts;

use picky_asn1::wrapper::Utf8StringAsn1;
use picky_asn1_x509::{oids, Certificate, ExtensionView, GeneralName};
use sha1::{Digest, Sha1};
use windows_sys::Win32::Security::Cryptography::{
    CertCloseStore, CertEnumCertificatesInStore, CertFreeCertificateContext, CertOpenStore, CryptAcquireContextW,
    CryptDestroyKey, CryptGetKeyParam, CryptGetProvParam, CryptGetUserKey, CryptReleaseContext, AT_KEYEXCHANGE,
    CERT_STORE_PROV_SYSTEM_W, CERT_SYSTEM_STORE_CURRENT_USER_ID, CERT_SYSTEM_STORE_LOCATION_SHIFT, CRYPT_FIRST,
    CRYPT_NEXT, CRYPT_SILENT, KP_CERTIFICATE, PP_ENUMCONTAINERS, PP_SMARTCARD_READER, PROV_RSA_FULL,
};

// UTF-16 encoded "Microsoft Base Smart Card Crypto Provider\0"
const CSP_NAME_W: &[u8] = &[
    77, 0, 105, 0, 99, 0, 114, 0, 111, 0, 115, 0, 111, 0, 102, 0, 116, 0, 32, 0, 66, 0, 97, 0, 115, 0, 101, 0, 32, 0,
    83, 0, 109, 0, 97, 0, 114, 0, 116, 0, 32, 0, 67, 0, 97, 0, 114, 0, 100, 0, 32, 0, 67, 0, 114, 0, 121, 0, 112, 0,
    116, 0, 111, 0, 32, 0, 80, 0, 114, 0, 111, 0, 118, 0, 105, 0, 100, 0, 101, 0, 114, 0, 0, 0,
];
const CSP_NAME: &str = "Microsoft Base Smart Card Crypto Provider";

// https://learn.microsoft.com/en-us/windows/win32/seccrypto/hcryptprov
pub type HCRYPTPROV = usize; // ULONG_PTR
                             // https://learn.microsoft.com/en-us/windows/win32/seccrypto/hcryptkey
pub type HCRYPTKEY = usize; // ULONG_PTR

use crate::{Error, ErrorKind, Result};

#[instrument(level = "trace", ret)]
unsafe fn find_raw_cert_by_thumbprint(thumbprint: &[u8], cert_store: *mut c_void) -> Result<Vec<u8>> {
    let mut certificate = CertEnumCertificatesInStore(cert_store, null_mut());

    while !certificate.is_null() {
        let cert_der = from_raw_parts((*certificate).pbCertEncoded, (*certificate).cbCertEncoded as usize);
        let mut sha1 = Sha1::new();
        sha1.update(cert_der);
        let cert_thumbprint = sha1.finalize().to_vec();

        if cert_thumbprint == thumbprint {
            CertFreeCertificateContext(certificate);

            return Ok(cert_der.to_vec());
        }

        let next_certificate = CertEnumCertificatesInStore(cert_store, certificate);

        certificate = next_certificate;
    }

    Err(Error::new(
        ErrorKind::InternalError,
        "Cannot find appropriate device certificate",
    ))
}

fn open_user_cert_store() -> Result<*mut c_void> {
    // "My\0" encoded as a wide string.
    // More info: https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-certopenstore#remarks
    let my: [u16; 3] = [77, 121, 0];
    // SAFETY:
    // * constant parameters are taken from the `windows_sys` crate. Thus, they are valid;
    // * `dwEncodingType` and `hCryptProv` are allowed to be zero by documentation;
    // * `my` is as valid wide C string.
    let cert_store = unsafe {
        CertOpenStore(
            CERT_STORE_PROV_SYSTEM_W,
            0,
            0,
            CERT_SYSTEM_STORE_CURRENT_USER_ID << CERT_SYSTEM_STORE_LOCATION_SHIFT,
            my.as_ptr() as *const _,
        )
    };

    if cert_store.is_null() {
        return Err(Error::new(
            ErrorKind::InternalError,
            "Cannot initialize certificate store: permission denied",
        ));
    }

    Ok(cert_store)
}

#[instrument(level = "trace", ret)]
pub fn extract_raw_certificate_by_thumbprint(thumbprint: &[u8]) -> Result<Vec<u8>> {
    let cert_store = open_user_cert_store()?;
    // SAFETY: `open_user_cert_store` returns valid store handle.
    let cert = unsafe { find_raw_cert_by_thumbprint(thumbprint, cert_store) }.inspect_err(|_err| {
        // SAFETY: `open_user_cert_store` returns valid store handle that needs to be closed.
        if unsafe { CertCloseStore(cert_store, 0) } == 0 {
            warn!("could not close the certificate store");
        }
    })?;

    // SAFETY: `open_user_cert_store` returns valid store handle that needs to be closed.
    if unsafe { CertCloseStore(cert_store, 0) } == 0 {
        return Err(Error::new(
            ErrorKind::InternalError,
            "could not close the certificate store",
        ));
    }

    Ok(cert)
}

#[instrument(level = "trace", ret)]
pub fn extract_certificate_by_thumbprint(thumbprint: &[u8]) -> Result<(Vec<u8>, Certificate)> {
    let raw_cert = extract_raw_certificate_by_thumbprint(thumbprint)?;

    Ok((raw_cert.to_vec(), picky_asn1_der::from_bytes(&raw_cert)?))
}

#[instrument(level = "trace", ret)]
unsafe fn acquire_key_container_context(key_container_name: &str) -> Result<HCRYPTPROV> {
    let container_name = key_container_name
        .encode_utf16()
        .chain(std::iter::once(0))
        .flat_map(|v| v.to_le_bytes())
        .collect::<Vec<_>>();
    let mut crypt_context_handle = HCRYPTPROV::default();

    if CryptAcquireContextW(
        &mut crypt_context_handle,
        container_name.as_ptr() as *const _,
        CSP_NAME_W.as_ptr() as *const _,
        PROV_RSA_FULL,
        CRYPT_SILENT,
    ) == 0
    {
        return Err(Error::new(
            ErrorKind::InternalError,
            "Cannot acquire crypt context handle.",
        ));
    }

    Ok(crypt_context_handle)
}

#[instrument(level = "trace", ret)]
unsafe fn get_reader_name(crypt_context_handle: HCRYPTPROV) -> Result<String> {
    let mut reader_buff_len = 0;
    if CryptGetProvParam(
        crypt_context_handle,
        PP_SMARTCARD_READER,
        null_mut(),
        &mut reader_buff_len,
        0,
    ) == 0
    {
        return Err(Error::new(ErrorKind::InternalError, "Cannot get reader name."));
    }

    let mut reader_buff = vec![0; reader_buff_len as usize];
    if CryptGetProvParam(
        crypt_context_handle,
        PP_SMARTCARD_READER,
        reader_buff.as_mut_ptr(),
        &mut reader_buff_len,
        0,
    ) == 0
    {
        return Err(Error::new(ErrorKind::InternalError, "Cannot get reader name."));
    }

    // remove null byte
    reader_buff.pop();

    String::from_utf8(reader_buff)
        .map_err(|_| Error::new(ErrorKind::InternalError, "reader name is not valid UTF-8 text"))
}

#[instrument(level = "trace", ret)]
pub unsafe fn get_key_container_certificate(crypt_context_handle: HCRYPTPROV) -> Result<Certificate> {
    let mut key = HCRYPTKEY::default();

    if CryptGetUserKey(crypt_context_handle, AT_KEYEXCHANGE, &mut key) == 0 {
        return Err(Error::new(ErrorKind::InternalError, "Cannot acquire key handle."));
    }

    let mut cert_data_len = 0;
    if CryptGetKeyParam(key, KP_CERTIFICATE, null_mut(), &mut cert_data_len, 0) == 0 {
        CryptDestroyKey(key);
        return Err(Error::new(ErrorKind::InternalError, "Cannot get certificate data len."));
    }

    let mut cert_data = vec![0; cert_data_len as usize];
    if CryptGetKeyParam(key, KP_CERTIFICATE, cert_data.as_mut_ptr(), &mut cert_data_len, 0) == 0 {
        CryptDestroyKey(key);
        return Err(Error::new(ErrorKind::InternalError, "Cannot get certificate data."));
    }

    CryptDestroyKey(key);

    Ok(picky_asn1_der::from_bytes(&cert_data)?)
}

#[derive(Debug)]
pub struct SmartCardInfo {
    pub key_container_name: String,
    pub reader_name: String,
    pub csp_name: String,
    pub certificate: Certificate,
    pub private_key_file_index: u8,
}

// This function gathers the smart card information like reader name, key container name,
// and so on using the provided certificate serial number.
// It iterates over existing key containers and tries to find a suitable reader name and key container.
// The similar approach is implemented in the FreeRDP for the smart card information gathering:
// https://github.com/FreeRDP/FreeRDP/blob/56324906a2d5b2538675e2f10b9f1ffe4a27de79/libfreerdp/core/smartcardlogon.c#L616
#[instrument(level = "trace", ret)]
pub fn finalize_smart_card_info(cert_serial_number: &[u8]) -> Result<SmartCardInfo> {
    let mut crypt_context_handle = HCRYPTPROV::default();
    // SAFETY:
    // * `phProv` is constructed using Rust references. This it is valid.
    // * `szContainer` can be null according to the documentation.
    // * all other parameters are hardcoded constants that are valid.
    if unsafe {
        CryptAcquireContextW(
            &mut crypt_context_handle,
            null(),
            CSP_NAME_W.as_ptr() as *const _,
            PROV_RSA_FULL,
            CRYPT_SILENT,
        )
    } == 0
    {
        return Err(Error::new(
            ErrorKind::InternalError,
            "Cannot acquire crypt context handle.",
        ));
    }

    let mut key_container_name_len = 0;
    let mut is_first = true;
    let mut index = 1;
    loop {
        // SAFETY:
        // * `crypt_context_handle` is obtained from the successful `CryptAcquireContextW` function call.
        // * `pbData` can be null according to the documentation.
        // * `key_container_name_len` is constructed using Rust references. This it is valid.
        // * all other parameters are hardcoded constants that are valid.
        if unsafe {
            CryptGetProvParam(
                crypt_context_handle,
                PP_ENUMCONTAINERS,
                null_mut(),
                &mut key_container_name_len,
                if is_first { CRYPT_FIRST } else { CRYPT_NEXT },
            )
        } == 0
        {
            break;
        }

        let mut key_container_name = vec![0; key_container_name_len as usize];

        // SAFETY:
        // * `crypt_context_handle` is obtained from the successful `CryptAcquireContextW` function call.
        // * `key_container_name` is a Rust vector buffer of valid length. Its len was previously obtained using `CryptGetProvParam`.
        // * `key_container_name_len` is constructed using Rust references. This it is valid.
        // * all other parameters are hardcoded constants that are valid.
        if unsafe {
            CryptGetProvParam(
                crypt_context_handle,
                PP_ENUMCONTAINERS,
                key_container_name.as_mut_ptr(),
                &mut key_container_name_len,
                if is_first { CRYPT_FIRST } else { CRYPT_NEXT },
            )
        } == 0
        {
            break;
        }
        let mut key_container_name = String::from_utf8(key_container_name).unwrap();
        // remove null char
        key_container_name.pop();

        let context = if let Ok(context) = unsafe { acquire_key_container_context(&key_container_name) } {
            context
        } else {
            index += 1;
            continue;
        };

        if let Ok(certificate) = unsafe { get_key_container_certificate(context) } {
            if certificate.tbs_certificate.serial_number.0 == cert_serial_number {
                let reader_name = unsafe { get_reader_name(crypt_context_handle) };

                // SAFETY: the `crypt_context_handle` was obtained using successful `CryptAcquireContextW` function call.
                // `dwFlags` parameter is reserved for future use and must be zero.
                if unsafe { CryptReleaseContext(crypt_context_handle, 0) } == 0 {
                    return Err(Error::new(
                        ErrorKind::InternalError,
                        "could not release the crypto context",
                    ));
                }

                let reader_name = match reader_name {
                    Ok(reader_name) => reader_name,
                    Err(err) => {
                        error!(?err);
                        continue;
                    }
                };

                return Ok(SmartCardInfo {
                    key_container_name,
                    reader_name,
                    certificate,
                    csp_name: CSP_NAME.to_owned(),
                    private_key_file_index: index,
                });
            }
        }

        index += 1;
        is_first = false;
    }

    // SAFETY: the `crypt_context_handle` was obtained using successful `CryptAcquireContextW` function call.
    // `dwFlags` parameter is reserved for future use and must be zero.
    if unsafe { CryptReleaseContext(crypt_context_handle, 0) } == 0 {
        return Err(Error::new(
            ErrorKind::InternalError,
            "could not release the crypto context",
        ));
    }

    Err(Error::new(ErrorKind::InternalError, "Cannot get smart card info"))
}

// This function tries to extract the user principal name from the smart card certificate by searching in the Subject Alternative Name.
#[instrument(level = "trace", ret)]
pub fn extract_user_name_from_certificate(certificate: &Certificate) -> Result<String> {
    let subject_alt_name_ext = &certificate
        .tbs_certificate
        .extensions
        .0
         .0
        .iter()
        .find(|extension| extension.extn_id().0 == oids::subject_alternative_name())
        .ok_or_else(|| {
            Error::new(
                ErrorKind::IncompleteCredentials,
                "Subject alternative name certificate extension is not present",
            )
        })?
        .extn_value();

    let alternate_name = match subject_alt_name_ext {
        ExtensionView::SubjectAltName(alternate_name) => alternate_name,
        // safe: checked above
        _ => unreachable!("ExtensionView must be SubjectAltName"),
    };

    let other_name = match alternate_name.0.first().expect("there is always at least one element") {
        GeneralName::OtherName(other_name) => other_name,
        _ => {
            return Err(Error::new(
                ErrorKind::IncompleteCredentials,
                "subject alternate name has unsupported value type",
            ))
        }
    };

    if other_name.type_id.0 != oids::user_principal_name() {
        return Err(Error::new(
            ErrorKind::IncompleteCredentials,
            "Subject alternate name must be UPN",
        ));
    }

    let data: Utf8StringAsn1 = picky_asn1_der::from_bytes(&other_name.value.0 .0)?;
    Ok(data.to_string())
}

#[cfg(test)]
mod tests {
    use picky::x509::Cert;
    use picky_asn1_x509::Certificate;

    use super::extract_user_name_from_certificate;

    #[test]
    fn username_extraction() {
        let certificate: Certificate = Cert::from_pem_str(include_str!("../test_assets/pw11.cer"))
            .unwrap()
            .into();

        assert_eq!(
            "pw11@example.com",
            extract_user_name_from_certificate(&certificate).unwrap()
        );
    }
}


--- File: src/channel_bindings.rs ---
use crate::{Error, ErrorKind, Result};

// size of SEC_CHANNEL_BINDINGS structure
const SEC_CHANNEL_BINDINGS_SIZE: usize = 32;

/// [SEC_CHANNEL_BINDINGS](https://docs.microsoft.com/en-us/windows/win32/api/sspi/ns-sspi-sec_channel_bindings)
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ChannelBindings {
    pub initiator_addr_type: u32,
    pub initiator: Vec<u8>,
    pub acceptor_addr_type: u32,
    pub acceptor: Vec<u8>,
    pub application_data: Vec<u8>,
}

impl ChannelBindings {
    pub fn from_bytes<T: AsRef<[u8]>>(data: T) -> Result<Self> {
        let data = data.as_ref();

        if data.len() < SEC_CHANNEL_BINDINGS_SIZE {
            return Err(Error::new(
                ErrorKind::InvalidParameter,
                format!(
                    "Invalid SEC_CHANNEL_BINDINGS buffer: buffer is too short: {}. Minimum len: {}",
                    data.len(),
                    SEC_CHANNEL_BINDINGS_SIZE,
                ),
            ));
        }

        let initiator_addr_type = u32::from_le_bytes(data[0..4].try_into().unwrap());

        let initiator_len = u32::from_le_bytes(data[4..8].try_into().unwrap()) as usize;
        let initiator_offset = u32::from_le_bytes(data[8..12].try_into().unwrap()) as usize;
        if initiator_offset + initiator_len > data.len() {
            return Err(Error::new(
                ErrorKind::InvalidParameter,
                format!(
                    "Invalid SEC_CHANNEL_BINDINGS buffer: initiator offset + len ({}) goes outside the buffer ({})",
                    initiator_offset + initiator_len,
                    data.len()
                ),
            ));
        }

        let initiator = if initiator_len > 0 {
            data[initiator_offset..(initiator_offset + initiator_len)].to_vec()
        } else {
            Vec::new()
        };

        let acceptor_addr_type = u32::from_le_bytes(data[12..16].try_into().unwrap());

        let acceptor_len = u32::from_le_bytes(data[16..20].try_into().unwrap()) as usize;
        let acceptor_offset = u32::from_le_bytes(data[20..24].try_into().unwrap()) as usize;
        if acceptor_offset + acceptor_len > data.len() {
            return Err(Error::new(
                ErrorKind::InvalidParameter,
                format!(
                    "Invalid SEC_CHANNEL_BINDINGS buffer: acceptor offset + len ({}) goes outside the buffer ({})",
                    acceptor_offset + acceptor_len,
                    data.len()
                ),
            ));
        }

        let acceptor = if acceptor_len > 0 {
            data[acceptor_offset..(acceptor_offset + acceptor_len)].to_vec()
        } else {
            Vec::new()
        };

        let application_len = u32::from_le_bytes(data[24..28].try_into().unwrap()) as usize;
        let application_offset = u32::from_le_bytes(data[28..32].try_into().unwrap()) as usize;
        if application_offset + application_len > data.len() {
            return Err(Error::new(
                ErrorKind::InvalidParameter,
                format!(
                    "Invalid SEC_CHANNEL_BINDINGS buffer: application offset + len ({}) goes outside the buffer ({})",
                    application_offset + application_len,
                    data.len()
                ),
            ));
        }

        let application_data = if application_len > 0 {
            data[application_offset..(application_offset + application_len)].to_vec()
        } else {
            Vec::new()
        };

        Ok(Self {
            initiator_addr_type,
            initiator,
            acceptor_addr_type,
            acceptor,
            application_data,
        })
    }
}

#[cfg(test)]
mod tests {
    use super::ChannelBindings;

    #[test]
    fn from_bytes() {
        let expected = ChannelBindings {
            initiator_addr_type: 0,
            initiator: Vec::new(),
            acceptor_addr_type: 0,
            acceptor: Vec::new(),
            application_data: vec![1, 2, 3, 4],
        };

        let channel_bindings_token = [1, 2, 3, 4];
        let application_offset = 32_u32;
        let application_len = channel_bindings_token.len();

        let mut buffer = [0; 36];

        buffer[24..28].copy_from_slice(&(application_len as u32).to_le_bytes());
        buffer[28..32].copy_from_slice(&application_offset.to_le_bytes());
        buffer[32..].copy_from_slice(&channel_bindings_token);

        let channel_bindings = ChannelBindings::from_bytes(buffer).unwrap();

        assert_eq!(channel_bindings, expected);
    }

    #[test]
    fn too_small_buffer() {
        assert!(ChannelBindings::from_bytes([1, 2, 3, 4, 5, 6, 7, 8]).is_err());

        assert!(ChannelBindings::from_bytes([]).is_err());
    }

    #[test]
    fn invalid_len() {
        let channel_bindings_token = [1, 2, 3, 4];
        let application_offset = 32_u32;
        // invalid len
        let application_len = channel_bindings_token.len() + 2;

        let mut buffer = [0; 36];

        buffer[24..28].copy_from_slice(&(application_len as u32).to_le_bytes());
        buffer[28..32].copy_from_slice(&application_offset.to_le_bytes());
        buffer[32..].copy_from_slice(&channel_bindings_token);

        let channel_bindings = ChannelBindings::from_bytes(buffer);

        assert!(channel_bindings.is_err());
    }

    #[test]
    fn invalid_offset() {
        let channel_bindings_token = [1, 2, 3, 4];
        // invalid offset
        let application_offset = 32_u32 + 3;
        let application_len = channel_bindings_token.len();

        let mut buffer = [0; 36];

        buffer[24..28].copy_from_slice(&(application_len as u32).to_le_bytes());
        buffer[28..32].copy_from_slice(&application_offset.to_le_bytes());
        buffer[32..].copy_from_slice(&channel_bindings_token);

        let channel_bindings = ChannelBindings::from_bytes(buffer);

        assert!(channel_bindings.is_err());
    }
}


--- File: src/credssp/mod.rs ---
#[cfg(feature = "tsssp")]
pub mod sspi_cred_ssp;
mod ts_request;

use std::io;

use byteorder::{LittleEndian, ReadBytesExt, WriteBytesExt};
use num_derive::{FromPrimitive, ToPrimitive};
use num_traits::{FromPrimitive, ToPrimitive};
use rand::rngs::OsRng;
use rand::Rng;
pub use ts_request::{read_ts_credentials, write_ts_credentials, NStatusCode, TsRequest};
use ts_request::{NONCE_SIZE, TS_REQUEST_VERSION};

#[cfg(feature = "tsssp")]
use self::sspi_cred_ssp::SspiCredSsp;
use crate::builders::{AcquireCredentialsHandle, ChangePassword, WithoutCredentialUse};
use crate::crypto::compute_sha256;
use crate::generator::{
    Generator, GeneratorAcceptSecurityContext, GeneratorChangePassword, GeneratorInitSecurityContext, NetworkRequest,
    YieldPointLocal,
};
use crate::kerberos::config::KerberosConfig;
use crate::kerberos::{self, Kerberos, ServerProperties};
use crate::ntlm::{self, Ntlm, NtlmConfig, SIGNATURE_SIZE};
use crate::pku2u::{self, Pku2u, Pku2uConfig};
use crate::{
    negotiate, AcceptSecurityContextResult, AcquireCredentialsHandleResult, AuthIdentity, AuthIdentityBuffers,
    BufferType, CertContext, CertTrustStatus, ClientRequestFlags, ConnectionInfo, ContextNames, ContextSizes,
    CredentialUse, Credentials, CredentialsBuffers, DataRepresentation, DecryptionFlags, EncryptionFlags, Error,
    ErrorKind, FilledAcceptSecurityContext, FilledAcquireCredentialsHandle, FilledInitializeSecurityContext,
    InitializeSecurityContextResult, Negotiate, NegotiateConfig, PackageInfo, SecurityBuffer, SecurityBufferRef,
    SecurityStatus, ServerRequestFlags, Sspi, SspiEx, SspiImpl, StreamSizes, Username,
};

pub const EARLY_USER_AUTH_RESULT_PDU_SIZE: usize = 4;

const HASH_MAGIC_LEN: usize = 38;
const SERVER_CLIENT_HASH_MAGIC: &[u8; HASH_MAGIC_LEN] = b"CredSSP Server-To-Client Binding Hash\0";
const CLIENT_SERVER_HASH_MAGIC: &[u8; HASH_MAGIC_LEN] = b"CredSSP Client-To-Server Binding Hash\0";

/// Provides an interface for implementing proxy credentials structures.
pub trait CredentialsProxy {
    type AuthenticationData;

    /// A method signature for implementing a behavior of searching and returning
    /// a user password based on a username and a domain provided as arguments.
    ///
    /// # Arguments
    ///
    /// * `username` - The username in UPN or Down-Level Logon Name format
    fn auth_data_by_user(&mut self, username: &Username) -> io::Result<Self::AuthenticationData>;
}

macro_rules! try_cred_ssp_server {
    ($e:expr, $ts_request:ident) => {
        match $e {
            Ok(v) => v,
            Err(e) => {
                let error = crate::Error::from(e);
                $ts_request.error_code = Some(construct_error(&error));

                return Err(ServerError {
                    ts_request: Some(Box::new($ts_request)),
                    error,
                });
            }
        }
    };
}

/// Indicates to the `CredSspClient` whether or not to transfer
/// the credentials in the auth_info `TsRequest` field.
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum CredSspMode {
    WithCredentials,
    /// Indicates that the client requires credential-less logon over CredSSP (also known as "restricted admin mode").
    CredentialLess,
}

/// The result of a CredSSP client processing.
#[derive(Debug, Clone)]
pub enum ClientState {
    /// Used as a result of processing of negotiation tokens.
    ReplyNeeded(TsRequest),
    /// Used as a result of processing of authentication info.
    FinalMessage(TsRequest),
}

/// The result of a CredSSP server processing.
#[derive(Debug, Clone)]
pub enum ServerState {
    /// Used as a result of processing of negotiation tokens.
    ReplyNeeded(TsRequest),
    /// Used as a result of the final state. Contains result of processing of authentication info.
    Finished(AuthIdentity),
}

/// The error of a CredSSP server processing.
/// Contains `TsRequest` with non-empty `error_code`, and the error which caused the server to fail.
#[derive(Debug, Clone)]
pub struct ServerError {
    pub ts_request: Option<Box<TsRequest>>,
    pub error: crate::Error,
}

/// The Early User Authorization Result PDU is sent from server to client
/// and is used to convey authorization information to the client.
/// This PDU is only sent by the server if the client advertised support for it
/// by specifying the ['HYBRID_EX protocol'](struct.SecurityProtocol.htlm)
/// of the [RDP Negotiation Request (RDP_NEG_REQ)](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpbcgr/902b090b-9cb3-4efc-92bf-ee13373371e3)
/// and it MUST be sent immediately after the CredSSP handshake has completed.
#[derive(Debug, Copy, Clone, FromPrimitive, ToPrimitive)]
#[repr(u32)]
pub enum EarlyUserAuthResult {
    /// The user has permission to access the server.
    Success = 0,
    /// The user does not have permission to access the server.
    AccessDenied = 5,
}

impl EarlyUserAuthResult {
    pub fn from_buffer(mut stream: impl io::Read) -> Result<Self, io::Error> {
        let result = stream.read_u32::<LittleEndian>()?;

        EarlyUserAuthResult::from_u32(result).ok_or_else(|| {
            io::Error::new(
                io::ErrorKind::InvalidData,
                format!("got invalid Early User Authorization Result: {:x}", result),
            )
        })
    }
    pub fn to_buffer(self, mut stream: impl io::Write) -> Result<(), io::Error> {
        stream.write_u32::<LittleEndian>(self.to_u32().unwrap())
    }
    pub fn buffer_len(self) -> usize {
        EARLY_USER_AUTH_RESULT_PDU_SIZE
    }
}

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
enum CredSspState {
    NegoToken,
    AuthInfo,
    Final,
}

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
enum EndpointType {
    Client,
    Server,
}

#[derive(Debug, Clone)]
pub enum ClientMode {
    Negotiate(NegotiateConfig),
    Kerberos(KerberosConfig),
    Pku2u(Box<Pku2uConfig>),
    Ntlm(NtlmConfig),
}

/// Implements the CredSSP *client*. The client's credentials are to
/// be securely delegated to the server.
///
/// # MSDN
///
/// * [Glossary](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-cssp/97e4a826-1112-4ab4-8662-cfa58418b4c1)
#[derive(Debug)]
pub struct CredSspClient {
    state: CredSspState,
    context: Option<CredSspContext>,
    credentials: Credentials,
    public_key: Vec<u8>,
    cred_ssp_mode: CredSspMode,
    client_nonce: [u8; NONCE_SIZE],
    credentials_handle: Option<CredentialsBuffers>,
    ts_request_version: u32,
    client_mode: Option<ClientMode>,
    service_principal_name: String,
}

impl CredSspClient {
    pub fn new(
        public_key: Vec<u8>,
        credentials: Credentials,
        cred_ssp_mode: CredSspMode,
        client_mode: ClientMode,
        service_principal_name: String,
    ) -> crate::Result<Self> {
        Ok(Self {
            state: CredSspState::NegoToken,
            context: None,
            credentials,
            public_key,
            cred_ssp_mode,
            client_nonce: OsRng.gen::<[u8; NONCE_SIZE]>(),
            credentials_handle: None,
            ts_request_version: TS_REQUEST_VERSION,
            client_mode: Some(client_mode),
            service_principal_name,
        })
    }

    pub fn new_with_version(
        public_key: Vec<u8>,
        credentials: Credentials,
        cred_ssp_mode: CredSspMode,
        ts_request_version: u32,
        client_mode: ClientMode,
        service_principal_name: String,
    ) -> crate::Result<Self> {
        Ok(Self {
            state: CredSspState::NegoToken,
            context: None,
            credentials,
            public_key,
            cred_ssp_mode,
            client_nonce: OsRng.gen::<[u8; NONCE_SIZE]>(),
            credentials_handle: None,
            ts_request_version,
            client_mode: Some(client_mode),
            service_principal_name,
        })
    }

    #[instrument(fields(state = ?self.state), skip_all)]
    pub fn process(
        &mut self,
        ts_request: TsRequest,
    ) -> Generator<NetworkRequest, crate::Result<Vec<u8>>, crate::Result<ClientState>> {
        Generator::<NetworkRequest, crate::Result<Vec<u8>>, crate::Result<ClientState>>::new(
            move |mut yield_point| async move { self.process_impl(&mut yield_point, ts_request).await },
        )
    }

    async fn process_impl(
        &mut self,
        yield_point: &mut YieldPointLocal,
        mut ts_request: TsRequest,
    ) -> crate::Result<ClientState> {
        ts_request.check_error()?;
        if let Some(ref mut context) = self.context {
            context.check_peer_version(ts_request.version)?;
        } else {
            self.context = match self
                .client_mode
                .take()
                .expect("CredSsp client mode should never be empty")
            {
                ClientMode::Negotiate(negotiate_config) => Some(CredSspContext::new(SspiContext::Negotiate(
                    Negotiate::new_client(negotiate_config)?,
                ))),
                ClientMode::Kerberos(kerberos_config) => Some(CredSspContext::new(SspiContext::Kerberos(
                    Kerberos::new_client_from_config(kerberos_config)?,
                ))),
                ClientMode::Pku2u(pku2u) => Some(CredSspContext::new(SspiContext::Pku2u(
                    Pku2u::new_client_from_config(*pku2u)?,
                ))),
                ClientMode::Ntlm(ntlm) => Some(CredSspContext::new(SspiContext::Ntlm(Ntlm::with_config(ntlm)))),
            };

            let sspi_context = &mut self
                .context
                .as_mut()
                .expect("Should not panic because the CredSSP context is set before")
                .sspi_context;
            let builder = AcquireCredentialsHandle::<'_, _, _, WithoutCredentialUse>::new();
            let AcquireCredentialsHandleResult { credentials_handle, .. } = builder
                .with_auth_data(&self.credentials)
                .with_credential_use(CredentialUse::Outbound)
                .execute(sspi_context)?;
            self.credentials_handle = credentials_handle;
        }

        ts_request.version = self.ts_request_version;

        match self.state {
            CredSspState::NegoToken => {
                let mut input_token = [SecurityBuffer::new(
                    ts_request.nego_tokens.take().unwrap_or_default(),
                    BufferType::Token,
                )];
                let mut output_token = vec![SecurityBuffer::new(Vec::with_capacity(1024), BufferType::Token)];

                let mut credentials_handle = self.credentials_handle.take();
                let cred_ssp_context = self
                    .context
                    .as_mut()
                    .expect("Should not panic because the CredSSP context is set before");
                let mut builder = cred_ssp_context
                    .sspi_context
                    .initialize_security_context()
                    .with_credentials_handle(&mut credentials_handle)
                    .with_context_requirements(
                        ClientRequestFlags::MUTUAL_AUTH
                            | ClientRequestFlags::USE_SESSION_KEY
                            | ClientRequestFlags::INTEGRITY
                            | ClientRequestFlags::CONFIDENTIALITY,
                    )
                    .with_target_data_representation(DataRepresentation::Native)
                    .with_target_name(&self.service_principal_name)
                    .with_input(&mut input_token)
                    .with_output(&mut output_token);
                let result = cred_ssp_context
                    .sspi_context
                    .initialize_security_context_impl(yield_point, &mut builder)
                    .await?;
                self.credentials_handle = credentials_handle;
                ts_request.nego_tokens = Some(output_token.remove(0).buffer);

                if result.status == SecurityStatus::Ok {
                    debug!("CredSSp finished NLA stage.");

                    let peer_version =
                        self.context.as_ref().unwrap().peer_version.expect(
                            "An encrypt public key client function cannot be fired without any incoming TSRequest",
                        );
                    ts_request.pub_key_auth = Some(
                        self.context
                            .as_mut()
                            .expect("Should not panic because the CredSSP context is set before")
                            .encrypt_public_key(
                                self.public_key.as_ref(),
                                EndpointType::Client,
                                &Some(self.client_nonce),
                                peer_version,
                            )?,
                    );
                    ts_request.client_nonce = Some(self.client_nonce);

                    if let Some(nego_tokens) = &ts_request.nego_tokens {
                        if nego_tokens.is_empty() {
                            ts_request.nego_tokens = None;
                        }
                    }

                    self.state = CredSspState::AuthInfo;
                }

                Ok(ClientState::ReplyNeeded(ts_request))
            }
            CredSspState::AuthInfo => {
                ts_request.nego_tokens = None;

                let pub_key_auth = ts_request.pub_key_auth.take().ok_or_else(|| {
                    crate::Error::new(
                        crate::ErrorKind::InvalidToken,
                        String::from("expected an encrypted public key"),
                    )
                })?;
                let peer_version = self
                    .context
                    .as_ref()
                    .expect("Should not panic because the CredSSP context is set before")
                    .peer_version
                    .expect("An decrypt public key client function cannot be fired without any incoming TSRequest");
                self.context.as_mut().unwrap().decrypt_public_key(
                    self.public_key.as_ref(),
                    pub_key_auth.as_ref(),
                    EndpointType::Client,
                    &Some(self.client_nonce),
                    peer_version,
                )?;

                ts_request.auth_info = Some(
                    self.context
                        .as_mut()
                        .unwrap()
                        .encrypt_ts_credentials(self.credentials_handle.as_ref().unwrap(), self.cred_ssp_mode)?,
                );
                debug!("tscredentials has been written");

                self.state = CredSspState::Final;

                Ok(ClientState::FinalMessage(ts_request))
            }
            CredSspState::Final => Err(Error::new(
                ErrorKind::OutOfSequence,
                "CredSSP client's 'process' method must not be fired after the 'Finished' state",
            )),
        }
    }
}

#[derive(Debug, Clone)]
pub enum ServerMode {
    Negotiate(NegotiateConfig),
    Kerberos(Box<(KerberosConfig, ServerProperties)>),
    Pku2u(Box<Pku2uConfig>),
    Ntlm(NtlmConfig),
}

/// Implements the CredSSP *server*. The client's credentials
/// securely delegated to the server for authentication using TLS.
///
/// # MSDN
///
/// * [Glossary](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-cssp/97e4a826-1112-4ab4-8662-cfa58418b4c1)
#[derive(Debug)]
pub struct CredSspServer<C: CredentialsProxy<AuthenticationData = AuthIdentity>> {
    credentials: C,
    state: CredSspState,
    context: Option<CredSspContext>,
    public_key: Vec<u8>,
    credentials_handle: Option<CredentialsBuffers>,
    ts_request_version: u32,
    context_config: Option<ServerMode>,
}

impl<C: CredentialsProxy<AuthenticationData = AuthIdentity> + Send> CredSspServer<C> {
    pub fn new(public_key: Vec<u8>, credentials: C, client_mode: ServerMode) -> crate::Result<Self> {
        Ok(Self {
            state: CredSspState::NegoToken,
            context: None,
            credentials,
            public_key,
            credentials_handle: None,
            ts_request_version: TS_REQUEST_VERSION,
            context_config: Some(client_mode),
        })
    }

    pub fn new_with_version(
        public_key: Vec<u8>,
        credentials: C,
        ts_request_version: u32,
        client_mode: ServerMode,
    ) -> crate::Result<Self> {
        Ok(Self {
            state: CredSspState::NegoToken,
            context: None,
            credentials,
            public_key,
            credentials_handle: None,
            ts_request_version,
            context_config: Some(client_mode),
        })
    }

    #[instrument(fields(state = ?self.state), skip_all)]
    pub fn process(
        &mut self,
        ts_request: TsRequest,
    ) -> Generator<NetworkRequest, crate::Result<Vec<u8>>, Result<ServerState, ServerError>> {
        Generator::<NetworkRequest, crate::Result<Vec<u8>>, Result<ServerState, ServerError>>::new(
            move |mut yield_point| async move { self.process_impl(&mut yield_point, ts_request).await },
        )
    }

    async fn process_impl(
        &mut self,
        yield_point: &mut YieldPointLocal,
        mut ts_request: TsRequest,
    ) -> Result<ServerState, ServerError> {
        if self.context.is_none() {
            self.context = match self
                .context_config
                .take()
                .expect("CredSsp client mode should never be empty")
            {
                ServerMode::Negotiate(neg_config) => Some(CredSspContext::new(SspiContext::Negotiate(
                    try_cred_ssp_server!(Negotiate::new_server(neg_config), ts_request),
                ))),
                ServerMode::Kerberos(kerberos_mode) => {
                    let (kerberos_config, server_properties) = *kerberos_mode;
                    Some(CredSspContext::new(SspiContext::Kerberos(try_cred_ssp_server!(
                        Kerberos::new_server_from_config(kerberos_config, server_properties),
                        ts_request
                    ))))
                }
                ServerMode::Ntlm(ntlm) => Some(CredSspContext::new(SspiContext::Ntlm(Ntlm::with_config(ntlm)))),
                ServerMode::Pku2u(pku2u) => Some(CredSspContext::new(SspiContext::Pku2u(try_cred_ssp_server!(
                    Pku2u::new_server_from_config(*pku2u),
                    ts_request
                )))),
            };
            let AcquireCredentialsHandleResult { credentials_handle, .. } = try_cred_ssp_server!(
                AcquireCredentialsHandle::<'_, _, _, WithoutCredentialUse>::new()
                    .with_credential_use(CredentialUse::Inbound)
                    .execute(
                        &mut self
                            .context
                            .as_mut()
                            .expect("Should not panic because the CredSSP context is set before")
                            .sspi_context
                    ),
                ts_request
            );
            self.credentials_handle = credentials_handle;
        }
        try_cred_ssp_server!(
            self.context
                .as_mut()
                .expect("Should not panic because the CredSSP context is set before")
                .check_peer_version(ts_request.version),
            ts_request
        );

        ts_request.version = self.ts_request_version;

        match self.state {
            CredSspState::AuthInfo => {
                let auth_info = try_cred_ssp_server!(
                    ts_request.auth_info.take().ok_or_else(|| {
                        crate::Error::new(
                            crate::ErrorKind::InvalidToken,
                            String::from("expected an encrypted ts credentials"),
                        )
                    }),
                    ts_request
                );

                let read_credentials = try_cred_ssp_server!(
                    self.context.as_mut().unwrap().decrypt_ts_credentials(&auth_info),
                    ts_request
                );

                self.state = CredSspState::Final;

                let auth_identity = try_cred_ssp_server!(
                    AuthIdentity::try_from(read_credentials.auth_identity().unwrap())
                        .map_err(|e| Error::new(ErrorKind::InvalidParameter, e)),
                    ts_request
                );

                Ok(ServerState::Finished(auth_identity))
            }
            CredSspState::NegoToken => {
                let input = ts_request.nego_tokens.take().unwrap_or_default();
                let mut input_token = vec![SecurityBuffer::new(input, BufferType::Token)];
                let mut output_token = vec![SecurityBuffer::new(Vec::with_capacity(1024), BufferType::Token)];

                let mut credentials_handle = self.credentials_handle.take();
                let sspi_context = &mut self.context.as_mut().unwrap().sspi_context;

                let builder = sspi_context
                    .accept_security_context()
                    .with_credentials_handle(&mut credentials_handle)
                    .with_context_requirements(ServerRequestFlags::empty())
                    .with_target_data_representation(DataRepresentation::Native)
                    .with_input(&mut input_token)
                    .with_output(&mut output_token);
                match try_cred_ssp_server!(
                    sspi_context.accept_security_context_impl(yield_point, builder).await,
                    ts_request
                ) {
                    AcceptSecurityContextResult {
                        status: SecurityStatus::ContinueNeeded,
                        ..
                    } => {
                        ts_request.nego_tokens = Some(output_token.remove(0).buffer);
                    }
                    AcceptSecurityContextResult {
                        status: SecurityStatus::CompleteNeeded | SecurityStatus::Ok,
                        ..
                    } => {
                        let ContextNames { username } = try_cred_ssp_server!(
                            self.context.as_mut().unwrap().sspi_context.query_context_names(),
                            ts_request
                        );
                        let auth_data = try_cred_ssp_server!(
                            self.credentials
                                .auth_data_by_user(&username)
                                .map_err(|e| crate::Error::new(crate::ErrorKind::LogonDenied, e.to_string())),
                            ts_request
                        );
                        try_cred_ssp_server!(
                            self.context
                                .as_mut()
                                .unwrap()
                                .sspi_context
                                .custom_set_auth_identity(Credentials::AuthIdentity(auth_data)),
                            ts_request
                        );

                        try_cred_ssp_server!(
                            self.context.as_mut().unwrap().sspi_context.complete_auth_token(&mut []),
                            ts_request
                        );
                        ts_request.nego_tokens = None;

                        let pub_key_auth = try_cred_ssp_server!(
                            ts_request.pub_key_auth.take().ok_or_else(|| {
                                crate::Error::new(
                                    crate::ErrorKind::InvalidToken,
                                    String::from("expected an encrypted public key"),
                                )
                            }),
                            ts_request
                        );
                        let peer_version = self.context.as_ref().unwrap().peer_version.expect(
                            "an decrypt public key server function cannot be fired without any incoming TSRequest",
                        );
                        try_cred_ssp_server!(
                            self.context.as_mut().unwrap().decrypt_public_key(
                                self.public_key.as_ref(),
                                pub_key_auth.as_ref(),
                                EndpointType::Server,
                                &ts_request.client_nonce,
                                peer_version,
                            ),
                            ts_request
                        );
                        let pub_key_auth = try_cred_ssp_server!(
                            self.context.as_mut().unwrap().encrypt_public_key(
                                self.public_key.as_ref(),
                                EndpointType::Server,
                                &ts_request.client_nonce,
                                peer_version,
                            ),
                            ts_request
                        );
                        ts_request.pub_key_auth = Some(pub_key_auth);

                        self.state = CredSspState::AuthInfo;
                    }
                    result => {
                        try_cred_ssp_server!(
                            Err(Error::new(
                                ErrorKind::InternalError,
                                format!("SSPI returned unexpected status: {:?}", result.status)
                            )),
                            ts_request
                        )
                    }
                };
                self.credentials_handle = credentials_handle;

                Ok(ServerState::ReplyNeeded(ts_request))
            }
            CredSspState::Final => Err(ServerError {
                ts_request: Some(Box::new(ts_request)),
                error: Error::new(
                    ErrorKind::UnsupportedFunction,
                    "CredSSP server's 'process' method must not be fired after the 'Finished' state",
                ),
            }),
        }
    }
}

#[derive(Debug)]
#[allow(clippy::large_enum_variant)]
pub enum SspiContext {
    Ntlm(Ntlm),
    Kerberos(Kerberos),
    Negotiate(Negotiate),
    Pku2u(Pku2u),
    #[cfg(feature = "tsssp")]
    CredSsp(SspiCredSsp),
}

impl SspiContext {
    pub fn package_name(&self) -> &str {
        match self {
            SspiContext::Ntlm(_) => ntlm::PKG_NAME,
            SspiContext::Kerberos(_) => kerberos::PKG_NAME,
            SspiContext::Negotiate(_) => negotiate::PKG_NAME,
            SspiContext::Pku2u(_) => pku2u::PKG_NAME,
            #[cfg(feature = "tsssp")]
            SspiContext::CredSsp(_) => crate::credssp::sspi_cred_ssp::PKG_NAME,
        }
    }
}

impl SspiImpl for SspiContext {
    type CredentialsHandle = Option<CredentialsBuffers>;
    type AuthenticationData = Credentials;

    #[instrument(ret, level = "debug", fields(security_package = self.package_name()), skip_all)]
    fn acquire_credentials_handle_impl(
        &mut self,
        builder: FilledAcquireCredentialsHandle<'_, Self::CredentialsHandle, Self::AuthenticationData>,
    ) -> crate::Result<AcquireCredentialsHandleResult<Self::CredentialsHandle>> {
        Ok(match self {
            SspiContext::Ntlm(ntlm) => {
                let auth_identity = match builder.auth_data {
                    Some(Credentials::AuthIdentity(identity)) => Some(identity),
                    Some(_) => {
                        return Err(Error::new(
                            ErrorKind::UnknownCredentials,
                            "only password-based auth is supported in NTLM",
                        ))
                    }
                    None => None,
                };
                builder
                    .full_transform(auth_identity)
                    .execute(ntlm)?
                    .transform_credentials_handle(&|a: Option<AuthIdentityBuffers>| {
                        a.map(CredentialsBuffers::AuthIdentity)
                    })
            }
            SspiContext::Kerberos(kerberos) => builder.execute(kerberos)?,
            SspiContext::Negotiate(negotiate) => builder.execute(negotiate)?,
            SspiContext::Pku2u(pku2u) => {
                let auth_identity = if let Some(Credentials::AuthIdentity(identity)) = builder.auth_data {
                    identity
                } else {
                    return Err(Error::new(
                        ErrorKind::NoCredentials,
                        "auth identity is not provided for the Pku2u",
                    ));
                };
                builder
                    .full_transform(Some(auth_identity))
                    .execute(pku2u)?
                    .transform_credentials_handle(&|a: Option<AuthIdentityBuffers>| {
                        a.map(CredentialsBuffers::AuthIdentity)
                    })
            }
            #[cfg(feature = "tsssp")]
            SspiContext::CredSsp(credssp) => builder.execute(credssp)?,
        })
    }

    #[instrument(ret, level = "debug", fields(security_package = self.package_name()), skip_all)]
    fn accept_security_context_impl<'a>(
        &'a mut self,
        builder: FilledAcceptSecurityContext<'a, Self::CredentialsHandle>,
    ) -> crate::Result<GeneratorAcceptSecurityContext<'a>> {
        Ok(GeneratorAcceptSecurityContext::new(move |mut yield_point| async move {
            self.accept_security_context_impl(&mut yield_point, builder).await
        }))
    }

    fn initialize_security_context_impl<'ctx, 'b, 'g>(
        &'ctx mut self,
        builder: &'b mut FilledInitializeSecurityContext<'ctx, Self::CredentialsHandle>,
    ) -> crate::Result<GeneratorInitSecurityContext<'g>>
    where
        'ctx: 'g,
        'b: 'g,
    {
        Ok(Generator::new(move |mut yield_point| async move {
            self.initialize_security_context_impl(&mut yield_point, builder).await
        }))
    }
}

impl<'a> SspiContext {
    #[instrument(ret, level = "debug", fields(security_package = self.package_name()), skip_all)]
    async fn change_password_impl(
        &mut self,
        yield_point: &mut YieldPointLocal,
        change_password: ChangePassword<'a>,
    ) -> crate::Result<()> {
        match self {
            SspiContext::Kerberos(kerberos) => kerberos.change_password(yield_point, change_password).await,
            SspiContext::Negotiate(negotiate) => negotiate.change_password(yield_point, change_password).await,
            _ => Err(crate::Error::new(
                ErrorKind::UnsupportedFunction,
                "change password not supported for this protocol",
            )),
        }
    }

    #[cfg(feature = "network_client")]
    pub fn initialize_security_context_sync(
        &mut self,
        builder: &mut FilledInitializeSecurityContext<<Self as SspiImpl>::CredentialsHandle>,
    ) -> crate::Result<InitializeSecurityContextResult> {
        Generator::new(move |mut yield_point| async move {
            self.initialize_security_context_impl(&mut yield_point, builder).await
        })
        .resolve_with_default_network_client()
    }

    #[cfg(feature = "network_client")]
    pub fn accept_security_context_sync(
        &mut self,
        builder: FilledAcceptSecurityContext<'_, <Self as SspiImpl>::CredentialsHandle>,
    ) -> crate::Result<AcceptSecurityContextResult> {
        Generator::new(move |mut yield_point| async move {
            self.accept_security_context_impl(&mut yield_point, builder).await
        })
        .resolve_with_default_network_client()
    }

    #[cfg(feature = "network_client")]
    pub fn change_password_sync(&mut self, builder: ChangePassword) -> crate::Result<()> {
        Generator::new(move |mut yield_point| async move { self.change_password_impl(&mut yield_point, builder).await })
            .resolve_with_default_network_client()
    }

    pub(crate) async fn accept_security_context_impl(
        &mut self,
        yield_point: &mut YieldPointLocal,
        builder: FilledAcceptSecurityContext<'a, <Self as SspiImpl>::CredentialsHandle>,
    ) -> crate::Result<AcceptSecurityContextResult> {
        match self {
            SspiContext::Ntlm(ntlm) => {
                let mut auth_identity = match builder.credentials_handle {
                    Some(Some(CredentialsBuffers::AuthIdentity(identity))) => Some(identity.clone()),
                    Some(Some(_)) => {
                        return Err(Error::new(
                            ErrorKind::UnknownCredentials,
                            "only password-based auth is supported in NTLM",
                        ))
                    }
                    Some(None) => None,
                    None => {
                        return Err(Error::new(
                            ErrorKind::NoCredentials,
                            "credentials handle is not provided for the NTLM",
                        ))
                    }
                };
                let new_builder = builder.full_transform(Some(&mut auth_identity));
                ntlm.accept_security_context_impl(new_builder)
            }
            SspiContext::Kerberos(kerberos) => kerberos.accept_security_context_impl(yield_point, builder).await,
            SspiContext::Negotiate(negotiate) => negotiate.accept_security_context_impl(yield_point, builder).await,
            SspiContext::Pku2u(pku2u) => {
                let mut creds_handle = builder
                    .credentials_handle
                    .as_ref()
                    .and_then(|creds| (*creds).clone())
                    .and_then(|creds_handle| creds_handle.auth_identity());
                let new_builder = builder.full_transform(Some(&mut creds_handle));
                pku2u.accept_security_context_impl(yield_point, new_builder).await
            }
            #[cfg(feature = "tsssp")]
            SspiContext::CredSsp(credssp) => credssp.accept_security_context_impl(yield_point, builder).await,
        }
    }

    #[instrument(ret, level = "debug", fields(security_package = self.package_name()), skip_all)]
    async fn initialize_security_context_impl(
        &'a mut self,
        yield_point: &mut YieldPointLocal,
        builder: &'a mut FilledInitializeSecurityContext<'_, <Self as SspiImpl>::CredentialsHandle>,
    ) -> crate::Result<InitializeSecurityContextResult> {
        match self {
            SspiContext::Ntlm(ntlm) => {
                let mut auth_identity = if let Some(Some(CredentialsBuffers::AuthIdentity(ref identity))) =
                    builder.credentials_handle_mut()
                {
                    Some(identity.clone())
                } else {
                    None
                };
                let mut new_builder = builder.full_transform(Some(&mut auth_identity));
                ntlm.initialize_security_context_impl(&mut new_builder)
            }
            SspiContext::Kerberos(kerberos) => kerberos.initialize_security_context_impl(yield_point, builder).await,
            SspiContext::Negotiate(negotiate) => negotiate.initialize_security_context_impl(yield_point, builder).await,
            SspiContext::Pku2u(pku2u) => {
                let mut auth_identity = if let Some(Some(CredentialsBuffers::AuthIdentity(ref identity))) =
                    builder.credentials_handle_mut()
                {
                    Some(identity.clone())
                } else {
                    None
                };
                let mut new_builder = builder.full_transform(Some(&mut auth_identity));
                pku2u.initialize_security_context_impl(&mut new_builder)
            }
            #[cfg(feature = "tsssp")]
            SspiContext::CredSsp(credssp) => credssp.initialize_security_context_impl(yield_point, builder).await,
        }
    }
}

impl Sspi for SspiContext {
    #[instrument(ret, level = "debug", fields(security_package = self.package_name()), skip(self))]
    fn complete_auth_token(&mut self, token: &mut [SecurityBuffer]) -> crate::Result<SecurityStatus> {
        match self {
            SspiContext::Ntlm(ntlm) => ntlm.complete_auth_token(token),
            SspiContext::Kerberos(kerberos) => kerberos.complete_auth_token(token),
            SspiContext::Negotiate(negotiate) => negotiate.complete_auth_token(token),
            SspiContext::Pku2u(pku2u) => pku2u.complete_auth_token(token),
            #[cfg(feature = "tsssp")]
            SspiContext::CredSsp(credssp) => credssp.complete_auth_token(token),
        }
    }

    #[instrument(ret, level = "debug", fields(security_package = self.package_name()), skip(self))]
    fn encrypt_message(
        &mut self,
        flags: EncryptionFlags,
        message: &mut [SecurityBufferRef],
        sequence_number: u32,
    ) -> crate::Result<SecurityStatus> {
        match self {
            SspiContext::Ntlm(ntlm) => ntlm.encrypt_message(flags, message, sequence_number),
            SspiContext::Kerberos(kerberos) => kerberos.encrypt_message(flags, message, sequence_number),
            SspiContext::Negotiate(negotiate) => negotiate.encrypt_message(flags, message, sequence_number),
            SspiContext::Pku2u(pku2u) => pku2u.encrypt_message(flags, message, sequence_number),
            #[cfg(feature = "tsssp")]
            SspiContext::CredSsp(credssp) => credssp.encrypt_message(flags, message, sequence_number),
        }
    }

    #[instrument(ret, level = "debug", fields(security_package = self.package_name()), skip(self))]
    fn decrypt_message(
        &mut self,
        message: &mut [SecurityBufferRef],
        sequence_number: u32,
    ) -> crate::Result<DecryptionFlags> {
        match self {
            SspiContext::Ntlm(ntlm) => ntlm.decrypt_message(message, sequence_number),
            SspiContext::Kerberos(kerberos) => kerberos.decrypt_message(message, sequence_number),
            SspiContext::Negotiate(negotiate) => negotiate.decrypt_message(message, sequence_number),
            SspiContext::Pku2u(pku2u) => pku2u.decrypt_message(message, sequence_number),
            #[cfg(feature = "tsssp")]
            SspiContext::CredSsp(credssp) => credssp.decrypt_message(message, sequence_number),
        }
    }

    #[instrument(ret, level = "debug", fields(security_package = self.package_name()), skip(self))]
    fn query_context_sizes(&mut self) -> crate::Result<ContextSizes> {
        match self {
            SspiContext::Ntlm(ntlm) => ntlm.query_context_sizes(),
            SspiContext::Kerberos(kerberos) => kerberos.query_context_sizes(),
            SspiContext::Negotiate(negotiate) => negotiate.query_context_sizes(),
            SspiContext::Pku2u(pku2u) => pku2u.query_context_sizes(),
            #[cfg(feature = "tsssp")]
            SspiContext::CredSsp(credssp) => credssp.query_context_sizes(),
        }
    }

    #[instrument(ret, level = "debug", fields(security_package = self.package_name()), skip(self))]
    fn query_context_names(&mut self) -> crate::Result<ContextNames> {
        match self {
            SspiContext::Ntlm(ntlm) => ntlm.query_context_names(),
            SspiContext::Kerberos(kerberos) => kerberos.query_context_names(),
            SspiContext::Negotiate(negotiate) => negotiate.query_context_names(),
            SspiContext::Pku2u(pku2u) => pku2u.query_context_names(),
            #[cfg(feature = "tsssp")]
            SspiContext::CredSsp(credssp) => credssp.query_context_names(),
        }
    }

    #[instrument(ret, level = "debug", fields(security_package = self.package_name()), skip(self))]
    fn query_context_stream_sizes(&mut self) -> crate::Result<StreamSizes> {
        match self {
            SspiContext::Ntlm(ntlm) => ntlm.query_context_stream_sizes(),
            SspiContext::Kerberos(kerberos) => kerberos.query_context_stream_sizes(),
            SspiContext::Negotiate(negotiate) => negotiate.query_context_stream_sizes(),
            SspiContext::Pku2u(pku2u) => pku2u.query_context_stream_sizes(),
            #[cfg(feature = "tsssp")]
            SspiContext::CredSsp(credssp) => credssp.query_context_stream_sizes(),
        }
    }

    #[instrument(ret, level = "debug", fields(security_package = self.package_name()), skip(self))]
    fn query_context_package_info(&mut self) -> crate::Result<PackageInfo> {
        match self {
            SspiContext::Ntlm(ntlm) => ntlm.query_context_package_info(),
            SspiContext::Kerberos(kerberos) => kerberos.query_context_package_info(),
            SspiContext::Negotiate(negotiate) => negotiate.query_context_package_info(),
            SspiContext::Pku2u(pku2u) => pku2u.query_context_package_info(),
            #[cfg(feature = "tsssp")]
            SspiContext::CredSsp(credssp) => credssp.query_context_package_info(),
        }
    }

    #[instrument(ret, level = "debug", fields(security_package = self.package_name()), skip(self))]
    fn query_context_cert_trust_status(&mut self) -> crate::Result<CertTrustStatus> {
        match self {
            SspiContext::Ntlm(ntlm) => ntlm.query_context_cert_trust_status(),
            SspiContext::Kerberos(kerberos) => kerberos.query_context_cert_trust_status(),
            SspiContext::Negotiate(negotiate) => negotiate.query_context_cert_trust_status(),
            SspiContext::Pku2u(pku2u) => pku2u.query_context_cert_trust_status(),
            #[cfg(feature = "tsssp")]
            SspiContext::CredSsp(credssp) => credssp.query_context_cert_trust_status(),
        }
    }

    #[instrument(ret, level = "debug", fields(security_package = self.package_name()), skip(self))]
    fn query_context_remote_cert(&mut self) -> crate::Result<CertContext> {
        match self {
            SspiContext::Ntlm(ntlm) => ntlm.query_context_remote_cert(),
            SspiContext::Kerberos(kerberos) => kerberos.query_context_remote_cert(),
            SspiContext::Negotiate(negotiate) => negotiate.query_context_remote_cert(),
            SspiContext::Pku2u(pku2u) => pku2u.query_context_remote_cert(),
            #[cfg(feature = "tsssp")]
            SspiContext::CredSsp(credssp) => credssp.query_context_remote_cert(),
        }
    }

    #[instrument(ret, level = "debug", fields(security_package = self.package_name()), skip(self))]
    fn query_context_negotiation_package(&mut self) -> crate::Result<PackageInfo> {
        match self {
            SspiContext::Ntlm(ntlm) => ntlm.query_context_negotiation_package(),
            SspiContext::Kerberos(kerberos) => kerberos.query_context_negotiation_package(),
            SspiContext::Negotiate(negotiate) => negotiate.query_context_negotiation_package(),
            SspiContext::Pku2u(pku2u) => pku2u.query_context_negotiation_package(),
            #[cfg(feature = "tsssp")]
            SspiContext::CredSsp(credssp) => credssp.query_context_negotiation_package(),
        }
    }

    #[instrument(ret, level = "debug", fields(security_package = self.package_name()), skip(self))]
    fn query_context_connection_info(&mut self) -> crate::Result<ConnectionInfo> {
        match self {
            SspiContext::Ntlm(ntlm) => ntlm.query_context_connection_info(),
            SspiContext::Kerberos(kerberos) => kerberos.query_context_connection_info(),
            SspiContext::Negotiate(negotiate) => negotiate.query_context_connection_info(),
            SspiContext::Pku2u(pku2u) => pku2u.query_context_connection_info(),
            #[cfg(feature = "tsssp")]
            SspiContext::CredSsp(credssp) => credssp.query_context_connection_info(),
        }
    }

    #[instrument(fields(security_package = self.package_name()), skip(self))]
    fn query_context_session_key(&self) -> crate::Result<crate::SessionKeys> {
        match self {
            SspiContext::Ntlm(ntlm) => ntlm.query_context_session_key(),
            SspiContext::Kerberos(kerberos) => kerberos.query_context_session_key(),
            SspiContext::Negotiate(negotiate) => negotiate.query_context_session_key(),
            SspiContext::Pku2u(pku2u) => pku2u.query_context_session_key(),
            #[cfg(feature = "tsssp")]
            SspiContext::CredSsp(credssp) => credssp.query_context_session_key(),
        }
    }

    fn change_password<'a>(
        &'a mut self,
        change_password: ChangePassword<'a>,
    ) -> crate::Result<GeneratorChangePassword<'a>> {
        Ok(GeneratorChangePassword::new(move |mut yield_point| async move {
            self.change_password_impl(&mut yield_point, change_password).await
        }))
    }

    fn make_signature(
        &mut self,
        flags: u32,
        message: &mut [SecurityBufferRef],
        sequence_number: u32,
    ) -> crate::Result<()> {
        match self {
            SspiContext::Ntlm(ntlm) => ntlm.make_signature(flags, message, sequence_number),
            SspiContext::Kerberos(kerberos) => kerberos.make_signature(flags, message, sequence_number),
            SspiContext::Negotiate(negotiate) => negotiate.make_signature(flags, message, sequence_number),
            SspiContext::Pku2u(pku2u) => pku2u.make_signature(flags, message, sequence_number),
            #[cfg(feature = "tsssp")]
            SspiContext::CredSsp(credssp) => credssp.make_signature(flags, message, sequence_number),
        }
    }

    fn verify_signature(&mut self, message: &mut [SecurityBufferRef], sequence_number: u32) -> crate::Result<u32> {
        match self {
            SspiContext::Ntlm(ntlm) => ntlm.verify_signature(message, sequence_number),
            SspiContext::Kerberos(kerberos) => kerberos.verify_signature(message, sequence_number),
            SspiContext::Negotiate(negotiate) => negotiate.verify_signature(message, sequence_number),
            SspiContext::Pku2u(pku2u) => pku2u.verify_signature(message, sequence_number),
            #[cfg(feature = "tsssp")]
            SspiContext::CredSsp(credssp) => credssp.verify_signature(message, sequence_number),
        }
    }
}

impl SspiEx for SspiContext {
    // #[instrument(level = "trace", ret, fields(security_package = self.package_name()), skip(self))]
    fn custom_set_auth_identity(&mut self, identity: Self::AuthenticationData) -> crate::Result<()> {
        match self {
            SspiContext::Ntlm(ntlm) => ntlm.custom_set_auth_identity(identity.auth_identity().ok_or_else(|| {
                Error::new(
                    ErrorKind::IncompleteCredentials,
                    "provided credentials are not password-based",
                )
            })?),
            SspiContext::Kerberos(kerberos) => kerberos.custom_set_auth_identity(identity),
            SspiContext::Negotiate(negotiate) => negotiate.custom_set_auth_identity(identity),
            SspiContext::Pku2u(pku2u) => pku2u.custom_set_auth_identity(identity.auth_identity().ok_or_else(|| {
                Error::new(
                    ErrorKind::IncompleteCredentials,
                    "provided credentials are not password-based",
                )
            })?),
            #[cfg(feature = "tsssp")]
            SspiContext::CredSsp(credssp) => credssp.custom_set_auth_identity(identity),
        }
    }
}

#[derive(Debug)]
struct CredSspContext {
    peer_version: Option<u32>,
    sspi_context: SspiContext,
    send_seq_num: u32,
    recv_seq_num: u32,
}

impl CredSspContext {
    fn new(sspi_context: SspiContext) -> Self {
        Self {
            peer_version: None,
            send_seq_num: 0,
            recv_seq_num: 0,
            sspi_context,
        }
    }

    fn check_peer_version(&mut self, other_peer_version: u32) -> crate::Result<()> {
        if let Some(peer_version) = self.peer_version {
            if peer_version != other_peer_version {
                Err(crate::Error::new(
                    crate::ErrorKind::MessageAltered,
                    format!(
                        "CredSSP peer changed protocol version from {} to {}",
                        peer_version, other_peer_version
                    ),
                ))
            } else {
                Ok(())
            }
        } else {
            self.peer_version = Some(other_peer_version);

            Ok(())
        }
    }

    fn encrypt_public_key(
        &mut self,
        public_key: &[u8],
        endpoint: EndpointType,
        client_nonce: &Option<[u8; NONCE_SIZE]>,
        peer_version: u32,
    ) -> crate::Result<Vec<u8>> {
        let hash_magic = match endpoint {
            EndpointType::Client => CLIENT_SERVER_HASH_MAGIC,
            EndpointType::Server => SERVER_CLIENT_HASH_MAGIC,
        };

        if peer_version < 5 {
            self.encrypt_public_key_echo(public_key, endpoint)
        } else {
            self.encrypt_public_key_hash(
                public_key,
                hash_magic,
                &client_nonce.ok_or(crate::Error::new(
                    crate::ErrorKind::InvalidToken,
                    String::from("client nonce from the TSRequest is empty, but a peer version is >= 5"),
                ))?,
            )
        }
    }

    fn decrypt_public_key(
        &mut self,
        public_key: &[u8],
        encrypted_public_key: &[u8],
        endpoint: EndpointType,
        client_nonce: &Option<[u8; NONCE_SIZE]>,
        peer_version: u32,
    ) -> crate::Result<()> {
        let hash_magic = match endpoint {
            EndpointType::Client => SERVER_CLIENT_HASH_MAGIC,
            EndpointType::Server => CLIENT_SERVER_HASH_MAGIC,
        };

        if peer_version < 5 {
            self.decrypt_public_key_echo(public_key, encrypted_public_key, endpoint)
        } else {
            self.decrypt_public_key_hash(
                public_key,
                encrypted_public_key,
                hash_magic,
                &client_nonce.ok_or(Error::new(
                    ErrorKind::InvalidToken,
                    String::from("client nonce from the TSRequest is empty, but a peer version is >= 5"),
                ))?,
            )
        }
    }

    fn encrypt_public_key_echo(&mut self, public_key: &[u8], endpoint: EndpointType) -> crate::Result<Vec<u8>> {
        let mut public_key = public_key.to_vec();

        if let SspiContext::Ntlm(_) = self.sspi_context {
            if endpoint == EndpointType::Server {
                integer_increment_le(&mut public_key);
            }
        }

        self.encrypt_message(&public_key)
    }

    fn encrypt_public_key_hash(
        &mut self,
        public_key: &[u8],
        hash_magic: &[u8],
        client_nonce: &[u8],
    ) -> crate::Result<Vec<u8>> {
        let mut data = hash_magic.to_vec();
        data.extend(client_nonce);
        data.extend(public_key);

        self.encrypt_message(&compute_sha256(&data))
    }

    fn decrypt_public_key_echo(
        &mut self,
        public_key: &[u8],
        encrypted_public_key: &[u8],
        endpoint: EndpointType,
    ) -> crate::Result<()> {
        let mut decrypted_public_key = self.decrypt_message(encrypted_public_key)?;
        if endpoint == EndpointType::Client {
            integer_decrement_le(&mut decrypted_public_key);
        }

        if public_key != decrypted_public_key.as_slice() {
            error!("Expected and decrypted public key are not the same");

            return Err(crate::Error::new(
                crate::ErrorKind::MessageAltered,
                String::from("could not verify a public key echo"),
            ));
        }

        Ok(())
    }

    fn decrypt_public_key_hash(
        &mut self,
        public_key: &[u8],
        encrypted_public_key: &[u8],
        hash_magic: &[u8],
        client_nonce: &[u8],
    ) -> crate::Result<()> {
        let decrypted_public_key = self.decrypt_message(encrypted_public_key)?;

        let mut data = hash_magic.to_vec();
        data.extend(client_nonce);
        data.extend(public_key);
        let expected_public_key = compute_sha256(&data);

        if expected_public_key.as_ref() != decrypted_public_key.as_slice() {
            error!("Expected and decrypted public key hash are not the same");

            return Err(crate::Error::new(
                crate::ErrorKind::MessageAltered,
                String::from("could not verify a public key hash"),
            ));
        }

        Ok(())
    }

    fn encrypt_ts_credentials(
        &mut self,
        credentials: &CredentialsBuffers,
        cred_ssp_mode: CredSspMode,
    ) -> crate::Result<Vec<u8>> {
        self.encrypt_message(&write_ts_credentials(credentials, cred_ssp_mode)?)
    }

    fn decrypt_ts_credentials(&mut self, auth_info: &[u8]) -> crate::Result<CredentialsBuffers> {
        let ts_credentials_buffer = self.decrypt_message(auth_info)?;

        read_ts_credentials(ts_credentials_buffer.as_slice())
    }

    fn encrypt_message(&mut self, input: &[u8]) -> crate::Result<Vec<u8>> {
        let mut token = [0; 1024];
        let mut data = input.to_vec();

        let mut buffers = vec![
            SecurityBufferRef::token_buf(token.as_mut_slice()),
            SecurityBufferRef::data_buf(data.as_mut_slice()),
        ];

        let send_seq_num = self.send_seq_num;

        self.sspi_context
            .encrypt_message(EncryptionFlags::empty(), &mut buffers, send_seq_num)?;

        let mut output = SecurityBufferRef::find_buffer(&buffers, BufferType::Token)?
            .data()
            .to_vec();
        output.extend_from_slice(SecurityBufferRef::find_buffer_mut(&mut buffers, BufferType::Data)?.data());

        self.send_seq_num += 1;

        Ok(output)
    }

    fn decrypt_message(&mut self, input: &[u8]) -> crate::Result<Vec<u8>> {
        let mut input = input.to_vec();
        let (signature, data) = input.split_at_mut(SIGNATURE_SIZE);
        let mut buffers = vec![
            SecurityBufferRef::data_buf(data),
            SecurityBufferRef::token_buf(signature),
        ];

        let recv_seq_num = self.recv_seq_num;

        self.sspi_context.decrypt_message(&mut buffers, recv_seq_num)?;

        let output = SecurityBufferRef::buf_data(&buffers, BufferType::Data)?.to_vec();

        self.recv_seq_num += 1;

        Ok(output)
    }
}

fn integer_decrement_le(buffer: &mut [u8]) {
    for elem in buffer.iter_mut() {
        let (value, overflow) = elem.overflowing_sub(1);
        *elem = value;
        if !overflow {
            break;
        }
    }
}

fn integer_increment_le(buffer: &mut [u8]) {
    for elem in buffer.iter_mut() {
        let (value, overflow) = elem.overflowing_add(1);
        *elem = value;
        if !overflow {
            break;
        }
    }
}

fn construct_error(e: &crate::Error) -> NStatusCode {
    let code = ((e.error_type as i64 & 0x0000_FFFF) | (0x7 << 16) | 0xC000_0000) as u32;
    NStatusCode(code)
}

#[cfg(test)]
mod tests {
    use static_assertions::assert_impl_one;

    use super::CredSspClient;

    #[test]
    fn cred_sspi_client_is_send() {
        assert_impl_one!(CredSspClient: Send);
    }

    #[test]
    fn cred_sspi_client_is_sync() {
        assert_impl_one!(CredSspClient: Sync);
    }
}


--- File: src/credssp/sspi_cred_ssp/cipher_block_size.rs ---
use rustls::CipherSuite;

// [Block Size and Padding](https://www.rfc-editor.org/rfc/rfc3826#section-3.1.1.3)
// The block size of the AES cipher is 128 bits
const AES_BLOCK_SIZE: u32 = 16;

// [Data Size](https://www.rfc-editor.org/rfc/rfc1851#section-1.3)
// The 3DES algorithm operates on blocks of eight octets. This often requires padding after
// the end of the unencrypted payload data.
const DES_BLOCK_SIZE: u32 = 8;

use crate::{Error, ErrorKind, Result};

pub fn get_cipher_block_size(cipher: CipherSuite) -> Result<u32> {
    match cipher {
        // Block ciphers
        CipherSuite::TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 => Ok(AES_BLOCK_SIZE),
        CipherSuite::TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 => Ok(AES_BLOCK_SIZE),
        CipherSuite::TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 => Ok(AES_BLOCK_SIZE),
        CipherSuite::TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 => Ok(AES_BLOCK_SIZE),
        CipherSuite::TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 => Ok(AES_BLOCK_SIZE),
        CipherSuite::TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 => Ok(AES_BLOCK_SIZE),
        CipherSuite::TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 => Ok(AES_BLOCK_SIZE),
        CipherSuite::TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 => Ok(AES_BLOCK_SIZE),
        CipherSuite::TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 => Ok(AES_BLOCK_SIZE),
        CipherSuite::TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA => Ok(AES_BLOCK_SIZE),
        CipherSuite::TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA => Ok(AES_BLOCK_SIZE),
        CipherSuite::TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA => Ok(AES_BLOCK_SIZE),
        CipherSuite::TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA => Ok(AES_BLOCK_SIZE),
        CipherSuite::TLS_RSA_WITH_AES_256_GCM_SHA384 => Ok(AES_BLOCK_SIZE),
        CipherSuite::TLS_RSA_WITH_AES_128_GCM_SHA256 => Ok(AES_BLOCK_SIZE),
        CipherSuite::TLS_RSA_WITH_AES_256_CBC_SHA256 => Ok(AES_BLOCK_SIZE),
        CipherSuite::TLS_RSA_WITH_AES_128_CBC_SHA256 => Ok(AES_BLOCK_SIZE),
        CipherSuite::TLS_RSA_WITH_AES_256_CBC_SHA => Ok(AES_BLOCK_SIZE),
        CipherSuite::TLS_RSA_WITH_AES_128_CBC_SHA => Ok(AES_BLOCK_SIZE),
        CipherSuite::TLS_RSA_WITH_3DES_EDE_CBC_SHA => Ok(DES_BLOCK_SIZE),
        CipherSuite::TLS_DHE_RSA_WITH_AES_256_CBC_SHA => Ok(AES_BLOCK_SIZE),
        CipherSuite::TLS_DHE_RSA_WITH_AES_128_CBC_SHA => Ok(AES_BLOCK_SIZE),
        CipherSuite::TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 => Ok(AES_BLOCK_SIZE),
        CipherSuite::TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 => Ok(AES_BLOCK_SIZE),
        CipherSuite::TLS_DHE_DSS_WITH_AES_256_CBC_SHA => Ok(AES_BLOCK_SIZE),
        CipherSuite::TLS_DHE_DSS_WITH_AES_128_CBC_SHA => Ok(AES_BLOCK_SIZE),
        CipherSuite::TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA => Ok(DES_BLOCK_SIZE),
        CipherSuite::TLS_PSK_WITH_AES_256_GCM_SHA384 => Ok(AES_BLOCK_SIZE),
        CipherSuite::TLS_PSK_WITH_AES_128_GCM_SHA256 => Ok(AES_BLOCK_SIZE),
        CipherSuite::TLS_PSK_WITH_AES_256_CBC_SHA384 => Ok(AES_BLOCK_SIZE),
        CipherSuite::TLS_PSK_WITH_AES_128_CBC_SHA256 => Ok(AES_BLOCK_SIZE),
        // Stream ciphers
        CipherSuite::TLS13_CHACHA20_POLY1305_SHA256 => Ok(0),
        CipherSuite::TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 => Ok(0),
        CipherSuite::TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 => Ok(0),
        CipherSuite::TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 => Ok(0),
        CipherSuite::TLS_PSK_WITH_CHACHA20_POLY1305_SHA256 => Ok(0),
        CipherSuite::TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256 => Ok(0),
        CipherSuite::TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256 => Ok(0),
        CipherSuite::TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256 => Ok(0),
        CipherSuite::TLS_RSA_WITH_RC4_128_SHA => Ok(0),
        CipherSuite::TLS_RSA_WITH_RC4_128_MD5 => Ok(0),
        CipherSuite::TLS_RSA_EXPORT1024_WITH_RC4_56_SHA => Ok(0),
        CipherSuite::TLS_RSA_EXPORT_WITH_RC4_40_MD5 => Ok(0),
        // Unsupported ciphers or others
        cipher => Err(Error::new(
            ErrorKind::InternalError,
            format!("can not get block size of cipher: {:?}", cipher),
        )),
    }
}


--- File: src/credssp/sspi_cred_ssp/mod.rs ---
mod cipher_block_size;
mod tls_connection;

use std::sync::{Arc, LazyLock};

use async_recursion::async_recursion;
use picky_asn1_x509::Certificate;
use rand::rngs::OsRng;
use rand::Rng;
use rustls::client::ClientConfig;
use rustls::{ClientConnection, Connection};

use self::tls_connection::{danger, TlsConnection};
use super::ts_request::NONCE_SIZE;
use super::{CredSspContext, CredSspMode, EndpointType, SspiContext, TsRequest};
use crate::credssp::sspi_cred_ssp::tls_connection::{DecryptionResult, DecryptionResultBuffers};
use crate::generator::{
    GeneratorAcceptSecurityContext, GeneratorChangePassword, GeneratorInitSecurityContext, YieldPointLocal,
};
use crate::{
    builders, negotiate, AcquireCredentialsHandleResult, BufferType, CertContext, CertEncodingType,
    CertTrustErrorStatus, CertTrustInfoStatus, CertTrustStatus, ClientRequestFlags, ClientResponseFlags,
    ConnectionInfo, ContextNames, ContextSizes, CredentialUse, Credentials, CredentialsBuffers, DataRepresentation,
    DecryptionFlags, EncryptionFlags, Error, ErrorKind, InitializeSecurityContextResult, PackageCapabilities,
    PackageInfo, Result, SecurityBuffer, SecurityBufferRef, SecurityPackageType, SecurityStatus, Sspi, SspiEx,
    SspiImpl, StreamSizes, PACKAGE_ID_NONE,
};

pub const PKG_NAME: &str = "CREDSSP";

pub static PACKAGE_INFO: LazyLock<PackageInfo> = LazyLock::new(|| PackageInfo {
    capabilities: PackageCapabilities::empty(),
    rpc_id: PACKAGE_ID_NONE,
    max_token_len: negotiate::PACKAGE_INFO.max_token_len + 1,
    name: SecurityPackageType::CredSsp,
    comment: String::from("CredSsp security package"),
});

#[derive(Debug, Clone)]
enum CredSspState {
    Tls,
    NegoToken,
    AuthInfo,
    Final,
}

#[derive(Debug)]
pub struct SspiCredSsp {
    state: CredSspState,
    cred_ssp_context: Box<CredSspContext>,
    auth_identity: Option<CredentialsBuffers>,
    // The TLS connection object will be set on the first initialize security context function call.
    // We need to specify the correct hostname which we'll know only during actual auth.
    tls_connection: Option<TlsConnection>,
    nonce: Option<[u8; NONCE_SIZE]>,
}

impl SspiCredSsp {
    pub fn new_client(sspi_context: SspiContext) -> Result<Self> {
        crate::rustls::install_default_crypto_provider_if_necessary().map_err(|()| {
            Error::new(
                ErrorKind::SecurityPackageNotFound,
                "failed to install the default crypto provider for TLS",
            )
        })?;

        Ok(Self {
            state: CredSspState::Tls,
            cred_ssp_context: Box::new(CredSspContext::new(sspi_context)),
            auth_identity: None,
            tls_connection: None,
            nonce: Some(OsRng.gen::<[u8; NONCE_SIZE]>()),
        })
    }

    /// * `sspi_context` is a security package that will be used for authorization
    pub fn new_server(sspi_context: SspiContext) -> Result<Self> {
        crate::rustls::install_default_crypto_provider_if_necessary().map_err(|()| {
            Error::new(
                ErrorKind::SecurityPackageNotFound,
                "failed to install the default crypto provider for TLS",
            )
        })?;

        Ok(Self {
            state: CredSspState::Tls,
            cred_ssp_context: Box::new(CredSspContext::new(sspi_context)),
            auth_identity: None,
            tls_connection: None,
            // nonce for the server will be in the incoming TsRequest
            nonce: None,
        })
    }

    fn raw_peer_public_key(&mut self) -> Result<Vec<u8>> {
        let peer_certificate = self.query_context_remote_cert()?.cert;

        let raw_public_key = match peer_certificate
            .tbs_certificate
            .subject_public_key_info
            .subject_public_key
        {
            picky_asn1_x509::PublicKey::Rsa(rsa_pk) => picky_asn1_der::to_vec(&rsa_pk.0)?,
            picky_asn1_x509::PublicKey::Ec(ec) => picky_asn1_der::to_vec(&ec)?,
            picky_asn1_x509::PublicKey::Ed(ed) => picky_asn1_der::to_vec(&ed)?,
        };

        Ok(raw_public_key)
    }

    fn decrypt_and_decode_ts_request(&mut self, input: &mut [SecurityBuffer]) -> Result<TsRequest> {
        let encrypted_ts_request = SecurityBuffer::find_buffer_mut(input, BufferType::Token)?;
        let DecryptionResult::Success(DecryptionResultBuffers {
            header: _,
            decrypted: raw_ts_request,
            extra: _,
        }) = self
            .tls_connection_mut()?
            .decrypt_tls(&mut encrypted_ts_request.buffer)?
        else {
            return Err(Error::new(ErrorKind::IncompleteMessage, "Input token is too short"));
        };

        let ts_request = TsRequest::from_buffer(raw_ts_request)?;
        ts_request.check_error()?;

        Ok(ts_request)
    }

    fn tls_connection_mut(&mut self) -> Result<&mut TlsConnection> {
        self.tls_connection
            .as_mut()
            .ok_or_else(|| Error::new(ErrorKind::OutOfSequence, "TLS connection is not yet established"))
    }

    fn tls_connection(&mut self) -> Result<&TlsConnection> {
        self.tls_connection
            .as_ref()
            .ok_or_else(|| Error::new(ErrorKind::OutOfSequence, "TLS connection is not yet established"))
    }
}

impl Sspi for SspiCredSsp {
    #[instrument(level = "debug", ret, fields(state = ?self.state), skip_all)]
    fn complete_auth_token(&mut self, _token: &mut [SecurityBuffer]) -> Result<SecurityStatus> {
        Ok(SecurityStatus::Ok)
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip(self, _flags))]
    fn encrypt_message(
        &mut self,
        _flags: EncryptionFlags,
        message: &mut [SecurityBufferRef],
        _sequence_number: u32,
    ) -> Result<SecurityStatus> {
        // CredSsp decrypt_message function just calls corresponding function from the Schannel
        // MSDN: message must contain four buffers
        // https://learn.microsoft.com/en-us/windows/win32/secauthn/decryptmessage--schannel
        if message.len() < 4 {
            return Err(Error::new(
                ErrorKind::InvalidParameter,
                "Input message must contain four buffers",
            ));
        }

        let plain_message = SecurityBufferRef::find_buffer_mut(message, BufferType::Data)?;

        let encrypted_data = self.tls_connection_mut()?.encrypt_tls(plain_message.data())?;
        let encrypted_data = encrypted_data.as_slice();

        let stream_header_buffer = SecurityBufferRef::find_buffer_mut(message, BufferType::StreamHeader)?;
        let (stream_header_data, encrypted_data) =
            encrypted_data.split_at(stream_header_buffer.buf_len().min(encrypted_data.len()));
        stream_header_buffer.write_data(stream_header_data)?;

        let data_buffer = SecurityBufferRef::find_buffer_mut(message, BufferType::Data)?;
        let (data_data, encrypted_data) = encrypted_data.split_at(data_buffer.buf_len().min(encrypted_data.len()));
        data_buffer.write_data(data_data)?;

        let stream_trailer_buffer = SecurityBufferRef::find_buffer_mut(message, BufferType::StreamTrailer)?;
        stream_trailer_buffer.write_data(encrypted_data)?;

        Ok(SecurityStatus::Ok)
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip(self, _sequence_number))]
    fn decrypt_message(&mut self, message: &mut [SecurityBufferRef], _sequence_number: u32) -> Result<DecryptionFlags> {
        // CredSsp decrypt_message function just calls corresponding function from the Schannel
        // MSDN: message must contain four buffers
        // https://learn.microsoft.com/en-us/windows/win32/secauthn/decryptmessage--schannel
        if message.len() < 4 {
            return Err(Error::new(
                ErrorKind::InvalidParameter,
                "Input message must contain four buffers",
            ));
        }

        match self
            .tls_connection_mut()?
            .decrypt_tls(SecurityBufferRef::take_buf_data_mut(message, BufferType::Data)?)?
        {
            DecryptionResult::Success(DecryptionResultBuffers {
                header,
                decrypted,
                extra,
            }) => {
                // buffers order is important. MSTSC won't work with another buffers order.
                message[0] = SecurityBufferRef::stream_header_buf(header);
                message[1] = SecurityBufferRef::data_buf(decrypted);
                // https://learn.microsoft.com/en-us/windows/win32/api/sspi/ns-sspi-secbuffer
                // SECBUFFER_STREAM_TRAILER: It is not usually of interest to callers.
                //
                // So, we can just set an empty buffer here.
                message[2] = SecurityBufferRef::stream_trailer_buf(&mut []);
                message[3] = SecurityBufferRef::extra_buf(extra);

                Ok(DecryptionFlags::empty())
            }
            DecryptionResult::IncompleteMessage(needed_bytes_amount) => {
                // This behavior is not documented anywhere and was discovered during debugging.
                // Change it at your risk.
                // Additional info:
                // * https://stackoverflow.com/a/6832633/9123725
                // * https://stackoverflow.com/a/65101172

                message[0] = SecurityBufferRef::missing_buf(needed_bytes_amount);
                message[1] = SecurityBufferRef::missing_buf(needed_bytes_amount);

                Err(Error::new(ErrorKind::IncompleteMessage, "Got incomplete TLS message"))
            }
        }
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip(self))]
    fn query_context_sizes(&mut self) -> Result<ContextSizes> {
        self.cred_ssp_context.sspi_context.query_context_sizes()
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip(self))]
    fn query_context_names(&mut self) -> Result<ContextNames> {
        self.cred_ssp_context.sspi_context.query_context_names()
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip(self))]
    fn query_context_stream_sizes(&mut self) -> Result<StreamSizes> {
        self.tls_connection()?.stream_sizes()
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip(self))]
    fn query_context_package_info(&mut self) -> Result<PackageInfo> {
        crate::query_security_package_info(SecurityPackageType::CredSsp)
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip(self))]
    fn query_context_cert_trust_status(&mut self) -> Result<CertTrustStatus> {
        // The CredSSP server does not request the client's X.509 certificate (thus far, the client is anonymous).
        // we do not check certificate validity
        Ok(CertTrustStatus {
            error_status: CertTrustErrorStatus::NO_ERROR,
            info_status: CertTrustInfoStatus::IS_SELF_SIGNED,
        })
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip(self))]
    fn query_context_remote_cert(&mut self) -> Result<CertContext> {
        let certificates = self.tls_connection()?.peer_certificates()?;
        let raw_server_certificate = certificates
            .first()
            .ok_or_else(|| Error::new(ErrorKind::CertificateUnknown, "cannot acquire server certificate"))?;

        let server_certificate: Certificate = picky_asn1_der::from_bytes(raw_server_certificate)?;

        Ok(CertContext {
            encoding_type: CertEncodingType::X509AsnEncoding,
            raw_cert: raw_server_certificate.to_vec(),
            cert: server_certificate,
        })
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip(self))]
    fn query_context_negotiation_package(&mut self) -> Result<PackageInfo> {
        self.cred_ssp_context.sspi_context.query_context_package_info()
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip(self))]
    fn query_context_connection_info(&mut self) -> Result<ConnectionInfo> {
        self.tls_connection()?.connection_info()
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip_all)]
    fn change_password(&mut self, _change_password: builders::ChangePassword) -> Result<GeneratorChangePassword> {
        Err(Error::new(
            ErrorKind::UnsupportedFunction,
            "ChangePassword is not supported in SspiCredSsp context",
        ))
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip_all)]
    fn make_signature(
        &mut self,
        _flags: u32,
        _message: &mut [SecurityBufferRef],
        _sequence_number: u32,
    ) -> crate::Result<()> {
        Err(Error::new(
            ErrorKind::UnsupportedFunction,
            "make_signature is not supported",
        ))
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip_all)]
    fn verify_signature(&mut self, _message: &mut [SecurityBufferRef], _sequence_number: u32) -> crate::Result<u32> {
        Err(Error::new(
            ErrorKind::UnsupportedFunction,
            "verify_signature is not supported",
        ))
    }
}

impl SspiImpl for SspiCredSsp {
    type CredentialsHandle = Option<CredentialsBuffers>;
    type AuthenticationData = Credentials;

    #[instrument(level = "trace", ret, fields(state = ?self.state), skip(self))]
    fn acquire_credentials_handle_impl(
        &mut self,
        builder: builders::FilledAcquireCredentialsHandle<'_, Self::CredentialsHandle, Self::AuthenticationData>,
    ) -> Result<AcquireCredentialsHandleResult<Self::CredentialsHandle>> {
        if builder.credential_use == CredentialUse::Outbound && builder.auth_data.is_none() {
            return Err(Error::new(
                ErrorKind::NoCredentials,
                "The client must specify the auth data",
            ));
        }

        self.auth_identity = builder
            .auth_data
            .cloned()
            .map(|auth_data| auth_data.try_into())
            .transpose()?;

        Ok(AcquireCredentialsHandleResult {
            credentials_handle: self.auth_identity.clone(),
            expiry: None,
        })
    }

    fn initialize_security_context_impl<'ctx, 'b, 'g>(
        &'ctx mut self,
        builder: &'b mut builders::FilledInitializeSecurityContext<'ctx, Self::CredentialsHandle>,
    ) -> Result<GeneratorInitSecurityContext<'g>>
    where
        'ctx: 'g,
        'b: 'g,
    {
        Ok(GeneratorInitSecurityContext::new(move |mut yield_point| async move {
            self.initialize_security_context_impl(&mut yield_point, builder).await
        }))
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip(self, builder))]
    fn accept_security_context_impl<'a>(
        &'a mut self,
        builder: builders::FilledAcceptSecurityContext<'a, Self::CredentialsHandle>,
    ) -> Result<GeneratorAcceptSecurityContext<'a>> {
        Ok(GeneratorAcceptSecurityContext::new(move |mut yield_point| async move {
            self.accept_security_context_impl(&mut yield_point, builder).await
        }))
    }
}

impl SspiCredSsp {
    pub(crate) async fn accept_security_context_impl(
        &mut self,
        _yield_point: &mut YieldPointLocal,
        _builder: builders::FilledAcceptSecurityContext<'_, <Self as SspiImpl>::CredentialsHandle>,
    ) -> Result<crate::AcceptSecurityContextResult> {
        Err(Error::new(
            ErrorKind::UnsupportedFunction,
            "accept_security_context_impl is not supported in SspiCredSsp",
        ))
    }

    #[instrument(ret, level = "debug", fields(state = ?self.state), skip_all)]
    #[async_recursion]
    pub(crate) async fn initialize_security_context_impl<'a>(
        &mut self,
        yield_point: &mut YieldPointLocal,
        builder: &mut builders::FilledInitializeSecurityContext<'a, <Self as SspiImpl>::CredentialsHandle>,
    ) -> Result<InitializeSecurityContextResult> {
        trace!(?builder);
        // In the CredSSP we always set DELEGATE flag
        //
        // https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-cssp/e36b36f6-edf4-4df1-9905-9e53b7d7c7b7
        // The CredSSP Protocol enables an application to securely delegate a user's credentials from a client to a target server.
        builder.context_requirements |= ClientRequestFlags::DELEGATE;

        // The CredSSP flag should be always set in the CredSsp protocol.
        builder.context_requirements.set(ClientRequestFlags::MUTUAL_AUTH, true);

        let status = match &self.state {
            CredSspState::Tls => {
                if self.tls_connection.is_none() {
                    let (_, target_hostname) =
                        crate::utils::parse_target_name(builder.target_name.ok_or_else(|| {
                            Error::new(
                                ErrorKind::NoCredentials,
                                "Service target name (service principal name) is not provided",
                            )
                        })?)?;

                    let mut client_config = ClientConfig::builder()
                        .dangerous()
                        .with_custom_certificate_verifier(Arc::new(danger::NoCertificateVerification))
                        .with_no_client_auth();

                    client_config.key_log = Arc::new(rustls::KeyLogFile::new());

                    let config = Arc::new(client_config);

                    self.tls_connection = Some(TlsConnection::Rustls(Connection::Client(
                        ClientConnection::new(
                            config,
                            target_hostname.to_owned().try_into().map_err(|e| {
                                Error::new(
                                    ErrorKind::InvalidParameter,
                                    format!("provided target name is not valid DNS name: {:?}", e),
                                )
                            })?,
                        )
                        .map_err(|err| Error::new(ErrorKind::InternalError, err.to_string()))?,
                    )));
                }

                // input token can not present on the first call
                let input_token = builder
                    .input
                    .as_mut()
                    .and_then(|buffers| SecurityBuffer::find_buffer_mut(buffers, BufferType::Token).ok())
                    .map(|sec_buffer| sec_buffer.buffer.as_slice())
                    .unwrap_or_default();
                let (bytes_written, tls_buffer) = self.tls_connection_mut()?.process_tls_packets(input_token)?;

                if bytes_written == 0 {
                    self.state = CredSspState::NegoToken;

                    // delete the previous TLS message
                    builder.input = None;

                    return self.initialize_security_context_impl(yield_point, builder).await;
                }

                let output_token = SecurityBuffer::find_buffer_mut(builder.output, BufferType::Token)?;
                output_token.buffer = tls_buffer;

                SecurityStatus::ContinueNeeded
            }
            CredSspState::NegoToken => {
                // decrypt and decode TsRequest from input buffers
                let mut ts_request = builder
                    .input
                    .as_mut()
                    .map(|input| self.decrypt_and_decode_ts_request(input))
                    .unwrap_or_else(|| Ok(TsRequest::default()))?;

                self.cred_ssp_context.check_peer_version(ts_request.version)?;

                let mut input_token = vec![SecurityBuffer::new(
                    ts_request.nego_tokens.take().unwrap_or_default(),
                    BufferType::Token,
                )];

                let mut output_token = vec![SecurityBuffer::new(Vec::with_capacity(1024), BufferType::Token)];

                let mut inner_builder = self
                    .cred_ssp_context
                    .sspi_context
                    .initialize_security_context()
                    .with_credentials_handle(builder.credentials_handle.take().ok_or_else(|| {
                        Error::new(ErrorKind::WrongCredentialHandle, "credentials handle is not present")
                    })?)
                    .with_context_requirements(builder.context_requirements)
                    .with_target_data_representation(DataRepresentation::Native);
                if let Some(target_name) = &builder.target_name {
                    inner_builder = inner_builder.with_target_name(target_name);
                }
                let mut inner_builder = inner_builder
                    .with_input(&mut input_token)
                    .with_output(&mut output_token);

                let result = self
                    .cred_ssp_context
                    .sspi_context
                    .initialize_security_context_impl(yield_point, &mut inner_builder)
                    .await?;

                ts_request.nego_tokens = Some(output_token.remove(0).buffer);

                if result.status == SecurityStatus::Ok {
                    let public_key = self.raw_peer_public_key()?;

                    let peer_version = self
                        .cred_ssp_context
                        .peer_version
                        .expect("An encrypt public key client function cannot be fired without any incoming TSRequest");
                    ts_request.pub_key_auth = Some(self.cred_ssp_context.encrypt_public_key(
                        &public_key,
                        EndpointType::Client,
                        &self.nonce,
                        peer_version,
                    )?);

                    ts_request.client_nonce = self.nonce;

                    if let Some(nego_tokens) = &ts_request.nego_tokens {
                        if nego_tokens.is_empty() {
                            ts_request.nego_tokens = None;
                        }
                    }

                    self.state = CredSspState::AuthInfo;
                }

                let mut encoded_ts_request = Vec::new();
                ts_request.encode_ts_request(&mut encoded_ts_request)?;

                let output_token = SecurityBuffer::find_buffer_mut(builder.output, BufferType::Token)?;
                output_token.buffer = self.tls_connection_mut()?.encrypt_tls(&encoded_ts_request)?;

                SecurityStatus::ContinueNeeded
            }
            CredSspState::AuthInfo => {
                let mut ts_request = builder
                    .input
                    .as_mut()
                    .map(|input| self.decrypt_and_decode_ts_request(input))
                    .unwrap_or_else(|| Ok(TsRequest::default()))?;

                ts_request.nego_tokens = None;

                let pub_key_auth = ts_request
                    .pub_key_auth
                    .take()
                    .ok_or_else(|| Error::new(ErrorKind::InvalidToken, "Expected an encrypted public key"))?;
                let peer_version = self
                    .cred_ssp_context
                    .peer_version
                    .expect("An encrypt public key client function cannot be fired without any incoming TSRequest");

                let peer_public_key = self.raw_peer_public_key()?;
                self.cred_ssp_context.decrypt_public_key(
                    &peer_public_key,
                    pub_key_auth.as_ref(),
                    EndpointType::Client,
                    &self.nonce,
                    peer_version,
                )?;

                let credentials = builder
                    .credentials_handle
                    .take()
                    .and_then(|c| c.as_ref())
                    .ok_or_else(|| Error::new(ErrorKind::WrongCredentialHandle, "credentials handle is not present"))?;

                ts_request.auth_info = Some(
                    self.cred_ssp_context
                        .encrypt_ts_credentials(credentials, CredSspMode::WithCredentials)?,
                );

                let mut encoded_ts_request = Vec::new();
                ts_request.encode_ts_request(&mut encoded_ts_request)?;

                let output_token = SecurityBuffer::find_buffer_mut(builder.output, BufferType::Token)?;
                output_token.buffer = self.tls_connection_mut()?.encrypt_tls(&encoded_ts_request)?;

                self.state = CredSspState::Final;

                SecurityStatus::Ok
            }
            CredSspState::Final => {
                return Err(Error::new(
                    ErrorKind::OutOfSequence,
                    "Initialize security context function has been called after authorization",
                ));
            }
        };

        trace!(?builder);

        Ok(InitializeSecurityContextResult {
            status,
            flags: ClientResponseFlags::empty(),
            expiry: None,
        })
    }
}

impl SspiEx for SspiCredSsp {
    #[instrument(level = "trace", ret, fields(state = ?self.state), skip(self))]
    fn custom_set_auth_identity(&mut self, identity: Self::AuthenticationData) -> Result<()> {
        self.auth_identity = Some(identity.try_into()?);

        Ok(())
    }
}


--- File: src/credssp/sspi_cred_ssp/tls_connection.rs ---
use std::io::{Read, Write};

use picky_asn1_x509::Certificate;
use rustls::{Connection, ProtocolVersion};

use crate::credssp::sspi_cred_ssp::cipher_block_size::get_cipher_block_size;
use crate::{
    ConnectionCipher, ConnectionHash, ConnectionInfo, ConnectionKeyExchange, ConnectionProtocol, Error, ErrorKind,
    Result, StreamSizes,
};

// type + version + length
pub const TLS_PACKET_HEADER_LEN: usize = 1 /* ContentType */ + 2 /* ProtocolVersion */ + 2 /* length: uint16 */;

// The Secure Sockets Layer (SSL) Protocol Version 3.0
// https://datatracker.ietf.org/doc/html/rfc6101#page-14
//
// ...Sequence numbers are of type uint64 and may not exceed 2^64-1.
const TLS_PACKET_SEQUENCE_NUMBER_LEN: usize = std::mem::size_of::<u64>();

// The Secure Sockets Layer (SSL) Protocol Version 3.0
// https://datatracker.ietf.org/doc/html/rfc6101#appendix-A.1
//
// application_data(23)
const TLS_APPLICATION_DATA_CONTENT_TYPE: u8 = 0x17;

// [Processing Events and Sequencing Rules](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-cssp/385a7489-d46b-464c-b224-f7340e308a5c)
// The CredSSP server does not request the client's X.509 certificate (thus far, the client is anonymous).
// Also, the CredSSP Protocol does not require the client to have a commonly trusted certification authority root with the CredSSP server.
//
// This configuration just accepts any certificate
pub mod danger {
    use rustls::client::danger::{HandshakeSignatureValid, ServerCertVerified, ServerCertVerifier};
    use rustls::{pki_types, DigitallySignedStruct, Error, SignatureScheme};

    #[derive(Debug)]
    pub struct NoCertificateVerification;

    impl ServerCertVerifier for NoCertificateVerification {
        fn verify_server_cert(
            &self,
            _: &pki_types::CertificateDer<'_>,
            _: &[pki_types::CertificateDer<'_>],
            _: &pki_types::ServerName<'_>,
            _: &[u8],
            _: pki_types::UnixTime,
        ) -> Result<ServerCertVerified, Error> {
            Ok(ServerCertVerified::assertion())
        }

        fn verify_tls12_signature(
            &self,
            _: &[u8],
            _: &pki_types::CertificateDer<'_>,
            _: &DigitallySignedStruct,
        ) -> Result<HandshakeSignatureValid, Error> {
            Ok(HandshakeSignatureValid::assertion())
        }

        fn verify_tls13_signature(
            &self,
            _: &[u8],
            _: &pki_types::CertificateDer<'_>,
            _: &DigitallySignedStruct,
        ) -> Result<HandshakeSignatureValid, Error> {
            Ok(HandshakeSignatureValid::assertion())
        }

        fn supported_verify_schemes(&self) -> Vec<SignatureScheme> {
            vec![
                SignatureScheme::RSA_PKCS1_SHA1,
                SignatureScheme::ECDSA_SHA1_Legacy,
                SignatureScheme::RSA_PKCS1_SHA256,
                SignatureScheme::ECDSA_NISTP256_SHA256,
                SignatureScheme::RSA_PKCS1_SHA384,
                SignatureScheme::ECDSA_NISTP384_SHA384,
                SignatureScheme::RSA_PKCS1_SHA512,
                SignatureScheme::ECDSA_NISTP521_SHA512,
                SignatureScheme::RSA_PSS_SHA256,
                SignatureScheme::RSA_PSS_SHA384,
                SignatureScheme::RSA_PSS_SHA512,
                SignatureScheme::ED25519,
                SignatureScheme::ED448,
            ]
        }
    }
}

/// Represents parsed part of the TLS traffic.
///
/// The input buffer can contain part of the TLS message, one TLS packet, or even more than one TLS packet.
/// To decrypt the incoming buffer sometimes we need to split it into parts. If it contains more then one TLS packet,
/// we should decrypt only first of them. This behavior corresponds to the SChannel behavior.
#[derive(Debug)]
struct TlsTrafficParts<'data> {
    /// TLS packet header with a sequence number.
    header: &'data mut [u8],
    /// Decrypted part of the TLS packet.
    ///
    /// *Pay attention*: the TLS packet sequence number must be in the [header] buffer.
    application_data: &'data mut [u8],
    /// Unprocessed TLS packets.
    extra: &'data mut [u8],
}

/// Represents buffers after the decryption.
///
/// We can not return just decrypted data because we also need a TLS header and unprocessed data buffers.
/// More info: https://learn.microsoft.com/en-us/windows/win32/secauthn/decryptmessage--schannel
///
/// After the decryption, the original SChannel produces four buffers (the order is important):
/// * SECBUFFER_STREAM_HEADER. It contains TLS packet header with a sequence number.
/// * SECBUFFER_DATA. It contains a decrypted data.
/// * SECBUFFER_STREAM_TRAILER. It contains the TLS packet HMAC with all unprocessed data.
/// * SECBUFFER_EXTRA. It contains the rest of the unprocessed TLS traffic. Usually, the start of this buffer
///   points to the start of the next TLS packet in the input buffer.
#[derive(Debug)]
pub struct DecryptionResultBuffers<'data> {
    /// TLS packet header with the sequence number.
    pub header: &'data mut [u8],
    /// Decrypted data.
    pub decrypted: &'data mut [u8],
    /// Unprocessed TLS packets.
    pub extra: &'data mut [u8],
}

/// Represent a successful [decrypt_message] function result.
///
/// This helper structure exists because sometimes the decrypt function can get incomplete TLS packet
/// and needs more bytes to perform the decryption. Such a situation is not an actual error but,
/// on the other hand, there is no data to return. So, this is why the [DecryptionResult::IncompleteMessage] exists.
#[derive(Debug)]
pub enum DecryptionResult<'data> {
    /// Indicated successful TLS packet decryption.
    Success(DecryptionResultBuffers<'data>),
    /// Indicated that the input buffer is too small to perform the decryption and
    /// the function needs more bytes to do it.
    IncompleteMessage(usize),
}

#[derive(Debug)]
pub enum TlsConnection {
    Rustls(Connection),
    // Schannel
}

/// Represents a result of extracting the first TLS packet from the TLS traffic buffer.
enum FindTlsPacketResult<'data> {
    /// TLS packet.
    TlsPacket(&'data mut [u8]),
    /// Indicated how many bytes the input buffer lacks to represent a complete TLS packet.
    Missing(usize),
}

impl TlsConnection {
    pub fn encrypt_tls(&mut self, plain_data: &[u8]) -> Result<Vec<u8>> {
        match self {
            TlsConnection::Rustls(tls_connection) => {
                let mut writer = tls_connection.writer();
                let _bytes_written = writer.write(plain_data)?;

                let mut tls_buffer = Vec::new();
                let _bytes_written = tls_connection.write_tls(&mut tls_buffer)?;

                Ok(tls_buffer)
            }
        }
    }

    // This function extracts the first TLS packet from the TLS traffic buffer.
    // If the input buffer contains less than one TLS packet (only a part of it), then
    // it returns how many bytes the input buffer lacks to represent a complete TLS packet.
    fn find_tls_data_to_decrypt<'data>(
        connection: &Connection,
        payload: &'data mut [u8],
    ) -> Result<FindTlsPacketResult<'data>> {
        if payload.len() < TLS_PACKET_HEADER_LEN {
            // We need at least TLS_PACKET_HEADER_LEN bytes to recognize the TLS packet, its type, and length.
            return Ok(FindTlsPacketResult::Missing(TLS_PACKET_HEADER_LEN));
        }

        // In the decryption stage, we accept only TLS packets with TLS_APPLICATION_CONTENT_TYPE specified.
        // Additional info: https://stackoverflow.com/a/65101172:
        // "...DecryptMessage() only works if the record type is "application data". For any other
        // record type (such as a TLS handshake "finished message"), DecryptMessage() won't even
        // try to decrypt it -- it will just return a SEC_E_DECRYPT_FAILURE code."
        let mut tls_packet_start = vec![TLS_APPLICATION_DATA_CONTENT_TYPE];

        let tls_version: u16 = connection
            .protocol_version()
            .ok_or_else(|| Error::new(ErrorKind::InternalError, "can not query negotiated TLS version"))?
            .into();

        tls_packet_start.extend_from_slice(&tls_version.to_be_bytes());

        // Safe: payload length is checked above.
        if payload[0..1 /* ContentType */ + 2 /* ProtocolVersion */] != tls_packet_start {
            return Err(Error::new(ErrorKind::InvalidToken, "invalid TLS packet header."));
        }

        // Safe: payload length is checked above.
        let encrypted_application_data_len = usize::from(u16::from_be_bytes(payload[3..5].try_into().unwrap()));

        let tls_packet_len = TLS_PACKET_HEADER_LEN + encrypted_application_data_len;
        if payload.len() < tls_packet_len {
            return Ok(FindTlsPacketResult::Missing(
                TLS_PACKET_HEADER_LEN + encrypted_application_data_len - payload.len(),
            ));
        }

        // Safe: payload length is checked above.
        Ok(FindTlsPacketResult::TlsPacket(&mut payload[0..tls_packet_len]))
    }

    // This function splits the incoming TLS traffic into three parts (if possible):
    // * header.
    // * application_data.
    // * extra.
    // See the [TlsTrafficParts] documentation for a more detailed explanation of those buffers.
    fn split_tls_traffic<'a>(connection: &Connection, payload: &'a mut [u8]) -> Result<TlsTrafficParts<'a>> {
        const TLS_PACKET_PREFIX_LEN: usize = TLS_PACKET_HEADER_LEN + TLS_PACKET_SEQUENCE_NUMBER_LEN;

        if payload.len() < TLS_PACKET_PREFIX_LEN {
            return Err(Error::new(ErrorKind::InvalidToken, "Input TLS buffer is too short."));
        }

        // In the decryption stage, we accept only TLS packets with TLS_APPLICATION_CONTENT_TYPE specified.
        // Additional info: https://stackoverflow.com/a/65101172:
        // "...DecryptMessage() only works if the record type is "application data". For any other
        // record type (such as a TLS handshake "finished message"), DecryptMessage() won't even
        // try to decrypt it -- it will just return a SEC_E_DECRYPT_FAILURE code."
        let mut tls_packet_start = vec![TLS_APPLICATION_DATA_CONTENT_TYPE];

        let tls_version: u16 = connection
            .protocol_version()
            .ok_or_else(|| Error::new(ErrorKind::InternalError, "can not query negotiated TLS version"))?
            .into();

        tls_packet_start.extend_from_slice(&tls_version.to_be_bytes());

        // Safe: payload length is checked above.
        if payload[0..1 /* ContentType */ + 2 /* ProtocolVersion */] != tls_packet_start {
            return Err(Error::new(ErrorKind::InvalidToken, "invalid TLS packet header."));
        }

        // Safe: payload length is checked above.
        let encrypted_application_data_len = usize::from(u16::from_be_bytes(payload[3..5].try_into().unwrap()));

        if payload.len() < TLS_PACKET_HEADER_LEN + encrypted_application_data_len {
            return Err(Error::new(ErrorKind::InvalidToken, "Input TLS buffer is too short."));
        }

        // Safe: payload length is checked above.
        let (header, rest) = payload.split_at_mut(TLS_PACKET_PREFIX_LEN);
        // `encrypted_application_data_len` is a len of the encrypted data with the sequence number.
        // But here we need the encrypted data *WITHOUT* a sequence number, so we subtract TLS_PACKET_SEQUENCE_NUMBER_LEN
        // from the overall data length.
        let (application_data, extra) =
            rest.split_at_mut(encrypted_application_data_len - TLS_PACKET_SEQUENCE_NUMBER_LEN);

        Ok(TlsTrafficParts {
            header,
            application_data,
            extra,
        })
    }

    /// Decrypt a part of the incoming TLS traffic.
    ///
    /// If the input buffer contains more than one TLS message,then only the first one will be decrypted.
    pub fn decrypt_tls<'a>(&mut self, payload: &'a mut [u8]) -> Result<DecryptionResult<'a>> {
        match self {
            TlsConnection::Rustls(tls_connection) => {
                let mut tls_packet = match TlsConnection::find_tls_data_to_decrypt(tls_connection, payload)? {
                    FindTlsPacketResult::TlsPacket(data) => data as &[u8],
                    FindTlsPacketResult::Missing(needed_bytes_amount) => {
                        return Ok(DecryptionResult::IncompleteMessage(needed_bytes_amount));
                    }
                };
                let mut plain_data = Vec::with_capacity(tls_packet.len());

                while !tls_packet.is_empty() {
                    let _ = tls_connection.read_tls(&mut tls_packet)?;

                    let tls_state = tls_connection
                        .process_new_packets()
                        .map_err(|err| Error::new(ErrorKind::DecryptFailure, err.to_string()))?;

                    let decrypted_data_len = plain_data.len();
                    plain_data.resize(decrypted_data_len + tls_state.plaintext_bytes_to_read(), 0);

                    let mut reader = tls_connection.reader();
                    let _plain_data_len = reader.read(&mut plain_data[decrypted_data_len..])?;
                }

                let TlsTrafficParts {
                    header,
                    application_data,
                    extra,
                } = TlsConnection::split_tls_traffic(tls_connection, payload)?;

                if application_data.len() < plain_data.len() {
                    return Err(Error::new(
                        ErrorKind::DecryptFailure,
                        "Decrypted data can not be larger then encrypted one.",
                    ));
                }

                let decrypted = &mut application_data[0..plain_data.len()];
                decrypted.copy_from_slice(&plain_data);

                Ok(DecryptionResult::Success(DecryptionResultBuffers {
                    header,
                    decrypted,
                    extra,
                }))
            }
        }
    }

    pub fn peer_certificates(&self) -> Result<Vec<&[u8]>> {
        match self {
            TlsConnection::Rustls(tls_connection) => tls_connection
                .peer_certificates()
                .map(|certificates| certificates.iter().map(|cert| cert.as_ref()).collect())
                .ok_or_else(|| Error::new(ErrorKind::CertificateUnknown, "The server certificate is not present")),
        }
    }

    pub fn process_tls_packets(&mut self, mut input_token: &[u8]) -> Result<(usize, Vec<u8>)> {
        match self {
            TlsConnection::Rustls(tls_connection) => {
                if !input_token.is_empty() {
                    let _bytes_read = tls_connection.read_tls(&mut input_token)?;
                }

                let _io_status = tls_connection
                    .process_new_packets()
                    .map_err(|err| Error::new(ErrorKind::EncryptFailure, err.to_string()))?;

                let mut tls_buffer = Vec::new();
                let bytes_written = tls_connection.write_tls(&mut tls_buffer)?;

                Ok((bytes_written, tls_buffer))
            }
        }
    }

    pub fn stream_sizes(&self) -> Result<StreamSizes> {
        match self {
            TlsConnection::Rustls(tls_connection) => {
                let connection_cipher = tls_connection
                    .negotiated_cipher_suite()
                    .ok_or_else(|| Error::new(ErrorKind::InternalError, "connection cipher is not negotiated"))?;

                let suite = match connection_cipher {
                    rustls::SupportedCipherSuite::Tls12(cipher_suite) => cipher_suite.common.suite,
                    rustls::SupportedCipherSuite::Tls13(cipher_suite) => cipher_suite.common.suite,
                };

                Ok(StreamSizes {
                    header: TLS_PACKET_HEADER_LEN as u32,
                    // trailer = tls mac + padding
                    // this value is taken from the win schannel
                    trailer: 0x2c,
                    // this value is taken from the win schannel
                    max_message: 0x4000,
                    // MSDN: message must contain four buffers
                    // https://learn.microsoft.com/en-us/windows/win32/secauthn/decryptmessage--schannel
                    buffers: 4,
                    block_size: get_cipher_block_size(suite)?,
                })
            }
        }
    }

    pub fn connection_info(&self) -> Result<ConnectionInfo> {
        match self {
            TlsConnection::Rustls(tls_connection) => {
                let protocol_version = tls_connection.protocol_version().ok_or_else(|| {
                    Error::new(
                        ErrorKind::InvalidParameter,
                        "Can not acquire connection protocol version",
                    )
                })?;

                let protocol = match tls_connection {
                    Connection::Client(_) => match protocol_version {
                        ProtocolVersion::SSLv2 => ConnectionProtocol::SpProtSsl2Client,
                        ProtocolVersion::TLSv1_0 => ConnectionProtocol::SpProtTls1Client,
                        ProtocolVersion::TLSv1_1 => ConnectionProtocol::SpProtTls1_1Client,
                        ProtocolVersion::TLSv1_2 => ConnectionProtocol::SpProtTls1_2Client,
                        ProtocolVersion::TLSv1_3 => ConnectionProtocol::SpProtTls1_3Client,
                        version => {
                            return Err(Error::new(
                                ErrorKind::InternalError,
                                format!("Unsupported connection protocol was used: {:?}", version),
                            ));
                        }
                    },
                    Connection::Server(_) => match protocol_version {
                        ProtocolVersion::SSLv2 => ConnectionProtocol::SpProtSsl2Server,
                        ProtocolVersion::TLSv1_0 => ConnectionProtocol::SpProtTls1Server,
                        ProtocolVersion::TLSv1_1 => ConnectionProtocol::SpProtTls1_1Server,
                        ProtocolVersion::TLSv1_2 => ConnectionProtocol::SpProtTls1_2Server,
                        ProtocolVersion::TLSv1_3 => ConnectionProtocol::SpProtTls1_3Server,
                        version => {
                            return Err(Error::new(
                                ErrorKind::InternalError,
                                format!("Unsupported connection protocol was used: {:?}", version),
                            ));
                        }
                    },
                };

                let connection_cipher = tls_connection
                    .negotiated_cipher_suite()
                    .ok_or_else(|| Error::new(ErrorKind::InternalError, "Connection cipher is not negotiated"))?;

                let common = match connection_cipher {
                    rustls::SupportedCipherSuite::Tls12(cipher_suite) => &cipher_suite.common,
                    rustls::SupportedCipherSuite::Tls13(cipher_suite) => &cipher_suite.common,
                };

                let (cipher, cipher_strength) = match common.suite.as_str() {
                    Some(name) if name.contains("AES_128_GCM") => (ConnectionCipher::CalgAes128, 128),
                    Some(name) if name.contains("AES_256_GCM") => (ConnectionCipher::CalgAes256, 256),
                    // NOTE: alg_id for CHACHA20_POLY1305 does not exist
                    _ => {
                        return Err(Error::new(
                            ErrorKind::UnsupportedFunction,
                            format!("alg_id for {:?} is not known", common.suite),
                        ))
                    }
                };

                let hash_strength = common.hash_provider.output_len().try_into()?;

                Ok(ConnectionInfo {
                    protocol,
                    cipher,
                    cipher_strength,
                    hash: ConnectionHash::CalgSha,
                    hash_strength,
                    key_exchange: ConnectionKeyExchange::CalgRsaKeyx,
                    exchange_strength: (self.raw_peer_public_key()?.len() * 8).try_into()?,
                })
            }
        }
    }

    pub fn raw_peer_public_key(&self) -> Result<Vec<u8>> {
        let certificates = self.peer_certificates()?;
        let peer_certificate = certificates
            .first()
            .ok_or_else(|| Error::new(ErrorKind::CertificateUnknown, "cannot acquire server certificate"))?;

        let peer_certificate: Certificate = picky_asn1_der::from_bytes(peer_certificate)?;

        let raw_public_key = match peer_certificate
            .tbs_certificate
            .subject_public_key_info
            .subject_public_key
        {
            picky_asn1_x509::PublicKey::Rsa(rsa_pk) => picky_asn1_der::to_vec(&rsa_pk.0)?,
            picky_asn1_x509::PublicKey::Ec(ec) => picky_asn1_der::to_vec(&ec)?,
            picky_asn1_x509::PublicKey::Ed(ed) => picky_asn1_der::to_vec(&ed)?,
        };

        Ok(raw_public_key)
    }
}


--- File: src/credssp/ts_request/mod.rs ---
#[cfg(test)]
mod test;

use core::fmt;
use std::io::{self, Read};

use picky_asn1::wrapper::{
    ExplicitContextTag0, ExplicitContextTag1, ExplicitContextTag2, ExplicitContextTag3, ExplicitContextTag4,
    IntegerAsn1, OctetStringAsn1, Optional,
};
use picky_krb::constants::cred_ssp::{AT_KEYEXCHANGE, TS_PASSWORD_CREDS};
use picky_krb::credssp::{TsCredentials, TsCspDataDetail, TsPasswordCreds, TsSmartCardCreds};

use super::CredSspMode;
use crate::{ber, AuthIdentityBuffers, CredentialsBuffers, Error, ErrorKind, SmartCardIdentityBuffers};

pub const TS_REQUEST_VERSION: u32 = 6;

pub const NONCE_SIZE: usize = 32;
const NONCE_FIELD_LEN: u16 = 36;

/// Used for communication in the CredSSP [client](struct.CredSspServer.html)
/// and [server](struct.CredSspServer.html). It's a top-most structure that
/// they use.
///
/// # MSDN
///
/// * [TSRequest](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-cssp/6aac4dea-08ef-47a6-8747-22ea7f6d8685)
#[derive(Debug, Clone)]
pub struct TsRequest {
    /// Specifies the supported version of the CredSSP protocol.
    pub version: u32,
    /// Contains the SPNEGO tokens or NTLM messages that are passed between the client
    /// and server.
    pub nego_tokens: Option<Vec<u8>>,
    /// Contains the user's credentials that are delegated to the server.
    pub auth_info: Option<Vec<u8>>,
    /// Used to assure that the public key that is used by the server during
    /// the TLS handshake belongs to the target server and not to a man-in-the-middle.
    pub pub_key_auth: Option<Vec<u8>>,
    /// If the SPNEGO exchange fails on the server, this field is used to send
    /// the failure code to the client.
    pub error_code: Option<NStatusCode>,
    /// An array of cryptographically random bytes used to provide sufficient
    /// entropy during hash computation.
    pub client_nonce: Option<[u8; NONCE_SIZE]>,
}

impl Default for TsRequest {
    fn default() -> Self {
        Self {
            version: TS_REQUEST_VERSION,
            nego_tokens: None,
            auth_info: None,
            pub_key_auth: None,
            error_code: None,
            client_nonce: None,
        }
    }
}

impl TsRequest {
    /// Returns a length of the 'TsRequest' buffer length
    ///
    /// # Arguments
    ///
    /// * `stream` - an input stream
    pub fn read_length(mut stream: impl io::Read) -> io::Result<usize> {
        let ts_request_len =
            ber::read_sequence_tag(&mut stream).map_err(|e| io::Error::new(io::ErrorKind::UnexpectedEof, e))?;

        Ok(usize::from(ber::sizeof_sequence(ts_request_len)))
    }

    /// Creates a `TsRequest` structure from a raw array.
    ///
    /// # Arguments
    ///
    /// * `buffer` - the array of bytes
    pub fn from_buffer(buffer: &[u8]) -> io::Result<TsRequest> {
        let mut stream = io::Cursor::new(buffer);

        if buffer.len() < TsRequest::read_length(&mut stream)? {
            return Err(io::Error::new(io::ErrorKind::UnexpectedEof, "Incomplete buffer"));
        }

        ber::read_contextual_tag(&mut stream, 0, ber::Pc::Construct)?;

        let version = ber::read_integer(&mut stream)? as u32;

        let nego_tokens = if ber::read_contextual_tag_or_unwind(&mut stream, 1, ber::Pc::Construct)?.is_some() {
            ber::read_sequence_tag(&mut stream)?;
            ber::read_sequence_tag(&mut stream)?;
            ber::read_contextual_tag(&mut stream, 0, ber::Pc::Construct)?;
            let length = ber::read_octet_string_tag(&mut stream)?;
            let mut nego_tokens = vec![0x00; length as usize];
            stream.read_exact(&mut nego_tokens)?;

            Some(nego_tokens)
        } else {
            None
        };

        let auth_info = if ber::read_contextual_tag_or_unwind(&mut stream, 2, ber::Pc::Construct)?.is_some() {
            let length = ber::read_octet_string_tag(&mut stream)?;
            let mut auth_info = vec![0x00; length as usize];
            stream.read_exact(&mut auth_info)?;

            Some(auth_info)
        } else {
            None
        };

        let pub_key_auth = if ber::read_contextual_tag_or_unwind(&mut stream, 3, ber::Pc::Construct)?.is_some() {
            let length = ber::read_octet_string_tag(&mut stream)?;
            let mut pub_key_auth = vec![0x00; length as usize];
            stream.read_exact(&mut pub_key_auth)?;

            Some(pub_key_auth)
        } else {
            None
        };

        let error_code =
            if version >= 3 && ber::read_contextual_tag_or_unwind(&mut stream, 4, ber::Pc::Construct)?.is_some() {
                let read_error_code = ber::read_integer(&mut stream)?;
                let error_code = read_error_code as u32;

                Some(NStatusCode(error_code))
            } else {
                None
            };

        let client_nonce =
            if version >= 5 && ber::read_contextual_tag_or_unwind(&mut stream, 5, ber::Pc::Construct)?.is_some() {
                let length = ber::read_octet_string_tag(&mut stream)?;
                if length != NONCE_SIZE as u16 {
                    return Err(io::Error::new(
                        io::ErrorKind::InvalidData,
                        format!("Got ClientNonce with invalid length: {}", length),
                    ));
                }

                let mut client_nonce = [0x00; NONCE_SIZE];
                stream.read_exact(&mut client_nonce)?;

                Some(client_nonce)
            } else {
                None
            };

        Ok(TsRequest {
            version,
            nego_tokens,
            auth_info,
            pub_key_auth,
            error_code,
            client_nonce,
        })
    }

    /// Encodes the `TsRequest` to be ready to be sent to the TLS stream.
    ///
    /// # Arguments
    ///
    /// * `buffer` - an output buffer
    pub fn encode_ts_request(&self, mut buffer: impl io::Write) -> io::Result<()> {
        let len = self.ts_request_len();

        ber::write_sequence_tag(&mut buffer, len)?;
        /* [0] version */
        ber::write_contextual_tag(&mut buffer, 0, 3, ber::Pc::Construct)?;
        ber::write_integer(&mut buffer, self.version)?;

        /* [1] negoTokens (NegoData) */
        if let Some(ref nego_tokens) = self.nego_tokens {
            ber::write_contextual_tag(
                &mut buffer,
                1,
                ber::sizeof_sequence(ber::sizeof_sequence(ber::sizeof_sequence_octet_string(
                    nego_tokens.len() as u16,
                ))),
                ber::Pc::Construct,
            )?;
            ber::write_sequence_tag(
                &mut buffer,
                ber::sizeof_sequence(ber::sizeof_sequence_octet_string(nego_tokens.len() as u16)),
            )?; /* SEQUENCE OF NegoDataItem */
            ber::write_sequence_tag(&mut buffer, ber::sizeof_sequence_octet_string(nego_tokens.len() as u16))?; /* NegoDataItem */
            ber::write_sequence_octet_string(&mut buffer, 0, nego_tokens)?; /* OCTET STRING */
        }

        /* [2] authInfo (OCTET STRING) */
        if let Some(ref auth_info) = self.auth_info {
            ber::write_sequence_octet_string(&mut buffer, 2, auth_info)?;
        }

        /* [3] pubKeyAuth (OCTET STRING) */
        if let Some(ref pub_key_auth) = self.pub_key_auth {
            ber::write_sequence_octet_string(&mut buffer, 3, pub_key_auth)?;
        }

        /* [4] errorCode (INTEGER) */
        match self.error_code {
            Some(error_code) if self.version >= 3 => {
                let (error_code_len, _) = get_error_code_len(self.version, self.error_code);
                ber::write_contextual_tag(&mut buffer, 4, error_code_len, ber::Pc::Construct)?;
                ber::write_integer(&mut buffer, error_code.0)?;
            }
            _ => {}
        }

        /* [5] clientNonce (OCTET STRING) */
        if self.version >= 5 && self.client_nonce.is_some() {
            ber::write_sequence_octet_string(&mut buffer, 5, self.client_nonce.as_ref().unwrap())?;
        }

        Ok(())
    }

    pub fn buffer_len(&self) -> u16 {
        ber::sizeof_sequence(self.ts_request_len())
    }

    pub fn check_error(&self) -> crate::Result<()> {
        match self.error_code {
            Some(error_code) if error_code != NStatusCode::SUCCESS => Err(crate::Error::new_with_nstatus(
                crate::ErrorKind::InvalidToken,
                "CredSSP server returned an error status",
                error_code,
            )),
            _ => Ok(()),
        }
    }

    fn ts_request_len(&self) -> u16 {
        let (error_code_len, error_code_context_len) = get_error_code_len(self.version, self.error_code);
        let client_nonce_len = if self.client_nonce.is_some() && self.version >= 5 {
            NONCE_FIELD_LEN
        } else {
            0
        };
        let fields_len = get_nego_tokens_len(&self.nego_tokens)
            + get_field_len(&self.pub_key_auth)
            + get_field_len(&self.auth_info)
            + client_nonce_len
            + error_code_context_len
            + error_code_len;

        fields_len + ber::sizeof_integer(2) + ber::sizeof_contextual_tag(3)
    }
}

#[instrument(ret, level = "debug")]
fn write_smart_card_credentials(credentials: &SmartCardIdentityBuffers) -> crate::Result<Vec<u8>> {
    let smart_card_creds = TsSmartCardCreds {
        pin: ExplicitContextTag0::from(OctetStringAsn1::from(credentials.pin.as_ref().to_vec())),
        csp_data: ExplicitContextTag1::from(TsCspDataDetail {
            key_spec: ExplicitContextTag0::from(IntegerAsn1::from(vec![AT_KEYEXCHANGE])),
            card_name: Optional::from(
                credentials
                    .card_name
                    .clone()
                    .map(|name| ExplicitContextTag1::from(OctetStringAsn1::from(name))),
            ),
            reader_name: Optional::from(Some(ExplicitContextTag2::from(OctetStringAsn1::from(
                credentials.reader_name.clone(),
            )))),
            container_name: Optional::from(Some(ExplicitContextTag3::from(OctetStringAsn1::from(
                credentials.container_name.clone(),
            )))),
            csp_name: Optional::from(Some(ExplicitContextTag4::from(OctetStringAsn1::from(
                credentials.csp_name.clone(),
            )))),
        }),
        user_hint: Optional::from(None),
        domain_hint: Optional::from(None),
    };

    Ok(picky_asn1_der::to_vec(&smart_card_creds)?)
}

#[instrument(level = "trace", ret)]
pub fn write_ts_credentials(credentials: &CredentialsBuffers, cred_ssp_mode: CredSspMode) -> crate::Result<Vec<u8>> {
    let (creds_type, encoded_credentials) = match credentials {
        CredentialsBuffers::AuthIdentity(creds) => {
            (TS_PASSWORD_CREDS, write_password_credentials(creds, cred_ssp_mode)?)
        }
        CredentialsBuffers::SmartCard(creds) => (
            picky_krb::constants::cred_ssp::TS_SMART_CARD_CREDS,
            write_smart_card_credentials(creds)?,
        ),
    };

    let ts_creds = TsCredentials {
        cred_type: ExplicitContextTag0::from(IntegerAsn1::from(vec![creds_type])),
        credentials: ExplicitContextTag1::from(OctetStringAsn1::from(encoded_credentials)),
    };

    Ok(picky_asn1_der::to_vec(&ts_creds)?)
}

#[instrument(ret, level = "debug")]
fn write_password_credentials(credentials: &AuthIdentityBuffers, cred_ssp_mode: CredSspMode) -> io::Result<Vec<u8>> {
    let empty_identity = AuthIdentityBuffers::default();
    let identity = match cred_ssp_mode {
        CredSspMode::WithCredentials => credentials,
        CredSspMode::CredentialLess => &empty_identity,
    };

    let ts_credentials_len = sizeof_ts_credentials(identity);
    let ts_credentials_sequence_len = ber::sizeof_sequence(ts_credentials_len);
    let password_credentials_len = sizeof_ts_password_creds(identity);

    let mut buffer = Vec::with_capacity(ts_credentials_sequence_len as usize);

    /* TSPasswordCreds (SEQUENCE) */
    ber::write_sequence_tag(&mut buffer, password_credentials_len)?;
    /* [0] domainName (OCTET STRING) */
    ber::write_sequence_octet_string(&mut buffer, 0, &identity.domain)?;
    /* [1] userName (OCTET STRING) */
    ber::write_sequence_octet_string(&mut buffer, 1, &identity.user)?;
    /* [2] password (OCTET STRING) */
    ber::write_sequence_octet_string(&mut buffer, 2, identity.password.as_ref())?;

    Ok(buffer)
}

fn read_password_credentials(data: impl AsRef<[u8]>) -> crate::Result<AuthIdentityBuffers> {
    let password_creds: TsPasswordCreds = picky_asn1_der::from_bytes(data.as_ref())?;

    let TsPasswordCreds {
        domain_name,
        user_name,
        password,
    } = password_creds;

    Ok(AuthIdentityBuffers {
        user: user_name.0 .0,
        domain: domain_name.0 .0,
        password: password.0 .0.into(),
    })
}

pub fn read_ts_credentials(mut buffer: impl io::Read) -> crate::Result<CredentialsBuffers> {
    let ts_credentials: TsCredentials = picky_asn1_der::from_reader(&mut buffer)?;

    match ts_credentials.cred_type.0 .0.first() {
        Some(&TS_PASSWORD_CREDS) => Ok(CredentialsBuffers::AuthIdentity(read_password_credentials(
            &ts_credentials.credentials.0 .0,
        )?)),
        Some(&picky_krb::constants::cred_ssp::TS_SMART_CARD_CREDS) => Err(Error::new(
            ErrorKind::UnsupportedFunction,
            "Reading of the TsSmartCard credentials is not supported yet",
        )),
        Some(cred_type) => Err(Error::new(
            ErrorKind::InvalidToken,
            format!("Invalid or unsupported TsCredentials::cred_type value: {}", cred_type),
        )),
        None => Err(Error::new(
            ErrorKind::InvalidToken,
            "TsCredentials::cred_type field is empty",
        )),
    }
}

fn sizeof_ts_credentials(identity: &AuthIdentityBuffers) -> u16 {
    ber::sizeof_integer(1)
        + ber::sizeof_contextual_tag(ber::sizeof_integer(1))
        + ber::sizeof_sequence_octet_string(ber::sizeof_sequence(sizeof_ts_password_creds(identity)))
}

fn sizeof_ts_password_creds(identity: &AuthIdentityBuffers) -> u16 {
    ber::sizeof_sequence_octet_string(identity.domain.len() as u16)
        + ber::sizeof_sequence_octet_string(identity.user.len() as u16)
        + ber::sizeof_sequence_octet_string(identity.password.as_ref().len() as u16)
}

fn get_nego_tokens_len(nego_tokens: &Option<Vec<u8>>) -> u16 {
    match nego_tokens {
        Some(nego_tokens) => {
            let nego_len = nego_tokens.len() as u16;
            let mut len = ber::sizeof_octet_string(nego_len);
            len += ber::sizeof_contextual_tag(len);
            len += ber::sizeof_sequence_tag(len);
            len += ber::sizeof_sequence_tag(len);
            len += ber::sizeof_contextual_tag(len);

            len
        }
        None => 0,
    }
}

fn get_error_code_len(version: u32, error_code: impl Into<Option<NStatusCode>>) -> (u16, u16) {
    match error_code.into() {
        Some(error_code) if version >= 3 && version != 5 => {
            let len = ber::sizeof_integer(error_code.0);
            let context_len = ber::sizeof_contextual_tag(len);

            (len, context_len)
        }
        _ => (0, 0),
    }
}

fn get_field_len(field: &Option<Vec<u8>>) -> u16 {
    match field {
        Some(field) => {
            let field_len = field.len() as u16;
            let mut len = ber::sizeof_octet_string(field_len);
            len += ber::sizeof_contextual_tag(len);

            len
        }
        None => 0,
    }
}

#[derive(Clone, Copy, PartialEq, Eq)]
pub struct NStatusCode(pub u32);

impl NStatusCode {
    pub const SUCCESS: Self = Self(0x0000_0000);
    pub const NO_QUOTAS_FOR_ACCOUNT: Self = Self(0x0000_010d);
    pub const NO_LOGON_SERVERS: Self = Self(0xc000_005e);
    pub const NO_SUCH_LOGON_SESSION: Self = Self(0xc000_005f);
    pub const NO_SUCH_PRIVILEGE: Self = Self(0xc000_0060);
    pub const PRIVILEGE_NOT_HELD: Self = Self(0xc000_0061);
    pub const INVALID_ACCOUNT_NAME: Self = Self(0xc000_0062);
    pub const USER_EXISTS: Self = Self(0xc000_0063);
    pub const NO_SUCH_USER: Self = Self(0xc000_0064);
    pub const GROUP_EXISTS: Self = Self(0xc000_0065);
    pub const NO_SUCH_GROUP: Self = Self(0xc000_0066);
    pub const MEMBER_IN_GROUP: Self = Self(0xc000_0067);
    pub const MEMBER_NOT_IN_GROUP: Self = Self(0xc000_0068);
    pub const LAST_ADMIN: Self = Self(0xc000_0069);
    pub const WRONG_PASSWORD: Self = Self(0xc000_006a);
    pub const ILL_FORMED_PASSWORD: Self = Self(0xc000_006b);
    pub const PASSWORD_RESTRICTION: Self = Self(0xc000_006c);
    pub const LOGON_FAILURE: Self = Self(0xc000_006d);
    pub const ACCOUNT_RESTRICTION: Self = Self(0xc000_006e);
    pub const INVALID_LOGON_HOURS: Self = Self(0xc000_006f);
    pub const INVALID_WORKSTATION: Self = Self(0xc000_0070);
    pub const PASSWORD_EXPIRED: Self = Self(0xc000_0071);
    pub const ACCOUNT_DISABLED: Self = Self(0xc000_0072);
    pub const IO_TIMEOUT: Self = Self(0xc000_00b5);
    pub const NOT_LOGON_PROCESS: Self = Self(0xc000_00ed);
    pub const LOGON_SESSION_EXISTS: Self = Self(0xc000_00ee);
    pub const BAD_LOGON_SESSION_STATE: Self = Self(0xc000_0104);
    pub const LOGON_SESSION_COLLISION: Self = Self(0xc000_0105);
    pub const INVALID_LOGON_TYPE: Self = Self(0xc000_010b);
    pub const SPECIAL_ACCOUNT: Self = Self(0xc000_0124);
    pub const TOKEN_ALREADY_IN_USE: Self = Self(0xc000_012b);
    pub const LOGON_SERVER_CONFLICT: Self = Self(0xc000_0132);
    pub const TIME_DIFFERENCE_AT_DC: Self = Self(0xc000_0133);
    pub const MEMBER_NOT_IN_ALIAS: Self = Self(0xc000_0152);
    pub const MEMBER_IN_ALIAS: Self = Self(0xc000_0153);
    pub const LOGON_NOT_GRANTED: Self = Self(0xc000_0155);
    pub const LOGON_TYPE_NOT_GRANTED: Self = Self(0xc000_015b);
    pub const TRANSACTION_TIMED_OUT: Self = Self(0xc000_0210);
    pub const PASSWORD_MUST_CHANGE: Self = Self(0xc000_0224);
    pub const ACCOUNT_LOCKED_OUT: Self = Self(0xc000_0234);
    pub const INSUFFICIENT_LOGON_INFO: Self = Self(0xc000_0250);
    pub const SMARTCARD_LOGON_REQUIRED: Self = Self(0xc000_02fa);
    pub const CTX_LOGON_DISABLED: Self = Self(0xc00a_0037);

    pub fn name(self) -> Option<&'static str> {
        let name = match self {
            Self::SUCCESS => "STATUS_SUCCESS",
            Self::NO_QUOTAS_FOR_ACCOUNT => "STATUS_NO_QUOTAS_FOR_ACCOUNT",
            Self::NO_LOGON_SERVERS => "STATUS_NO_LOGON_SERVERS",
            Self::NO_SUCH_LOGON_SESSION => "STATUS_NO_SUCH_LOGON_SESSION",
            Self::NO_SUCH_PRIVILEGE => "STATUS_NO_SUCH_PRIVILEGE",
            Self::PRIVILEGE_NOT_HELD => "STATUS_PRIVILEGE_NOT_HELD",
            Self::INVALID_ACCOUNT_NAME => "STATUS_INVALID_ACCOUNT_NAME",
            Self::USER_EXISTS => "STATUS_USER_EXISTS",
            Self::NO_SUCH_USER => "STATUS_NO_SUCH_USER",
            Self::GROUP_EXISTS => "STATUS_GROUP_EXISTS",
            Self::NO_SUCH_GROUP => "STATUS_NO_SUCH_GROUP",
            Self::MEMBER_IN_GROUP => "STATUS_MEMBER_IN_GROUP",
            Self::MEMBER_NOT_IN_GROUP => "STATUS_MEMBER_NOT_IN_GROUP",
            Self::LAST_ADMIN => "STATUS_LAST_ADMIN",
            Self::WRONG_PASSWORD => "STATUS_WRONG_PASSWORD",
            Self::ILL_FORMED_PASSWORD => "STATUS_ILL_FORMED_PASSWORD",
            Self::PASSWORD_RESTRICTION => "STATUS_PASSWORD_RESTRICTION",
            Self::LOGON_FAILURE => "STATUS_LOGON_FAILURE",
            Self::ACCOUNT_RESTRICTION => "STATUS_ACCOUNT_RESTRICTION",
            Self::INVALID_LOGON_HOURS => "STATUS_INVALID_LOGON_HOURS",
            Self::INVALID_WORKSTATION => "STATUS_INVALID_WORKSTATION",
            Self::PASSWORD_EXPIRED => "STATUS_PASSWORD_EXPIRED",
            Self::ACCOUNT_DISABLED => "STATUS_ACCOUNT_DISABLED",
            Self::IO_TIMEOUT => "STATUS_IO_TIMEOUT",
            Self::NOT_LOGON_PROCESS => "STATUS_NOT_LOGON_PROCESS",
            Self::LOGON_SESSION_EXISTS => "STATUS_LOGON_SESSION_EXISTS",
            Self::BAD_LOGON_SESSION_STATE => "STATUS_BAD_LOGON_SESSION_STATE",
            Self::LOGON_SESSION_COLLISION => "STATUS_LOGON_SESSION_COLLISION",
            Self::INVALID_LOGON_TYPE => "STATUS_INVALID_LOGON_TYPE",
            Self::SPECIAL_ACCOUNT => "STATUS_SPECIAL_ACCOUNT",
            Self::TOKEN_ALREADY_IN_USE => "STATUS_TOKEN_ALREADY_IN_USE",
            Self::LOGON_SERVER_CONFLICT => "STATUS_LOGON_SERVER_CONFLICT",
            Self::TIME_DIFFERENCE_AT_DC => "STATUS_TIME_DIFFERENCE_AT_DC",
            Self::MEMBER_NOT_IN_ALIAS => "STATUS_MEMBER_NOT_IN_ALIAS",
            Self::MEMBER_IN_ALIAS => "STATUS_MEMBER_IN_ALIAS",
            Self::LOGON_NOT_GRANTED => "STATUS_LOGON_NOT_GRANTED",
            Self::LOGON_TYPE_NOT_GRANTED => "STATUS_LOGON_TYPE_NOT_GRANTED",
            Self::TRANSACTION_TIMED_OUT => "STATUS_TRANSACTION_TIMED_OUT",
            Self::PASSWORD_MUST_CHANGE => "STATUS_PASSWORD_MUST_CHANGE",
            Self::ACCOUNT_LOCKED_OUT => "STATUS_ACCOUNT_LOCKED_OUT",
            Self::INSUFFICIENT_LOGON_INFO => "STATUS_INSUFFICIENT_LOGON_INFO",
            Self::SMARTCARD_LOGON_REQUIRED => "STATUS_SMARTCARD_LOGON_REQUIRED",
            Self::CTX_LOGON_DISABLED => "STATUS_CTX_LOGON_DISABLED",
            _ => return None,
        };

        Some(name)
    }
}

impl fmt::Debug for NStatusCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "NStatusCode({:#x})", self.0)
    }
}

impl fmt::Display for NStatusCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if let Some(name) = self.name() {
            write!(f, "{name} [{:#x}]", self.0)
        } else {
            write!(f, "NSTATUS code {:#x}", self.0)
        }
    }
}


--- File: src/credssp/ts_request/test.rs ---
use std::sync::LazyLock;

use super::*;
use crate::credssp::CredSspMode;
use crate::{AuthIdentity, Username};

const NTLM_CLIENT_NONCE: [u8; 32] = [
    0x22, 0x10, 0x12, 0xad, 0x12, 0x5c, 0x7a, 0x15, 0xfe, 0xb6, 0x4b, 0x1f, 0xcb, 0x94, 0x83, 0x3a, 0xc5, 0x6f, 0x66,
    0x4c, 0xf3, 0xbc, 0xe7, 0x54, 0x8a, 0x5d, 0x9e, 0x05, 0x0a, 0x46, 0x91, 0xdb,
];

const NTLM_1_PHASE_TS_REQUEST: [u8; 93] = [
    0x30, 0x5b, 0xa0, 0x03, 0x02, 0x01, 0x06, 0xa1, 0x30, 0x30, 0x2e, 0x30, 0x2c, 0xa0, 0x2a, 0x04, 0x28, 0x4e, 0x54,
    0x4c, 0x4d, 0x53, 0x53, 0x50, 0x00, 0x01, 0x00, 0x00, 0x00, 0xb7, 0x82, 0x08, 0xe2, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x01, 0xb1, 0x1d, 0x00, 0x00, 0x00, 0x0f,
    0xa5, 0x22, 0x04, 0x20, 0x22, 0x10, 0x12, 0xad, 0x12, 0x5c, 0x7a, 0x15, 0xfe, 0xb6, 0x4b, 0x1f, 0xcb, 0x94, 0x83,
    0x3a, 0xc5, 0x6f, 0x66, 0x4c, 0xf3, 0xbc, 0xe7, 0x54, 0x8a, 0x5d, 0x9e, 0x05, 0x0a, 0x46, 0x91, 0xdb,
];
const NTLM_1_PHASE_NEGO_TOKEN: [u8; 40] = [
    0x4e, 0x54, 0x4c, 0x4d, 0x53, 0x53, 0x50, 0x00, 0x01, 0x00, 0x00, 0x00, 0xb7, 0x82, 0x08, 0xe2, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x01, 0xb1, 0x1d, 0x00, 0x00,
    0x00, 0x0f,
];

const NTLM_2_PHASE_TS_REQUEST: [u8; 187] = [
    0x30, 0x81, 0xb8, 0xa0, 0x03, 0x02, 0x01, 0x06, 0xa1, 0x81, 0x8c, 0x30, 0x81, 0x89, 0x30, 0x81, 0x86, 0xa0, 0x81,
    0x83, 0x04, 0x81, 0x80, 0x4e, 0x54, 0x4c, 0x4d, 0x53, 0x53, 0x50, 0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08,
    0x00, 0x38, 0x00, 0x00, 0x00, 0xb7, 0x82, 0x88, 0xe2, 0xc8, 0x6f, 0x7d, 0x24, 0xd5, 0xb0, 0x65, 0x65, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x00, 0x00, 0x06, 0x01, 0xb1, 0x1d, 0x00,
    0x00, 0x00, 0x0f, 0x56, 0x00, 0x47, 0x00, 0x50, 0x00, 0x43, 0x00, 0x02, 0x00, 0x08, 0x00, 0x56, 0x00, 0x47, 0x00,
    0x50, 0x00, 0x43, 0x00, 0x01, 0x00, 0x08, 0x00, 0x56, 0x00, 0x47, 0x00, 0x50, 0x00, 0x43, 0x00, 0x04, 0x00, 0x08,
    0x00, 0x56, 0x00, 0x47, 0x00, 0x50, 0x00, 0x43, 0x00, 0x03, 0x00, 0x08, 0x00, 0x56, 0x00, 0x47, 0x00, 0x50, 0x00,
    0x43, 0x00, 0x07, 0x00, 0x08, 0x00, 0x80, 0x26, 0x00, 0xe1, 0x4a, 0xcf, 0xd4, 0x01, 0x00, 0x00, 0x00, 0x00, 0xa5,
    0x22, 0x04, 0x20, 0x22, 0x10, 0x12, 0xad, 0x12, 0x5c, 0x7a, 0x15, 0xfe, 0xb6, 0x4b, 0x1f, 0xcb, 0x94, 0x83, 0x3a,
    0xc5, 0x6f, 0x66, 0x4c, 0xf3, 0xbc, 0xe7, 0x54, 0x8a, 0x5d, 0x9e, 0x05, 0x0a, 0x46, 0x91, 0xdb,
];
const NTLM_2_PHASE_NEGO_TOKEN: [u8; 128] = [
    0x4e, 0x54, 0x4c, 0x4d, 0x53, 0x53, 0x50, 0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x38, 0x00, 0x00,
    0x00, 0xb7, 0x82, 0x88, 0xe2, 0xc8, 0x6f, 0x7d, 0x24, 0xd5, 0xb0, 0x65, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x00, 0x00, 0x06, 0x01, 0xb1, 0x1d, 0x00, 0x00, 0x00, 0x0f, 0x56,
    0x00, 0x47, 0x00, 0x50, 0x00, 0x43, 0x00, 0x02, 0x00, 0x08, 0x00, 0x56, 0x00, 0x47, 0x00, 0x50, 0x00, 0x43, 0x00,
    0x01, 0x00, 0x08, 0x00, 0x56, 0x00, 0x47, 0x00, 0x50, 0x00, 0x43, 0x00, 0x04, 0x00, 0x08, 0x00, 0x56, 0x00, 0x47,
    0x00, 0x50, 0x00, 0x43, 0x00, 0x03, 0x00, 0x08, 0x00, 0x56, 0x00, 0x47, 0x00, 0x50, 0x00, 0x43, 0x00, 0x07, 0x00,
    0x08, 0x00, 0x80, 0x26, 0x00, 0xe1, 0x4a, 0xcf, 0xd4, 0x01, 0x00, 0x00, 0x00, 0x00,
];

const NTLM_3_PHASE_TS_REQUEST: [u8; 429] = [
    0x30, 0x82, 0x01, 0xa9, 0xa0, 0x03, 0x02, 0x01, 0x06, 0xa1, 0x82, 0x01, 0x48, 0x30, 0x82, 0x01, 0x44, 0x30, 0x82,
    0x01, 0x40, 0xa0, 0x82, 0x01, 0x3c, 0x04, 0x82, 0x01, 0x38, 0x4e, 0x54, 0x4c, 0x4d, 0x53, 0x53, 0x50, 0x00, 0x03,
    0x00, 0x00, 0x00, 0x18, 0x00, 0x18, 0x00, 0x5a, 0x00, 0x00, 0x00, 0xb6, 0x00, 0xb6, 0x00, 0x72, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x5a, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00, 0x28, 0x01, 0x00, 0x00, 0x35, 0x82, 0x88, 0xe2, 0x06, 0x01,
    0xb1, 0x1d, 0x00, 0x00, 0x00, 0x0f, 0x85, 0x61, 0x57, 0xd0, 0xe4, 0x87, 0x1c, 0x1a, 0x75, 0xc8, 0x71, 0x22, 0x58,
    0x13, 0xaa, 0x22, 0x61, 0x00, 0x4f, 0x16, 0x46, 0xf0, 0x76, 0x0b, 0x22, 0x06, 0x36, 0xba, 0x46, 0x5f, 0x56, 0x79,
    0x8b, 0x89, 0x99, 0x79, 0x66, 0x9f, 0x64, 0xc9, 0x23, 0x2b, 0xda, 0x0a, 0xa5, 0xec, 0xf1, 0x1b, 0xf8, 0xb3, 0x8d,
    0xf9, 0x23, 0xbd, 0xda, 0x3b, 0x48, 0xbc, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x26, 0x00, 0xe1,
    0x4a, 0xcf, 0xd4, 0x01, 0x99, 0x79, 0x66, 0x9f, 0x64, 0xc9, 0x23, 0x2b, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x08,
    0x00, 0x56, 0x00, 0x47, 0x00, 0x50, 0x00, 0x43, 0x00, 0x01, 0x00, 0x08, 0x00, 0x56, 0x00, 0x47, 0x00, 0x50, 0x00,
    0x43, 0x00, 0x04, 0x00, 0x08, 0x00, 0x56, 0x00, 0x47, 0x00, 0x50, 0x00, 0x43, 0x00, 0x03, 0x00, 0x08, 0x00, 0x56,
    0x00, 0x47, 0x00, 0x50, 0x00, 0x43, 0x00, 0x07, 0x00, 0x08, 0x00, 0x80, 0x26, 0x00, 0xe1, 0x4a, 0xcf, 0xd4, 0x01,
    0x06, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x1e, 0x00, 0x54, 0x00, 0x45, 0x00, 0x52, 0x00,
    0x4d, 0x00, 0x53, 0x00, 0x52, 0x00, 0x56, 0x00, 0x2f, 0x00, 0x30, 0x00, 0x2e, 0x00, 0x30, 0x00, 0x2e, 0x00, 0x30,
    0x00, 0x2e, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7f, 0x2b, 0x04, 0x65, 0x22, 0x3a, 0xc5, 0x25, 0x9d, 0x8f, 0x29, 0x30, 0x68, 0xce, 0x6a, 0x9d, 0xa3,
    0x32, 0x04, 0x30, 0x01, 0x00, 0x00, 0x00, 0xca, 0x18, 0x71, 0xef, 0x99, 0xe5, 0x16, 0x21, 0x00, 0x00, 0x00, 0x00,
    0x23, 0x1f, 0xb3, 0xbe, 0xb8, 0x05, 0x19, 0x0c, 0xe1, 0xa2, 0x9d, 0x30, 0x23, 0xd0, 0xd4, 0x21, 0x33, 0xcb, 0x94,
    0x2c, 0x5b, 0xa4, 0x66, 0x77, 0x84, 0x2e, 0x05, 0xd9, 0x4b, 0x46, 0x98, 0xac, 0xa5, 0x22, 0x04, 0x20, 0x22, 0x10,
    0x12, 0xad, 0x12, 0x5c, 0x7a, 0x15, 0xfe, 0xb6, 0x4b, 0x1f, 0xcb, 0x94, 0x83, 0x3a, 0xc5, 0x6f, 0x66, 0x4c, 0xf3,
    0xbc, 0xe7, 0x54, 0x8a, 0x5d, 0x9e, 0x05, 0x0a, 0x46, 0x91, 0xdb,
];
const NTLM_3_PHASE_NEGO_TOKEN: [u8; 312] = [
    0x4e, 0x54, 0x4c, 0x4d, 0x53, 0x53, 0x50, 0x00, 0x03, 0x00, 0x00, 0x00, 0x18, 0x00, 0x18, 0x00, 0x5a, 0x00, 0x00,
    0x00, 0xb6, 0x00, 0xb6, 0x00, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x02, 0x00,
    0x02, 0x00, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00, 0x28,
    0x01, 0x00, 0x00, 0x35, 0x82, 0x88, 0xe2, 0x06, 0x01, 0xb1, 0x1d, 0x00, 0x00, 0x00, 0x0f, 0x85, 0x61, 0x57, 0xd0,
    0xe4, 0x87, 0x1c, 0x1a, 0x75, 0xc8, 0x71, 0x22, 0x58, 0x13, 0xaa, 0x22, 0x61, 0x00, 0x4f, 0x16, 0x46, 0xf0, 0x76,
    0x0b, 0x22, 0x06, 0x36, 0xba, 0x46, 0x5f, 0x56, 0x79, 0x8b, 0x89, 0x99, 0x79, 0x66, 0x9f, 0x64, 0xc9, 0x23, 0x2b,
    0xda, 0x0a, 0xa5, 0xec, 0xf1, 0x1b, 0xf8, 0xb3, 0x8d, 0xf9, 0x23, 0xbd, 0xda, 0x3b, 0x48, 0xbc, 0x01, 0x01, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x26, 0x00, 0xe1, 0x4a, 0xcf, 0xd4, 0x01, 0x99, 0x79, 0x66, 0x9f, 0x64, 0xc9,
    0x23, 0x2b, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x08, 0x00, 0x56, 0x00, 0x47, 0x00, 0x50, 0x00, 0x43, 0x00, 0x01,
    0x00, 0x08, 0x00, 0x56, 0x00, 0x47, 0x00, 0x50, 0x00, 0x43, 0x00, 0x04, 0x00, 0x08, 0x00, 0x56, 0x00, 0x47, 0x00,
    0x50, 0x00, 0x43, 0x00, 0x03, 0x00, 0x08, 0x00, 0x56, 0x00, 0x47, 0x00, 0x50, 0x00, 0x43, 0x00, 0x07, 0x00, 0x08,
    0x00, 0x80, 0x26, 0x00, 0xe1, 0x4a, 0xcf, 0xd4, 0x01, 0x06, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00, 0x00, 0x0a, 0x00,
    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09,
    0x00, 0x1e, 0x00, 0x54, 0x00, 0x45, 0x00, 0x52, 0x00, 0x4d, 0x00, 0x53, 0x00, 0x52, 0x00, 0x56, 0x00, 0x2f, 0x00,
    0x30, 0x00, 0x2e, 0x00, 0x30, 0x00, 0x2e, 0x00, 0x30, 0x00, 0x2e, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x2b, 0x04, 0x65, 0x22, 0x3a, 0xc5, 0x25,
    0x9d, 0x8f, 0x29, 0x30, 0x68, 0xce, 0x6a, 0x9d,
];
const NTLM_3_PHASE_PUB_KEY_AUTH: [u8; 48] = [
    0x01, 0x00, 0x00, 0x00, 0xca, 0x18, 0x71, 0xef, 0x99, 0xe5, 0x16, 0x21, 0x00, 0x00, 0x00, 0x00, 0x23, 0x1f, 0xb3,
    0xbe, 0xb8, 0x05, 0x19, 0x0c, 0xe1, 0xa2, 0x9d, 0x30, 0x23, 0xd0, 0xd4, 0x21, 0x33, 0xcb, 0x94, 0x2c, 0x5b, 0xa4,
    0x66, 0x77, 0x84, 0x2e, 0x05, 0xd9, 0x4b, 0x46, 0x98, 0xac,
];

const NTLM_4_PHASE_TS_REQUEST: [u8; 95] = [
    0x30, 0x5d, 0xa0, 0x03, 0x02, 0x01, 0x06, 0xa3, 0x32, 0x04, 0x30, 0x01, 0x00, 0x00, 0x00, 0xce, 0x7a, 0x5a, 0xf4,
    0xf7, 0xe2, 0x57, 0x1b, 0x00, 0x00, 0x00, 0x00, 0xda, 0xcc, 0x16, 0x8f, 0xb2, 0x34, 0x45, 0xed, 0x02, 0x67, 0x31,
    0xc1, 0x63, 0x90, 0xa8, 0x5c, 0x6b, 0x01, 0xbc, 0x1f, 0x8d, 0x93, 0x5e, 0x34, 0xde, 0x66, 0xb9, 0xb3, 0xd7, 0xf5,
    0xa1, 0xab, 0xa5, 0x22, 0x04, 0x20, 0x22, 0x10, 0x12, 0xad, 0x12, 0x5c, 0x7a, 0x15, 0xfe, 0xb6, 0x4b, 0x1f, 0xcb,
    0x94, 0x83, 0x3a, 0xc5, 0x6f, 0x66, 0x4c, 0xf3, 0xbc, 0xe7, 0x54, 0x8a, 0x5d, 0x9e, 0x05, 0x0a, 0x46, 0x91, 0xdb,
];
const NTLM_4_PHASE_PUB_KEY_AUTH: [u8; 48] = [
    0x01, 0x00, 0x00, 0x00, 0xce, 0x7a, 0x5a, 0xf4, 0xf7, 0xe2, 0x57, 0x1b, 0x00, 0x00, 0x00, 0x00, 0xda, 0xcc, 0x16,
    0x8f, 0xb2, 0x34, 0x45, 0xed, 0x02, 0x67, 0x31, 0xc1, 0x63, 0x90, 0xa8, 0x5c, 0x6b, 0x01, 0xbc, 0x1f, 0x8d, 0x93,
    0x5e, 0x34, 0xde, 0x66, 0xb9, 0xb3, 0xd7, 0xf5, 0xa1, 0xab,
];

const NTLM_5_PHASE_TS_REQUEST: [u8; 92] = [
    0x30, 0x5a, 0xa0, 0x03, 0x02, 0x01, 0x06, 0xa2, 0x2f, 0x04, 0x2d, 0x01, 0x00, 0x00, 0x00, 0xe0, 0xba, 0xe3, 0xba,
    0xc2, 0x72, 0x54, 0xe8, 0x01, 0x00, 0x00, 0x00, 0x6e, 0x03, 0x7c, 0x4c, 0x9d, 0x02, 0x4e, 0x5e, 0xeb, 0xa1, 0x9f,
    0xab, 0x60, 0x32, 0x97, 0xcd, 0x95, 0xcf, 0xfe, 0x8f, 0x44, 0x70, 0x79, 0x6e, 0x6c, 0xcd, 0xea, 0x74, 0x6a, 0xa5,
    0x22, 0x04, 0x20, 0x22, 0x10, 0x12, 0xad, 0x12, 0x5c, 0x7a, 0x15, 0xfe, 0xb6, 0x4b, 0x1f, 0xcb, 0x94, 0x83, 0x3a,
    0xc5, 0x6f, 0x66, 0x4c, 0xf3, 0xbc, 0xe7, 0x54, 0x8a, 0x5d, 0x9e, 0x05, 0x0a, 0x46, 0x91, 0xdb,
];
const NTLM_5_PHASE_AUTH_INFO: [u8; 45] = [
    0x01, 0x00, 0x00, 0x00, 0xe0, 0xba, 0xe3, 0xba, 0xc2, 0x72, 0x54, 0xe8, 0x01, 0x00, 0x00, 0x00, 0x6e, 0x03, 0x7c,
    0x4c, 0x9d, 0x02, 0x4e, 0x5e, 0xeb, 0xa1, 0x9f, 0xab, 0x60, 0x32, 0x97, 0xcd, 0x95, 0xcf, 0xfe, 0x8f, 0x44, 0x70,
    0x79, 0x6e, 0x6c, 0xcd, 0xea, 0x74, 0x6a,
];

const NTLM_WITHOUT_CLIENT_NONCE: [u8; 262] = [
    0x30, 0x82, 0x1, 0x2, 0xa0, 0x3, 0x2, 0x1, 0x6, 0xa1, 0x81, 0xfa, 0x30, 0x81, 0xf7, 0x30, 0x81, 0xf4, 0xa0, 0x81,
    0xf1, 0x4, 0x81, 0xee, 0x4e, 0x54, 0x4c, 0x4d, 0x53, 0x53, 0x50, 0x0, 0x2, 0x0, 0x0, 0x0, 0x1e, 0x0, 0x1e, 0x0,
    0x38, 0x0, 0x0, 0x0, 0x35, 0x82, 0x8a, 0xe2, 0x6e, 0x80, 0x3b, 0xb7, 0xf8, 0xb9, 0xf6, 0x5c, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x98, 0x0, 0x98, 0x0, 0x56, 0x0, 0x0, 0x0, 0xa, 0x0, 0xab, 0x3f, 0x0, 0x0, 0x0, 0xf, 0x44, 0x0,
    0x45, 0x0, 0x53, 0x0, 0x4b, 0x0, 0x54, 0x0, 0x4f, 0x0, 0x50, 0x0, 0x2d, 0x0, 0x4b, 0x0, 0x4d, 0x0, 0x44, 0x0, 0x54,
    0x0, 0x34, 0x0, 0x32, 0x0, 0x30, 0x0, 0x2, 0x0, 0x1e, 0x0, 0x44, 0x0, 0x45, 0x0, 0x53, 0x0, 0x4b, 0x0, 0x54, 0x0,
    0x4f, 0x0, 0x50, 0x0, 0x2d, 0x0, 0x4b, 0x0, 0x4d, 0x0, 0x44, 0x0, 0x54, 0x0, 0x34, 0x0, 0x32, 0x0, 0x30, 0x0, 0x1,
    0x0, 0x1e, 0x0, 0x44, 0x0, 0x45, 0x0, 0x53, 0x0, 0x4b, 0x0, 0x54, 0x0, 0x4f, 0x0, 0x50, 0x0, 0x2d, 0x0, 0x4b, 0x0,
    0x4d, 0x0, 0x44, 0x0, 0x54, 0x0, 0x34, 0x0, 0x32, 0x0, 0x30, 0x0, 0x4, 0x0, 0x1e, 0x0, 0x44, 0x0, 0x45, 0x0, 0x53,
    0x0, 0x4b, 0x0, 0x54, 0x0, 0x4f, 0x0, 0x50, 0x0, 0x2d, 0x0, 0x4b, 0x0, 0x4d, 0x0, 0x44, 0x0, 0x54, 0x0, 0x34, 0x0,
    0x32, 0x0, 0x30, 0x0, 0x3, 0x0, 0x1e, 0x0, 0x44, 0x0, 0x45, 0x0, 0x53, 0x0, 0x4b, 0x0, 0x54, 0x0, 0x4f, 0x0, 0x50,
    0x0, 0x2d, 0x0, 0x4b, 0x0, 0x4d, 0x0, 0x44, 0x0, 0x54, 0x0, 0x34, 0x0, 0x32, 0x0, 0x30, 0x0, 0x7, 0x0, 0x8, 0x0,
    0x75, 0xc6, 0x84, 0x56, 0xd7, 0xd8, 0xd4, 0x1, 0x0, 0x0, 0x0, 0x0,
];

const NTLM_WITH_ERROR_CODE_TS_REQUEST: [u8; 103] = [
    0x30, 0x65, 0xa0, 0x3, 0x2, 0x1, 0x6, 0xa3, 0x32, 0x4, 0x30, 0x1, 0x0, 0x0, 0x0, 0xd8, 0xb3, 0xc, 0x7e, 0x37, 0x51,
    0x21, 0x84, 0x0, 0x0, 0x0, 0x0, 0x6c, 0x47, 0xc8, 0xe3, 0x2, 0x59, 0x92, 0x19, 0xd1, 0x99, 0xdf, 0xbd, 0xf, 0xf5,
    0x71, 0x61, 0x3a, 0xdf, 0x74, 0x3, 0xef, 0xfc, 0xa5, 0x23, 0x16, 0x23, 0x37, 0x55, 0xff, 0x91, 0x20, 0xd8, 0xa4,
    0x6, 0x2, 0x4, 0xc0, 0x7, 0x0, 0xea, 0xa5, 0x22, 0x4, 0x20, 0xf8, 0x8d, 0xd4, 0xb7, 0x55, 0x9a, 0x94, 0xe5, 0xe8,
    0x7f, 0x2b, 0x2f, 0x94, 0xc2, 0x38, 0x58, 0xa9, 0x84, 0xfc, 0x7, 0x69, 0x7d, 0xf8, 0x57, 0x76, 0xc9, 0x57, 0xa3,
    0x15, 0x12, 0xeb, 0x32,
];

const NTLM_WITH_ERROR_CODE_PUB_KEY_AUTH: [u8; 48] = [
    0x1, 0x0, 0x0, 0x0, 0xd8, 0xb3, 0xc, 0x7e, 0x37, 0x51, 0x21, 0x84, 0x0, 0x0, 0x0, 0x0, 0x6c, 0x47, 0xc8, 0xe3, 0x2,
    0x59, 0x92, 0x19, 0xd1, 0x99, 0xdf, 0xbd, 0xf, 0xf5, 0x71, 0x61, 0x3a, 0xdf, 0x74, 0x3, 0xef, 0xfc, 0xa5, 0x23,
    0x16, 0x23, 0x37, 0x55, 0xff, 0x91, 0x20, 0xd8,
];

const NTLM_WITH_ERROR_CODE_ERROR_CODE: NStatusCode = NStatusCode(0xC007_00EA);

const NTLM_WITH_ERROR_CODE_CLIENT_NONCE: [u8; 32] = [
    0xf8, 0x8d, 0xd4, 0xb7, 0x55, 0x9a, 0x94, 0xe5, 0xe8, 0x7f, 0x2b, 0x2f, 0x94, 0xc2, 0x38, 0x58, 0xa9, 0x84, 0xfc,
    0x7, 0x69, 0x7d, 0xf8, 0x57, 0x76, 0xc9, 0x57, 0xa3, 0x15, 0x12, 0xeb, 0x32,
];

const TS_CREDENTIALS_ONE_SYMBOL_USERNAME_AND_PASSWORD: [u8; 29] = [
    0x30, 0x1b, 0xa0, 0x03, 0x02, 0x01, 0x01, 0xa1, 0x14, 0x04, 0x12, 0x30, 0x10, 0xa0, 0x02, 0x04, 0x00, 0xa1, 0x04,
    0x04, 0x02, 0x61, 0x00, 0xa2, 0x04, 0x04, 0x02, 0x31, 0x00,
];

const TS_CREDENTIALS_STRONG_USERNAME_AND_PASSWORD: [u8; 337] = [
    0x30, 0x82, 0x01, 0x4d, 0xa0, 0x03, 0x02, 0x01, 0x01, 0xa1, 0x82, 0x01, 0x44, 0x04, 0x82, 0x01, 0x40, 0x30, 0x82,
    0x01, 0x3c, 0xa0, 0x02, 0x04, 0x00, 0xa1, 0x7e, 0x04, 0x7c, 0x51, 0x00, 0x57, 0x00, 0x45, 0x00, 0x52, 0x00, 0x54,
    0x00, 0x59, 0x00, 0x55, 0x00, 0x49, 0x00, 0x4f, 0x00, 0x50, 0x00, 0x41, 0x00, 0x53, 0x00, 0x44, 0x00, 0x46, 0x00,
    0x47, 0x00, 0x48, 0x00, 0x4a, 0x00, 0x4b, 0x00, 0x4c, 0x00, 0x5a, 0x00, 0x58, 0x00, 0x43, 0x00, 0x56, 0x00, 0x42,
    0x00, 0x4e, 0x00, 0x4d, 0x00, 0x71, 0x00, 0x77, 0x00, 0x65, 0x00, 0x72, 0x00, 0x74, 0x00, 0x79, 0x00, 0x75, 0x00,
    0x69, 0x00, 0x6f, 0x00, 0x70, 0x00, 0x61, 0x00, 0x73, 0x00, 0x64, 0x00, 0x66, 0x00, 0x67, 0x00, 0x68, 0x00, 0x6a,
    0x00, 0x6b, 0x00, 0x6c, 0x00, 0x7a, 0x00, 0x78, 0x00, 0x63, 0x00, 0x76, 0x00, 0x62, 0x00, 0x6e, 0x00, 0x6d, 0x00,
    0x31, 0x00, 0x32, 0x00, 0x33, 0x00, 0x34, 0x00, 0x35, 0x00, 0x36, 0x00, 0x37, 0x00, 0x38, 0x00, 0x39, 0x00, 0x30,
    0x00, 0xa2, 0x81, 0xb5, 0x04, 0x81, 0xb2, 0x40, 0x00, 0x23, 0x00, 0x24, 0x00, 0x25, 0x00, 0x5e, 0x00, 0x26, 0x00,
    0x2a, 0x00, 0x28, 0x00, 0x29, 0x00, 0x5f, 0x00, 0x2b, 0x00, 0x31, 0x00, 0x32, 0x00, 0x33, 0x00, 0x34, 0x00, 0x35,
    0x00, 0x36, 0x00, 0x37, 0x00, 0x38, 0x00, 0x39, 0x00, 0x30, 0x00, 0x2d, 0x00, 0x3d, 0x00, 0x51, 0x00, 0x57, 0x00,
    0x45, 0x00, 0x52, 0x00, 0x54, 0x00, 0x59, 0x00, 0x55, 0x00, 0x49, 0x00, 0x4f, 0x00, 0x50, 0x00, 0x7b, 0x00, 0x7d,
    0x00, 0x71, 0x00, 0x77, 0x00, 0x65, 0x00, 0x72, 0x00, 0x74, 0x00, 0x79, 0x00, 0x75, 0x00, 0x69, 0x00, 0x6f, 0x00,
    0x70, 0x00, 0x5b, 0x00, 0x5d, 0x00, 0x61, 0x00, 0x73, 0x00, 0x64, 0x00, 0x66, 0x00, 0x67, 0x00, 0x68, 0x00, 0x6a,
    0x00, 0x6b, 0x00, 0x6c, 0x00, 0x3b, 0x00, 0x41, 0x00, 0x53, 0x00, 0x44, 0x00, 0x46, 0x00, 0x47, 0x00, 0x48, 0x00,
    0x4a, 0x00, 0x4b, 0x00, 0x4c, 0x00, 0x3a, 0x00, 0x5c, 0x00, 0x22, 0x00, 0x7c, 0x00, 0x7a, 0x00, 0x78, 0x00, 0x63,
    0x00, 0x76, 0x00, 0x62, 0x00, 0x6e, 0x00, 0x6d, 0x00, 0x2c, 0x00, 0x2e, 0x00, 0x5a, 0x00, 0x58, 0x00, 0x43, 0x00,
    0x56, 0x00, 0x42, 0x00, 0x4e, 0x00, 0x4d, 0x00, 0x3c, 0x00, 0x3e, 0x00, 0x3f, 0x00,
];

const TS_CREDENTIALS_SIMPLE_WITH_USERNAME_AND_DOMAIN_AND_PASSWORD: [u8; 69] = [
    0x30, 0x43, 0xa0, 0x03, 0x02, 0x01, 0x01, 0xa1, 0x3c, 0x04, 0x3a, 0x30, 0x38, 0xa0, 0x0e, 0x04, 0x0c, 0x44, 0x00,
    0x6f, 0x00, 0x6d, 0x00, 0x61, 0x00, 0x69, 0x00, 0x6e, 0x00, 0xa1, 0x12, 0x04, 0x10, 0x55, 0x00, 0x73, 0x00, 0x65,
    0x00, 0x72, 0x00, 0x6e, 0x00, 0x61, 0x00, 0x6d, 0x00, 0x65, 0x00, 0xa2, 0x12, 0x04, 0x10, 0x50, 0x00, 0x61, 0x00,
    0x73, 0x00, 0x73, 0x00, 0x77, 0x00, 0x6f, 0x00, 0x72, 0x00, 0x64, 0x00,
];

const TS_CREDENTIALS_WITH_RESTRICTED_ADMIN_MODE_REQUIRED: [u8; 25] = [
    0x30, 0x17, 0xa0, 0x03, 0x02, 0x01, 0x01, 0xa1, 0x10, 0x04, 0x0e, 0x30, 0x0c, 0xa0, 0x02, 0x04, 0x00, 0xa1, 0x02,
    0x04, 0x00, 0xa2, 0x02, 0x04, 0x00,
];

static AUTH_IDENTITY_ONE_SYMBOL_USER_AND_PASSWORD: LazyLock<CredentialsBuffers> = LazyLock::new(|| {
    CredentialsBuffers::AuthIdentity(
        AuthIdentity {
            username: Username::parse("a").unwrap(),
            password: String::from("1").into(),
        }
        .into(),
    )
});

static AUTH_IDENTITY_STRONG_USERNAME_AND_PASSWORD: LazyLock<CredentialsBuffers> = LazyLock::new(|| {
    CredentialsBuffers::AuthIdentity(
        AuthIdentity {
            username: Username::new("QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm1234567890", None).unwrap(),
            password: String::from(
                "@#$%^&*()_+1234567890-=QWERTYUIOP{}qwertyuiop[]asdfghjkl;ASDFGHJKL:\\\"|zxcvbnm,.ZXCVBNM<>?",
            )
            .into(),
        }
        .into(),
    )
});

static AUTH_IDENTITY_SIMPLE_WITH_USERNAME_AND_DOMAIN_AND_PASSWORD: LazyLock<CredentialsBuffers> = LazyLock::new(|| {
    CredentialsBuffers::AuthIdentity(
        AuthIdentity {
            username: Username::new("Username", Some("Domain")).unwrap(),
            password: String::from("Password").into(),
        }
        .into(),
    )
});

static AUTH_IDENTITY_WITH_RESTRICTED_ADMIN_MODE_REQUIRED: LazyLock<CredentialsBuffers> = LazyLock::new(|| {
    CredentialsBuffers::AuthIdentity(
        AuthIdentity {
            username: Username::new("", Some("")).unwrap(),
            password: String::from("").into(),
        }
        .into(),
    )
});

#[test]
fn ntlm_decode_first_phase_with_nego_token_and_client_nonce() {
    let buffer = NTLM_1_PHASE_TS_REQUEST;

    let expected_version = TS_REQUEST_VERSION;
    let expected_nego_token = NTLM_1_PHASE_NEGO_TOKEN;
    let expected_client_nonce = NTLM_CLIENT_NONCE;

    let ts_request = TsRequest::from_buffer(&buffer).unwrap();

    assert_eq!(expected_version, ts_request.version);
    assert_eq!(ts_request.nego_tokens.unwrap().as_slice(), expected_nego_token.as_ref());
    assert_eq!(ts_request.client_nonce.unwrap(), expected_client_nonce);
    assert!(ts_request.auth_info.is_none());
    assert!(ts_request.pub_key_auth.is_none());
    assert!(ts_request.error_code.is_none());
}

#[test]
fn ntlm_decode_second_phase_with_nego_token_and_client_nonce() {
    let buffer = NTLM_2_PHASE_TS_REQUEST;

    let expected_version = TS_REQUEST_VERSION;
    let expected_nego_token = NTLM_2_PHASE_NEGO_TOKEN;
    let expected_client_nonce = NTLM_CLIENT_NONCE;

    let ts_request = TsRequest::from_buffer(&buffer).unwrap();

    assert_eq!(expected_version, ts_request.version);
    assert_eq!(ts_request.nego_tokens.unwrap().as_slice(), expected_nego_token.as_ref());
    assert_eq!(ts_request.client_nonce.unwrap(), expected_client_nonce);
    assert!(ts_request.auth_info.is_none());
    assert!(ts_request.pub_key_auth.is_none());
    assert!(ts_request.error_code.is_none());
}

#[test]
fn ntlm_decode_third_phase_with_nego_token_and_pub_key_auth_and_client_nonce() {
    let buffer = NTLM_3_PHASE_TS_REQUEST;

    let expected_version = TS_REQUEST_VERSION;

    let expected_nego_token = NTLM_3_PHASE_NEGO_TOKEN;
    let expected_pub_key_auth = NTLM_3_PHASE_PUB_KEY_AUTH;
    let expected_client_nonce = NTLM_CLIENT_NONCE;

    let ts_request = TsRequest::from_buffer(&buffer).unwrap();

    assert_eq!(expected_version, ts_request.version);
    assert_eq!(ts_request.nego_tokens.unwrap().as_slice(), expected_nego_token.as_ref());
    assert_eq!(
        ts_request.pub_key_auth.unwrap().as_slice(),
        expected_pub_key_auth.as_ref()
    );
    assert_eq!(ts_request.client_nonce.unwrap(), expected_client_nonce);
    assert!(ts_request.auth_info.is_none());
    assert!(ts_request.error_code.is_none());
}

#[test]
fn ntlm_decode_fourth_phase_with_pub_key_auth_and_client_nonce() {
    let buffer = NTLM_4_PHASE_TS_REQUEST;

    let expected_version = TS_REQUEST_VERSION;
    let expected_pub_key_auth = NTLM_4_PHASE_PUB_KEY_AUTH;
    let expected_client_nonce = NTLM_CLIENT_NONCE;

    let ts_request = TsRequest::from_buffer(&buffer).unwrap();

    assert_eq!(expected_version, ts_request.version);
    assert_eq!(
        ts_request.pub_key_auth.unwrap().as_slice(),
        expected_pub_key_auth.as_ref()
    );
    assert_eq!(ts_request.client_nonce.unwrap(), expected_client_nonce);
    assert!(ts_request.nego_tokens.is_none());
    assert!(ts_request.auth_info.is_none());
    assert!(ts_request.error_code.is_none());
}

#[test]
fn ntlm_decode_fiveth_phase_with_auth_info_and_client_nonce() {
    let buffer = NTLM_5_PHASE_TS_REQUEST;

    let expected_version = TS_REQUEST_VERSION;
    let expected_auth_info = NTLM_5_PHASE_AUTH_INFO;
    let expected_client_nonce = NTLM_CLIENT_NONCE;

    let ts_request = TsRequest::from_buffer(&buffer).unwrap();

    assert_eq!(expected_version, ts_request.version);
    assert_eq!(ts_request.auth_info.unwrap().as_slice(), expected_auth_info.as_ref());
    assert_eq!(ts_request.client_nonce.unwrap(), expected_client_nonce);
    assert!(ts_request.nego_tokens.is_none());
    assert!(ts_request.pub_key_auth.is_none());
    assert!(ts_request.error_code.is_none());
}

#[test]
fn decode_with_wrong_len() {
    let mut buffer = NTLM_1_PHASE_TS_REQUEST;
    buffer[1] += 1;

    assert!(TsRequest::from_buffer(&buffer).is_err());
}

#[test]
fn decode_with_error_code() {
    let buffer = NTLM_WITH_ERROR_CODE_TS_REQUEST;
    let expected_error = NTLM_WITH_ERROR_CODE_ERROR_CODE;

    let ts_request = TsRequest::from_buffer(&buffer).unwrap();

    assert_eq!(expected_error, ts_request.error_code.unwrap());
    assert!(ts_request.check_error().is_err());
}

#[test]
fn decode_without_client_nonce() {
    let buffer = NTLM_WITHOUT_CLIENT_NONCE;

    let ts_request = TsRequest::from_buffer(&buffer).unwrap();

    assert!(ts_request.client_nonce.is_none());
}

#[test]
fn ntlm_encode_first_phase_with_nego_token_and_client_nonce() {
    let expected_buffer = NTLM_1_PHASE_TS_REQUEST;

    let ts_request = TsRequest {
        nego_tokens: Some(NTLM_1_PHASE_NEGO_TOKEN.to_vec()),
        auth_info: None,
        pub_key_auth: None,
        error_code: None,
        client_nonce: Some(NTLM_CLIENT_NONCE),
        version: TS_REQUEST_VERSION,
    };

    let ts_request_len = ts_request.buffer_len();
    assert_eq!(ts_request_len as usize, expected_buffer.len());

    let mut buffer = Vec::with_capacity(ts_request_len as usize);
    ts_request.encode_ts_request(&mut buffer).unwrap();

    assert_eq!(buffer.as_slice(), expected_buffer.as_ref());
}

#[test]
fn ntlm_encode_second_phase_with_nego_token_and_client_nonce() {
    let expected_buffer = NTLM_2_PHASE_TS_REQUEST;

    let ts_request = TsRequest {
        nego_tokens: Some(NTLM_2_PHASE_NEGO_TOKEN.to_vec()),
        auth_info: None,
        pub_key_auth: None,
        error_code: None,
        client_nonce: Some(NTLM_CLIENT_NONCE),
        version: TS_REQUEST_VERSION,
    };

    let ts_request_len = ts_request.buffer_len();
    assert_eq!(ts_request_len as usize, expected_buffer.len());

    let mut buffer = Vec::with_capacity(ts_request_len as usize);
    ts_request.encode_ts_request(&mut buffer).unwrap();

    assert_eq!(buffer.as_slice(), expected_buffer.as_ref());
}

#[test]
fn ntlm_encode_third_phase_with_nego_token_and_pub_key_auth_and_client_nonce() {
    let expected_buffer = NTLM_3_PHASE_TS_REQUEST;

    let ts_request = TsRequest {
        nego_tokens: Some(NTLM_3_PHASE_NEGO_TOKEN.to_vec()),
        auth_info: None,
        pub_key_auth: Some(NTLM_3_PHASE_PUB_KEY_AUTH.to_vec()),
        error_code: None,
        client_nonce: Some(NTLM_CLIENT_NONCE),
        version: TS_REQUEST_VERSION,
    };

    let ts_request_len = ts_request.buffer_len();
    assert_eq!(ts_request_len as usize, expected_buffer.len());

    let mut buffer = Vec::with_capacity(ts_request_len as usize);
    ts_request.encode_ts_request(&mut buffer).unwrap();

    assert_eq!(buffer.as_slice(), expected_buffer.as_ref());
}

#[test]
fn ntlm_encode_fourth_phase_with_pub_key_auth_and_client_nonce() {
    let expected_buffer = NTLM_4_PHASE_TS_REQUEST;

    let ts_request = TsRequest {
        nego_tokens: None,
        auth_info: None,
        pub_key_auth: Some(NTLM_4_PHASE_PUB_KEY_AUTH.to_vec()),
        error_code: None,
        client_nonce: Some(NTLM_CLIENT_NONCE),
        version: TS_REQUEST_VERSION,
    };

    let ts_request_len = ts_request.buffer_len();
    assert_eq!(ts_request_len as usize, expected_buffer.len());

    let mut buffer = Vec::with_capacity(ts_request_len as usize);
    ts_request.encode_ts_request(&mut buffer).unwrap();

    assert_eq!(buffer.as_slice(), expected_buffer.as_ref());
}

#[test]
fn ntlm_encode_fiveth_phase_with_auth_info_and_client_nonce() {
    let expected_buffer = NTLM_5_PHASE_TS_REQUEST;

    let ts_request = TsRequest {
        nego_tokens: None,
        auth_info: Some(NTLM_5_PHASE_AUTH_INFO.to_vec()),
        pub_key_auth: None,
        error_code: None,
        client_nonce: Some(NTLM_CLIENT_NONCE),
        version: TS_REQUEST_VERSION,
    };

    let ts_request_len = ts_request.buffer_len();
    assert_eq!(ts_request_len as usize, expected_buffer.len());

    let mut buffer = Vec::with_capacity(ts_request_len as usize);
    ts_request.encode_ts_request(&mut buffer).unwrap();

    assert_eq!(buffer.as_slice(), expected_buffer.as_ref());
}

#[test]
fn ntlm_encode_with_error_code() {
    let expected_buffer = NTLM_WITH_ERROR_CODE_TS_REQUEST;

    let ts_request = TsRequest {
        nego_tokens: None,
        auth_info: None,
        pub_key_auth: Some(NTLM_WITH_ERROR_CODE_PUB_KEY_AUTH.to_vec()),
        error_code: Some(NTLM_WITH_ERROR_CODE_ERROR_CODE),
        client_nonce: Some(NTLM_WITH_ERROR_CODE_CLIENT_NONCE),
        version: TS_REQUEST_VERSION,
    };

    let ts_request_len = ts_request.buffer_len();
    assert_eq!(ts_request_len as usize, expected_buffer.len());

    let mut buffer = Vec::with_capacity(ts_request_len as usize);
    ts_request.encode_ts_request(&mut buffer).unwrap();

    assert_eq!(buffer.as_slice(), expected_buffer.as_ref());
}

#[test]
fn decode_ts_credentials_with_one_symbol_user_and_password() {
    let buffer = TS_CREDENTIALS_ONE_SYMBOL_USERNAME_AND_PASSWORD;

    let identity = read_ts_credentials(buffer.as_ref()).unwrap();

    assert_eq!(*AUTH_IDENTITY_ONE_SYMBOL_USER_AND_PASSWORD, identity);
}

#[test]
fn encode_ts_credentials_with_one_symbol_user_and_password() {
    let expected_buffer = TS_CREDENTIALS_ONE_SYMBOL_USERNAME_AND_PASSWORD;

    let identity = &AUTH_IDENTITY_ONE_SYMBOL_USER_AND_PASSWORD;
    let cred_ssp_mode = CredSspMode::WithCredentials;
    let buffer = write_ts_credentials(identity, cred_ssp_mode).unwrap();

    assert_eq!(expected_buffer.as_ref(), buffer.as_slice());
}

#[test]
fn decode_ts_credentials_with_strong_user_and_password() {
    let buffer = TS_CREDENTIALS_STRONG_USERNAME_AND_PASSWORD;

    let identity = read_ts_credentials(buffer.as_ref()).unwrap();

    assert_eq!(*AUTH_IDENTITY_STRONG_USERNAME_AND_PASSWORD, identity);
}

#[test]
fn encode_ts_credentials_with_strong_user_and_password() {
    let expected_buffer = TS_CREDENTIALS_STRONG_USERNAME_AND_PASSWORD;

    let identity = &AUTH_IDENTITY_STRONG_USERNAME_AND_PASSWORD;
    let cred_ssp_mode = CredSspMode::WithCredentials;
    let buffer = write_ts_credentials(identity, cred_ssp_mode).unwrap();

    assert_eq!(expected_buffer.as_ref(), buffer.as_slice());
}

#[test]
fn decode_ts_credentials_with_simple_username_and_domain_and_password() {
    let buffer = TS_CREDENTIALS_SIMPLE_WITH_USERNAME_AND_DOMAIN_AND_PASSWORD;

    let identity = read_ts_credentials(buffer.as_ref()).unwrap();

    assert_eq!(*AUTH_IDENTITY_SIMPLE_WITH_USERNAME_AND_DOMAIN_AND_PASSWORD, identity);
}

#[test]
fn encode_ts_credentials_with_simple_username_and_domain_and_password() {
    let expected_buffer = TS_CREDENTIALS_SIMPLE_WITH_USERNAME_AND_DOMAIN_AND_PASSWORD;

    let identity = &AUTH_IDENTITY_SIMPLE_WITH_USERNAME_AND_DOMAIN_AND_PASSWORD;
    let cred_ssp_mode = CredSspMode::WithCredentials;
    let buffer = write_ts_credentials(identity, cred_ssp_mode).unwrap();

    assert_eq!(expected_buffer.as_ref(), buffer.as_slice());
}

#[test]
fn decode_ts_credentials_with_restricted_admin_mode_required() {
    let buffer = TS_CREDENTIALS_WITH_RESTRICTED_ADMIN_MODE_REQUIRED;

    let identity = read_ts_credentials(buffer.as_ref()).unwrap();

    assert_eq!(*AUTH_IDENTITY_WITH_RESTRICTED_ADMIN_MODE_REQUIRED, identity);
}

#[test]
fn encode_ts_credentials_with_restricted_admin_mode_required() {
    let expected_buffer = TS_CREDENTIALS_WITH_RESTRICTED_ADMIN_MODE_REQUIRED;

    let identity = &AUTH_IDENTITY_WITH_RESTRICTED_ADMIN_MODE_REQUIRED;
    let cred_ssp_mode = CredSspMode::CredentialLess;
    let buffer = write_ts_credentials(identity, cred_ssp_mode).unwrap();

    assert_eq!(expected_buffer.as_ref(), buffer.as_slice());
}

#[test]
fn decode_ts_request_fails_on_incomplete_buffer() {
    let mut buffer = NTLM_3_PHASE_TS_REQUEST.to_vec();
    let _ = buffer.split_off(buffer.len() - 1);

    assert!(TsRequest::from_buffer(buffer.as_ref()).is_err());
}

#[test]
fn decode_ts_credentials_fails_on_incomplete_buffer() {
    let mut buffer = TS_CREDENTIALS_WITH_RESTRICTED_ADMIN_MODE_REQUIRED.to_vec();
    let _ = buffer.split_off(buffer.len() - 1);

    assert!(read_ts_credentials(buffer.as_slice()).is_err());
}

#[test]
fn buffer_len_correct_returns_len() {
    let buffer = NTLM_3_PHASE_TS_REQUEST;
    let ts_request = TsRequest::from_buffer(buffer.as_ref()).unwrap();

    assert_eq!(buffer.len() as u16, ts_request.buffer_len());
}

#[test]
fn buffer_len_correct_returns_len_with_garbage() {
    let garbage_len = 10;
    let garbage = vec![0x00; garbage_len];

    let mut buffer = NTLM_3_PHASE_TS_REQUEST.to_vec();
    buffer.extend_from_slice(&garbage);

    let ts_request = TsRequest::from_buffer(buffer.as_ref()).unwrap();

    assert_eq!((buffer.len() - garbage_len) as u16, ts_request.buffer_len());
}


--- File: src/crypto/mod.rs ---
mod rc4;

use std::io;

use md4::{Digest, Md4};
use md5::Md5;
pub use rc4::Rc4;
use sha2::Sha256;

use crate::channel_bindings::ChannelBindings;

pub const HASH_SIZE: usize = 16;

const SHA256_SIZE: usize = 32;

pub fn compute_md4(data: &[u8]) -> [u8; HASH_SIZE] {
    let mut context = Md4::new();
    let mut result = [0x00; HASH_SIZE];
    context.update(data);
    result.clone_from_slice(&context.finalize());

    result
}

pub fn compute_md5(data: &[u8]) -> [u8; HASH_SIZE] {
    let mut context = Md5::new();
    let mut result = [0x00; HASH_SIZE];
    context.update(data);
    result.clone_from_slice(&context.finalize());

    result
}

pub fn compute_md5_channel_bindings_hash(channel_bindings: &ChannelBindings) -> [u8; HASH_SIZE] {
    let mut context = Md5::new();
    let mut result = [0x00; HASH_SIZE];

    let initiator_len = channel_bindings.initiator.len() as u32;
    context.update(channel_bindings.initiator_addr_type.to_le_bytes());
    context.update(initiator_len.to_le_bytes());
    context.update(&channel_bindings.initiator);

    let acceptor_len = channel_bindings.acceptor.len() as u32;
    context.update(channel_bindings.acceptor_addr_type.to_le_bytes());
    context.update(acceptor_len.to_le_bytes());
    context.update(&channel_bindings.acceptor);

    let application_data_len = channel_bindings.application_data.len() as u32;
    context.update(application_data_len.to_le_bytes());
    context.update(&channel_bindings.application_data);

    result.clone_from_slice(&context.finalize());

    result
}

pub fn compute_sha256(data: &[u8]) -> [u8; SHA256_SIZE] {
    let mut context = Sha256::new();
    let mut result = [0x00; SHA256_SIZE];
    context.update(data);
    result.clone_from_slice(&context.finalize());

    result
}

pub fn compute_hmac_md5(key: &[u8], input: &[u8]) -> io::Result<[u8; HASH_SIZE]> {
    use hmac::Mac as _;

    let mut mac = hmac::Hmac::<Md5>::new_from_slice(key)
        .map_err(|e| io::Error::new(io::ErrorKind::Other, format!("Failed to compute hmac md5: {}", e)))?;
    let mut result = [0x00; HASH_SIZE];
    mac.update(input);
    result.clone_from_slice(&mac.finalize().into_bytes());

    Ok(result)
}


--- File: src/crypto/rc4.rs ---
use std::{fmt, ops};

#[derive(Debug, Clone)]
pub struct Rc4 {
    i: usize,
    j: usize,
    state: State,
}

impl Rc4 {
    pub fn new(key: &[u8]) -> Self {
        // key scheduling
        let mut state = State::default();
        for (i, item) in state.iter_mut().enumerate().take(256) {
            *item = i as u8;
        }
        let mut j = 0usize;
        for i in 0..256 {
            j = (j + state[i] as usize + key[i % key.len()] as usize) % 256;
            state.swap(i, j);
        }

        Self { i: 0, j: 0, state }
    }

    pub fn process(&mut self, message: &[u8]) -> Vec<u8> {
        // PRGA
        let mut output = Vec::with_capacity(message.len());
        while output.capacity() > output.len() {
            self.i = (self.i + 1) % 256;
            self.j = (self.j + self.state[self.i] as usize) % 256;
            self.state.swap(self.i, self.j);
            let idx_k = (self.state[self.i] as usize + self.state[self.j] as usize) % 256;
            let k = self.state[idx_k];
            let idx_msg = output.len();
            output.push(k ^ message[idx_msg]);
        }

        output
    }
}

#[derive(Clone)]
struct State([u8; 256]);

impl Default for State {
    fn default() -> Self {
        Self([0; 256])
    }
}

impl fmt::Debug for State {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.0.fmt(f)
    }
}

impl ops::Deref for State {
    type Target = [u8];

    fn deref(&self) -> &Self::Target {
        self.0.as_ref()
    }
}

impl ops::DerefMut for State {
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.0.as_mut()
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn check_common_case() {
        let key = "key".to_string();
        let message = "message".to_string();
        let expected = [0x66, 0x09, 0x47, 0x9E, 0x45, 0xE8, 0x1E];
        assert_eq!(Rc4::new(key.as_bytes()).process(message.as_bytes())[..], expected);
    }

    #[test]
    fn one_symbol_key() {
        let key = "0".to_string();
        let message = "message".to_string();
        let expected = [0xE5, 0x1A, 0xD5, 0xF3, 0xA2, 0x1C, 0xB1];
        assert_eq!(Rc4::new(key.as_bytes()).process(message.as_bytes())[..], expected);
    }

    #[test]
    fn one_symbol_similar_key_and_message() {
        let key = "0".to_string();
        let message = "0".to_string();
        let expected = [0xb8];
        assert_eq!(Rc4::new(key.as_bytes()).process(message.as_bytes())[..], expected);
    }

    #[test]
    fn one_symbol_key_and_message() {
        let key = "0".to_string();
        let message = "a".to_string();
        let expected = [0xe9];
        assert_eq!(Rc4::new(key.as_bytes()).process(message.as_bytes())[..], expected);
    }

    #[test]
    fn empty_message() {
        let key = "key".to_string();
        let message = "".to_string();
        let expected: [u8; 0] = [];
        assert_eq!(Rc4::new(key.as_bytes()).process(message.as_bytes())[..], expected);
    }

    #[test]
    fn long_key() {
        let key = "oigjwr984 874Y8 7W68 8&$y*%&78 4  8724JIOGROGN I4UI928 98FRUWNKRJB GRGg ergeowp".to_string();
        let message = "message".to_string();
        let expected = [0xBE, 0x74, 0xEB, 0x88, 0x64, 0x8E, 0x6A];
        assert_eq!(Rc4::new(key.as_bytes()).process(message.as_bytes())[..], expected);
    }

    #[test]
    fn long_message() {
        let key = "key".to_string();
        let message = "oigjwr984 874Y8 7W68 8&$y*%&78 4  8724JIOGROGN I4UI928 98FRUWNKRJB GRGg ergeowp".to_string();
        let expected = [
            0x64, 0x05, 0x53, 0x87, 0x53, 0xFD, 0x42, 0x72, 0x7C, 0x6B, 0x30, 0x4C, 0x22, 0x04, 0x2A, 0xDD, 0xB8, 0x23,
            0xDB, 0x5E, 0x8B, 0xD9, 0xC5, 0xDB, 0x4F, 0xD9, 0x8D, 0x9B, 0x0E, 0xD4, 0x5B, 0xAA, 0x34, 0x1D, 0x8E, 0xB9,
            0x9B, 0xBB, 0xF0, 0xF5, 0x7C, 0x90, 0xAD, 0xFE, 0x64, 0x33, 0x06, 0xCA, 0xCE, 0x68, 0x71, 0x1E, 0x5E, 0xE1,
            0x29, 0xBD, 0xCB, 0x29, 0x6A, 0x6D, 0xD4, 0xC9, 0x99, 0x59, 0xE9, 0x3B, 0xCC, 0x97, 0xEE, 0x32, 0xB5, 0x98,
            0x57, 0x1C, 0x13, 0x6D, 0x35, 0x0C, 0xDE,
        ];
        assert_eq!(Rc4::new(key.as_bytes()).process(message.as_bytes())[..], expected[..]);
    }

    #[test]
    fn long_key_message() {
        let key = "iogjerwo ghoreh trojtrj trjrohjigjw9iehgfwe 315 989&*$*%&*  &*^*& q 4unkregeor 847847786 ^&**^*"
            .to_string();
        let message = "oigjwr984 874Y8 7W68 8&$y*%&78 4  8724JIOGROGN I4UI928 98FRUWNKRJB GRGg ergeowp".to_string();
        let expected = [
            0x6B, 0x92, 0x32, 0x1B, 0xAD, 0x5A, 0x3A, 0x62, 0xE4, 0xC9, 0xD4, 0x2A, 0xAF, 0x34, 0xF1, 0xA3, 0xA0, 0x23,
            0x5B, 0x8D, 0x12, 0x7B, 0x4C, 0xE6, 0x23, 0xE6, 0x13, 0x81, 0xF0, 0xDA, 0xE0, 0x02, 0x65, 0x71, 0x2B, 0x1D,
            0x39, 0x17, 0x2A, 0x7E, 0x60, 0x68, 0x26, 0x2B, 0xF0, 0x46, 0x03, 0xA0, 0x40, 0xC4, 0xBA, 0x78, 0xF9, 0x82,
            0x35, 0x42, 0xE2, 0x8A, 0x69, 0xEE, 0xE0, 0x29, 0x31, 0x66, 0xBE, 0xAF, 0x9E, 0x81, 0xD8, 0x58, 0xCC, 0xA6,
            0x4D, 0xBD, 0xEE, 0x31, 0x32, 0x2A, 0x2F,
        ];
        assert_eq!(Rc4::new(key.as_bytes()).process(message.as_bytes())[..], expected[..]);
    }
}


--- File: src/dns.rs ---
#![allow(dead_code)]
#![allow(unused_imports)]

cfg_if::cfg_if! {
    if #[cfg(windows)] {
        use windows::{
            core::*,
            Win32::NetworkManagement::Dns::*,
        };
        use windows_registry::LOCAL_MACHINE;
        use std::ptr::{null_mut};
        use core::ffi::{c_void};

        pub fn dns_query_srv_records(name: &str) -> Vec<String> {
            let mut records = Vec::new();
            unsafe {
                let mut p_query_results: *mut DNS_RECORDA = null_mut();
                let dns_status = DnsQuery_W(&HSTRING::from(name), DNS_TYPE_SRV,
                    DNS_QUERY_STANDARD, None, &mut p_query_results, None);

                match dns_status.ok() {
                    Ok(()) => {
                        let p_name_target = (*p_query_results).Data.Srv.pNameTarget;
                        if let Ok(name_target) = PWSTR::from_raw(p_name_target.as_ptr() as *mut u16).to_string() {
                            records.push(name_target);
                        }
                    }
                    Err(error) => error!(%error, "DnsQuery_W failed"),
                }

                DnsFree(Some(p_query_results as *const c_void), DnsFreeRecordList);
            }
            records
        }

        pub struct DnsClientNrptRule {
            rule_name: String,
            namespace: String,
            name_servers: Vec<String>
        }

        pub fn get_dns_client_nrpt_rules() -> Vec<DnsClientNrptRule> {
            let mut rules: Vec<DnsClientNrptRule> = Vec::new();
            let hklm = LOCAL_MACHINE;
            let dns_policy_config_key_path = "System\\CurrentControlSet\\Services\\Dnscache\\Parameters\\DnsPolicyConfig";
            if let Ok(dns_policy_config_key) = hklm.open(dns_policy_config_key_path) {
                for rule_name in dns_policy_config_key.keys().unwrap() {
                    let dns_policy_rule_key_path = format!("{}\\{}", dns_policy_config_key_path, &rule_name);
                    if let Ok(dns_policy_rule_key) = hklm.open(dns_policy_rule_key_path) {
                        let namespace: Option<String> = dns_policy_rule_key.get_string("Name").ok(); // REG_MULTI_SZ
                        let name_server_list: Option<String> = dns_policy_rule_key.get_string("GenericDNSServers").ok(); // REG_SZ
                        if let (Some(namespace), Some(name_server_list)) = (namespace, name_server_list) {
                            let name_servers: Vec<String> = name_server_list.split(';').map(|x| x.to_string()).collect();
                            rules.push(DnsClientNrptRule {
                                rule_name,
                                namespace,
                                name_servers,
                            });
                        }
                    }
                }
            }
            rules
        }

        pub fn get_default_name_servers() -> Vec<String> {
            let hklm = LOCAL_MACHINE;
            let tcpip_linkage_key_path = "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Linkage";
            let tcpip_interfaces_key_path = "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces";
            let dns_registered_adapters_key_path = "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\DNSRegisteredAdapters";

            if let Ok(tcpip_linkage_key) = hklm.open(tcpip_linkage_key_path) {
                let bind_devices: Vec<String> = tcpip_linkage_key.get_multi_string("Bind").unwrap();
                let device_ids = bind_devices.iter().map(|x| x.strip_prefix("\\Device\\").unwrap());

                for device_id in device_ids {
                    let interface_key_path = format!("{}\\{}", tcpip_interfaces_key_path, &device_id);
                    let dns_adapter_key_path = format!("{}\\{}", dns_registered_adapters_key_path, &device_id);

                    if let (Ok(interface_key), Ok(dns_adapter_key)) = (hklm.open(interface_key_path), hklm.open(dns_adapter_key_path)) {
                        let name_server: Option<String> = interface_key.get_string("NameServer").ok().filter(|x: &String| !x.is_empty());
                        let dhcp_name_server: Option<String> = interface_key.get_string("DhcpNameServer").ok().filter(|x: &String| !x.is_empty());
                        let stale_adapter: u32 = dns_adapter_key.get_u32("StaleAdapter").unwrap_or(1);

                        if stale_adapter != 1 {
                            if let Some(name_server_list) = name_server.or(dhcp_name_server) {
                                let name_servers: Vec<String> = name_server_list.split(' ')
                                    .map(|c| c.trim().to_string()).filter(|x: &String| !x.is_empty()).collect();
                                return name_servers;
                            }
                        }
                    }
                }
            }
            Vec::new()
        }

        pub fn get_name_servers_for_domain(domain: &str) -> Vec<String> {
            let domain_namespace = if domain.starts_with('.') {
                domain.to_string()
            } else {
                format!(".{}", &domain)
            };

            for nrpt_rule in get_dns_client_nrpt_rules() {
                if nrpt_rule.namespace.ends_with(&domain_namespace) {
                    return nrpt_rule.name_servers;
                }
            }

            get_default_name_servers()
        }

        pub fn detect_kdc_hosts_from_dns_windows(domain: &str) -> Vec<String> {
            let krb_tcp_name = &format!("_kerberos._tcp.{}", domain);
            let krb_tcp_srv = dns_query_srv_records(krb_tcp_name);

            if !krb_tcp_srv.is_empty() {
                return krb_tcp_srv.iter().map(|x| format!("tcp://{}:88", x)).collect()
            }

            let krb_udp_name = &format!("_kerberos._udp.{}", domain);
            let krb_udp_srv = dns_query_srv_records(krb_udp_name);

            if !krb_udp_srv.is_empty() {
                return krb_udp_srv.iter().map(|x| format!("udp://{}:88", x)).collect()
            }

            Vec::new()
        }
    }
}

cfg_if::cfg_if! {
    if #[cfg(any(target_os="macos", target_os="ios"))] {
        use std::time::Duration;
        use tokio::time::timeout;
        use futures::stream::{StreamExt};
        use async_dnssd::{query_record, QueryRecordResult, QueriedRecordFlags, Type};

        #[derive(Clone)]
        pub struct DnsSrvRecord {
            priority: u16,
            weight: u16,
            port: u16,
            target: String
        }

        impl From<&QueryRecordResult> for DnsSrvRecord {
            fn from(record: &QueryRecordResult) -> Self {
                let rdata = record.rdata.as_slice();
                let priority = u16::from_be_bytes(rdata[0..2].try_into().unwrap());
                let weight = u16::from_be_bytes(rdata[2..4].try_into().unwrap());
                let port = u16::from_be_bytes(rdata[4..6].try_into().unwrap());
                let target_data = &rdata[6..rdata.len()];
                DnsSrvRecord {
                    priority,
                    weight,
                    port,
                    target: dns_decode_target_data_to_string(target_data)
                }
            }
        }

        pub fn dns_decode_target_data_to_string(v: &[u8]) -> String {
            let mut names = Vec::new();

            let mut i = 0;
            while i < v.len() {
                let size = v[i] as usize;
                if size == 0 || i + 1 + size > v.len() {
                    break;
                }
                names.push(String::from_utf8_lossy(&v[i+1..i+1+size]));
                i = i + 1 + size;
            }

            names.join(".")
        }

        pub fn dns_query_srv_records(name: &str) -> Vec<DnsSrvRecord> {
            const QUERY_TIMEOUT: u64 = 1000;

            async fn query_with_timeout(name: &str, query_timeout: u64) -> Vec<DnsSrvRecord> {
                let mut dns_records: Vec<DnsSrvRecord> = Vec::new();
                let mut query = query_record(name, Type::SRV);

                loop {
                    match timeout(Duration::from_millis(query_timeout), query.next()).await {
                        Ok(Some(Ok(dns_record))) => {
                            let srv_record: DnsSrvRecord = (&dns_record).into();
                            dns_records.push(srv_record.to_owned());
                            if !dns_record.flags.contains(QueriedRecordFlags::MORE_COMING) {
                                break;
                            }
                        }
                        Ok(None) => {
                            break
                        }
                        Ok(Some(Err(error))) => {
                            error!(%error, "IO error when reading DNS query");
                            break;
                        }
                        Err(error) => {
                            error!(%error, "Timeout when reading DNS query");
                            break;
                        }
                    }
                }

                dns_records
            }

            execute_future(query_with_timeout(name, QUERY_TIMEOUT))
        }

        pub fn detect_kdc_hosts_from_dns_apple(domain: &str) -> Vec<String> {
            let krb_tcp_name = &format!("_kerberos._tcp.{}", domain);
            let krb_tcp_srv = dns_query_srv_records(krb_tcp_name);

            if !krb_tcp_srv.is_empty() {
                return krb_tcp_srv.iter().map(|x| format!("tcp://{}:{}", &x.target, x.port)).collect()
            }

            let krb_udp_name = &format!("_kerberos._udp.{}", domain);
            let krb_udp_srv = dns_query_srv_records(krb_udp_name);

            if !krb_udp_srv.is_empty() {
                return krb_udp_srv.iter().map(|x| format!("udp://{}:{}", &x.target, x.port)).collect()
            }

            Vec::new()
        }
    }
}

cfg_if::cfg_if! {
    if #[cfg(feature="dns_resolver")] {
        use hickory_resolver::TokioAsyncResolver;
        use hickory_resolver::system_conf::read_system_conf;
        use hickory_resolver::config::{ResolverConfig,NameServerConfig,Protocol,ResolverOpts};
        use std::env;
        use std::net::{IpAddr,SocketAddr};
        use std::str::FromStr;
        use url::Url;

        fn get_dns_name_server_from_url(url: &str) -> Option<NameServerConfig> {
            let url = if !url.contains("://") && !url.is_empty() {
                format!("udp://{}", url)
            } else {
                url.to_string()
            };

            if let Ok(url) = Url::parse(&url) {
                if let Some(url_host) = url.host_str() {
                    let url_port = url.port().unwrap_or(53);
                    let protocol = match url.scheme().to_lowercase().as_str() {
                        "tcp" => Protocol::Tcp,
                        "udp" => Protocol::Udp,
                        _ => Protocol::Udp,
                    };
                    if let Ok(ip_addr) = IpAddr::from_str(url_host) {
                        let socket_addr = SocketAddr::new(ip_addr, url_port);
                        return Some(NameServerConfig {
                            socket_addr,
                            protocol,
                            tls_dns_name: None,
                            trust_negative_responses: false,
                            bind_addr: None
                        });
                    }
                }
            }

            None
        }

        fn get_dns_resolver_from_name_servers(name_servers: Vec<String>) -> TokioAsyncResolver {
            let mut resolver_config = ResolverConfig::new();

            for name_server_url in name_servers {
                if let Some(name_server) = get_dns_name_server_from_url(&name_server_url) {
                    resolver_config.add_name_server(name_server);
                }
            }

            let mut resolver_options = ResolverOpts::default();
            resolver_options.validate = false;

            TokioAsyncResolver::tokio(resolver_config, resolver_options)
        }

        #[cfg(target_os="windows")]
        fn get_dns_resolver(domain: &str) -> Option<TokioAsyncResolver> {
            let name_servers = get_name_servers_for_domain(domain);
            Some(get_dns_resolver_from_name_servers(name_servers))
        }

        #[cfg(not(target_os="windows"))]
        fn get_dns_resolver(_domain: &str) -> Option<TokioAsyncResolver> {
            if let Ok(name_server_list) = env::var("SSPI_DNS_URL") {
                let name_servers: Vec<String> = name_server_list
                    .split(',').map(|c|c.trim()).filter(|x| !x.is_empty()).map(String::from).collect();
                Some(get_dns_resolver_from_name_servers(name_servers))
            } else if let Ok((resolver_config, resolver_options)) = read_system_conf() {
                Some(TokioAsyncResolver::tokio(resolver_config, resolver_options))
            } else {
                None
            }
        }

        pub fn detect_kdc_hosts_from_dns_resolver(domain: &str) -> Vec<String> {
            let mut kdc_hosts = Vec::new();

            if let Some(resolver) = get_dns_resolver(domain) {
                if let Ok(records) = execute_future(resolver.srv_lookup(format!("_kerberos._tcp.{}", domain))) {
                    for record in records {
                        let port = record.port();
                        let target_name = record.target().to_string();
                        let target_name = target_name.trim_end_matches('.').to_string();
                        let kdc_host = format!("tcp://{}:{}", &target_name, port);
                        kdc_hosts.push(kdc_host);
                    }
                }

                if let Ok(records) = execute_future(resolver.srv_lookup(format!("_kerberos._udp.{}", domain))) {
                    for record in records {
                        let port = record.port();
                        let target_name = record.target().to_string();
                        let target_name = target_name.trim_end_matches('.').to_string();
                        let kdc_host = format!("udp://{}:{}", &target_name, port);
                        kdc_hosts.push(kdc_host);
                    }
                }
            }

            kdc_hosts
        }
    }
}

#[cfg(any(feature = "dns_resolver", target_os = "macos", target_os = "ios"))]
fn execute_future<Fut>(fut: Fut) -> Fut::Output
where
    Fut: std::future::IntoFuture + Send,
    Fut::Output: Send,
{
    use std::thread;

    use tokio::runtime::{Builder, Handle, Runtime, RuntimeFlavor};
    use tokio::task;

    fn new_runtime() -> Runtime {
        Builder::new_current_thread().enable_all().build().unwrap()
    }

    match Handle::try_current() {
        Ok(handle) => {
            match handle.runtime_flavor() {
                RuntimeFlavor::CurrentThread => thread::scope(|s| {
                    s.spawn(move || new_runtime().block_on(fut.into_future()))
                        .join()
                        .unwrap()
                }),
                // block_in_place can't be used in current_thread runtime
                _ => task::block_in_place(move || handle.block_on(fut.into_future())),
            }
        }
        Err(_) => new_runtime().block_on(fut.into_future()),
    }
}

#[allow(unused_variables)]
#[instrument(level = "debug", ret)]
pub fn detect_kdc_hosts_from_dns(domain: &str) -> Vec<String> {
    cfg_if::cfg_if! {
        if #[cfg(windows)] {
            detect_kdc_hosts_from_dns_windows(domain)
        } else if #[cfg(any(target_os="macos", target_os="ios"))] {
            detect_kdc_hosts_from_dns_apple(domain)
        } else if #[cfg(feature="dns_resolver")] {
            detect_kdc_hosts_from_dns_resolver(domain)
        } else {
            Vec::new()
        }
    }
}


--- File: src/generator.rs ---
use std::future::Future;
use std::pin::Pin;
use std::sync::{Arc, Mutex};
use std::task::{Context, Poll, Wake, Waker};

use url::Url;

use crate::credssp::ServerError;
use crate::network_client::{AsyncNetworkClient, NetworkClient, NetworkProtocol};
use crate::{AcceptSecurityContextResult, Error, InitializeSecurityContextResult};

pub struct Interrupt<YieldTy, ResumeTy> {
    value_to_yield: Option<YieldTy>,
    yielded_value: YieldedValue<YieldTy>,
    resumed_value: ResumedValue<ResumeTy>,
    ready_to_resume: bool,
}

impl<YieldTy, ResumeTy> Future for Interrupt<YieldTy, ResumeTy>
where
    YieldTy: Unpin,
{
    type Output = ResumeTy;

    fn poll(self: Pin<&mut Self>, _: &mut Context<'_>) -> Poll<Self::Output> {
        let this = self.get_mut();

        if this.ready_to_resume {
            let resumed_value = this.resumed_value.try_lock().unwrap().take().unwrap();
            Poll::Ready(resumed_value)
        } else {
            let value_to_yield = this.value_to_yield.take().unwrap();
            *this.yielded_value.try_lock().unwrap() = Some(value_to_yield);
            this.ready_to_resume = true;
            Poll::Pending
        }
    }
}

#[derive(Debug)]
pub struct YieldPoint<YieldTy, ResumeTy> {
    yielded_value: YieldedValue<YieldTy>,
    resumed_value: ResumedValue<ResumeTy>,
}

impl<YieldTy, ResumeTy> Clone for YieldPoint<YieldTy, ResumeTy> {
    fn clone(&self) -> Self {
        Self {
            yielded_value: self.yielded_value.clone(),
            resumed_value: self.resumed_value.clone(),
        }
    }
}

impl<YieldTy, ResumeTy> YieldPoint<YieldTy, ResumeTy> {
    pub fn suspend(&mut self, value: YieldTy) -> Interrupt<YieldTy, ResumeTy> {
        Interrupt {
            value_to_yield: Some(value),
            yielded_value: Arc::clone(&self.yielded_value),
            resumed_value: Arc::clone(&self.resumed_value),
            ready_to_resume: false,
        }
    }
}

type YieldedValue<T> = Arc<Mutex<Option<T>>>;
type ResumedValue<T> = Arc<Mutex<Option<T>>>;
type PinnedFuture<'a, T> = Pin<Box<dyn Future<Output = T> + Send + 'a>>;

pub enum GeneratorState<YieldTy, OutTy> {
    Suspended(YieldTy),
    Completed(OutTy),
}

pub struct Generator<'a, YieldTy, ResumeTy, OutTy> {
    yielded_value: YieldedValue<YieldTy>,
    resumed_value: ResumedValue<ResumeTy>,
    generator: PinnedFuture<'a, OutTy>,
}

impl<'a, YieldTy, ResumeTy, OutTy> Generator<'a, YieldTy, ResumeTy, OutTy>
where
    OutTy: Send + 'a,
{
    pub fn new<Producer, Task>(producer: Producer) -> Self
    where
        Producer: FnOnce(YieldPoint<YieldTy, ResumeTy>) -> Task,
        Task: Future<Output = OutTy> + Send + 'a,
    {
        let yielded_value = Arc::new(Mutex::new(None));
        let resumed_value = Arc::new(Mutex::new(None));

        let yield_point = YieldPoint {
            yielded_value: Arc::clone(&yielded_value),
            resumed_value: Arc::clone(&resumed_value),
        };
        Self {
            yielded_value,
            resumed_value,
            generator: Box::pin(producer(yield_point)),
        }
    }

    pub fn start(&mut self) -> GeneratorState<YieldTy, OutTy> {
        self.step()
    }

    pub fn resume(&mut self, value: ResumeTy) -> GeneratorState<YieldTy, OutTy> {
        *self.resumed_value.try_lock().unwrap() = Some(value);
        self.step()
    }

    fn step(&mut self) -> GeneratorState<YieldTy, OutTy> {
        match execute_one_step(&mut self.generator) {
            None => {
                let value = self.yielded_value.try_lock().unwrap().take().unwrap();
                GeneratorState::Suspended(value)
            }
            Some(value) => GeneratorState::Completed(value),
        }
    }
}

fn execute_one_step<OutTy>(task: &mut PinnedFuture<OutTy>) -> Option<OutTy> {
    struct NoopWake;

    impl Wake for NoopWake {
        fn wake(self: std::sync::Arc<Self>) {
            // do nothing
        }
    }

    let waker = Waker::from(Arc::new(NoopWake));
    let mut context = Context::from_waker(&waker);

    match task.as_mut().poll(&mut context) {
        Poll::Pending => None,
        Poll::Ready(item) => Some(item),
    }
}

/// Utility types and methods
impl<'a, YieldTy, ResumeTy, OutTy> Generator<'a, YieldTy, ResumeTy, Result<OutTy, Error>>
where
    OutTy: Send + 'a,
{
    pub fn resolve_to_result(&mut self) -> Result<OutTy, Error> {
        let state = self.start();
        match state {
            GeneratorState::Suspended(_) => Err(Error::new(
                crate::ErrorKind::UnsupportedFunction,
                "cannot finish generator",
            )),
            GeneratorState::Completed(res) => res,
        }
    }

    pub fn unwrap(&mut self) -> OutTy {
        self.resolve_to_result().unwrap()
    }

    pub fn expect(&mut self, msg: &str) -> OutTy {
        self.resolve_to_result().expect(msg)
    }
}

impl<'a, YieldTy, ResumeTy, OutTy> Generator<'a, YieldTy, ResumeTy, Result<OutTy, ServerError>>
where
    OutTy: Send + 'a,
{
    pub fn resolve_to_result(&mut self) -> Result<OutTy, ServerError> {
        let state = self.start();
        match state {
            GeneratorState::Suspended(_) => Err(ServerError {
                ts_request: None,
                error: Error::new(crate::ErrorKind::UnsupportedFunction, "cannot finish generator"),
            }),
            GeneratorState::Completed(res) => res,
        }
    }
}

#[derive(Debug, Clone)]
pub struct NetworkRequest {
    pub protocol: NetworkProtocol,
    pub url: Url,
    pub data: Vec<u8>, // avoid life time problem, suspend requires 'static life time
}

impl<YieldTy, ResumeTy, OutTy> std::fmt::Debug for Generator<'_, YieldTy, ResumeTy, OutTy>
where
    YieldTy: std::fmt::Debug,
    ResumeTy: std::fmt::Debug,
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Generator")
            .field("yielded_value", &self.yielded_value)
            .field("resumed_value", &self.resumed_value)
            .finish()
    }
}

pub type GeneratorInitSecurityContext<'a> =
    Generator<'a, NetworkRequest, crate::Result<Vec<u8>>, crate::Result<InitializeSecurityContextResult>>;

pub type GeneratorAcceptSecurityContext<'a> =
    Generator<'a, NetworkRequest, crate::Result<Vec<u8>>, crate::Result<AcceptSecurityContextResult>>;

pub type GeneratorChangePassword<'a> = Generator<'a, NetworkRequest, crate::Result<Vec<u8>>, crate::Result<()>>;

pub(crate) type YieldPointLocal = YieldPoint<NetworkRequest, crate::Result<Vec<u8>>>;

impl<'a, YieldType, ResumeType, OutType, ErrorType> From<Result<OutType, ErrorType>>
    for Generator<'a, YieldType, ResumeType, Result<OutType, ErrorType>>
where
    OutType: Send + 'a,
    ErrorType: Send + 'a,
{
    fn from(value: Result<OutType, ErrorType>) -> Self {
        Generator::new(move |_| async move { value })
    }
}

/// Utilities for working with network client
impl<'a, OutTy> Generator<'a, NetworkRequest, crate::Result<Vec<u8>>, OutTy>
where
    OutTy: 'a + Send,
{
    #[cfg(feature = "network_client")]
    pub fn resolve_with_default_network_client(&mut self) -> OutTy {
        let network_client = crate::network_client::reqwest_network_client::ReqwestNetworkClient;
        self.resolve_with_client(&network_client)
    }

    pub fn resolve_with_client(&mut self, network_client: &dyn NetworkClient) -> OutTy {
        let mut state = self.start();
        loop {
            match state {
                GeneratorState::Suspended(ref request) => {
                    state = self.resume(crate::network_client::NetworkClient::send(network_client, request));
                }
                GeneratorState::Completed(res) => {
                    return res;
                }
            }
        }
    }

    pub async fn resolve_with_async_client(&mut self, network_client: &mut dyn AsyncNetworkClient) -> OutTy {
        let mut state = self.start();

        loop {
            match state {
                GeneratorState::Suspended(ref request) => {
                    state = self.resume(network_client.send(request).await);
                }
                GeneratorState::Completed(client_state) => {
                    return client_state;
                }
            }
        }
    }
}


--- File: src/kdc.rs ---
cfg_if::cfg_if! {
    if #[cfg(windows)] {
        use windows_registry::LOCAL_MACHINE;
    }
}

use std::env;
#[cfg(not(target_os = "windows"))]
use std::path::Path;
use std::str::FromStr;

use url::Url;

use crate::dns::detect_kdc_hosts_from_dns;
#[cfg(not(target_os = "windows"))]
use crate::krb::Krb5Conf;

#[cfg(target_os = "windows")]
#[instrument(level = "debug", ret)]
pub fn detect_kdc_hosts_from_system(domain: &str) -> Vec<String> {
    let domain_upper = domain.to_uppercase();
    let hklm = LOCAL_MACHINE;
    let domains_key_path = "SYSTEM\\CurrentControlSet\\Control\\Lsa\\Kerberos\\Domains";
    let domain_key_path = format!("{}\\{}", domains_key_path, &domain_upper);
    if let Ok(domain_key) = hklm.open(domain_key_path) {
        let kdc_names: Vec<String> = domain_key.get_multi_string("KdcNames").unwrap_or_default();
        kdc_names.iter().map(|x| format!("tcp://{}:88", x)).collect()
    } else {
        Vec::new()
    }
}

#[cfg(not(target_os = "windows"))]
#[instrument(level = "debug", ret)]
pub fn detect_kdc_hosts_from_system(domain: &str) -> Vec<String> {
    // https://web.mit.edu/kerberos/krb5-current/doc/user/user_config/kerberos.html#environment-variables

    let krb5_config = env::var("KRB5_CONFIG").unwrap_or_else(|_| "/etc/krb5.conf:/usr/local/etc/krb5.conf".to_string());
    let krb5_conf_paths = krb5_config.split(':').map(Path::new).collect::<Vec<&Path>>();

    for krb5_conf_path in krb5_conf_paths {
        if krb5_conf_path.exists() {
            if let Some(krb5_conf) = Krb5Conf::new_from_file(krb5_conf_path) {
                if let Some(kdc) = krb5_conf.get_value(vec!["realms", domain, "kdc"]) {
                    let kdc_url = format!("tcp://{}", kdc.as_str());
                    return vec![kdc_url];
                }
            }
        }
    }

    Vec::new()
}

#[instrument(ret, level = "debug")]
pub fn detect_kdc_hosts(domain: &str) -> Vec<String> {
    if let Ok(kdc_url) = env::var(format!("SSPI_KDC_URL_{}", domain)) {
        return vec![kdc_url];
    }

    if let Ok(kdc_url) = env::var("SSPI_KDC_URL") {
        return vec![kdc_url];
    }

    let kdc_hosts = detect_kdc_hosts_from_system(domain);

    if !kdc_hosts.is_empty() {
        return kdc_hosts;
    }

    detect_kdc_hosts_from_dns(domain)
}

pub fn detect_kdc_host(domain: &str) -> Option<String> {
    let kdc_hosts = detect_kdc_hosts(domain);
    if !kdc_hosts.is_empty() {
        Some(kdc_hosts.first().unwrap().to_string())
    } else {
        None
    }
}

pub fn detect_kdc_url(domain: &str) -> Option<Url> {
    let kdc_host = detect_kdc_host(domain)?;
    Url::from_str(&kdc_host).ok()
}

#[cfg(test)]
mod tests {
    use super::detect_kdc_hosts;
    #[test]
    fn test_detect_kdc() {
        if let Ok(domain) = std::env::var("TEST_KERBEROS_REALM") {
            println!("Finding KDC for {} domain", &domain);
            let kdc_hosts = detect_kdc_hosts(&domain);
            if let Some(kdc_host) = kdc_hosts.first() {
                println!("KDC server: {}", kdc_host);
            } else {
                println!("No KDC server found!");
            }
        }
    }
}


--- File: src/kerberos/client/as_exchange.rs ---
use picky_krb::data_types::{KrbResult, ResultExt};
use picky_krb::messages::{AsRep, KdcReqBody};

use crate::generator::YieldPointLocal;
use crate::kerberos::client::extractors::extract_salt_from_krb_error;
use crate::kerberos::client::generators::generate_as_req;
use crate::kerberos::pa_datas::AsReqPaDataOptions;
use crate::kerberos::utils::serialize_message;
use crate::{Error, ErrorKind, Kerberos, Result};

/// Performs AS exchange as specified in [RFC 4210: The Authentication Service Exchange](https://www.rfc-editor.org/rfc/rfc4120#section-3.1).
pub async fn as_exchange(
    client: &mut Kerberos,
    yield_point: &mut YieldPointLocal,
    kdc_req_body: &KdcReqBody,
    mut pa_data_options: AsReqPaDataOptions<'_>,
) -> Result<AsRep> {
    pa_data_options.with_pre_auth(false);
    let pa_datas = pa_data_options.generate()?;
    let as_req = generate_as_req(pa_datas, kdc_req_body.clone());

    let response = client.send(yield_point, &serialize_message(&as_req)?).await?;

    // first 4 bytes are message len. skipping them
    {
        if response.len() < 4 {
            return Err(Error::new(
                ErrorKind::InternalError,
                "the KDC reply message is too small: expected at least 4 bytes",
            ));
        }

        let mut d = picky_asn1_der::Deserializer::new_from_bytes(&response[4..]);
        let as_rep: KrbResult<AsRep> = KrbResult::deserialize(&mut d)?;

        if as_rep.is_ok() {
            error!("KDC replied with AS_REP to the AS_REQ without the encrypted timestamp. The KRB_ERROR expected.");

            return Err(Error::new(
                ErrorKind::InvalidToken,
                "KDC server should not process AS_REQ without the pa-pac data",
            ));
        }

        if let Some(correct_salt) = extract_salt_from_krb_error(&as_rep.unwrap_err())? {
            debug!("salt extracted successfully from the KRB_ERROR");

            pa_data_options.with_salt(correct_salt.as_bytes().to_vec());
        }
    }

    pa_data_options.with_pre_auth(true);
    let pa_datas = pa_data_options.generate()?;

    let as_req = generate_as_req(pa_datas, kdc_req_body.clone());

    let response = client.send(yield_point, &serialize_message(&as_req)?).await?;

    if response.len() < 4 {
        return Err(Error::new(
            ErrorKind::InternalError,
            "the KDC reply message is too small: expected at least 4 bytes",
        ));
    }

    // first 4 bytes are message len. skipping them
    let mut d = picky_asn1_der::Deserializer::new_from_bytes(&response[4..]);

    Ok(KrbResult::<AsRep>::deserialize(&mut d)?.inspect_err(|err| error!(?err, "AS exchange error"))?)
}


--- File: src/kerberos/client/change_password.rs ---
use picky_krb::crypto::CipherSuite;
use picky_krb::messages::KrbPrivMessage;
use rand::rngs::OsRng;
use rand::Rng;

use crate::builders::ChangePassword;
use crate::generator::YieldPointLocal;
use crate::kerberos::client::extractors::{
    extract_encryption_params_from_as_rep, extract_session_key_from_as_rep, extract_status_code_from_krb_priv_response,
};
use crate::kerberos::client::generators::{
    generate_as_req_kdc_body, generate_authenticator, generate_krb_priv_request, get_client_principal_name_type,
    get_client_principal_realm, EncKey, GenerateAsPaDataOptions, GenerateAsReqOptions, GenerateAuthenticatorOptions,
};
use crate::kerberos::pa_datas::AsReqPaDataOptions;
use crate::kerberos::utils::{serialize_message, unwrap_hostname};
use crate::kerberos::{client, CHANGE_PASSWORD_SERVICE_NAME, DEFAULT_ENCRYPTION_TYPE, KADMIN};
use crate::utils::generate_random_symmetric_key;
use crate::{ClientRequestFlags, Error, ErrorKind, Kerberos, Result};

/// [Kerberos Change Password and Set Password Protocols](https://datatracker.ietf.org/doc/html/rfc3244#section-2)
/// "The service accepts requests on UDP port 464 and TCP port 464 as well."
const KPASSWD_PORT: u16 = 464;

#[instrument(level = "debug", ret, fields(state = ?client.state), skip(client, change_password))]
pub async fn change_password<'a>(
    client: &'a mut Kerberos,
    yield_point: &mut YieldPointLocal,
    change_password: ChangePassword<'a>,
) -> Result<()> {
    let username = &change_password.account_name;
    let domain = &change_password.domain_name;
    let password = &change_password.old_password;

    let salt = format!("{}{}", domain, username);

    let cname_type = get_client_principal_name_type(username, domain);
    let realm = &get_client_principal_realm(username, domain);
    let hostname = unwrap_hostname(client.config.client_computer_name.as_deref())?;

    let options = GenerateAsReqOptions {
        realm,
        username,
        cname_type,
        snames: &[KADMIN, CHANGE_PASSWORD_SERVICE_NAME],
        // 4 = size of u32
        nonce: &OsRng.gen::<u32>().to_ne_bytes(),
        hostname: &hostname,
        context_requirements: ClientRequestFlags::empty(),
    };
    let kdc_req_body = generate_as_req_kdc_body(&options)?;

    let pa_data_options = AsReqPaDataOptions::AuthIdentity(GenerateAsPaDataOptions {
        password: password.as_ref(),
        salt: salt.as_bytes().to_vec(),
        enc_params: client.encryption_params.clone(),
        with_pre_auth: false,
    });

    let as_rep = client::as_exchange(client, yield_point, &kdc_req_body, pa_data_options).await?;

    debug!("AS exchange finished successfully.");

    client.realm = Some(as_rep.0.crealm.0.to_string());

    let (encryption_type, salt) = extract_encryption_params_from_as_rep(&as_rep)?;
    debug!(?encryption_type, "Negotiated encryption type");

    client.encryption_params.encryption_type = Some(CipherSuite::try_from(usize::from(encryption_type))?);

    let session_key = extract_session_key_from_as_rep(&as_rep, &salt, password.as_ref(), &client.encryption_params)?;

    let seq_num = client.next_seq_number();

    let enc_type = client
        .encryption_params
        .encryption_type
        .as_ref()
        .unwrap_or(&DEFAULT_ENCRYPTION_TYPE);
    let authenticator_seb_key = generate_random_symmetric_key(enc_type, &mut OsRng);

    let authenticator = generate_authenticator(GenerateAuthenticatorOptions {
        kdc_rep: &as_rep.0,
        seq_num: Some(seq_num),
        sub_key: Some(EncKey {
            key_type: enc_type.clone(),
            key_value: authenticator_seb_key,
        }),
        checksum: None,
        channel_bindings: client.channel_bindings.as_ref(),
        extensions: Vec::new(),
    })?;

    let krb_priv = generate_krb_priv_request(
        as_rep.0.ticket.0,
        &session_key,
        change_password.new_password.as_ref().as_bytes(),
        &authenticator,
        &client.encryption_params,
        seq_num,
        &hostname,
    )?;

    if let Some((_realm, mut kdc_url)) = client.get_kdc() {
        kdc_url
            .set_port(Some(KPASSWD_PORT))
            .map_err(|_| Error::new(ErrorKind::InvalidParameter, "Cannot set port for KDC URL"))?;

        let response = client.send(yield_point, &serialize_message(&krb_priv)?).await?;
        trace!(?response, "Change password raw response");

        if response.len() < 4 {
            return Err(Error::new(
                ErrorKind::InternalError,
                "the KDC reply message is too small: expected at least 4 bytes",
            ));
        }

        let krb_priv_response = KrbPrivMessage::deserialize(&response[4..]).map_err(|err| {
            Error::new(
                ErrorKind::InvalidToken,
                format!("cannot deserialize krb_priv_response: {:?}", err),
            )
        })?;

        let result_status = extract_status_code_from_krb_priv_response(
            &krb_priv_response.krb_priv,
            &authenticator.0.subkey.0.as_ref().unwrap().0.key_value.0 .0,
            &client.encryption_params,
        )?;

        if result_status != 0 {
            return Err(Error::new(
                ErrorKind::WrongCredentialHandle,
                format!("unsuccessful krb result code: {}. expected 0", result_status),
            ));
        }
    } else {
        return Err(Error::new(
            ErrorKind::NoAuthenticatingAuthority,
            "no KDC server found".to_owned(),
        ));
    }

    Ok(())
}


--- File: src/kerberos/client/extractors.rs ---
use std::io::Read;

use picky_asn1::wrapper::{Asn1SequenceOf, ObjectIdentifierAsn1};
use picky_asn1_der::application_tag::ApplicationTag;
use picky_asn1_der::Asn1RawDer;
use picky_krb::constants::key_usages::{AP_REP_ENC, AS_REP_ENC, KRB_PRIV_ENC_PART, TGS_REP_ENC_SESSION_KEY};
use picky_krb::constants::types::PA_ETYPE_INFO2_TYPE;
use picky_krb::crypto::CipherSuite;
use picky_krb::data_types::{EncApRepPart, EncKrbPrivPart, EtypeInfo2, PaData, Ticket};
use picky_krb::gss_api::NegTokenTarg1;
use picky_krb::messages::{ApRep, AsRep, EncAsRepPart, EncTgsRepPart, KrbError, KrbPriv, TgsRep, TgtRep};

use crate::kerberos::{EncryptionParams, DEFAULT_ENCRYPTION_TYPE};
use crate::{Error, ErrorKind, Result};

/// Extracts password salt from the KRB error.
///
/// We need a salt to derive the correct encryption key from user's password. Usually, the salt is domain+username, but the custom salt
/// value can be set in KDC database. So, we always extract the correct salt from the [KrbError] message. More info in [RFC 4120 PA-ETYPE-INFO2](https://www.rfc-editor.org/rfc/rfc4120#section-5.2.7.5):
///
/// > The ETYPE-INFO2 pre-authentication type is sent by the KDC in a KRB-ERROR indicating a requirement for additional pre-authentication.
/// > It is usually used to notify a client of which key to use for the encryption of an encrypted timestamp for the purposes of sending a
/// > PA-ENC-TIMESTAMP pre-authentication value.
pub fn extract_salt_from_krb_error(error: &KrbError) -> Result<Option<String>> {
    trace!(?error, "KRB_ERROR");

    if let Some(e_data) = error.0.e_data.0.as_ref() {
        let pa_datas: Asn1SequenceOf<PaData> = picky_asn1_der::from_bytes(&e_data.0 .0)?;

        if let Some(pa_etype_info_2) = pa_datas
            .0
            .into_iter()
            .find(|pa_data| pa_data.padata_type.0 .0 == PA_ETYPE_INFO2_TYPE)
        {
            let etype_info_2: EtypeInfo2 = picky_asn1_der::from_bytes(&pa_etype_info_2.padata_data.0 .0)?;
            if let Some(params) = etype_info_2.0.first() {
                return Ok(params.salt.0.as_ref().map(|salt| salt.0.to_string()));
            }
        }
    }

    Ok(None)
}

/// Extracts a session from the [AsRep].
#[instrument(level = "trace", ret, skip(password))]
pub fn extract_session_key_from_as_rep(
    as_rep: &AsRep,
    salt: &str,
    password: &str,
    enc_params: &EncryptionParams,
) -> Result<Vec<u8>> {
    let cipher = enc_params
        .encryption_type
        .as_ref()
        .unwrap_or(&DEFAULT_ENCRYPTION_TYPE)
        .cipher();

    let key = cipher.generate_key_from_password(password.as_bytes(), salt.as_bytes())?;

    let enc_data = cipher.decrypt(&key, AS_REP_ENC, &as_rep.0.enc_part.0.cipher.0 .0)?;

    let enc_as_rep_part: EncAsRepPart = picky_asn1_der::from_bytes(&enc_data)?;

    Ok(enc_as_rep_part.0.key.0.key_value.0.to_vec())
}

/// Extracts a session from the [TgsRep].
#[instrument(level = "trace", ret)]
pub fn extract_session_key_from_tgs_rep(
    tgs_rep: &TgsRep,
    session_key: &[u8],
    enc_params: &EncryptionParams,
) -> Result<Vec<u8>> {
    let cipher = enc_params
        .encryption_type
        .as_ref()
        .unwrap_or(&DEFAULT_ENCRYPTION_TYPE)
        .cipher();

    let enc_data = cipher
        .decrypt(session_key, TGS_REP_ENC_SESSION_KEY, &tgs_rep.0.enc_part.0.cipher.0 .0)
        .map_err(|e| Error::new(ErrorKind::DecryptFailure, format!("{:?}", e)))?;

    trace!(?enc_data, "Plain TgsRep::EncData");

    let enc_as_rep_part: EncTgsRepPart = picky_asn1_der::from_bytes(&enc_data)?;

    Ok(enc_as_rep_part.0.key.0.key_value.0.to_vec())
}

/// Extracts encryption type and salt from [AsRep].
///
/// More info in [RFC 4120 Receipt of KRB_AS_REP Message](https://www.rfc-editor.org/rfc/rfc4120#section-3.1.5):
///
/// > If any padata fields are present, they may be used to derive the proper secret key to decrypt the message.
#[instrument(level = "trace", ret)]
pub fn extract_encryption_params_from_as_rep(as_rep: &AsRep) -> Result<(u8, String)> {
    match as_rep
        .0
        .padata
        .0
        .as_ref()
        .map(|v| {
            v.0 .0
                .iter()
                .find(|e| e.padata_type.0 .0 == PA_ETYPE_INFO2_TYPE)
                .map(|pa_data| pa_data.padata_data.0 .0.clone())
        })
        .unwrap_or_default()
    {
        Some(data) => {
            let pa_etype_info2: EtypeInfo2 = picky_asn1_der::from_bytes(&data)?;
            let pa_etype_info2 = pa_etype_info2
                .0
                .first()
                .ok_or_else(|| Error::new(ErrorKind::InvalidParameter, "Missing EtypeInto2Entry in EtypeInfo2"))?;

            Ok((
                pa_etype_info2.etype.0 .0.first().copied().unwrap(),
                pa_etype_info2
                    .salt
                    .0
                    .as_ref()
                    .map(|salt| salt.0.to_string())
                    .ok_or_else(|| Error::new(ErrorKind::InvalidParameter, "Missing salt in EtypeInto2Entry"))?,
            ))
        }
        None => Ok((*as_rep.0.enc_part.0.etype.0 .0.first().unwrap(), Default::default())),
    }
}

/// Extract a status code from the [KrbPriv] message.
pub fn extract_status_code_from_krb_priv_response(
    krb_priv: &KrbPriv,
    auth_key: &[u8],
    encryption_params: &EncryptionParams,
) -> Result<u16> {
    let encryption_type = encryption_params
        .encryption_type
        .clone()
        .unwrap_or(CipherSuite::try_from(
            *krb_priv
                .0
                .enc_part
                .0
                .etype
                .0
                 .0
                .first()
                .unwrap_or(&((&DEFAULT_ENCRYPTION_TYPE).into())) as usize,
        )?);

    let cipher = encryption_type.cipher();

    let enc_part: EncKrbPrivPart = picky_asn1_der::from_bytes(&cipher.decrypt(
        auth_key,
        KRB_PRIV_ENC_PART,
        &krb_priv.0.enc_part.0.cipher.0 .0,
    )?)?;
    let user_data = enc_part.0.user_data.0 .0;

    if user_data.len() < 2 {
        return Err(Error::new(
            ErrorKind::InvalidToken,
            "Invalid KRB_PRIV message: user-data first is too short (expected at least 2 bytes)",
        ));
    }

    Ok(u16::from_be_bytes(user_data[0..2].try_into().unwrap()))
}

/// Extracts [ApRep] from the [NegTokenTarg1] .
#[instrument(ret, level = "trace")]
pub fn extract_ap_rep_from_neg_token_targ(token: &NegTokenTarg1) -> Result<ApRep> {
    let resp_token = &token
        .0
        .response_token
        .0
        .as_ref()
        .ok_or_else(|| Error::new(ErrorKind::InvalidToken, "missing response token in NegTokenTarg"))?
        .0
         .0;

    let mut data = resp_token.as_slice();
    let _oid: ApplicationTag<Asn1RawDer, 0> = picky_asn1_der::from_reader(&mut data)?;

    let mut t = [0, 0];
    data.read_exact(&mut t)?;

    Ok(picky_asn1_der::from_reader(&mut data)?)
}

/// Extracts the sequence number from the [ApRep].
#[instrument(level = "trace", ret)]
pub fn extract_seq_number_from_ap_rep(
    ap_rep: &ApRep,
    session_key: &[u8],
    enc_params: &EncryptionParams,
) -> Result<Vec<u8>> {
    let cipher = enc_params
        .encryption_type
        .as_ref()
        .unwrap_or(&DEFAULT_ENCRYPTION_TYPE)
        .cipher();

    let res = cipher
        .decrypt(session_key, AP_REP_ENC, &ap_rep.0.enc_part.cipher.0 .0)
        .map_err(|err| {
            Error::new(
                ErrorKind::DecryptFailure,
                format!("cannot decrypt ap_rep.enc_part: {:?}", err),
            )
        })?;

    let ap_rep_enc_part: EncApRepPart = picky_asn1_der::from_bytes(&res)?;

    Ok(ap_rep_enc_part
        .0
        .seq_number
        .0
        .ok_or_else(|| Error::new(ErrorKind::InvalidToken, "missing sequence number in ap_rep"))?
        .0
         .0)
}

/// Extracts a sub-session key from the [ApRep].
#[instrument(level = "trace", ret)]
pub fn extract_sub_session_key_from_ap_rep(
    ap_rep: &ApRep,
    session_key: &[u8],
    enc_params: &EncryptionParams,
) -> Result<Vec<u8>> {
    let cipher = enc_params
        .encryption_type
        .as_ref()
        .unwrap_or(&DEFAULT_ENCRYPTION_TYPE)
        .cipher();

    let res = cipher
        .decrypt(session_key, AP_REP_ENC, &ap_rep.0.enc_part.cipher.0 .0)
        .map_err(|err| {
            Error::new(
                ErrorKind::DecryptFailure,
                format!("cannot decrypt ap_rep.enc_part: {:?}", err),
            )
        })?;

    let ap_rep_enc_part: EncApRepPart = picky_asn1_der::from_bytes(&res)?;

    Ok(ap_rep_enc_part
        .0
        .subkey
        .0
        .ok_or_else(|| Error::new(ErrorKind::InvalidToken, "missing sub-key in ap_req"))?
        .0
        .key_value
        .0
         .0)
}

/// Extracts TGT Ticket from encoded [NegTokenTarg1].
///
/// Returned OID means the selected authentication mechanism by the target server. More info:
/// * [3.2.1. Syntax](https://datatracker.ietf.org/doc/html/rfc2478#section-3.2.1): `responseToken` field;
///
/// We use this oid to choose between the regular Kerberos 5 and Kerberos 5 User-to-User authentication.
#[instrument(level = "trace", ret)]
pub fn extract_tgt_ticket_with_oid(data: &[u8]) -> Result<Option<(Ticket, ObjectIdentifierAsn1)>> {
    if data.is_empty() {
        return Ok(None);
    }

    let neg_token_targ: NegTokenTarg1 = picky_asn1_der::from_bytes(data)?;

    if let Some(resp_token) = neg_token_targ.0.response_token.0.as_ref().map(|ticket| &ticket.0 .0) {
        let mut c = resp_token.as_slice();

        let oid: ApplicationTag<Asn1RawDer, 0> = picky_asn1_der::from_reader(&mut c)?;
        let oid: ObjectIdentifierAsn1 = picky_asn1_der::from_bytes(&oid.0 .0)?;

        let mut t = [0, 0];

        c.read_exact(&mut t)?;

        let tgt_rep: TgtRep = picky_asn1_der::from_reader(&mut c)?;

        Ok(Some((tgt_rep.ticket.0, oid)))
    } else {
        Ok(None)
    }
}


--- File: src/kerberos/client/generators.rs ---
use std::env;
use std::path::Path;
use std::str::FromStr;

use bitflags;
use md5::{Digest, Md5};
use picky_asn1::bit_string::BitString;
use picky_asn1::date::GeneralizedTime;
use picky_asn1::restricted_string::IA5String;
use picky_asn1::wrapper::{
    Asn1SequenceOf, ExplicitContextTag0, ExplicitContextTag1, ExplicitContextTag11, ExplicitContextTag2,
    ExplicitContextTag3, ExplicitContextTag4, ExplicitContextTag5, ExplicitContextTag6, ExplicitContextTag7,
    ExplicitContextTag8, ExplicitContextTag9, GeneralizedTimeAsn1, IntegerAsn1, ObjectIdentifierAsn1, OctetStringAsn1,
    Optional,
};
use picky_asn1_der::Asn1RawDer;
use picky_asn1_x509::oids;
use picky_krb::constants::gss_api::{
    ACCEPT_COMPLETE, ACCEPT_INCOMPLETE, AP_REQ_TOKEN_ID, AUTHENTICATOR_CHECKSUM_TYPE, TGT_REQ_TOKEN_ID,
};
use picky_krb::constants::key_usages::{
    AP_REP_ENC, AP_REQ_AUTHENTICATOR, KRB_PRIV_ENC_PART, TGS_REQ_PA_DATA_AP_REQ_AUTHENTICATOR,
};
use picky_krb::constants::types::{
    AD_AUTH_DATA_AP_OPTION_TYPE, AP_REP_MSG_TYPE, AP_REQ_MSG_TYPE, AS_REQ_MSG_TYPE, KERB_AP_OPTIONS_CBT, KRB_PRIV,
    NET_BIOS_ADDR_TYPE, NT_ENTERPRISE, NT_PRINCIPAL, NT_SRV_INST, PA_ENC_TIMESTAMP, PA_ENC_TIMESTAMP_KEY_USAGE,
    PA_PAC_OPTIONS_TYPE, PA_PAC_REQUEST_TYPE, PA_TGS_REQ_TYPE, TGS_REQ_MSG_TYPE, TGT_REQ_MSG_TYPE,
};
use picky_krb::crypto::CipherSuite;
use picky_krb::data_types::{
    ApOptions, Authenticator, AuthenticatorInner, AuthorizationData, AuthorizationDataInner, Checksum, EncApRepPart,
    EncApRepPartInner, EncKrbPrivPart, EncKrbPrivPartInner, EncryptedData, EncryptionKey, HostAddress,
    KerbPaPacRequest, KerberosFlags, KerberosStringAsn1, KerberosTime, PaData, PaEncTsEnc, PaPacOptions, PrincipalName,
    Realm, Ticket,
};
use picky_krb::gss_api::{
    ApplicationTag0, GssApiNegInit, KrbMessage, MechType, MechTypeList, NegTokenInit, NegTokenTarg, NegTokenTarg1,
};
use picky_krb::messages::{
    ApMessage, ApRep, ApRepInner, ApReq, ApReqInner, AsReq, KdcRep, KdcReq, KdcReqBody, KrbPriv, KrbPrivInner,
    KrbPrivMessage, TgsReq, TgtReq,
};
use rand::rngs::OsRng;
use rand::Rng;
use time::{Duration, OffsetDateTime};

use crate::channel_bindings::ChannelBindings;
use crate::crypto::compute_md5_channel_bindings_hash;
use crate::kerberos::flags::{ApOptions as ApOptionsFlags, KdcOptions};
use crate::kerberos::{EncryptionParams, DEFAULT_ENCRYPTION_TYPE, KERBEROS_VERSION};
use crate::krb::Krb5Conf;
use crate::utils::parse_target_name;
use crate::{ClientRequestFlags, Error, ErrorKind, Result};

const TGT_TICKET_LIFETIME_DAYS: i64 = 3;
const NONCE_LEN: usize = 4;
/// [Microseconds](https://www.rfc-editor.org/rfc/rfc4120#section-5.2.4).
/// The maximum microseconds value.
///
/// ```not_rust
/// Microseconds    ::= INTEGER (0..999999)
/// ```
pub const MAX_MICROSECONDS: u32 = 999_999;
const MD5_CHECKSUM_TYPE: [u8; 1] = [0x07];

// Renewable, Canonicalize, and Renewable-ok are on by default
// https://www.rfc-editor.org/rfc/rfc4120#section-5.4.1
pub const DEFAULT_AS_REQ_OPTIONS: [u8; 4] = [0x00, 0x81, 0x00, 0x10];

// Renewable, Canonicalize.
// https://www.rfc-editor.org/rfc/rfc4120#section-5.4.1
const DEFAULT_TGS_REQ_OPTIONS: [u8; 4] = [0x00, 0x81, 0x00, 0x00];

const DEFAULT_PA_PAC_OPTIONS: [u8; 4] = [0x40, 0x00, 0x00, 0x00];

/// [Authenticator Checksum](https://datatracker.ietf.org/doc/html/rfc4121#section-4.1.1)
///
/// **Important**: the last 4 bytes are [Checksum Flags Field](https://datatracker.ietf.org/doc/html/rfc4121#section-4.1.1.1).
/// This value should be set separately based on provided [CLientRequestFlags] or [GssFlags].
pub const AUTHENTICATOR_DEFAULT_CHECKSUM: [u8; 24] = [
    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00,
];

/// [MS-KILE] 3.3.5.6.1 Client Principal Lookup
/// https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/6435d3fb-8cf6-4df5-a156-1277690ed59c
pub fn get_client_principal_name_type(username: &str, _domain: &str) -> u8 {
    if username.contains('@') {
        NT_ENTERPRISE
    } else {
        NT_PRINCIPAL
    }
}

pub fn get_client_principal_realm(username: &str, domain: &str) -> String {
    // https://web.mit.edu/kerberos/krb5-current/doc/user/user_config/kerberos.html#environment-variables

    let krb5_config = env::var("KRB5_CONFIG").unwrap_or_else(|_| "/etc/krb5.conf:/usr/local/etc/krb5.conf".to_string());
    let krb5_conf_paths = krb5_config.split(':').map(Path::new).collect::<Vec<&Path>>();

    get_client_principal_realm_impl(&krb5_conf_paths, username, domain)
}

fn get_client_principal_realm_impl(krb5_conf_paths: &[&Path], username: &str, domain: &str) -> String {
    let domain = if domain.is_empty() {
        if let Some((_left, right)) = username.split_once('@') {
            right.to_string()
        } else {
            String::new()
        }
    } else {
        domain.to_string()
    };

    for krb5_conf_path in krb5_conf_paths {
        if !krb5_conf_path.exists() {
            continue;
        }

        if let Some(krb5_conf) = Krb5Conf::new_from_file(krb5_conf_path) {
            if let Some(mappings) = krb5_conf.get_values_in_section(&["domain_realm"]) {
                for (mapping_domain, realm) in mappings {
                    if matches_domain(&domain, mapping_domain) {
                        return realm.to_owned();
                    }
                }
            }
        }
    }

    domain.to_uppercase()
}

fn matches_domain(domain: &str, mapping_domain: &str) -> bool {
    if mapping_domain.starts_with('.') {
        domain
            .split_once('.')
            .map(|(_, remaining)| remaining.eq_ignore_ascii_case(&mapping_domain[1..]))
            .unwrap_or(false)
    } else {
        domain.eq_ignore_ascii_case(mapping_domain)
    }
}

/// Parameters for generating pa-datas for [AsReq] message.
#[derive(Debug)]
pub struct GenerateAsPaDataOptions<'a> {
    pub password: &'a str,
    /// Salt for deriving the encryption key.
    ///
    /// The salt value should be extracted from the [KrbError] message.
    pub salt: Vec<u8>,
    pub enc_params: EncryptionParams,
    /// Flag that indicates whether to generate pa-datas.
    pub with_pre_auth: bool,
}

#[instrument(level = "trace", ret, skip_all, fields(options.salt, options.enc_params, options.with_pre_auth))]
pub fn generate_pa_datas_for_as_req(options: &GenerateAsPaDataOptions) -> Result<Vec<PaData>> {
    let GenerateAsPaDataOptions {
        password,
        salt,
        enc_params,
        with_pre_auth,
    } = options;

    let mut pa_datas = if *with_pre_auth {
        let current_date = OffsetDateTime::now_utc();
        let microseconds = current_date.microsecond().min(MAX_MICROSECONDS);

        let timestamp = PaEncTsEnc {
            patimestamp: ExplicitContextTag0::from(KerberosTime::from(GeneralizedTime::from(current_date))),
            pausec: Optional::from(Some(ExplicitContextTag1::from(IntegerAsn1::from(
                microseconds.to_be_bytes().to_vec(),
            )))),
        };
        let timestamp_bytes = picky_asn1_der::to_vec(&timestamp)?;

        let encryption_type = enc_params.encryption_type.as_ref().unwrap_or(&DEFAULT_ENCRYPTION_TYPE);
        let cipher = encryption_type.cipher();

        let key = cipher.generate_key_from_password(password.as_bytes(), salt)?;
        trace!(?key, ?encryption_type, "AS timestamp encryption params",);

        let encrypted_timestamp = cipher.encrypt(&key, PA_ENC_TIMESTAMP_KEY_USAGE, &timestamp_bytes)?;

        trace!(
            ?current_date,
            ?microseconds,
            ?timestamp_bytes,
            ?encrypted_timestamp,
            "Encrypted timestamp params",
        );

        vec![PaData {
            padata_type: ExplicitContextTag1::from(IntegerAsn1::from(PA_ENC_TIMESTAMP.to_vec())),
            padata_data: ExplicitContextTag2::from(OctetStringAsn1::from(picky_asn1_der::to_vec(&EncryptedData {
                etype: ExplicitContextTag0::from(IntegerAsn1::from(vec![encryption_type.into()])),
                kvno: Optional::from(None),
                cipher: ExplicitContextTag2::from(OctetStringAsn1::from(encrypted_timestamp)),
            })?)),
        }]
    } else {
        Vec::new()
    };

    pa_datas.push(PaData {
        padata_type: ExplicitContextTag1::from(IntegerAsn1::from(PA_PAC_REQUEST_TYPE.to_vec())),
        padata_data: ExplicitContextTag2::from(OctetStringAsn1::from(picky_asn1_der::to_vec(&KerbPaPacRequest {
            include_pac: ExplicitContextTag0::from(true),
        })?)),
    });

    Ok(pa_datas)
}

/// Parameters for generating [AsReq].
#[derive(Debug)]
pub struct GenerateAsReqOptions<'a> {
    pub realm: &'a str,
    pub username: &'a str,
    pub cname_type: u8,
    pub snames: &'a [&'a str],
    pub nonce: &'a [u8],
    pub hostname: &'a str,
    pub context_requirements: ClientRequestFlags,
}

#[instrument(level = "trace", ret)]
pub fn generate_as_req_kdc_body(options: &GenerateAsReqOptions) -> Result<KdcReqBody> {
    let GenerateAsReqOptions {
        realm,
        username,
        cname_type,
        snames,
        nonce,
        hostname: address,
        context_requirements,
    } = options;

    let expiration_date = OffsetDateTime::now_utc()
        .checked_add(Duration::days(TGT_TICKET_LIFETIME_DAYS))
        .unwrap();

    let host_address = HostAddress {
        addr_type: ExplicitContextTag0::from(IntegerAsn1::from(vec![NET_BIOS_ADDR_TYPE])),
        address: ExplicitContextTag1::from(OctetStringAsn1::from(address.as_bytes().to_vec())),
    };

    let address = Some(ExplicitContextTag9::from(Asn1SequenceOf::from(vec![host_address])));

    let mut service_names = Vec::with_capacity(snames.len());
    for sname in *snames {
        service_names.push(KerberosStringAsn1::from(IA5String::from_string((*sname).to_owned())?));
    }

    let mut as_req_options = KdcOptions::from_bits(u32::from_be_bytes(DEFAULT_AS_REQ_OPTIONS)).unwrap();
    if context_requirements.contains(ClientRequestFlags::DELEGATE) {
        as_req_options |= KdcOptions::FORWARDABLE;
    }

    Ok(KdcReqBody {
        kdc_options: ExplicitContextTag0::from(KerberosFlags::from(BitString::with_bytes(
            as_req_options.bits().to_be_bytes().to_vec(),
        ))),
        cname: Optional::from(Some(ExplicitContextTag1::from(PrincipalName {
            name_type: ExplicitContextTag0::from(IntegerAsn1::from(vec![*cname_type])),
            name_string: ExplicitContextTag1::from(Asn1SequenceOf::from(vec![KerberosStringAsn1::from(
                IA5String::from_string((*username).into())?,
            )])),
        }))),
        realm: ExplicitContextTag2::from(Realm::from(IA5String::from_string((*realm).into())?)),
        sname: Optional::from(Some(ExplicitContextTag3::from(PrincipalName {
            name_type: ExplicitContextTag0::from(IntegerAsn1::from(vec![NT_SRV_INST])),
            name_string: ExplicitContextTag1::from(Asn1SequenceOf::from(service_names)),
        }))),
        from: Optional::from(None),
        till: ExplicitContextTag5::from(GeneralizedTimeAsn1::from(GeneralizedTime::from(expiration_date))),
        rtime: Optional::from(Some(ExplicitContextTag6::from(GeneralizedTimeAsn1::from(
            GeneralizedTime::from(expiration_date),
        )))),
        nonce: ExplicitContextTag7::from(IntegerAsn1::from(nonce.to_vec())),
        etype: ExplicitContextTag8::from(Asn1SequenceOf::from(vec![
            IntegerAsn1::from(vec![CipherSuite::Aes256CtsHmacSha196.into()]),
            IntegerAsn1::from(vec![CipherSuite::Aes128CtsHmacSha196.into()]),
        ])),
        addresses: Optional::from(address),
        enc_authorization_data: Optional::from(None),
        additional_tickets: Optional::from(None),
    })
}

#[instrument(level = "debug", ret, skip_all)]
pub fn generate_as_req(pa_datas: Vec<PaData>, kdc_req_body: KdcReqBody) -> AsReq {
    AsReq::from(KdcReq {
        pvno: ExplicitContextTag1::from(IntegerAsn1::from(vec![KERBEROS_VERSION])),
        msg_type: ExplicitContextTag2::from(IntegerAsn1::from(vec![AS_REQ_MSG_TYPE])),
        padata: Optional::from(Some(ExplicitContextTag3::from(Asn1SequenceOf::from(pa_datas)))),
        req_body: ExplicitContextTag4::from(kdc_req_body),
    })
}

/// Parameters for generating [TgsReq].
#[derive(Debug)]
pub struct GenerateTgsReqOptions<'a> {
    pub realm: &'a str,
    pub service_principal: &'a str,
    pub session_key: &'a [u8],
    /// [Ticket] extracted from the [AsRep] message.
    pub ticket: Ticket,
    /// [Authenticator] to be included in [TgsReq] pa-data.
    pub authenticator: &'a mut Authenticator,
    /// If the Kerberos U2U auth is negotiated, then this parameter must have one ticket: TGT ticket of the application service.
    /// Otherwise, set it to `None`.
    pub additional_tickets: Option<Vec<Ticket>>,
    pub enc_params: &'a EncryptionParams,
    pub context_requirements: ClientRequestFlags,
}

#[instrument(level = "debug", ret)]
pub fn generate_tgs_req(options: GenerateTgsReqOptions) -> Result<TgsReq> {
    let GenerateTgsReqOptions {
        realm,
        service_principal,
        session_key,
        ticket,
        authenticator,
        additional_tickets,
        enc_params,
        context_requirements,
    } = options;

    let (service_name, service_principal_name) = parse_target_name(service_principal)?;

    let expiration_date = OffsetDateTime::now_utc()
        .checked_add(Duration::days(TGT_TICKET_LIFETIME_DAYS))
        .unwrap();

    let mut tgs_req_options = KdcOptions::from_bits(u32::from_be_bytes(DEFAULT_TGS_REQ_OPTIONS)).unwrap();
    if context_requirements.contains(ClientRequestFlags::DELEGATE) {
        tgs_req_options |= KdcOptions::FORWARDABLE;
    }
    if context_requirements.contains(ClientRequestFlags::USE_SESSION_KEY) {
        tgs_req_options |= KdcOptions::ENC_TKT_IN_SKEY;
    }

    let req_body = KdcReqBody {
        kdc_options: ExplicitContextTag0::from(KerberosFlags::from(BitString::with_bytes(
            tgs_req_options.bits().to_be_bytes().to_vec(),
        ))),
        cname: Optional::from(None),
        realm: ExplicitContextTag2::from(Realm::from(IA5String::from_str(realm)?)),
        sname: Optional::from(Some(ExplicitContextTag3::from(PrincipalName {
            name_type: ExplicitContextTag0::from(IntegerAsn1::from(vec![NT_SRV_INST])),
            name_string: ExplicitContextTag1::from(Asn1SequenceOf::from(vec![
                KerberosStringAsn1::from(IA5String::from_string(service_name.into())?),
                KerberosStringAsn1::from(IA5String::from_string(service_principal_name.into())?),
            ])),
        }))),
        from: Optional::from(None),
        till: ExplicitContextTag5::from(GeneralizedTimeAsn1::from(GeneralizedTime::from(expiration_date))),
        rtime: Optional::from(None),
        nonce: ExplicitContextTag7::from(IntegerAsn1::from(OsRng.gen::<[u8; NONCE_LEN]>().to_vec())),
        etype: ExplicitContextTag8::from(Asn1SequenceOf::from(vec![
            IntegerAsn1::from(vec![CipherSuite::Aes256CtsHmacSha196.into()]),
            IntegerAsn1::from(vec![CipherSuite::Aes128CtsHmacSha196.into()]),
        ])),
        addresses: Optional::from(None),
        enc_authorization_data: Optional::from(None),
        additional_tickets: Optional::from(
            additional_tickets.map(|tickets| ExplicitContextTag11::from(Asn1SequenceOf::from(tickets))),
        ),
    };

    let mut md5 = Md5::new();
    md5.update(&picky_asn1_der::to_vec(&req_body)?);
    let checksum = md5.finalize();

    authenticator.0.cksum = Optional::from(Some(ExplicitContextTag3::from(Checksum {
        cksumtype: ExplicitContextTag0::from(IntegerAsn1::from(MD5_CHECKSUM_TYPE.to_vec())),
        checksum: ExplicitContextTag1::from(OctetStringAsn1::from(checksum.to_vec())),
    })));

    let pa_tgs_req =
        PaData {
            padata_type: ExplicitContextTag1::from(IntegerAsn1::from(PA_TGS_REQ_TYPE.to_vec())),
            padata_data: ExplicitContextTag2::from(OctetStringAsn1::from(picky_asn1_der::to_vec(
                &generate_tgs_ap_req(ticket, session_key, authenticator, enc_params)?,
            )?)),
        };

    let pa_pac_options = PaData {
        padata_type: ExplicitContextTag1::from(IntegerAsn1::from(PA_PAC_OPTIONS_TYPE.to_vec())),
        padata_data: ExplicitContextTag2::from(OctetStringAsn1::from(picky_asn1_der::to_vec(&PaPacOptions {
            flags: ExplicitContextTag0::from(KerberosFlags::from(BitString::with_bytes(
                DEFAULT_PA_PAC_OPTIONS.to_vec(),
            ))),
        })?)),
    };

    Ok(TgsReq::from(KdcReq {
        pvno: ExplicitContextTag1::from(IntegerAsn1::from(vec![KERBEROS_VERSION])),
        msg_type: ExplicitContextTag2::from(IntegerAsn1::from(vec![TGS_REQ_MSG_TYPE])),
        padata: Optional::from(Some(ExplicitContextTag3::from(Asn1SequenceOf::from(vec![
            pa_tgs_req,
            pa_pac_options,
        ])))),
        req_body: ExplicitContextTag4::from(req_body),
    }))
}

#[derive(Debug)]
pub struct ChecksumOptions {
    pub checksum_type: Vec<u8>,
    pub checksum_value: ChecksumValues,
}

#[derive(Debug)]
pub struct ChecksumValues {
    inner: Vec<u8>, // use named fields for future extensibility, this is a temporary solution
}

impl Default for ChecksumValues {
    fn default() -> Self {
        Self {
            inner: AUTHENTICATOR_DEFAULT_CHECKSUM.to_vec(),
        }
    }
}

impl From<ChecksumValues> for Vec<u8> {
    fn from(val: ChecksumValues) -> Self {
        val.inner
    }
}

impl From<[u8; 24]> for ChecksumValues {
    fn from(bytes: [u8; 24]) -> Self {
        ChecksumValues {
            inner: Vec::from(bytes),
        }
    }
}

impl ChecksumValues {
    pub(crate) fn set_flags(&mut self, flags: GssFlags) {
        let flag_bits = flags.bits();
        let flag_bytes = flag_bits.to_le_bytes();
        self.inner[20..24].copy_from_slice(&flag_bytes);
    }

    pub(crate) fn into_inner(self) -> Vec<u8> {
        self.inner
    }
}

bitflags::bitflags! {
    /// The checksum "Flags" field is used to convey service options or extension negotiation information.
    /// More info:
    /// * https://datatracker.ietf.org/doc/html/rfc4121#section-4.1.1.1
    #[derive(Debug,Clone,Copy)]
    pub(crate) struct GssFlags: u32 {
        // [Checksum Flags Field](https://datatracker.ietf.org/doc/html/rfc4121#section-4.1.1.1).
        const GSS_C_DELEG_FLAG      = 1;
        const GSS_C_MUTUAL_FLAG     = 2;
        const GSS_C_REPLAY_FLAG     = 4;
        const GSS_C_SEQUENCE_FLAG   = 8;
        const GSS_C_CONF_FLAG       = 16;
        const GSS_C_INTEG_FLAG      = 32;

        const GSS_C_ANON_FLAG       = 64;
        const GSS_C_PROT_READY_FLAG = 128;
        const GSS_C_TRANS_FLAG      = 256;
        const GSS_C_DELEG_POLICY_FLAG = 32768;

        // Additional GSS flags from MS-KILE specification:
        // * [3.2.5.2 Authenticator Checksum Flags](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/387806fc-ed78-445e-afd8-c5639fe4a90a)

        // [Mechanism Specific Changes](https://www.rfc-editor.org/rfc/rfc4757.html#section-7.1):
        // Setting this flag indicates that the client wants to be informed of extended error information. In
        // particular, Windows 2000 status codes may be returned in the data field of a Kerberos error message.
        // This allows the client to understand a server failure more precisely.
        const GSS_C_EXTENDED_ERROR_FLAG = 0x4000;
        // This flag allows the client to indicate to the server that it should only allow the server application to identify
        // the client by name and ID, but not to impersonate the client.
        const GSS_C_IDENTIFY_FLAG = 0x2000;
        // This flag was added for use with Microsoft's implementation of Distributed Computing Environment Remote Procedure
        // Call (DCE RPC), which initially expected three legs of authentication.
        const GSS_C_DCE_STYLE = 0x1000;
    }
}

impl From<ClientRequestFlags> for GssFlags {
    /*
       the semantics of some of the flags of SSPI are I believe one to one mapped to the GSS flags
    */
    fn from(value: ClientRequestFlags) -> Self {
        let mut flags = GssFlags::empty();

        if value.contains(ClientRequestFlags::DELEGATE) {
            flags |= GssFlags::GSS_C_DELEG_FLAG;
        }

        if value.contains(ClientRequestFlags::MUTUAL_AUTH) {
            flags |= GssFlags::GSS_C_MUTUAL_FLAG;
        }

        if value.contains(ClientRequestFlags::REPLAY_DETECT) {
            flags |= GssFlags::GSS_C_REPLAY_FLAG;
        }

        if value.contains(ClientRequestFlags::SEQUENCE_DETECT) {
            flags |= GssFlags::GSS_C_SEQUENCE_FLAG;
        }

        if value.contains(ClientRequestFlags::CONFIDENTIALITY) {
            flags |= GssFlags::GSS_C_CONF_FLAG;
        }

        if value.contains(ClientRequestFlags::INTEGRITY) {
            flags |= GssFlags::GSS_C_INTEG_FLAG;
        }

        if value.contains(ClientRequestFlags::NO_INTEGRITY) {
            flags &= !GssFlags::GSS_C_INTEG_FLAG;
        }

        if value.contains(ClientRequestFlags::USE_DCE_STYLE) {
            flags |= GssFlags::GSS_C_DCE_STYLE;
        }

        flags
    }
}

#[derive(Debug)]
pub struct AuthenticatorChecksumExtension {
    pub extension_type: u32,
    pub extension_value: Vec<u8>,
}

/// Encryption key.
#[derive(Debug)]
pub struct EncKey {
    /// Encryption type.
    pub key_type: CipherSuite,
    /// Encryption key value.
    pub key_value: Vec<u8>,
}

/// Input parameters for generating ApReq Authenticator.
#[derive(Debug)]
pub struct GenerateAuthenticatorOptions<'a> {
    /// [KdcRep] from previous interaction with KDC.
    pub kdc_rep: &'a KdcRep,
    /// Sequence number.
    pub seq_num: Option<u32>,
    /// Sub-session encryption key.
    pub sub_key: Option<EncKey>,
    /// Authenticator checksum options.
    pub checksum: Option<ChecksumOptions>,
    /// Channel bindings.
    pub channel_bindings: Option<&'a ChannelBindings>,
    /// Possible authenticator extensions.
    pub extensions: Vec<AuthenticatorChecksumExtension>,
}

/// Generated ApReq Authenticator.
#[instrument(level = "trace", ret)]
pub fn generate_authenticator(options: GenerateAuthenticatorOptions) -> Result<Authenticator> {
    let GenerateAuthenticatorOptions {
        kdc_rep,
        seq_num,
        sub_key,
        checksum,
        channel_bindings,
        ..
    } = options;

    let current_date = OffsetDateTime::now_utc();
    let mut microseconds = current_date.microsecond();
    if microseconds > MAX_MICROSECONDS {
        microseconds = MAX_MICROSECONDS;
    }

    let authorization_data = Optional::from(channel_bindings.as_ref().map(|_| {
        ExplicitContextTag8::from(AuthorizationData::from(vec![AuthorizationDataInner {
            ad_type: ExplicitContextTag0::from(IntegerAsn1::from(AD_AUTH_DATA_AP_OPTION_TYPE.to_vec())),
            ad_data: ExplicitContextTag1::from(OctetStringAsn1::from(KERB_AP_OPTIONS_CBT.to_vec())),
        }]))
    }));

    let cksum = if let Some(ChecksumOptions {
        checksum_type,
        checksum_value,
    }) = checksum
    {
        let mut checksum_value = checksum_value.into_inner();
        if checksum_type == AUTHENTICATOR_CHECKSUM_TYPE && channel_bindings.is_some() {
            if checksum_value.len() < 20 {
                return Err(Error::new(
                    ErrorKind::InvalidParameter,
                    format!(
                        "Invalid authenticator checksum length: expected >= 20 but got {}. ",
                        checksum_value.len()
                    ),
                ));
            }
            // [Authenticator Checksum](https://datatracker.ietf.org/doc/html/rfc4121#section-4.1.1)
            // 4..19 - Channel binding information (19 inclusive).
            checksum_value[4..20]
                .copy_from_slice(&compute_md5_channel_bindings_hash(channel_bindings.as_ref().unwrap()));
        }
        Optional::from(Some(ExplicitContextTag3::from(Checksum {
            cksumtype: ExplicitContextTag0::from(IntegerAsn1::from(checksum_type)),
            checksum: ExplicitContextTag1::from(OctetStringAsn1::from(checksum_value)),
        })))
    } else {
        Optional::from(None)
    };

    Ok(Authenticator::from(AuthenticatorInner {
        authenticator_vno: ExplicitContextTag0::from(IntegerAsn1::from(vec![KERBEROS_VERSION])),
        crealm: ExplicitContextTag1::from(kdc_rep.crealm.0.clone()),
        cname: ExplicitContextTag2::from(kdc_rep.cname.0.clone()),
        cksum,
        cusec: ExplicitContextTag4::from(IntegerAsn1::from(microseconds.to_be_bytes().to_vec())),
        ctime: ExplicitContextTag5::from(KerberosTime::from(GeneralizedTime::from(current_date))),
        subkey: Optional::from(sub_key.map(|EncKey { key_type, key_value }| {
            ExplicitContextTag6::from(EncryptionKey {
                key_type: ExplicitContextTag0::from(IntegerAsn1::from(vec![key_type.into()])),
                key_value: ExplicitContextTag1::from(OctetStringAsn1::from(key_value)),
            })
        })),
        seq_number: Optional::from(seq_num.map(|seq_num| {
            ExplicitContextTag7::from(IntegerAsn1::from_bytes_be_unsigned(seq_num.to_be_bytes().to_vec()))
        })),
        authorization_data,
    }))
}

#[instrument(level = "trace", skip_all, ret)]
pub fn generate_ap_rep(session_key: &[u8], seq_number: Vec<u8>, enc_params: &EncryptionParams) -> Result<ApRep> {
    let current_date = OffsetDateTime::now_utc();
    let microseconds = current_date.microsecond().min(MAX_MICROSECONDS);

    let encryption_type = enc_params.encryption_type.as_ref().unwrap_or(&DEFAULT_ENCRYPTION_TYPE);

    let enc_ap_rep_part = EncApRepPart::from(EncApRepPartInner {
        ctime: ExplicitContextTag0::from(KerberosTime::from(GeneralizedTime::from(current_date))),
        cusec: ExplicitContextTag1::from(IntegerAsn1::from(microseconds.to_be_bytes().to_vec())),
        subkey: Optional::from(None),
        seq_number: Optional::from(Some(ExplicitContextTag3::from(IntegerAsn1::from(seq_number)))),
    });

    let cipher = encryption_type.cipher();

    let encoded_enc_ap_rep_part = picky_asn1_der::to_vec(&enc_ap_rep_part)?;
    let encrypted_enc_ap_rep_part = cipher.encrypt(session_key, AP_REP_ENC, &encoded_enc_ap_rep_part)?;

    Ok(ApRep::from(ApRepInner {
        pvno: ExplicitContextTag0::from(IntegerAsn1::from(vec![KERBEROS_VERSION])),
        msg_type: ExplicitContextTag1::from(IntegerAsn1::from(vec![AP_REP_MSG_TYPE])),
        enc_part: ExplicitContextTag2::from(EncryptedData {
            etype: ExplicitContextTag0::from(IntegerAsn1::from(vec![encryption_type.into()])),
            kvno: Optional::from(None),
            cipher: ExplicitContextTag2::from(OctetStringAsn1::from(encrypted_enc_ap_rep_part)),
        }),
    }))
}

pub fn generate_tgs_ap_req(
    ticket: Ticket,
    session_key: &[u8],
    authenticator: &Authenticator,
    enc_params: &EncryptionParams,
) -> Result<ApReq> {
    let encryption_type = enc_params.encryption_type.as_ref().unwrap_or(&DEFAULT_ENCRYPTION_TYPE);
    let cipher = encryption_type.cipher();

    let encoded_authenticator = picky_asn1_der::to_vec(&authenticator)?;
    let encrypted_authenticator = cipher.encrypt(
        session_key,
        TGS_REQ_PA_DATA_AP_REQ_AUTHENTICATOR,
        &encoded_authenticator,
    )?;

    trace!(
        ?session_key,
        ?encryption_type,
        "TGS AP_REQ authenticator encryption params",
    );
    trace!(
        plain = ?encoded_authenticator,
        encrypted = ?encrypted_authenticator,
        "TGS AP_REQ authenticator",
    );

    Ok(ApReq::from(ApReqInner {
        pvno: ExplicitContextTag0::from(IntegerAsn1::from(vec![KERBEROS_VERSION])),
        msg_type: ExplicitContextTag1::from(IntegerAsn1::from(vec![AP_REQ_MSG_TYPE])),
        ap_options: ExplicitContextTag2::from(ApOptions::from(BitString::with_bytes(vec![
            // do not need any options when ap_req uses in tgs_req pa_data
            0x00, 0x00, 0x00, 0x00,
        ]))),
        ticket: ExplicitContextTag3::from(ticket),
        authenticator: ExplicitContextTag4::from(EncryptedData {
            etype: ExplicitContextTag0::from(IntegerAsn1::from(vec![encryption_type.into()])),
            kvno: Optional::from(None),
            cipher: ExplicitContextTag2::from(OctetStringAsn1::from(encrypted_authenticator)),
        }),
    }))
}

#[instrument(level = "trace", ret)]
pub fn generate_ap_req(
    ticket: Ticket,
    session_key: &[u8],
    authenticator: &Authenticator,
    enc_params: &EncryptionParams,
    options: ApOptionsFlags,
) -> Result<ApReq> {
    let encryption_type = enc_params.encryption_type.as_ref().unwrap_or(&DEFAULT_ENCRYPTION_TYPE);
    let cipher = encryption_type.cipher();

    let encoded_authenticator = picky_asn1_der::to_vec(&authenticator)?;
    let encrypted_authenticator = cipher.encrypt(session_key, AP_REQ_AUTHENTICATOR, &encoded_authenticator)?;

    trace!(
        plain = ?encoded_authenticator,
        encrypted = ?encrypted_authenticator,
        "AP_REQ authenticator",
    );

    Ok(ApReq::from(ApReqInner {
        pvno: ExplicitContextTag0::from(IntegerAsn1::from(vec![KERBEROS_VERSION])),
        msg_type: ExplicitContextTag1::from(IntegerAsn1::from(vec![AP_REQ_MSG_TYPE])),
        ap_options: ExplicitContextTag2::from(ApOptions::from(BitString::with_bytes(
            options.bits().to_be_bytes().to_vec(),
        ))),
        ticket: ExplicitContextTag3::from(ticket),
        authenticator: ExplicitContextTag4::from(EncryptedData {
            etype: ExplicitContextTag0::from(IntegerAsn1::from(vec![encryption_type.into()])),
            kvno: Optional::from(None),
            cipher: ExplicitContextTag2::from(OctetStringAsn1::from(encrypted_authenticator)),
        }),
    }))
}

/// Returns supported authentication types.
pub fn get_mech_list() -> MechTypeList {
    MechTypeList::from(vec![MechType::from(oids::ms_krb5()), MechType::from(oids::krb5())])
}

/// Generates the initial SPNEGO token.
///
/// The `sname` parameter is optional. If it is present, then the Kerberos U2U is in use, and `TgtReq` will be generated
/// for the input `sname` and placed in the `mech_token` field.
pub fn generate_neg_token_init(sname: Option<&[&str]>) -> Result<ApplicationTag0<GssApiNegInit>> {
    let mech_token = if let Some(sname) = sname {
        let sname = sname
            .iter()
            .map(|sname| Ok(KerberosStringAsn1::from(IA5String::from_string(sname.to_string())?)))
            .collect::<Result<Vec<_>>>()?;

        let krb5_neg_token_init = ApplicationTag0(KrbMessage {
            krb5_oid: ObjectIdentifierAsn1::from(oids::krb5_user_to_user()),
            krb5_token_id: TGT_REQ_TOKEN_ID,
            krb_msg: TgtReq {
                pvno: ExplicitContextTag0::from(IntegerAsn1::from(vec![KERBEROS_VERSION])),
                msg_type: ExplicitContextTag1::from(IntegerAsn1::from(vec![TGT_REQ_MSG_TYPE])),
                server_name: ExplicitContextTag2::from(PrincipalName {
                    name_type: ExplicitContextTag0::from(IntegerAsn1::from(vec![NT_SRV_INST])),
                    name_string: ExplicitContextTag1::from(Asn1SequenceOf::from(sname)),
                }),
            },
        });

        Some(ExplicitContextTag2::from(OctetStringAsn1::from(
            picky_asn1_der::to_vec(&krb5_neg_token_init)?,
        )))
    } else {
        None
    };

    Ok(ApplicationTag0(GssApiNegInit {
        oid: ObjectIdentifierAsn1::from(oids::spnego()),
        neg_token_init: ExplicitContextTag0::from(NegTokenInit {
            mech_types: Optional::from(Some(ExplicitContextTag0::from(get_mech_list()))),
            req_flags: Optional::from(None),
            mech_token: Optional::from(mech_token),
            mech_list_mic: Optional::from(None),
        }),
    }))
}

pub fn generate_neg_ap_req(ap_req: ApReq, mech_id: oid::ObjectIdentifier) -> Result<ExplicitContextTag1<NegTokenTarg>> {
    let krb_blob = ApplicationTag0(KrbMessage {
        krb5_oid: ObjectIdentifierAsn1::from(mech_id),
        krb5_token_id: AP_REQ_TOKEN_ID,
        krb_msg: ap_req,
    });

    Ok(ExplicitContextTag1::from(NegTokenTarg {
        neg_result: Optional::from(Some(ExplicitContextTag0::from(Asn1RawDer(ACCEPT_INCOMPLETE.to_vec())))),
        supported_mech: Optional::from(None),
        response_token: Optional::from(Some(ExplicitContextTag2::from(OctetStringAsn1::from(
            picky_asn1_der::to_vec(&krb_blob)?,
        )))),
        mech_list_mic: Optional::from(None),
    }))
}

pub fn generate_final_neg_token_targ(mech_list_mic: Option<Vec<u8>>) -> NegTokenTarg1 {
    NegTokenTarg1::from(NegTokenTarg {
        neg_result: Optional::from(Some(ExplicitContextTag0::from(Asn1RawDer(ACCEPT_COMPLETE.to_vec())))),
        supported_mech: Optional::from(None),
        response_token: Optional::from(None),
        mech_list_mic: Optional::from(mech_list_mic.map(|v| ExplicitContextTag3::from(OctetStringAsn1::from(v)))),
    })
}

#[instrument(level = "trace", ret)]
pub fn generate_krb_priv_request(
    ticket: Ticket,
    session_key: &[u8],
    new_password: &[u8],
    authenticator: &Authenticator,
    enc_params: &EncryptionParams,
    seq_num: u32,
    address: &str,
) -> Result<KrbPrivMessage> {
    let ap_req = generate_ap_req(ticket, session_key, authenticator, enc_params, ApOptionsFlags::empty())?;

    let enc_part = EncKrbPrivPart::from(EncKrbPrivPartInner {
        user_data: ExplicitContextTag0::from(OctetStringAsn1::from(new_password.to_vec())),
        timestamp: Optional::from(None),
        usec: Optional::from(None),
        seq_number: Optional::from(Some(ExplicitContextTag3::from(IntegerAsn1::from_bytes_be_unsigned(
            seq_num.to_be_bytes().to_vec(),
        )))),
        s_address: ExplicitContextTag4::from(HostAddress {
            addr_type: ExplicitContextTag0::from(IntegerAsn1::from(vec![NET_BIOS_ADDR_TYPE])),
            address: ExplicitContextTag1::from(OctetStringAsn1::from(address.as_bytes().to_vec())),
        }),
        r_address: Optional::from(None),
    });

    let encryption_type = enc_params.encryption_type.as_ref().unwrap_or(&DEFAULT_ENCRYPTION_TYPE);
    let cipher = encryption_type.cipher();

    let encryption_key = &authenticator.0.subkey.0.as_ref().unwrap().key_value.0;
    let encoded_krb_priv = picky_asn1_der::to_vec(&enc_part)?;

    let enc_part = cipher.encrypt(encryption_key, KRB_PRIV_ENC_PART, &encoded_krb_priv)?;

    trace!(?encryption_key, ?encryption_type, "KRB_PRIV encryption params",);
    trace!(
        plain = ?encoded_krb_priv,
        encrypted = ?enc_part,
        "KRB_PRIV encrypted part",
    );

    let krb_priv = KrbPriv::from(KrbPrivInner {
        pvno: ExplicitContextTag0::from(IntegerAsn1::from(vec![KERBEROS_VERSION])),
        msg_type: ExplicitContextTag1::from(IntegerAsn1::from(vec![KRB_PRIV])),
        enc_part: ExplicitContextTag3::from(EncryptedData {
            etype: ExplicitContextTag0::from(IntegerAsn1::from(vec![encryption_type.into()])),
            kvno: Optional::from(None),
            cipher: ExplicitContextTag2::from(OctetStringAsn1::from(enc_part)),
        }),
    });

    Ok(KrbPrivMessage {
        ap_message: ApMessage::ApReq(ap_req),
        krb_priv,
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    const KRB5_CONFIG_FILE_PATH: &str = "test_assets/krb5.conf";

    #[test]
    fn test_set_flags() {
        let mut checksum_values = ChecksumValues::default();
        let flags = GssFlags::GSS_C_MUTUAL_FLAG | GssFlags::GSS_C_REPLAY_FLAG;
        checksum_values.set_flags(flags);
        let expected_bytes = flags.bits().to_le_bytes();
        assert_eq!(checksum_values.inner[20..24], expected_bytes);
    }

    #[test]
    fn test_default() {
        // ensure backwards compatibility
        let checksum_values = ChecksumValues::default();
        assert_eq!(checksum_values.into_inner(), AUTHENTICATOR_DEFAULT_CHECKSUM);
    }

    #[test]
    fn test_flag_for_sign_and_seal() {
        let mut checksum_values = ChecksumValues::default();
        let flags = GssFlags::GSS_C_MUTUAL_FLAG
            | GssFlags::GSS_C_REPLAY_FLAG
            | GssFlags::GSS_C_SEQUENCE_FLAG
            | GssFlags::GSS_C_CONF_FLAG
            | GssFlags::GSS_C_INTEG_FLAG;
        checksum_values.set_flags(flags);
        let expected_bytes = [0x3E, 0x00, 0x00, 0x00];
        assert_eq!(checksum_values.inner[20..24], expected_bytes);
    }

    #[test]
    fn test_get_client_principal_realm_from_domain() {
        let username = "";
        let domain = "TBT.com";

        let realm = get_client_principal_realm_impl(&[Path::new(KRB5_CONFIG_FILE_PATH)], username, domain);

        assert_eq!(realm, "TBT.COM");
    }

    #[test]
    fn test_get_client_principal_realm_from_username() {
        let username = "user@tbt.com";
        let domain = "";

        let realm = get_client_principal_realm_impl(&[Path::new(KRB5_CONFIG_FILE_PATH)], username, domain);

        assert_eq!(realm, "TBT.COM");
    }

    #[test]
    fn test_get_client_principal_realm_from_subdomain_and_domain() {
        let username = "";
        let domain = "s.tbt.com";

        let realm = get_client_principal_realm_impl(&[Path::new(KRB5_CONFIG_FILE_PATH)], username, domain);

        assert_eq!(realm, "TBT.COM");
    }
}


--- File: src/kerberos/client/mod.rs ---
mod as_exchange;
mod change_password;
pub mod extractors;
pub mod generators;

use std::io::Write;

pub use as_exchange::as_exchange;
pub use change_password::change_password;
use picky::key::PrivateKey;
use picky_asn1_x509::oids;
use picky_krb::constants::gss_api::AUTHENTICATOR_CHECKSUM_TYPE;
use picky_krb::constants::key_usages::ACCEPTOR_SIGN;
use picky_krb::crypto::CipherSuite;
use picky_krb::data_types::{KrbResult, ResultExt};
use picky_krb::gss_api::NegTokenTarg1;
use picky_krb::messages::TgsRep;
use rand::rngs::OsRng;
use rand::Rng;
use rsa::{Pkcs1v15Sign, RsaPrivateKey};
use sha1::{Digest, Sha1};

use self::extractors::{
    extract_ap_rep_from_neg_token_targ, extract_encryption_params_from_as_rep, extract_seq_number_from_ap_rep,
    extract_session_key_from_tgs_rep, extract_sub_session_key_from_ap_rep, extract_tgt_ticket_with_oid,
};
use self::generators::{
    generate_ap_rep, generate_ap_req, generate_as_req_kdc_body, generate_authenticator, generate_neg_ap_req,
    generate_neg_token_init, generate_tgs_req, get_client_principal_name_type, get_client_principal_realm,
    get_mech_list, ChecksumOptions, ChecksumValues, EncKey, GenerateAsPaDataOptions, GenerateAsReqOptions,
    GenerateAuthenticatorOptions, GenerateTgsReqOptions, GssFlags,
};
use crate::channel_bindings::ChannelBindings;
use crate::generator::YieldPointLocal;
use crate::kerberos::pa_datas::{AsRepSessionKeyExtractor, AsReqPaDataOptions};
use crate::kerberos::utils::{serialize_message, unwrap_hostname, validate_mic_token};
use crate::kerberos::{DEFAULT_ENCRYPTION_TYPE, EC, TGT_SERVICE_NAME};
use crate::pku2u::generate_client_dh_parameters;
use crate::utils::{generate_random_symmetric_key, parse_target_name, utf16_bytes_to_utf8_string};
use crate::{
    pk_init, BufferType, ClientRequestFlags, ClientResponseFlags, CredentialsBuffers, Error, ErrorKind,
    InitializeSecurityContextResult, Kerberos, KerberosState, Result, SecurityBuffer, SecurityStatus, SspiImpl,
};

/// Indicated that the MIC token `SentByAcceptor` flag must be enabled in the incoming MIC token.
const SENT_BY_ACCEPTOR: u8 = 1;

/// Performs one authentication step.
///
/// The user should call this function until it returns `SecurityStatus::Ok`.
pub async fn initialize_security_context<'a>(
    client: &'a mut Kerberos,
    yield_point: &mut YieldPointLocal,
    builder: &'a mut crate::builders::FilledInitializeSecurityContext<'_, <Kerberos as SspiImpl>::CredentialsHandle>,
) -> Result<crate::InitializeSecurityContextResult> {
    trace!(?builder);

    let status = match client.state {
        KerberosState::Negotiate => {
            let sname = if builder
                .context_requirements
                .contains(ClientRequestFlags::USE_SESSION_KEY)
            {
                let (service_name, service_principal_name) =
                    parse_target_name(builder.target_name.ok_or_else(|| {
                        Error::new(
                            ErrorKind::NoCredentials,
                            "Service target name (service principal name) is not provided",
                        )
                    })?)?;

                Some([service_name, service_principal_name])
            } else {
                None
            };

            debug!(?sname);

            let encoded_neg_token_init =
                picky_asn1_der::to_vec(&generate_neg_token_init(sname.as_ref().map(|sname| sname.as_slice()))?)?;

            let output_token = SecurityBuffer::find_buffer_mut(builder.output, BufferType::Token)?;
            output_token.buffer.write_all(&encoded_neg_token_init)?;

            client.state = KerberosState::Preauthentication;

            SecurityStatus::ContinueNeeded
        }
        KerberosState::Preauthentication => {
            let input = builder
                .input
                .as_ref()
                .ok_or_else(|| crate::Error::new(ErrorKind::InvalidToken, "input buffers must be specified"))?;

            if let Ok(sec_buffer) =
                SecurityBuffer::find_buffer(builder.input.as_ref().unwrap(), BufferType::ChannelBindings)
            {
                client.channel_bindings = Some(ChannelBindings::from_bytes(&sec_buffer.buffer)?);
            }

            let input_token = SecurityBuffer::find_buffer(input, BufferType::Token)?;

            let (tgt_ticket, mech_id) =
                if let Some((tbt_ticket, mech_oid)) = extract_tgt_ticket_with_oid(&input_token.buffer)? {
                    (Some(tbt_ticket), mech_oid.0)
                } else {
                    (None, oids::krb5())
                };
            client.krb5_user_to_user = mech_id == oids::krb5_user_to_user();

            let credentials = builder
                .credentials_handle
                .as_ref()
                .unwrap()
                .as_ref()
                .ok_or_else(|| Error::new(ErrorKind::WrongCredentialHandle, "No credentials provided"))?;

            let (username, password, realm, cname_type) = match credentials {
                CredentialsBuffers::AuthIdentity(auth_identity) => {
                    let username = utf16_bytes_to_utf8_string(&auth_identity.user);
                    let domain = utf16_bytes_to_utf8_string(&auth_identity.domain);
                    let password = utf16_bytes_to_utf8_string(auth_identity.password.as_ref());

                    let realm = get_client_principal_realm(&username, &domain);
                    let cname_type = get_client_principal_name_type(&username, &domain);

                    (username, password, realm, cname_type)
                }
                CredentialsBuffers::SmartCard(smart_card) => {
                    let username = utf16_bytes_to_utf8_string(&smart_card.username);
                    let password = utf16_bytes_to_utf8_string(smart_card.pin.as_ref());

                    let realm = get_client_principal_realm(&username, "");
                    let cname_type = get_client_principal_name_type(&username, "");

                    (username, password, realm.to_uppercase(), cname_type)
                }
            };
            client.realm = Some(realm.clone());

            let options = GenerateAsReqOptions {
                realm: &realm,
                username: &username,
                cname_type,
                snames: &[TGT_SERVICE_NAME, &realm],
                // 4 = size of u32
                nonce: &OsRng.gen::<[u8; 4]>(),
                hostname: &unwrap_hostname(client.config.client_computer_name.as_deref())?,
                context_requirements: builder.context_requirements,
            };
            let kdc_req_body = generate_as_req_kdc_body(&options)?;

            let pa_data_options = match credentials {
                CredentialsBuffers::AuthIdentity(auth_identity) => {
                    let domain = utf16_bytes_to_utf8_string(&auth_identity.domain);
                    let salt = format!("{}{}", domain, username);

                    AsReqPaDataOptions::AuthIdentity(GenerateAsPaDataOptions {
                        password: &password,
                        salt: salt.as_bytes().to_vec(),
                        enc_params: client.encryption_params.clone(),
                        with_pre_auth: false,
                    })
                }
                CredentialsBuffers::SmartCard(smart_card) => {
                    let private_key_pem = utf16_bytes_to_utf8_string(
                        smart_card
                            .private_key_pem
                            .as_ref()
                            .ok_or_else(|| Error::new(ErrorKind::InternalError, "scard private key is missing"))?,
                    );
                    client.dh_parameters = Some(generate_client_dh_parameters(&mut OsRng)?);

                    AsReqPaDataOptions::SmartCard(Box::new(pk_init::GenerateAsPaDataOptions {
                        p2p_cert: picky_asn1_der::from_bytes(&smart_card.certificate)?,
                        kdc_req_body: &kdc_req_body,
                        dh_parameters: client.dh_parameters.clone().unwrap(),
                        sign_data: Box::new(move |data_to_sign| {
                            let mut sha1 = Sha1::new();
                            sha1.update(data_to_sign);
                            let hash = sha1.finalize().to_vec();
                            let private_key = PrivateKey::from_pem_str(&private_key_pem)?;
                            let rsa_private_key = RsaPrivateKey::try_from(&private_key)?;
                            Ok(rsa_private_key.sign(Pkcs1v15Sign::new::<Sha1>(), &hash)?)
                        }),
                        with_pre_auth: false,
                        authenticator_nonce: OsRng.gen::<[u8; 4]>(),
                    }))
                }
            };

            let as_rep = as_exchange(client, yield_point, &kdc_req_body, pa_data_options).await?;

            debug!("AS exchange finished successfully.");

            client.realm = Some(as_rep.0.crealm.0.to_string());

            let (encryption_type, salt) = extract_encryption_params_from_as_rep(&as_rep)?;

            let encryption_type = CipherSuite::try_from(encryption_type as usize)?;

            client.encryption_params.encryption_type = Some(encryption_type);

            let mut authenticator = generate_authenticator(GenerateAuthenticatorOptions {
                kdc_rep: &as_rep.0,
                seq_num: Some(OsRng.gen::<u32>()),
                sub_key: None,
                checksum: None,
                channel_bindings: client.channel_bindings.as_ref(),
                extensions: Vec::new(),
            })?;

            let mut session_key_extractor = match credentials {
                CredentialsBuffers::AuthIdentity(_) => AsRepSessionKeyExtractor::AuthIdentity {
                    salt: &salt,
                    password: &password,
                    enc_params: &mut client.encryption_params,
                },
                CredentialsBuffers::SmartCard(_) => AsRepSessionKeyExtractor::SmartCard {
                    dh_parameters: client.dh_parameters.as_mut().unwrap(),
                    enc_params: &mut client.encryption_params,
                },
            };
            let session_key_1 = session_key_extractor.session_key(&as_rep)?;

            let service_principal = builder.target_name.ok_or_else(|| {
                Error::new(
                    ErrorKind::NoCredentials,
                    "Service target name (service principal name) is not provided",
                )
            })?;

            let mut context_requirements = builder.context_requirements;

            if client.krb5_user_to_user && !context_requirements.contains(ClientRequestFlags::USE_SESSION_KEY) {
                warn!("KRB5 U2U has been negotiated (selected by the server) but the USE_SESSION_KEY flag is not set. Forcibly turning it on...");
                context_requirements.set(ClientRequestFlags::USE_SESSION_KEY, true);
            }

            let tgs_req = generate_tgs_req(GenerateTgsReqOptions {
                realm: &as_rep.0.crealm.0.to_string(),
                service_principal,
                session_key: &session_key_1,
                ticket: as_rep.0.ticket.0,
                authenticator: &mut authenticator,
                additional_tickets: tgt_ticket.map(|ticket| vec![ticket]),
                enc_params: &client.encryption_params,
                context_requirements,
            })?;

            let response = client.send(yield_point, &serialize_message(&tgs_req)?).await?;

            if response.len() < 4 {
                return Err(Error::new(
                    ErrorKind::InternalError,
                    "the KDC reply message is too small: expected at least 4 bytes",
                ));
            }

            // first 4 bytes are message len. skipping them
            let mut d = picky_asn1_der::Deserializer::new_from_bytes(&response[4..]);
            let tgs_rep: KrbResult<TgsRep> = KrbResult::deserialize(&mut d)?;
            let tgs_rep = tgs_rep?;

            debug!("TGS exchange finished successfully");

            let session_key_2 = extract_session_key_from_tgs_rep(&tgs_rep, &session_key_1, &client.encryption_params)?;

            client.encryption_params.session_key = Some(session_key_2);

            let enc_type = client
                .encryption_params
                .encryption_type
                .as_ref()
                .unwrap_or(&DEFAULT_ENCRYPTION_TYPE);
            let authenticator_sub_key = generate_random_symmetric_key(enc_type, &mut OsRng);

            // the original flag is
            // GSS_C_MUTUAL_FLAG | GSS_C_REPLAY_FLAG | GSS_C_SEQUENCE_FLAG | GSS_C_CONF_FLAG | GSS_C_INTEG_FLAG
            // we want to be able to turn of sign and seal, so we leave confidentiality and integrity flags out
            let mut flags: GssFlags = builder.context_requirements.into();
            if flags.contains(GssFlags::GSS_C_DELEG_FLAG) {
                // Below are reasons why we turn off the GSS_C_DELEG_FLAG flag.
                //
                // RFC4121: The Kerberos Version 5 GSS-API. Section 4.1.1:  Authenticator Checksum
                // https://datatracker.ietf.org/doc/html/rfc4121#section-4.1.1.1
                //
                // "The length of the checksum field MUST be at least 24 octets when GSS_C_DELEG_FLAG is not set,
                // and at least 28 octets plus Dlgth octets when GSS_C_DELEG_FLAG is set."
                // Out implementation _always_ uses the 24 octets checksum and do not support Kerberos credentials delegation.
                //
                // "When delegation is used, a ticket-granting ticket will be transferred in a KRB_CRED message."
                // We do not support KRB_CRED messages. So, the GSS_C_DELEG_FLAG flags should be turned off.
                warn!("Kerberos ApReq Authenticator checksum GSS_C_DELEG_FLAG is not supported. Turning it off...");
                flags.remove(GssFlags::GSS_C_DELEG_FLAG);
            }
            debug!(?flags, "ApReq Authenticator checksum flags");

            let mut checksum_value = ChecksumValues::default();
            checksum_value.set_flags(flags);

            let authenticator_options = GenerateAuthenticatorOptions {
                kdc_rep: &tgs_rep.0,
                // The AP_REQ Authenticator sequence number should be the same as `seq_num` in the first Kerberos Wrap token generated
                // by the `encrypt_message` method. So, we set the next sequence number but do not increment the counter,
                // which will be incremented on each `encrypt_message` method call.
                seq_num: Some(client.seq_number + 1),
                sub_key: Some(EncKey {
                    key_type: enc_type.clone(),
                    key_value: authenticator_sub_key,
                }),

                checksum: Some(ChecksumOptions {
                    checksum_type: AUTHENTICATOR_CHECKSUM_TYPE.to_vec(),
                    checksum_value,
                }),
                channel_bindings: client.channel_bindings.as_ref(),
                extensions: Vec::new(),
            };

            let authenticator = generate_authenticator(authenticator_options)?;
            let encoded_auth = picky_asn1_der::to_vec(&authenticator)?;
            debug!(encoded_ap_req_authenticator = ?encoded_auth);

            let ap_req = generate_ap_req(
                tgs_rep.0.ticket.0,
                client
                    .encryption_params
                    .session_key
                    .as_ref()
                    .ok_or_else(|| Error::new(ErrorKind::InternalError, "session key is not set"))?,
                &authenticator,
                &client.encryption_params,
                context_requirements.into(),
            )?;

            let encoded_neg_ap_req = if !builder.context_requirements.contains(ClientRequestFlags::USE_DCE_STYLE) {
                // Wrap in a NegToken.
                picky_asn1_der::to_vec(&generate_neg_ap_req(ap_req, mech_id)?)?
            } else {
                // Do not wrap if the `USE_DCE_STYLE` flag is set.
                // https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/190ab8de-dc42-49cf-bf1b-ea5705b7a087
                picky_asn1_der::to_vec(&ap_req)?
            };

            let output_token = SecurityBuffer::find_buffer_mut(builder.output, BufferType::Token)?;
            output_token.buffer.write_all(&encoded_neg_ap_req)?;

            client.state = KerberosState::ApExchange;

            SecurityStatus::ContinueNeeded
        }
        KerberosState::ApExchange => {
            let input = builder
                .input
                .as_ref()
                .ok_or_else(|| Error::new(ErrorKind::InvalidToken, "Input buffers must be specified"))?;
            let input_token = SecurityBuffer::find_buffer(input, BufferType::Token)?;

            if builder.context_requirements.contains(ClientRequestFlags::USE_DCE_STYLE) {
                // The `EC` field depends on the authentication type. For example, during RDP auth
                // it is equal to 0, but during RPC auth it is equal to EC.
                client.encryption_params.ec = EC;

                use picky_krb::messages::ApRep;

                let ap_rep: ApRep = picky_asn1_der::from_bytes(&input_token.buffer)?;

                let session_key = client
                    .encryption_params
                    .session_key
                    .as_ref()
                    .ok_or_else(|| Error::new(ErrorKind::InternalError, "session key is not set"))?;
                let sub_session_key =
                    extract_sub_session_key_from_ap_rep(&ap_rep, session_key, &client.encryption_params)?;
                let seq_number = extract_seq_number_from_ap_rep(&ap_rep, session_key, &client.encryption_params)?;

                trace!(?sub_session_key, "DCE AP_REP sub-session key");

                client.encryption_params.sub_session_key = Some(sub_session_key);

                let ap_rep = generate_ap_rep(session_key, seq_number, &client.encryption_params)?;
                let ap_rep = picky_asn1_der::to_vec(&ap_rep)?;

                let output_token = SecurityBuffer::find_buffer_mut(builder.output, BufferType::Token)?;
                output_token.buffer.write_all(&ap_rep)?;
            } else {
                let neg_token_targ = {
                    let mut d = picky_asn1_der::Deserializer::new_from_bytes(&input_token.buffer);
                    let neg_token_targ: NegTokenTarg1 = KrbResult::deserialize(&mut d)??;
                    neg_token_targ
                };

                let ap_rep = extract_ap_rep_from_neg_token_targ(&neg_token_targ)?;

                let session_key = client
                    .encryption_params
                    .session_key
                    .as_ref()
                    .ok_or_else(|| Error::new(ErrorKind::InternalError, "session key is not set"))?;
                let sub_session_key =
                    extract_sub_session_key_from_ap_rep(&ap_rep, session_key, &client.encryption_params)?;

                client.encryption_params.sub_session_key = Some(sub_session_key);

                if let Some(ref token) = neg_token_targ.0.mech_list_mic.0 {
                    validate_mic_token::<SENT_BY_ACCEPTOR>(
                        &token.0 .0,
                        ACCEPTOR_SIGN,
                        &client.encryption_params,
                        &get_mech_list(),
                    )?;
                }

                client.next_seq_number();
                client.prepare_final_neg_token(builder)?;
            }

            client.state = KerberosState::PubKeyAuth;
            SecurityStatus::Ok
        }
        _ => {
            return Err(Error::new(
                ErrorKind::OutOfSequence,
                format!("got wrong Kerberos state: {:?}", client.state),
            ))
        }
    };

    trace!(output_buffers = ?builder.output);

    Ok(InitializeSecurityContextResult {
        status,
        flags: ClientResponseFlags::empty(),
        expiry: None,
    })
}


--- File: src/kerberos/config.rs ---
use std::fmt::Debug;
use std::str::FromStr;

use url::Url;

use crate::kdc::detect_kdc_url;
use crate::kerberos::ServerProperties;
use crate::negotiate::{NegotiatedProtocol, ProtocolConfig};
use crate::{Kerberos, Result};

/// Kerberos client configuration.
#[derive(Clone, Debug)]
pub struct KerberosConfig {
    /// KDC URL
    ///
    /// Depending on the scheme it is expected to be either:
    /// - a (Kerberos) KDC address (e.g.: tcp://domain:88, udp://domain:88), or
    /// - a KDC _Proxy_ URL (e.g.: <https://gateway.devolutions.net/jet/KdcProxy?token=…>)
    ///
    /// That is, when the scheme is `http` or `https`, the KDC Proxy Protocol ([KKDCP]) will be
    /// used on top of the Kerberos protocol, wrapping the messages.
    /// Otherwise, the scheme must be either `tcp` or `udp`, and the KDC protocol will be used
    /// in order to communicate with the KDC server directly.
    ///
    /// [KKDCP]: https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-kkdcp/5bcebb8d-b747-4ee5-9453-428aec1c5c38
    pub kdc_url: Option<Url>,
    /// Computer name, or "workstation name", of the client machine performing the authentication attempt
    ///
    /// This is also referred to as the "Source Workstation", i.e.: the name of the computer attempting to logon.
    pub client_computer_name: Option<String>,
}

impl ProtocolConfig for KerberosConfig {
    fn new_instance(&self) -> Result<NegotiatedProtocol> {
        Ok(NegotiatedProtocol::Kerberos(Kerberos::new_client_from_config(
            self.clone(),
        )?))
    }

    fn box_clone(&self) -> Box<dyn ProtocolConfig> {
        Box::new(self.clone())
    }
}

pub fn parse_kdc_url(kdc_url: &str) -> Option<Url> {
    if !kdc_url.contains("://") {
        Url::from_str(&format!("tcp://{kdc_url}")).ok()
    } else {
        Url::from_str(kdc_url).ok()
    }
}

impl KerberosConfig {
    pub fn new(kdc_url: &str, client_computer_name: String) -> Self {
        let kdc_url = parse_kdc_url(kdc_url);

        Self {
            kdc_url,
            client_computer_name: Some(client_computer_name),
        }
    }

    pub fn get_kdc_url(self, domain: &str) -> Option<Url> {
        if let Some(kdc_url) = self.kdc_url {
            Some(kdc_url)
        } else {
            detect_kdc_url(domain)
        }
    }

    pub fn from_kdc_url(url: &str) -> Self {
        let kdc_url = parse_kdc_url(url);

        Self {
            kdc_url,
            client_computer_name: None,
        }
    }
}

/// Kerberos server configuration.
#[derive(Clone, Debug)]
pub struct KerberosServerConfig {
    /// General Kerberos configuration.
    pub kerberos_config: KerberosConfig,
    /// Kerberos server specific parameters.
    pub server_properties: ServerProperties,
}

impl ProtocolConfig for KerberosServerConfig {
    fn new_instance(&self) -> Result<NegotiatedProtocol> {
        Ok(NegotiatedProtocol::Kerberos(Kerberos::new_server_from_config(
            self.kerberos_config.clone(),
            self.server_properties.clone(),
        )?))
    }

    fn box_clone(&self) -> Box<dyn ProtocolConfig> {
        Box::new(self.clone())
    }
}


--- File: src/kerberos/encryption_params.rs ---
use picky_krb::constants::key_usages::{ACCEPTOR_SEAL, INITIATOR_SEAL};
use picky_krb::crypto::aes::AesSize;
use picky_krb::crypto::CipherSuite;

#[derive(Debug, Clone)]
pub struct EncryptionParams {
    pub encryption_type: Option<CipherSuite>,
    pub session_key: Option<Vec<u8>>,
    pub sub_session_key: Option<Vec<u8>>,
    pub sspi_encrypt_key_usage: i32,
    pub sspi_decrypt_key_usage: i32,
    /// EC field of the Kerberos Wrap token.
    ///
    /// Related documentation:
    /// * [RFC 4121: EC Field](https://www.rfc-editor.org/rfc/rfc4121#section-4.2.3).
    /// * [3.4.5.4.1 Kerberos Binding of GSS_WrapEx()](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/e94b3acd-8415-4d0d-9786-749d0c39d550).
    ///
    /// This value is different during RDP and RPC authentication.
    /// We negotiate it during the authentication process.
    pub ec: u16,
}

impl EncryptionParams {
    pub fn default_for_client() -> Self {
        Self {
            encryption_type: None,
            session_key: None,
            sub_session_key: None,
            sspi_encrypt_key_usage: INITIATOR_SEAL,
            sspi_decrypt_key_usage: ACCEPTOR_SEAL,
            ec: 0,
        }
    }

    pub fn default_for_server() -> Self {
        Self {
            encryption_type: None,
            session_key: None,
            sub_session_key: None,
            sspi_encrypt_key_usage: ACCEPTOR_SEAL,
            sspi_decrypt_key_usage: INITIATOR_SEAL,
            ec: 0,
        }
    }

    pub fn aes_size(&self) -> Option<AesSize> {
        self.encryption_type.as_ref().and_then(|e_type| match e_type {
            CipherSuite::Aes256CtsHmacSha196 => Some(AesSize::Aes256),
            CipherSuite::Aes128CtsHmacSha196 => Some(AesSize::Aes128),
            CipherSuite::Des3CbcSha1Kd => None,
        })
    }
}


--- File: src/kerberos/flags.rs ---
use bitflags::bitflags;

use crate::ClientRequestFlags;

bitflags! {
    /// This flags appears in the KRB_AS_REQ and KRB_TGS_REQ requests to
    /// the KDC and indicates the flags that the client wants set on the tickets.
    ///
    /// [KDCOptions](https://www.rfc-editor.org/rfc/rfc4120#section-5.4.1)
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct KdcOptions: u32 {
        const FORWARDABLE = 0x40000000;
        const FORWARDED = 0x20000000;
        const PROXIABLE = 0b10000000;
        const PROXY = 0x08000000;
        const ALLOW_POSTDATE = 0x04000000;
        const POSTDATED = 0x02000000;
        const RENEWABLE = 0x00800000;
        const OPT_HARDWARE_AUTH = 0x00100000;
        const CANONICALIZE = 0x00010000;
        const DISABLE_TRANSITED_CHECK = 0x00000020;
        const RENEWABLE_OK = 0x00000010;
        const ENC_TKT_IN_SKEY = 0x00000008;
        const RENEW = 0x00000002;
        const VALIDATE = 0x00000001;
    }
}

bitflags! {
    /// This flags appears in the application request (KRB_AP_REQ) and
    /// affects the way the request is processed.
    ///
    /// [APOptions](https://www.rfc-editor.org/rfc/rfc4120#section-5.5.1)
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ApOptions: u32 {
        const USE_SESSION_KEY = 0x40000000;
        const MUTUAL_REQUIRED = 0x20000000;
    }
}

impl From<ClientRequestFlags> for ApOptions {
    fn from(flags: ClientRequestFlags) -> Self {
        let mut ap_options = ApOptions::empty();

        if flags.contains(ClientRequestFlags::MUTUAL_AUTH) {
            ap_options |= ApOptions::MUTUAL_REQUIRED;
        }
        if flags.contains(ClientRequestFlags::USE_SESSION_KEY) {
            ap_options |= ApOptions::USE_SESSION_KEY;
        }

        ap_options
    }
}


--- File: src/kerberos/mod.rs ---
pub mod client;
pub mod config;
mod encryption_params;
pub mod flags;
mod pa_datas;
pub mod server;
#[cfg(test)]
mod tests;
mod utils;

use std::fmt::Debug;
use std::io::Write;
use std::sync::LazyLock;

use picky_asn1::restricted_string::IA5String;
use picky_asn1::wrapper::{ExplicitContextTag0, ExplicitContextTag1, OctetStringAsn1, Optional};
use picky_krb::crypto::{CipherSuite, DecryptWithoutChecksum, EncryptWithoutChecksum};
use picky_krb::data_types::KerberosStringAsn1;
use picky_krb::gss_api::WrapToken;
use picky_krb::messages::KdcProxyMessage;
use rand::rngs::OsRng;
use rand::Rng;
use url::Url;

pub use self::client::initialize_security_context;
use self::config::KerberosConfig;
pub use self::encryption_params::EncryptionParams;
pub use self::server::{accept_security_context, ServerProperties};
use super::channel_bindings::ChannelBindings;
use crate::builders::ChangePassword;
use crate::generator::{
    GeneratorAcceptSecurityContext, GeneratorChangePassword, GeneratorInitSecurityContext, NetworkRequest,
    YieldPointLocal,
};
use crate::kerberos::client::generators::{generate_final_neg_token_targ, get_mech_list};
use crate::kerberos::utils::generate_initiator_raw;
use crate::network_client::NetworkProtocol;
use crate::pk_init::DhParameters;
use crate::utils::{extract_encrypted_data, get_encryption_key, save_decrypted_data, utf16_bytes_to_utf8_string};
use crate::{
    detect_kdc_url, AcceptSecurityContextResult, AcquireCredentialsHandleResult, AuthIdentity, BufferType,
    ContextNames, ContextSizes, CredentialUse, Credentials, CredentialsBuffers, DecryptionFlags, Error, ErrorKind,
    PackageCapabilities, PackageInfo, Result, SecurityBuffer, SecurityBufferFlags, SecurityBufferRef,
    SecurityPackageType, SecurityStatus, SessionKeys, Sspi, SspiEx, SspiImpl, PACKAGE_ID_NONE,
};

pub const PKG_NAME: &str = "Kerberos";
pub const KERBEROS_VERSION: u8 = 0x05;
pub const TGT_SERVICE_NAME: &str = "krbtgt";
pub const KADMIN: &str = "kadmin";
pub const CHANGE_PASSWORD_SERVICE_NAME: &str = "changepw";

// pub const SSPI_KDC_URL_ENV: &str = "SSPI_KDC_URL";
pub const DEFAULT_ENCRYPTION_TYPE: CipherSuite = CipherSuite::Aes256CtsHmacSha196;

/// [3.4.5.4.1 Kerberos Binding of GSS_WrapEx()](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/e94b3acd-8415-4d0d-9786-749d0c39d550)
/// The RRC field is 12 if no encryption is requested or 28 if encryption is requested
pub const RRC: u16 = 28;
// wrap token header len
pub const MAX_SIGNATURE: usize = 16;
/// Required `TOKEN` buffer length during data encryption (`encrypt_message` method call).
///
/// **Note**: Actual security trailer len is `SECURITY_TRAILER` + `EC`. The `EC` field is negotiated
// during the authentication process.
pub const SECURITY_TRAILER: usize = 60;

/// [3.4.5.4.1 Kerberos Binding of GSS_WrapEx()](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/e94b3acd-8415-4d0d-9786-749d0c39d550)
///
/// The extra count (EC) must not be zero. The sender should set extra count (EC) to 1 block - 16 bytes.
pub(crate) const EC: u16 = 16;

pub static PACKAGE_INFO: LazyLock<PackageInfo> = LazyLock::new(|| PackageInfo {
    capabilities: PackageCapabilities::empty(),
    rpc_id: PACKAGE_ID_NONE,
    max_token_len: 0xbb80, // 48 000 bytes: default maximum token len in Windows
    name: SecurityPackageType::Kerberos,
    comment: String::from("Kerberos Security Package"),
});

#[derive(Debug, Clone, Copy)]
pub enum KerberosState {
    Negotiate,
    Preauthentication,
    ApExchange,
    PubKeyAuth,
    Credentials,
    Final,
}

#[derive(Debug, Clone)]
pub struct Kerberos {
    pub(crate) state: KerberosState,
    pub(crate) config: KerberosConfig,
    pub(crate) auth_identity: Option<CredentialsBuffers>,
    pub(crate) encryption_params: EncryptionParams,
    pub(crate) seq_number: u32,
    pub(crate) realm: Option<String>,
    pub(crate) kdc_url: Option<Url>,
    pub(crate) channel_bindings: Option<ChannelBindings>,
    pub(crate) dh_parameters: Option<DhParameters>,
    pub(crate) krb5_user_to_user: bool,
    pub(crate) server: Option<Box<ServerProperties>>,
}

impl Kerberos {
    pub fn new_client_from_config(config: KerberosConfig) -> Result<Self> {
        let kdc_url = config.kdc_url.clone();

        Ok(Self {
            state: KerberosState::Negotiate,
            config,
            auth_identity: None,
            encryption_params: EncryptionParams::default_for_client(),
            seq_number: OsRng.gen::<u32>(),
            realm: None,
            kdc_url,
            channel_bindings: None,
            dh_parameters: None,
            krb5_user_to_user: false,
            server: None,
        })
    }

    pub fn new_server_from_config(config: KerberosConfig, server_properties: ServerProperties) -> Result<Self> {
        let kdc_url = config.kdc_url.clone();

        Ok(Self {
            state: KerberosState::Negotiate,
            config,
            auth_identity: None,
            encryption_params: EncryptionParams::default_for_server(),
            seq_number: OsRng.gen::<u32>(),
            realm: None,
            kdc_url,
            channel_bindings: None,
            dh_parameters: None,
            krb5_user_to_user: false,
            server: Some(Box::new(server_properties)),
        })
    }

    pub fn config(&self) -> &KerberosConfig {
        &self.config
    }

    pub fn next_seq_number(&mut self) -> u32 {
        self.seq_number += 1;
        self.seq_number
    }

    #[instrument(level = "debug", ret, skip(self))]
    pub fn get_kdc(&self) -> Option<(String, Url)> {
        let realm = self.realm.to_owned()?;
        if let Some(kdc_url) = &self.kdc_url {
            Some((realm, kdc_url.to_owned()))
        } else {
            let kdc_url = detect_kdc_url(&realm)?;
            Some((realm, kdc_url))
        }
    }

    async fn send(&self, yield_point: &mut YieldPointLocal, data: &[u8]) -> Result<Vec<u8>> {
        if let Some((realm, kdc_url)) = self.get_kdc() {
            let protocol = NetworkProtocol::from_url_scheme(kdc_url.scheme()).ok_or_else(|| {
                Error::new(
                    ErrorKind::InvalidParameter,
                    format!("Invalid protocol `{}` for KDC server", kdc_url.scheme()),
                )
            })?;

            return match protocol {
                NetworkProtocol::Tcp => {
                    let request = NetworkRequest {
                        protocol,
                        url: kdc_url.clone(),
                        data: data.to_vec(),
                    };
                    yield_point.suspend(request).await
                }
                NetworkProtocol::Udp => {
                    if data.len() < 4 {
                        return Err(Error::new(
                            ErrorKind::InternalError,
                            format!(
                                "kerberos message has invalid length. expected >= 4 but got {}",
                                data.len()
                            ),
                        ));
                    }

                    // First 4 bytes are message length and it’s not included when using UDP
                    let request = NetworkRequest {
                        protocol,
                        url: kdc_url.clone(),
                        data: data[4..].to_vec(),
                    };
                    yield_point.suspend(request).await
                }
                NetworkProtocol::Http | NetworkProtocol::Https => {
                    let data = OctetStringAsn1::from(data.to_vec());
                    let domain = KerberosStringAsn1::from(IA5String::from_string(realm)?);

                    let kdc_proxy_message = KdcProxyMessage {
                        kerb_message: ExplicitContextTag0::from(data),
                        target_domain: Optional::from(Some(ExplicitContextTag1::from(domain))),
                        dclocator_hint: Optional::from(None),
                    };

                    let message_request = picky_asn1_der::to_vec(&kdc_proxy_message)?;
                    let request = NetworkRequest {
                        protocol,
                        url: kdc_url,
                        data: message_request,
                    };
                    let result_bytes = yield_point.suspend(request).await?;
                    let message_response: KdcProxyMessage = picky_asn1_der::from_bytes(&result_bytes)?;
                    Ok(message_response.kerb_message.0 .0)
                }
            };
        }
        Err(Error::new(ErrorKind::NoAuthenticatingAuthority, "No KDC server found"))
    }

    fn prepare_final_neg_token(
        &mut self,
        builder: &mut crate::builders::FilledInitializeSecurityContext<'_, <Self as SspiImpl>::CredentialsHandle>,
    ) -> Result<()> {
        let neg_token_targ = generate_final_neg_token_targ(Some(generate_initiator_raw(
            picky_asn1_der::to_vec(&get_mech_list())?,
            self.seq_number as u64,
            self.encryption_params
                .sub_session_key
                .as_ref()
                .ok_or_else(|| Error::new(ErrorKind::InternalError, "kerberos sub-session key is not set"))?,
        )?));

        let encoded_final_neg_token_targ = picky_asn1_der::to_vec(&neg_token_targ)?;

        let output_token = SecurityBuffer::find_buffer_mut(builder.output, BufferType::Token)?;
        output_token.buffer.write_all(&encoded_final_neg_token_targ)?;
        Ok(())
    }
}

impl Sspi for Kerberos {
    #[instrument(level = "debug", ret, fields(state = ?self.state), skip_all)]
    fn complete_auth_token(&mut self, _token: &mut [SecurityBuffer]) -> Result<SecurityStatus> {
        Ok(SecurityStatus::Ok)
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip(self, _flags, _sequence_number))]
    fn encrypt_message(
        &mut self,
        _flags: crate::EncryptionFlags,
        message: &mut [SecurityBufferRef],
        _sequence_number: u32,
    ) -> Result<SecurityStatus> {
        trace!(encryption_params = ?self.encryption_params);

        // checks if the Token buffer present
        let _ = SecurityBufferRef::find_buffer(message, BufferType::Token)?;
        // Find `Data` buffers but skip `Data` buffers with the `READONLY_WITH_CHECKSUM`/`READONLY` flag.
        let data_to_encrypt =
            SecurityBufferRef::buffers_of_type_and_flags(message, BufferType::Data, SecurityBufferFlags::NONE);

        let cipher = self
            .encryption_params
            .encryption_type
            .as_ref()
            .unwrap_or(&DEFAULT_ENCRYPTION_TYPE)
            .cipher();

        let seq_number = self.next_seq_number();

        let key = get_encryption_key(&self.encryption_params)?;

        let key_usage = self.encryption_params.sspi_encrypt_key_usage;

        let mut wrap_token = WrapToken::with_seq_number(seq_number as u64);
        if self.server.is_some() {
            // [Flags Field](https://datatracker.ietf.org/doc/html/rfc4121#section-4.2.2):
            //
            // The meanings of bits in this field (the least significant bit is bit 0) are as follows:
            //   Bit    Name             Description
            //  --------------------------------------------------------------
            //   0   SentByAcceptor   When set, this flag indicates the sender
            //                        is the context acceptor.  When not set,
            //                        it indicates the sender is the context
            //                        initiator.
            // When the Kerberos is used as the Kerberos server we have to set the `SentByAcceptor` flag.
            wrap_token.flags |= 0x01;
        }
        wrap_token.ec = self.encryption_params.ec;

        let mut payload = data_to_encrypt.fold(Vec::new(), |mut acc, buffer| {
            acc.extend_from_slice(buffer.data());
            acc
        });
        // Add filler bytes to payload vector.
        // More info:
        // * [4.2.3.  EC Field](https://datatracker.ietf.org/doc/html/rfc4121#section-4.2.3):
        //   In Wrap tokens with confidentiality, the EC field SHALL be used to encode the number of octets in the filler.
        // * [4.2.4.  Encryption and Checksum Operations](https://datatracker.ietf.org/doc/html/rfc4121#section-4.2.4):
        //   payload = plaintext-data | filler | "header"
        payload.extend_from_slice(&vec![0; usize::from(self.encryption_params.ec)]);
        payload.extend_from_slice(&wrap_token.header());

        let EncryptWithoutChecksum {
            mut encrypted,
            confounder,
            ki: _,
        } = cipher.encrypt_no_checksum(key, key_usage, &payload)?;

        // Find `Data` buffers (including `Data` buffers with the `READONLY_WITH_CHECKSUM` flag).
        let mut data_to_sign =
            SecurityBufferRef::buffers_of_type(message, BufferType::Data).fold(confounder, |mut acc, buffer| {
                acc.extend_from_slice(buffer.data());
                acc
            });
        // Add filler bytes to payload vector.
        // More info:
        // * [4.2.3.  EC Field](https://datatracker.ietf.org/doc/html/rfc4121#section-4.2.3):
        //   In Wrap tokens with confidentiality, the EC field SHALL be used to encode the number of octets in the filler.
        // * [4.2.4.  Encryption and Checksum Operations](https://datatracker.ietf.org/doc/html/rfc4121#section-4.2.4):
        //   payload = plaintext-data | filler | "header"
        data_to_sign.extend_from_slice(&vec![0; usize::from(self.encryption_params.ec)]);
        data_to_sign.extend_from_slice(&wrap_token.header());

        let checksum = cipher.encryption_checksum(key, key_usage, &data_to_sign)?;

        encrypted.extend_from_slice(&checksum);

        // [3.4.5.4.1 Kerberos Binding of GSS_WrapEx()](learn.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/e94b3acd-8415-4d0d-9786-749d0c39d550):
        // The trailing metadata H1 is rotated by RRC+EC bytes, which is different from RRC alone.
        encrypted.rotate_right(usize::from(RRC + self.encryption_params.ec));

        wrap_token.set_rrc(RRC);
        wrap_token.set_checksum(encrypted);

        let mut raw_wrap_token = Vec::with_capacity(wrap_token.checksum.len() + WrapToken::header_len());
        wrap_token.encode(&mut raw_wrap_token)?;

        match self.state {
            KerberosState::PubKeyAuth | KerberosState::Credentials | KerberosState::Final => {
                let security_trailer_len = self.query_context_sizes()?.security_trailer.try_into()?;

                let (token, data) = if raw_wrap_token.len() < security_trailer_len {
                    (raw_wrap_token.as_slice(), &[] as &[u8])
                } else {
                    raw_wrap_token.split_at(security_trailer_len)
                };

                let data_buffer = SecurityBufferRef::buffers_of_type_and_flags_mut(
                    message,
                    BufferType::Data,
                    SecurityBufferFlags::NONE,
                )
                .next()
                .ok_or_else(|| Error::new(ErrorKind::InvalidToken, "no buffer was provided with type Data"))?;

                data_buffer.write_data(data)?;

                let token_buffer = SecurityBufferRef::find_buffer_mut(message, BufferType::Token)?;
                token_buffer.write_data(token)?;
            }
            KerberosState::Negotiate | KerberosState::Preauthentication | KerberosState::ApExchange => {
                return Err(Error::new(
                    ErrorKind::OutOfSequence,
                    format!("Kerberos context is not established: current state: {:?}", self.state),
                ))
            }
        };

        Ok(SecurityStatus::Ok)
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip(self, _sequence_number))]
    fn decrypt_message(&mut self, message: &mut [SecurityBufferRef], _sequence_number: u32) -> Result<DecryptionFlags> {
        trace!(encryption_params = ?self.encryption_params);

        let encrypted = extract_encrypted_data(message)?;

        let cipher = self
            .encryption_params
            .encryption_type
            .as_ref()
            .unwrap_or(&DEFAULT_ENCRYPTION_TYPE)
            .cipher();

        let key = get_encryption_key(&self.encryption_params)?;

        let key_usage = self.encryption_params.sspi_decrypt_key_usage;

        let wrap_token = WrapToken::decode(encrypted.as_slice())?;
        // [Flags Field](https://datatracker.ietf.org/doc/html/rfc4121#section-4.2.2):
        //
        // The meanings of bits in this field (the least significant bit is bit 0) are as follows:
        //   Bit    Name             Description
        //  --------------------------------------------------------------
        //   0   SentByAcceptor   When set, this flag indicates the sender
        //                        is the context acceptor.  When not set,
        //                        it indicates the sender is the context
        //                        initiator.
        let is_server = u8::from(self.server.is_some());
        // If the Kerberos acts as the Kerberos application server, then the `SentByAcceptor` flag
        // of the incoming WRAP token must be disabled (because it is sent by initiator).
        if wrap_token.flags & 0x01 == is_server {
            return Err(Error::new(
                ErrorKind::InvalidToken,
                "invalid WRAP token SentByAcceptor flag",
            ));
        }
        //        1   Sealed           When set in Wrap tokens, this flag
        //                             indicates confidentiality is provided
        //                             for.  It SHALL NOT be set in MIC tokens.
        if wrap_token.flags & 0b10 != 0b10 {
            return Err(Error::new(
                ErrorKind::InvalidToken,
                "the Sealed flag has to be set in WRAP token",
            ));
        }

        let mut checksum = wrap_token.checksum;
        // [3.4.5.4.1 Kerberos Binding of GSS_WrapEx()](learn.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/e94b3acd-8415-4d0d-9786-749d0c39d550):
        // The trailing metadata H1 is rotated by RRC+EC bytes, which is different from RRC alone.
        checksum.rotate_left((RRC + wrap_token.ec).into());

        let DecryptWithoutChecksum {
            plaintext: decrypted,
            confounder,
            checksum,
            ki: _,
        } = cipher.decrypt_no_checksum(key, key_usage, &checksum)?;

        if decrypted.len() < usize::from(wrap_token.ec) + WrapToken::header_len() {
            return Err(Error::new(ErrorKind::DecryptFailure, "decrypted data is too short"));
        }

        let plaintext_len = decrypted.len() - usize::from(wrap_token.ec) - WrapToken::header_len();

        let plaintext = &decrypted[0..plaintext_len];
        let wrap_token_header = &decrypted[plaintext_len..];

        // Find `Data` buffers (including `Data` buffers with the `READONLY_WITH_CHECKSUM` flag).
        let mut data_to_sign =
            SecurityBufferRef::buffers_of_type(message, BufferType::Data).fold(confounder, |mut acc, buffer| {
                if buffer
                    .buffer_flags()
                    .contains(SecurityBufferFlags::SECBUFFER_READONLY_WITH_CHECKSUM)
                {
                    acc.extend_from_slice(buffer.data());
                } else {
                    // The `Data` buffer contains encrypted data, but the checksum was calculated over the decrypted data.
                    // So, we replace encrypted data with decrypted one.
                    // Note: our implementation expect maximum one plain `DATA` buffer but multiple `DATA` buffers
                    // with `SECBUFFER_READONLY_WITH_CHECKSUM` flag are allowed.
                    acc.extend_from_slice(plaintext);
                }
                acc
            });
        data_to_sign.extend_from_slice(wrap_token_header);

        let calculated_checksum = cipher.encryption_checksum(key, key_usage, &data_to_sign)?;

        if calculated_checksum != checksum {
            return Err(picky_krb::crypto::KerberosCryptoError::IntegrityCheck.into());
        }

        save_decrypted_data(plaintext, message)?;

        match self.state {
            KerberosState::PubKeyAuth => {
                self.state = KerberosState::Credentials;
                Ok(DecryptionFlags::empty())
            }
            KerberosState::Credentials => {
                self.state = KerberosState::Final;
                Ok(DecryptionFlags::empty())
            }
            _ => Ok(DecryptionFlags::empty()),
        }
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip(self))]
    fn query_context_sizes(&mut self) -> Result<ContextSizes> {
        // We prevent users from calling `query_context_sizes` on a non-established security context
        // because it can lead to invalid values being returned.
        match self.state {
            KerberosState::PubKeyAuth | KerberosState::Credentials | KerberosState::Final => Ok(ContextSizes {
                max_token: PACKAGE_INFO.max_token_len,
                max_signature: MAX_SIGNATURE as u32,
                block: 0,
                security_trailer: SECURITY_TRAILER as u32 + u32::from(self.encryption_params.ec),
            }),
            _ => {
                return Err(Error::new(
                    ErrorKind::OutOfSequence,
                    "Kerberos context is not established",
                ))
            }
        }
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip(self))]
    fn query_context_names(&mut self) -> Result<ContextNames> {
        if let Some(client) = self.server.as_ref().and_then(|server| server.client.as_ref()) {
            return Ok(ContextNames {
                username: client.clone(),
            });
        }

        if let Some(CredentialsBuffers::AuthIdentity(identity_buffers)) = &self.auth_identity {
            let identity =
                AuthIdentity::try_from(identity_buffers).map_err(|e| Error::new(ErrorKind::InvalidParameter, e))?;

            return Ok(ContextNames {
                username: identity.username,
            });
        }

        if let Some(CredentialsBuffers::SmartCard(ref identity_buffers)) = self.auth_identity {
            let username = utf16_bytes_to_utf8_string(&identity_buffers.username);
            let username = crate::Username::parse(&username).map_err(|e| Error::new(ErrorKind::InvalidParameter, e))?;
            return Ok(ContextNames { username });
        }

        Err(Error::new(
            ErrorKind::NoCredentials,
            "requested names, but no credentials were provided",
        ))
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip(self))]
    fn query_context_package_info(&mut self) -> Result<PackageInfo> {
        crate::query_security_package_info(SecurityPackageType::Kerberos)
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip(self))]
    fn query_context_cert_trust_status(&mut self) -> Result<crate::CertTrustStatus> {
        Err(Error::new(
            ErrorKind::UnsupportedFunction,
            "certificate trust status is not supported".to_owned(),
        ))
    }

    #[instrument(level = "debug", fields(state = ?self.state), skip(self))]
    fn query_context_session_key(&self) -> Result<SessionKeys> {
        Ok(SessionKeys {
            session_key: get_encryption_key(&self.encryption_params)?.to_vec().into(),
        })
    }

    fn change_password<'a>(&'a mut self, change_password: ChangePassword<'a>) -> Result<GeneratorChangePassword<'a>> {
        Ok(GeneratorChangePassword::new(move |mut yield_point| async move {
            client::change_password(self, &mut yield_point, change_password).await
        }))
    }

    fn make_signature(
        &mut self,
        _flags: u32,
        _message: &mut [SecurityBufferRef],
        _sequence_number: u32,
    ) -> crate::Result<()> {
        Err(Error::new(
            ErrorKind::UnsupportedFunction,
            "make_signature is not supported. use encrypt_message to sign messages instead",
        ))
    }

    fn verify_signature(&mut self, _message: &mut [SecurityBufferRef], _sequence_number: u32) -> crate::Result<u32> {
        Err(Error::new(
            ErrorKind::UnsupportedFunction,
            "verify_signature is not supported. use decrypt_message to verify signatures instead",
        ))
    }
}

impl SspiImpl for Kerberos {
    type CredentialsHandle = Option<CredentialsBuffers>;

    type AuthenticationData = Credentials;

    #[instrument(level = "trace", ret, fields(state = ?self.state), skip(self))]
    fn acquire_credentials_handle_impl(
        &mut self,
        builder: crate::builders::FilledAcquireCredentialsHandle<'_, Self::CredentialsHandle, Self::AuthenticationData>,
    ) -> Result<crate::AcquireCredentialsHandleResult<Self::CredentialsHandle>> {
        if builder.credential_use == CredentialUse::Outbound && builder.auth_data.is_none() {
            return Err(Error::new(
                ErrorKind::NoCredentials,
                "the client must specify the auth data",
            ));
        }

        self.auth_identity = builder
            .auth_data
            .cloned()
            .map(|auth_data| auth_data.try_into())
            .transpose()?;

        Ok(AcquireCredentialsHandleResult {
            credentials_handle: self.auth_identity.clone(),
            expiry: None,
        })
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip(self, builder))]
    fn accept_security_context_impl<'a>(
        &'a mut self,
        builder: crate::builders::FilledAcceptSecurityContext<'a, Self::CredentialsHandle>,
    ) -> Result<GeneratorAcceptSecurityContext<'a>> {
        Ok(GeneratorAcceptSecurityContext::new(move |mut yield_point| async move {
            self.accept_security_context_impl(&mut yield_point, builder).await
        }))
    }

    fn initialize_security_context_impl<'ctx, 'b, 'g>(
        &'ctx mut self,
        builder: &'b mut crate::builders::FilledInitializeSecurityContext<'ctx, Self::CredentialsHandle>,
    ) -> Result<GeneratorInitSecurityContext<'g>>
    where
        'ctx: 'b,
        'b: 'g,
    {
        Ok(GeneratorInitSecurityContext::new(move |mut yield_point| async move {
            self.initialize_security_context_impl(&mut yield_point, builder).await
        }))
    }
}

impl<'a> Kerberos {
    #[instrument(level = "debug", ret, fields(state = ?self.state), skip(self, change_password))]
    pub async fn change_password(
        &'a mut self,
        yield_point: &mut YieldPointLocal,
        change_password: ChangePassword<'a>,
    ) -> Result<()> {
        client::change_password(self, yield_point, change_password).await
    }

    pub(crate) async fn accept_security_context_impl(
        &'a mut self,
        yield_point: &mut YieldPointLocal,
        builder: crate::builders::FilledAcceptSecurityContext<'a, <Self as SspiImpl>::CredentialsHandle>,
    ) -> Result<AcceptSecurityContextResult> {
        server::accept_security_context(self, yield_point, builder).await
    }

    pub(crate) async fn initialize_security_context_impl(
        &'a mut self,
        yield_point: &mut YieldPointLocal,
        builder: &'a mut crate::builders::FilledInitializeSecurityContext<'_, <Self as SspiImpl>::CredentialsHandle>,
    ) -> Result<crate::InitializeSecurityContextResult> {
        client::initialize_security_context(self, yield_point, builder).await
    }
}

impl SspiEx for Kerberos {
    #[instrument(level = "trace", ret, fields(state = ?self.state), skip(self))]
    fn custom_set_auth_identity(&mut self, identity: Self::AuthenticationData) -> Result<()> {
        self.auth_identity = Some(identity.try_into()?);

        Ok(())
    }
}

#[cfg(any(feature = "__test-data", test))]
pub mod test_data {
    use std::time::Duration;

    use picky_asn1::restricted_string::IA5String;
    use picky_asn1::wrapper::{Asn1SequenceOf, ExplicitContextTag0, ExplicitContextTag1, IntegerAsn1};
    use picky_krb::constants::key_usages::{ACCEPTOR_SEAL, INITIATOR_SEAL};
    use picky_krb::constants::types::NT_SRV_INST;
    use picky_krb::crypto::CipherSuite;
    use picky_krb::data_types::{KerberosStringAsn1, PrincipalName};
    use picky_krb::gss_api::MechTypeList;

    use super::{EncryptionParams, KerberosConfig, KerberosState};
    use crate::kerberos::ServerProperties;
    use crate::Kerberos;

    const SESSION_KEY: &[u8] = &[
        21, 56, 207, 133, 152, 47, 177, 117, 223, 235, 169, 237, 173, 202, 11, 254, 142, 185, 237, 5, 97, 79, 112, 46,
        73, 182, 117, 0, 35, 91, 24, 66,
    ];
    const SUB_SESSION_KEY: &[u8] = &[
        146, 61, 191, 46, 26, 68, 247, 94, 124, 95, 1, 190, 15, 185, 245, 64, 18, 203, 212, 49, 43, 222, 254, 217, 85,
        222, 7, 92, 254, 153, 105, 144,
    ];

    pub fn fake_client() -> Kerberos {
        Kerberos {
            state: KerberosState::Final,
            config: KerberosConfig {
                kdc_url: None,
                client_computer_name: None,
            },
            auth_identity: None,
            encryption_params: EncryptionParams {
                encryption_type: Some(CipherSuite::Aes256CtsHmacSha196),
                session_key: Some(SESSION_KEY.to_vec()),
                sub_session_key: Some(SUB_SESSION_KEY.to_vec()),
                sspi_encrypt_key_usage: INITIATOR_SEAL,
                sspi_decrypt_key_usage: ACCEPTOR_SEAL,
                ec: 0,
            },
            seq_number: 1234,
            realm: None,
            kdc_url: None,
            channel_bindings: None,
            dh_parameters: None,
            krb5_user_to_user: false,
            server: None,
        }
    }

    pub fn fake_server_properties() -> ServerProperties {
        ServerProperties {
            mech_types: MechTypeList::from(Vec::new()),
            max_time_skew: Duration::from_secs(3 * 60),
            ticket_decryption_key: None,
            service_name: PrincipalName {
                name_type: ExplicitContextTag0::from(IntegerAsn1::from(vec![NT_SRV_INST])),
                name_string: ExplicitContextTag1::from(Asn1SequenceOf::from(vec![
                    KerberosStringAsn1::from(IA5String::from_string("TERMSRV".to_owned()).unwrap()),
                    KerberosStringAsn1::from(IA5String::from_string("VM1.example.com".to_owned()).unwrap()),
                ])),
            },
            user: None,
            client: None,
            authenticators_cache: Default::default(),
        }
    }

    pub fn fake_server() -> Kerberos {
        Kerberos {
            state: KerberosState::Final,
            config: KerberosConfig {
                kdc_url: None,
                client_computer_name: None,
            },
            auth_identity: None,
            encryption_params: EncryptionParams {
                encryption_type: Some(CipherSuite::Aes256CtsHmacSha196),
                session_key: Some(SESSION_KEY.to_vec()),
                sub_session_key: Some(SUB_SESSION_KEY.to_vec()),
                sspi_encrypt_key_usage: ACCEPTOR_SEAL,
                sspi_decrypt_key_usage: INITIATOR_SEAL,
                ec: 0,
            },
            seq_number: 0,
            realm: None,
            kdc_url: None,
            channel_bindings: None,
            dh_parameters: None,
            krb5_user_to_user: false,
            server: Some(Box::new(fake_server_properties())),
        }
    }
}


--- File: src/kerberos/pa_datas.rs ---
use picky_asn1_x509::signed_data::SignedData;
use picky_krb::crypto::diffie_hellman::{generate_key, DhNonce};
use picky_krb::crypto::CipherSuite;
use picky_krb::data_types::PaData;
use picky_krb::messages::AsRep;
use picky_krb::pkinit::PaPkAsRep;

use crate::kerberos::client::extractors::extract_session_key_from_as_rep;
use crate::kerberos::client::generators::{
    generate_pa_datas_for_as_req as generate_password_based, GenerateAsPaDataOptions as AuthIdentityPaDataOptions,
};
use crate::kerberos::encryption_params::EncryptionParams;
use crate::pk_init::{
    extract_server_dh_public_key, generate_pa_datas_for_as_req as generate_private_key_based, DhParameters,
    GenerateAsPaDataOptions as SmartCardPaDataOptions, Wrapper,
};
use crate::pku2u::{extract_pa_pk_as_rep, extract_server_nonce, validate_server_p2p_certificate, validate_signed_data};
use crate::{check_if_empty, pku2u, Error, ErrorKind, Result};

// PA-DATAs are very different for the Kerberos logon using username+password and smart card.
// This enum provides a unified way to generate PA-DATAs based on the provided options.
pub enum AsReqPaDataOptions<'a> {
    AuthIdentity(AuthIdentityPaDataOptions<'a>),
    SmartCard(Box<SmartCardPaDataOptions<'a>>),
}

impl AsReqPaDataOptions<'_> {
    pub fn generate(&self) -> Result<Vec<PaData>> {
        match self {
            AsReqPaDataOptions::AuthIdentity(options) => generate_password_based(options),
            AsReqPaDataOptions::SmartCard(options) => generate_private_key_based(options),
        }
    }

    pub fn with_pre_auth(&mut self, pre_auth: bool) {
        match self {
            AsReqPaDataOptions::AuthIdentity(options) => options.with_pre_auth = pre_auth,
            AsReqPaDataOptions::SmartCard(options) => options.with_pre_auth = pre_auth,
        }
    }

    pub fn with_salt(&mut self, salt: Vec<u8>) {
        match self {
            AsReqPaDataOptions::AuthIdentity(options) => options.salt = salt,
            AsReqPaDataOptions::SmartCard(_) => {}
        }
    }
}

// ApRep session key extraction process is different for the Kerberos logon using username+password and smart card.
// This enum provides a unified way to extract session key from the AsRep.
#[derive(Debug)]
pub enum AsRepSessionKeyExtractor<'a> {
    AuthIdentity {
        salt: &'a str,
        password: &'a str,
        enc_params: &'a EncryptionParams,
    },
    SmartCard {
        dh_parameters: &'a mut DhParameters,
        enc_params: &'a mut EncryptionParams,
    },
}

impl AsRepSessionKeyExtractor<'_> {
    #[instrument(level = "trace", ret, skip(self))]
    pub fn session_key(&mut self, as_rep: &AsRep) -> Result<Vec<u8>> {
        match self {
            AsRepSessionKeyExtractor::AuthIdentity {
                salt,
                password,
                enc_params,
            } => extract_session_key_from_as_rep(as_rep, salt, password, enc_params),
            AsRepSessionKeyExtractor::SmartCard {
                dh_parameters,
                enc_params,
            } => {
                let dh_rep_info = match extract_pa_pk_as_rep(as_rep)? {
                    PaPkAsRep::DhInfo(dh) => dh.0,
                    PaPkAsRep::EncKeyPack(_) => {
                        return Err(Error::new(
                            ErrorKind::OperationNotSupported,
                            "encKeyPack is not supported for the PA-PK-AS-REP",
                        ))
                    }
                };

                let server_nonce = extract_server_nonce(&dh_rep_info)?;
                dh_parameters.server_nonce = Some(server_nonce);

                let wrapped_signed_data: Wrapper<SignedData> =
                    picky_asn1_der::from_bytes(&dh_rep_info.dh_signed_data.0)?;
                let signed_data = wrapped_signed_data.content.0;

                let rsa_public_key = validate_server_p2p_certificate(&signed_data)?;
                validate_signed_data(&signed_data, &rsa_public_key)?;

                let public_key = extract_server_dh_public_key(&signed_data)?;
                dh_parameters.other_public_key = Some(public_key);

                enc_params.encryption_type = Some(CipherSuite::try_from(as_rep.0.enc_part.0.etype.0 .0.as_slice())?);

                let key = generate_key(
                    check_if_empty!(dh_parameters.other_public_key.as_ref(), "dh public key is not set"),
                    &dh_parameters.private_key,
                    &dh_parameters.modulus,
                    Some(DhNonce {
                        client_nonce: check_if_empty!(dh_parameters.client_nonce.as_ref(), "dh client none is not set"),
                        server_nonce: check_if_empty!(
                            dh_parameters.server_nonce.as_ref(),
                            "dh server nonce is not set"
                        ),
                    }),
                    check_if_empty!(enc_params.encryption_type.as_ref(), "encryption type is not set")
                        .cipher()
                        .as_ref(),
                )?;

                let session_key = pku2u::extract_session_key_from_as_rep(as_rep, &key, enc_params)?;

                Ok(session_key)
            }
        }
    }
}


--- File: src/kerberos/server/as_exchange.rs ---
use picky_krb::crypto::CipherSuite;
use picky_krb::data_types::Ticket;
use picky_krb::messages::TgtReq;
use rand::rngs::OsRng;
use rand::Rng;

use crate::generator::YieldPointLocal;
use crate::kerberos::client::extractors::extract_encryption_params_from_as_rep;
use crate::kerberos::client::generators::{
    generate_as_req_kdc_body, get_client_principal_name_type, get_client_principal_realm, GenerateAsPaDataOptions,
    GenerateAsReqOptions,
};
use crate::kerberos::pa_datas::{AsRepSessionKeyExtractor, AsReqPaDataOptions};
use crate::kerberos::utils::unwrap_hostname;
use crate::kerberos::{client, TGT_SERVICE_NAME};
use crate::utils::utf16_bytes_to_utf8_string;
use crate::{ClientRequestFlags, CredentialsBuffers, Error, ErrorKind, Kerberos, Result};

/// Requests the TGT ticket from KDC.
///
/// Basically, it performs the AS exchange, saves the session key, and returns the ticket.
pub async fn request_tgt(
    server: &mut Kerberos,
    credentials: &CredentialsBuffers,
    tgt_req: &TgtReq,
    yield_point: &mut YieldPointLocal,
) -> Result<Ticket> {
    let service_name = &server
        .server
        .as_ref()
        .ok_or_else(|| {
            Error::new(
                ErrorKind::InvalidHandle,
                "Kerberos server properties are not initialized",
            )
        })?
        .service_name;
    if tgt_req.server_name.0 != *service_name {
        return Err(Error::new(
            ErrorKind::InvalidToken,
            format!(
                "invalid ticket service name ({:?}): Kerberos server is configured for {:?}",
                tgt_req.server_name.0, service_name
            ),
        ));
    }

    let (username, password, realm, cname_type) = match credentials {
        CredentialsBuffers::AuthIdentity(auth_identity) => {
            let username = utf16_bytes_to_utf8_string(&auth_identity.user);
            let domain = utf16_bytes_to_utf8_string(&auth_identity.domain);
            let password = utf16_bytes_to_utf8_string(auth_identity.password.as_ref());

            let realm = get_client_principal_realm(&username, &domain);
            let cname_type = get_client_principal_name_type(&username, &domain);

            (username, password, realm, cname_type)
        }
        CredentialsBuffers::SmartCard(_) => {
            return Err(Error::new(
                ErrorKind::UnsupportedPreAuth,
                "smart card credentials are not supported in Kerberos application server",
            ));
        }
    };
    server.realm = Some(realm.clone());

    let options = GenerateAsReqOptions {
        realm: &realm,
        username: &username,
        cname_type,
        snames: &[TGT_SERVICE_NAME, &realm],
        // 4 = size of u32
        nonce: &OsRng.gen::<[u8; 4]>(),
        hostname: &unwrap_hostname(server.config.client_computer_name.as_deref())?,
        context_requirements: ClientRequestFlags::empty(),
    };
    let kdc_req_body = generate_as_req_kdc_body(&options)?;

    let pa_data_options = match credentials {
        CredentialsBuffers::AuthIdentity(auth_identity) => {
            let domain = utf16_bytes_to_utf8_string(&auth_identity.domain);
            let salt = format!("{}{}", domain, username);

            AsReqPaDataOptions::AuthIdentity(GenerateAsPaDataOptions {
                password: &password,
                salt: salt.as_bytes().to_vec(),
                enc_params: server.encryption_params.clone(),
                with_pre_auth: false,
            })
        }
        CredentialsBuffers::SmartCard(_) => {
            return Err(Error::new(
                ErrorKind::UnsupportedPreAuth,
                "smart card credentials are not supported in Kerberos application server",
            ));
        }
    };

    let as_rep = client::as_exchange(server, yield_point, &kdc_req_body, pa_data_options).await?;

    debug!("AS exchange finished successfully.");

    server.realm = Some(as_rep.0.crealm.0.to_string());

    let (encryption_type, salt) = extract_encryption_params_from_as_rep(&as_rep)?;

    let encryption_type = CipherSuite::try_from(encryption_type as usize)?;
    server.encryption_params.encryption_type = Some(encryption_type);

    let mut session_key_extractor = AsRepSessionKeyExtractor::AuthIdentity {
        salt: &salt,
        password: &password,
        enc_params: &mut server.encryption_params,
    };

    let server_props = server.server.as_mut().ok_or_else(|| {
        Error::new(
            ErrorKind::InvalidHandle,
            "Kerberos server properties are not initialized",
        )
    })?;
    server_props.ticket_decryption_key = Some(session_key_extractor.session_key(&as_rep)?);

    Ok(as_rep.0.ticket.0)
}


--- File: src/kerberos/server/cache.rs ---
use std::collections::HashSet;
use std::hash::{Hash, Hasher};

use picky_asn1::wrapper::GeneralizedTimeAsn1;
use picky_krb::data_types::{Microseconds, PrincipalName};

#[derive(Debug, Clone, Eq)]
pub struct AuthenticatorCacheRecord {
    pub cname: PrincipalName,
    pub sname: PrincipalName,
    pub ctime: GeneralizedTimeAsn1,
    pub microseconds: Microseconds,
}

// https://doc.rust-lang.org/std/hash/trait.Hash.html#hash-and-eq
// > When implementing both `Hash` and `Eq`, it is important that the following property holds:
// ```
// k1 == k2 -> hash(k1) == hash(k2)
// ```
// The `PrincipalName` implements the `PartialEq` trait but does not implement the `Hash` trait.
// We implement `PartialEq` manually to make sure we follow required properties.
impl PartialEq for AuthenticatorCacheRecord {
    fn eq(&self, other: &Self) -> bool {
        fn compare_principal_names(name_1: &PrincipalName, name_2: &PrincipalName) -> bool {
            if name_1.name_type.0 != name_2.name_type.0 {
                return false;
            }

            let names_1 = &name_1.name_string.0 .0;
            let names_2 = &name_2.name_string.0 .0;

            if names_1.len() != names_2.len() {
                return false;
            }

            for (name_1, name_2) in names_1.iter().zip(names_2.iter()) {
                if name_1.0 != name_2.0 {
                    return false;
                }
            }

            true
        }

        compare_principal_names(&self.cname, &other.cname)
            && compare_principal_names(&self.sname, &other.sname)
            && self.ctime == other.ctime
            && self.microseconds == other.microseconds
    }
}

impl Hash for AuthenticatorCacheRecord {
    fn hash<H: Hasher>(&self, state: &mut H) {
        fn hash_principal_name<H: Hasher>(name: &PrincipalName, state: &mut H) {
            name.name_type.0.hash(state);
            for name_string in &name.name_string.0 .0 {
                name_string.0.hash(state);
            }
        }

        hash_principal_name(&self.cname, state);
        hash_principal_name(&self.sname, state);
        self.ctime.hash(state);
        self.microseconds.hash(state);
    }
}

pub type AuthenticatorsCache = HashSet<AuthenticatorCacheRecord>;


--- File: src/kerberos/server/extractors.rs ---
use oid::ObjectIdentifier;
use picky::oids;
use picky_asn1::wrapper::ExplicitContextTag1;
use picky_krb::constants::gss_api::{ACCEPT_COMPLETE, AP_REQ_TOKEN_ID};
use picky_krb::constants::key_usages::{AP_REQ_AUTHENTICATOR, TICKET_REP};
use picky_krb::constants::types::NT_PRINCIPAL;
use picky_krb::crypto::CipherSuite;
use picky_krb::data_types::{Authenticator, EncTicketPart, PrincipalName};
use picky_krb::gss_api::{
    ApplicationTag0, GssApiNegInit, KrbMessage, MechTypeList, NegTokenInit, NegTokenTarg, NegTokenTarg1,
};
use picky_krb::messages::{ApReq, TgtReq};

use crate::{Error, ErrorKind, Result};

/// Extract TGT request and mech types from the first token returned by the Kerberos client.
#[instrument(ret, level = "trace")]
pub fn decode_initial_neg_init(data: &[u8]) -> Result<(Option<TgtReq>, MechTypeList)> {
    let token: ApplicationTag0<GssApiNegInit> = picky_asn1_der::from_bytes(data)?;
    let NegTokenInit {
        mech_types,
        req_flags: _,
        mech_token,
        mech_list_mic: _,
    } = token.0.neg_token_init.0;

    let mech_types = mech_types
        .0
        .ok_or_else(|| {
            Error::new(
                ErrorKind::InvalidToken,
                "mech_types is missing in GssApiNegInit message",
            )
        })?
        .0;

    let tgt_req = if let Some(mech_token) = mech_token.0 {
        let encoded_tgt_req = mech_token.0 .0;
        let neg_token_init = KrbMessage::<TgtReq>::decode_application_krb_message(&encoded_tgt_req)?;

        let token_oid = &neg_token_init.0.krb5_oid.0;
        let krb5_u2u = oids::krb5_user_to_user();
        if *token_oid != krb5_u2u {
            return Err(Error::new(
                ErrorKind::InvalidToken,
                format!(
                    "invalid oid inside mech_token: expected krb5 u2u ({:?}) but got {:?}",
                    krb5_u2u, token_oid
                ),
            ));
        }

        Some(neg_token_init.0.krb_msg)
    } else {
        None
    };

    Ok((tgt_req, mech_types))
}

/// Decodes incoming SPNEGO message and extracts [ApReq] Kerberos message.
pub fn decode_neg_ap_req(data: &[u8]) -> Result<ApReq> {
    let neg_token_targ: ExplicitContextTag1<NegTokenTarg> = picky_asn1_der::from_bytes(data)?;

    let krb_message = KrbMessage::<ApReq>::decode_application_krb_message(
        &neg_token_targ
            .0
            .response_token
            .0
            .ok_or_else(|| {
                Error::new(
                    ErrorKind::InvalidToken,
                    "response_token is missing in NegTokenTarg message",
                )
            })?
            .0
             .0,
    )?
    .0;

    if krb_message.krb5_token_id != AP_REQ_TOKEN_ID {
        return Err(Error::new(
            ErrorKind::InvalidToken,
            format!(
                "invalid kerberos token id: expected {:?} but got {:?}",
                AP_REQ_TOKEN_ID, krb_message.krb5_token_id
            ),
        ));
    }

    Ok(krb_message.krb_msg)
}

/// Decrypts the [ApReq] ticket and returns decoded encrypted part of the ticket.
pub fn decrypt_ap_req_ticket(key: &[u8], ap_req: &ApReq) -> Result<EncTicketPart> {
    let ticket_enc_part = &ap_req.0.ticket.0 .0.enc_part.0;
    let cipher = CipherSuite::try_from(ticket_enc_part.etype.0 .0.as_slice())?.cipher();

    let encoded_enc_part = cipher.decrypt(key, TICKET_REP, &ticket_enc_part.cipher.0 .0)?;

    Ok(picky_asn1_der::from_bytes(&encoded_enc_part)?)
}

/// Decrypts [ApReq] Authenticator and returns decoded authenticator.
pub fn decrypt_ap_req_authenticator(session_key: &[u8], ap_req: &ApReq) -> Result<Authenticator> {
    let encrypted_authenticator = &ap_req.0.authenticator.0;
    let cipher = CipherSuite::try_from(encrypted_authenticator.etype.0 .0.as_slice())?.cipher();

    let encoded_authenticator =
        cipher.decrypt(session_key, AP_REQ_AUTHENTICATOR, &encrypted_authenticator.cipher.0 .0)?;

    Ok(picky_asn1_der::from_bytes(&encoded_authenticator)?)
}

/// Validated client final [NegTokenTarg1] message and extract its MIC token.
///
/// **Note**: the input client message should be last message in the _authentication_ sequence.
pub fn extract_client_mic_token(data: &[u8]) -> Result<Vec<u8>> {
    let neg_token_targ: NegTokenTarg1 = picky_asn1_der::from_bytes(data)?;
    let NegTokenTarg {
        neg_result,
        supported_mech: _,
        response_token: _,
        mech_list_mic,
    } = neg_token_targ.0;

    let neg_result = neg_result
        .0
        .ok_or_else(|| Error::new(ErrorKind::InvalidToken, "neg_result is missing in NegTokenTarg message"))?
        .0
         .0;
    if neg_result != ACCEPT_COMPLETE {
        return Err(Error::new(
            ErrorKind::InvalidToken,
            "invalid neg result: expected accept_complete",
        ));
    }

    let mic_token = mech_list_mic
        .0
        .ok_or_else(|| {
            Error::new(
                ErrorKind::InvalidToken,
                "mech_list_mic is missing in NegTokenTarg message",
            )
        })?
        .0
         .0;

    Ok(mic_token)
}

/// Selects the preferred Kerberos oid.
///
/// 1.2.840.48018.1.2.2 (MS KRB5 - Microsoft Kerberos 5) is preferred over 1.2.840.113554.1.2.2 (KRB5 - Kerberos 5).
pub fn select_mech_type(mech_list: &MechTypeList) -> Result<ObjectIdentifier> {
    let ms_krb5 = oids::ms_krb5();
    if mech_list.0.iter().any(|mech_type| mech_type.0 == ms_krb5) {
        return Ok(ms_krb5);
    }

    let krb5 = oids::krb5();
    if mech_list.0.iter().any(|mech_type| mech_type.0 == krb5) {
        return Ok(krb5);
    }

    Err(Error::new(
        ErrorKind::InvalidToken,
        "invalid mech type list: Kerberos protocol is not present",
    ))
}

/// Extract username from the [PrincipalName].
pub fn extract_username(cname: &PrincipalName) -> Result<String> {
    let name_type = &cname.name_type.0 .0;
    if name_type == &[NT_PRINCIPAL] {
        cname
            .name_string
            .0
             .0
            .first()
            .map(|name| name.to_string())
            .ok_or_else(|| Error::new(ErrorKind::InvalidToken, "missing cname value in token"))
    } else {
        Err(Error::new(
            ErrorKind::InvalidToken,
            format!("unsupported principal name type: {:?}", name_type),
        ))
    }
}


--- File: src/kerberos/server/generators.rs ---
use oid::ObjectIdentifier;
use picky::oids;
use picky_asn1::wrapper::{
    ExplicitContextTag0, ExplicitContextTag1, ExplicitContextTag2, ExplicitContextTag3, IntegerAsn1,
    ObjectIdentifierAsn1, OctetStringAsn1, Optional,
};
use picky_asn1_der::Asn1RawDer;
use picky_krb::constants::gss_api::{ACCEPT_INCOMPLETE, AP_REP_TOKEN_ID, TGT_REP_TOKEN_ID};
use picky_krb::constants::key_usages::{ACCEPTOR_SIGN, AP_REP_ENC};
use picky_krb::constants::types::{AP_REP_MSG_TYPE, TGT_REP_MSG_TYPE};
use picky_krb::crypto::aes::{checksum_sha_aes, AesSize};
use picky_krb::data_types::{
    EncApRepPart, EncApRepPartInner, EncryptedData, EncryptionKey, KerberosTime, Microseconds, Ticket,
};
use picky_krb::gss_api::{ApplicationTag0, KrbMessage, MechType, MicToken, NegTokenTarg, NegTokenTarg1};
use picky_krb::messages::{ApRep, ApRepInner, TgtRep};

use crate::kerberos::{EncryptionParams, DEFAULT_ENCRYPTION_TYPE};
use crate::{Result, KERBEROS_VERSION};

pub fn generate_neg_token_targ(mech_type: ObjectIdentifier, tgt_rep: Option<TgtRep>) -> Result<NegTokenTarg1> {
    let response_token = tgt_rep
        .map(|tgt_rep| {
            Result::Ok(ExplicitContextTag2::from(OctetStringAsn1::from(
                picky_asn1_der::to_vec(&ApplicationTag0(KrbMessage {
                    krb5_oid: ObjectIdentifierAsn1::from(oids::krb5_user_to_user()),
                    krb5_token_id: TGT_REP_TOKEN_ID,
                    krb_msg: tgt_rep,
                }))?,
            )))
        })
        .transpose()?;
    Ok(NegTokenTarg1::from(NegTokenTarg {
        neg_result: Optional::from(Some(ExplicitContextTag0::from(Asn1RawDer(ACCEPT_INCOMPLETE.to_vec())))),
        supported_mech: Optional::from(Some(ExplicitContextTag1::from(MechType::from(mech_type)))),
        response_token: Optional::from(response_token),
        mech_list_mic: Optional::from(None),
    }))
}

pub fn generate_ap_rep(
    session_key: &[u8],
    ctime: KerberosTime,
    cusec: Microseconds,
    seq_number: Vec<u8>,
    enc_params: &EncryptionParams,
) -> Result<ApRep> {
    let encryption_type = enc_params.encryption_type.as_ref().unwrap_or(&DEFAULT_ENCRYPTION_TYPE);

    let enc_part = EncApRepPart::from(EncApRepPartInner {
        ctime: ExplicitContextTag0::from(ctime),
        cusec: ExplicitContextTag1::from(cusec),
        subkey: Optional::from(enc_params.sub_session_key.as_ref().map(|sub_key| {
            ExplicitContextTag2::from(EncryptionKey {
                key_type: ExplicitContextTag0::from(IntegerAsn1::from(vec![encryption_type.into()])),
                key_value: ExplicitContextTag1::from(OctetStringAsn1::from(sub_key.clone())),
            })
        })),
        seq_number: Optional::from(Some(ExplicitContextTag3::from(IntegerAsn1::from(seq_number)))),
    });

    let cipher = encryption_type.cipher();
    let enc_data = cipher.encrypt(session_key, AP_REP_ENC, &picky_asn1_der::to_vec(&enc_part)?)?;

    Ok(ApRep::from(ApRepInner {
        pvno: ExplicitContextTag0::from(IntegerAsn1::from(vec![KERBEROS_VERSION])),
        msg_type: ExplicitContextTag1::from(IntegerAsn1::from(vec![AP_REP_MSG_TYPE])),
        enc_part: ExplicitContextTag2::from(EncryptedData {
            etype: ExplicitContextTag0::from(IntegerAsn1::from(vec![encryption_type.into()])),
            kvno: Optional::from(None),
            cipher: ExplicitContextTag2::from(OctetStringAsn1::from(enc_data)),
        }),
    }))
}

pub fn generate_final_neg_token_targ(mech_id: ObjectIdentifier, ap_rep: ApRep, mic: Vec<u8>) -> Result<NegTokenTarg1> {
    let krb_blob = ApplicationTag0(KrbMessage {
        krb5_oid: ObjectIdentifierAsn1::from(mech_id),
        krb5_token_id: AP_REP_TOKEN_ID,
        krb_msg: ap_rep,
    });

    Ok(NegTokenTarg1::from(NegTokenTarg {
        neg_result: Optional::from(Some(ExplicitContextTag0::from(Asn1RawDer(ACCEPT_INCOMPLETE.to_vec())))),
        supported_mech: Optional::from(None),
        response_token: Optional::from(Some(ExplicitContextTag2::from(OctetStringAsn1::from(
            picky_asn1_der::to_vec(&krb_blob)?,
        )))),
        mech_list_mic: Optional::from(Some(ExplicitContextTag3::from(OctetStringAsn1::from(mic)))),
    }))
}

pub fn generate_mic_token(seq_number: u64, mut payload: Vec<u8>, session_key: &[u8]) -> Result<Vec<u8>> {
    let mut mic_token = MicToken::with_acceptor_flags().with_seq_number(seq_number);

    payload.extend_from_slice(&mic_token.header());

    mic_token.set_checksum(checksum_sha_aes(
        session_key,
        ACCEPTOR_SIGN,
        &payload,
        &AesSize::Aes256,
    )?);

    let mut mic_token_raw = Vec::new();
    mic_token.encode(&mut mic_token_raw)?;

    Ok(mic_token_raw)
}

pub fn generate_tgt_rep(ticket: Ticket) -> TgtRep {
    TgtRep {
        pvno: ExplicitContextTag0::from(IntegerAsn1::from(vec![KERBEROS_VERSION])),
        msg_type: ExplicitContextTag1::from(IntegerAsn1::from(vec![TGT_REP_MSG_TYPE])),
        ticket: ExplicitContextTag2::from(ticket),
    }
}


--- File: src/kerberos/server/mod.rs ---
mod as_exchange;
mod cache;
mod extractors;
mod generators;

use std::io::Write;
use std::time::Duration;

use cache::AuthenticatorCacheRecord;
use extractors::{extract_client_mic_token, extract_username, select_mech_type};
use generators::{generate_mic_token, generate_tgt_rep};
use picky::oids;
use picky_asn1::restricted_string::IA5String;
use picky_asn1::wrapper::{Asn1SequenceOf, ExplicitContextTag0, ExplicitContextTag1, IntegerAsn1};
use picky_krb::constants::key_usages::INITIATOR_SIGN;
use picky_krb::constants::types::NT_SRV_INST;
use picky_krb::data_types::{AuthenticatorInner, KerberosStringAsn1, PrincipalName};
use picky_krb::gss_api::MechTypeList;
use rand::rngs::OsRng;
use rand::RngCore;
use time::OffsetDateTime;

use self::as_exchange::request_tgt;
use self::cache::AuthenticatorsCache;
use self::extractors::{
    decode_initial_neg_init, decode_neg_ap_req, decrypt_ap_req_authenticator, decrypt_ap_req_ticket,
};
use self::generators::{generate_ap_rep, generate_final_neg_token_targ, generate_neg_token_targ};
use super::utils::validate_mic_token;
use crate::builders::FilledAcceptSecurityContext;
use crate::generator::YieldPointLocal;
use crate::kerberos::flags::ApOptions;
use crate::kerberos::DEFAULT_ENCRYPTION_TYPE;
use crate::{
    AcceptSecurityContextResult, BufferType, CredentialsBuffers, Error, ErrorKind, Kerberos, KerberosState, Result,
    SecurityBuffer, SecurityStatus, ServerRequestFlags, ServerResponseFlags, SspiImpl, Username,
};

/// Indicated that the MIC token `SentByAcceptor` flag must not be enabled in the incoming MIC token.
const SENT_BY_INITIATOR: u8 = 0;

/// Additional properties that are needed only for server-side Kerberos.
#[derive(Debug, Clone)]
pub struct ServerProperties {
    /// Supported mech types sent by the client in the first incoming message.
    /// We user them for checksum calculation during MIC token generation.
    pub mech_types: MechTypeList,
    /// Maximum allowed time difference between client and server clocks.
    /// It is recommended to set this value not greater then a few minutes.
    pub max_time_skew: Duration,
    /// Key that is used for TGS tickets decryption.
    /// It should be provided by the user during regular Kerberos auth. Or
    /// it will be established during AS exchange in the case of Kerberos U2U auth.
    pub ticket_decryption_key: Option<Vec<u8>>,
    /// Name of the Kerberos service.
    pub service_name: PrincipalName,
    /// User credentials on whose behalf the TGT ticket will be requested.
    pub user: Option<CredentialsBuffers>,
    /// Username of the authenticated client.
    ///
    /// This field should be set by the Kerberos implementation after successful log on.
    pub client: Option<Username>,
    /// Authenticators cache.
    ///
    /// [Receipt of KRB_AP_REQ Message](https://www.rfc-editor.org/rfc/rfc4120#section-3.2.3):
    ///
    /// > The server MUST utilize a replay cache to remember any authenticator presented within the allowable clock skew.
    /// > The replay cache will store at least the server name, along with the client name, time,
    /// > and microsecond fields from the recently-seen authenticators, and if a matching tuple is found,
    /// > the error is returned.
    pub authenticators_cache: AuthenticatorsCache,
}

impl ServerProperties {
    /// Creates a new instance of [ServerProperties].
    pub fn new(
        sname: &[&str],
        user: Option<CredentialsBuffers>,
        max_time_skew: Duration,
        ticket_decryption_key: Option<Vec<u8>>,
    ) -> Result<Self> {
        let service_names = sname
            .iter()
            .map(|sname| Ok(KerberosStringAsn1::from(IA5String::from_string((*sname).to_owned())?)))
            .collect::<Result<Vec<_>>>()?;

        Ok(Self {
            mech_types: MechTypeList::from(Vec::new()),
            max_time_skew,
            ticket_decryption_key,
            service_name: PrincipalName {
                name_type: ExplicitContextTag0::from(IntegerAsn1::from(vec![NT_SRV_INST])),
                name_string: ExplicitContextTag1::from(Asn1SequenceOf::from(service_names)),
            },
            user,
            client: None,
            authenticators_cache: AuthenticatorsCache::new(),
        })
    }
}

/// Performs one authentication step.
///
/// The user should call this function until it returns `SecurityStatus::Ok`.
pub async fn accept_security_context(
    server: &mut Kerberos,
    yield_point: &mut YieldPointLocal,
    builder: FilledAcceptSecurityContext<'_, <Kerberos as SspiImpl>::CredentialsHandle>,
) -> Result<AcceptSecurityContextResult> {
    let input = builder
        .input
        .as_ref()
        .ok_or_else(|| crate::Error::new(ErrorKind::InvalidToken, "input buffers must be specified"))?;
    let input_token = SecurityBuffer::find_buffer(input, BufferType::Token)?;

    let status = match server.state {
        KerberosState::Negotiate => {
            let (tgt_req, mech_types) = decode_initial_neg_init(&input_token.buffer)?;
            let mech_type = select_mech_type(&mech_types)?;

            let server_props = server.server.as_mut().ok_or_else(|| {
                Error::new(
                    ErrorKind::InvalidHandle,
                    "Kerberos server properties are not initialized",
                )
            })?;
            server_props.mech_types = mech_types;

            let tgt_rep = if let Some(tgt_req) = tgt_req {
                // If user sent us TgtReq than they want Kerberos User-to-User auth.
                // At this point, we need to request TGT token in KDC and send it back to the user.

                if !builder
                    .context_requirements
                    .contains(ServerRequestFlags::USE_SESSION_KEY)
                {
                    warn!("KRB5 U2U has been negotiated (requested by the client) but the USE_SESSION_KEY flag is not set.");
                }

                server.krb5_user_to_user = true;

                let credentials = builder
                    .credentials_handle
                    .and_then(|credentials_handle| (*credentials_handle).clone())
                    .or_else(|| server_props.user.clone());
                let credentials = credentials.as_ref().ok_or_else(|| {
                    Error::new(
                        ErrorKind::WrongCredentialHandle,
                        "failed to request TGT ticket: no credentials provided",
                    )
                })?;

                Some(generate_tgt_rep(
                    request_tgt(server, credentials, &tgt_req, yield_point).await?,
                ))
            } else {
                None
            };

            let encoded_neg_token_targ = picky_asn1_der::to_vec(&generate_neg_token_targ(mech_type, tgt_rep)?)?;

            let output_token = SecurityBuffer::find_buffer_mut(builder.output, BufferType::Token)?;
            output_token.buffer.write_all(&encoded_neg_token_targ)?;

            server.state = KerberosState::Preauthentication;

            SecurityStatus::ContinueNeeded
        }
        KerberosState::Preauthentication => {
            let ap_req = decode_neg_ap_req(&input_token.buffer)?;

            let server_data = server.server.as_ref().ok_or_else(|| {
                Error::new(
                    ErrorKind::InvalidHandle,
                    "Kerberos server properties are not initialized",
                )
            })?;

            let ticket_service_name = &ap_req.0.ticket.0 .0.sname.0;
            if *ticket_service_name != server_data.service_name {
                return Err(Error::new(
                    ErrorKind::InvalidToken,
                    format!(
                        "invalid ticket service name ({:?}): Kerberos server is configured for {:?}",
                        ticket_service_name, server_data.service_name
                    ),
                ));
            }

            let ticket_decryption_key = server_data
                .ticket_decryption_key
                .as_ref()
                .ok_or_else(|| Error::new(ErrorKind::InternalError, "ticket decryption key is not set"))?;

            let ticket_enc_part = decrypt_ap_req_ticket(ticket_decryption_key, &ap_req)?;
            let session_key = ticket_enc_part.0.key.0.key_value.0 .0.clone();

            let AuthenticatorInner {
                authenticator_vno: _,
                crealm,
                cname,
                cksum: _,
                cusec,
                ctime,
                subkey: _,
                seq_number: _,
                authorization_data: _,
            } = decrypt_ap_req_authenticator(&session_key, &ap_req)?.0;

            // [3.2.3.  Receipt of KRB_AP_REQ Message](https://www.rfc-editor.org/rfc/rfc4120#section-3.2.3)
            // The name and realm of the client from the ticket are compared against the same fields in the authenticator.
            if ticket_enc_part.0.crealm.0 != crealm.0 || ticket_enc_part.0.cname != cname.0 {
                return Err(Error::new(
                    ErrorKind::InvalidToken,
                    "the name and realm of the client in ticket and authenticator do not match",
                ));
            }

            let now = OffsetDateTime::now_utc();
            let client_time = OffsetDateTime::try_from(ctime.0 .0.clone())
                .map_err(|err| Error::new(ErrorKind::InvalidToken, format!("clint time is not valid: {:?}", err)))?;
            let max_time_skew = server_data.max_time_skew;

            if (now - client_time).abs() > max_time_skew {
                return Err(Error::new(
                    ErrorKind::TimeSkew,
                    "invalid authenticator ctime: time skew is too big",
                ));
            }

            let ticket_start_time = ticket_enc_part
                .0
                .starttime
                .0
                .map(|start_time| start_time.0)
                // [5.3.  Tickets](https://www.rfc-editor.org/rfc/rfc4120#section-5.3)
                // If the starttime field is absent from the ticket, then the authtime field SHOULD be used in its place to determine
                // the life of the ticket.
                .unwrap_or_else(|| ticket_enc_part.0.auth_time.0)
                .0;
            let ticket_start_time = OffsetDateTime::try_from(ticket_start_time).map_err(|err| {
                Error::new(
                    ErrorKind::InvalidToken,
                    format!("ticket end time is not valid: {:?}", err),
                )
            })?;
            if ticket_start_time > now + max_time_skew {
                return Err(Error::new(
                    ErrorKind::InvalidToken,
                    "ticket not yet valid: ticket start time is greater than current time + max time skew",
                ));
            }

            let ticket_end_time = OffsetDateTime::try_from(ticket_enc_part.0.endtime.0 .0).map_err(|err| {
                Error::new(
                    ErrorKind::InvalidToken,
                    format!("ticket end time is not valid: {:?}", err),
                )
            })?;
            if now > ticket_end_time + max_time_skew {
                return Err(Error::new(
                    ErrorKind::InvalidToken,
                    "ticket is expired: current time is greater than ticket end time + max time skew",
                ));
            }

            let server_data = server.server.as_mut().ok_or_else(|| {
                Error::new(
                    ErrorKind::InvalidHandle,
                    "Kerberos server properties are not initialized",
                )
            })?;

            let cache_record = AuthenticatorCacheRecord {
                cname: cname.0.clone(),
                sname: ticket_service_name.clone(),
                ctime: ctime.0.clone(),
                microseconds: cusec.0.clone(),
            };
            if !server_data.authenticators_cache.contains(&cache_record) {
                server_data.authenticators_cache.insert(cache_record);
            } else {
                return Err(Error::new(
                    ErrorKind::InvalidToken,
                    "ApReq Authenticator replay detected",
                ));
            }

            debug!("ApReq Ticket and Authenticator are valid!");

            server_data.client = Some(Username::new_upn(
                &extract_username(&cname.0)?,
                &crealm.0 .0.to_string().to_ascii_lowercase(),
            )?);

            let ap_options_bytes = ap_req.0.ap_options.0 .0.as_bytes();
            // [5.5.1.  KRB_AP_REQ Definition](https://www.rfc-editor.org/rfc/rfc4120#section-5.5.1)
            // The `ap-options` field has 32 bits or 4 bytes long. But it is encoded as BitStringAsn1, so the first byte
            // indicates the number of bits used. Thus, the overall number of expected bytes is 1 + 4 = 5.
            if ap_options_bytes.len() != 1 + 4 {
                return Err(Error::new(
                    ErrorKind::InvalidToken,
                    format!(
                        "invalid ApReq ap-options: invalid data length: expected 5 bytes but got {}",
                        ap_options_bytes.len()
                    ),
                ));
            }
            let ap_options =
                u32::from_be_bytes(ap_options_bytes[1..].try_into().map_err(|err| {
                    Error::new(ErrorKind::InvalidToken, format!("invalid ApReq ap-options: {:?}", err))
                })?);
            let ap_options = ApOptions::from_bits(ap_options)
                .ok_or_else(|| Error::new(ErrorKind::InvalidToken, "invalid ApReq ap-options"))?;

            // [3.2.4.  Generation of a KRB_AP_REP Message](https://www.rfc-editor.org/rfc/rfc4120#section-3.2.3)
            // ...the server need not explicitly reply to the KRB_AP_REQ. However, if mutual authentication is being performed,
            // the KRB_AP_REQ message will have MUTUAL-REQUIRED set in its ap-options field, and a KRB_AP_REP message
            // is required in response.
            if ap_options.contains(ApOptions::MUTUAL_REQUIRED) {
                let key_size = server
                    .encryption_params
                    .encryption_type
                    .as_ref()
                    .unwrap_or(&DEFAULT_ENCRYPTION_TYPE)
                    .cipher()
                    .key_size();
                let mut sub_session_key = vec![0; key_size];
                OsRng.fill_bytes(&mut sub_session_key);
                server.encryption_params.sub_session_key = Some(sub_session_key);

                // [3.2.4.  Generation of a KRB_AP_REP Message](https://www.rfc-editor.org/rfc/rfc4120#section-3.2.3)
                // A subkey MAY be included if the server desires to negotiate a different subkey.
                // The KRB_AP_REP message is encrypted in the session key extracted from the ticket.
                let ap_rep = generate_ap_rep(
                    &session_key,
                    ctime.0,
                    cusec.0,
                    (server.seq_number + 1).to_be_bytes().to_vec(),
                    &server.encryption_params,
                )?;

                let mic_payload = picky_asn1_der::to_vec(
                    &server
                        .server
                        .as_ref()
                        .ok_or_else(|| {
                            Error::new(
                                ErrorKind::InvalidHandle,
                                "Kerberos server properties are not initialized",
                            )
                        })?
                        .mech_types,
                )?;
                let mic = generate_mic_token(
                    u64::from(server.next_seq_number()),
                    mic_payload,
                    server
                        .encryption_params
                        .sub_session_key
                        .as_ref()
                        .expect("sub-session key should present"),
                )?;

                let mech_id = if server.krb5_user_to_user {
                    oids::krb5_user_to_user()
                } else {
                    oids::krb5()
                };

                let encoded_neg_ap_rep = picky_asn1_der::to_vec(&generate_final_neg_token_targ(mech_id, ap_rep, mic)?)?;

                let output_token = SecurityBuffer::find_buffer_mut(builder.output, BufferType::Token)?;
                output_token.buffer.write_all(&encoded_neg_ap_rep)?;
            }

            server.encryption_params.session_key = Some(session_key);
            server.state = KerberosState::ApExchange;

            SecurityStatus::ContinueNeeded
        }
        KerberosState::ApExchange => {
            let server_props = server.server.as_mut().ok_or_else(|| {
                Error::new(
                    ErrorKind::InvalidHandle,
                    "Kerberos server properties are not initialized",
                )
            })?;

            let client_mic = extract_client_mic_token(&input_token.buffer)?;
            validate_mic_token::<SENT_BY_INITIATOR>(
                &client_mic,
                INITIATOR_SIGN,
                &server.encryption_params,
                &server_props.mech_types,
            )?;

            server.state = KerberosState::PubKeyAuth;

            SecurityStatus::Ok
        }
        KerberosState::PubKeyAuth | KerberosState::Credentials | KerberosState::Final => {
            return Err(Error::new(
                ErrorKind::OutOfSequence,
                format!("got wrong Kerberos state: {:?}", server.state),
            ))
        }
    };

    Ok(AcceptSecurityContextResult {
        status,
        flags: ServerResponseFlags::empty(),
        expiry: None,
    })
}


--- File: src/kerberos/tests.rs ---
use picky_krb::constants::key_usages::{ACCEPTOR_SEAL, INITIATOR_SEAL};
use picky_krb::crypto::CipherSuite;

use crate::kerberos::{test_data, EncryptionParams, KerberosConfig, KerberosState};
use crate::{EncryptionFlags, Kerberos, SecurityBufferFlags, SecurityBufferRef, Sspi};

#[test]
fn stream_buffer_decryption() {
    // https://learn.microsoft.com/en-us/windows/win32/secauthn/sspi-kerberos-interoperability-with-gssapi

    let mut kerberos_server = test_data::fake_server();
    let mut kerberos_client = test_data::fake_client();

    let plain_message = b"some plain message";

    let mut token = [0; 1024];
    let mut data = plain_message.to_vec();
    let mut message = [
        SecurityBufferRef::token_buf(token.as_mut_slice()),
        SecurityBufferRef::data_buf(data.as_mut_slice()),
    ];

    kerberos_server
        .encrypt_message(EncryptionFlags::empty(), &mut message, 0)
        .unwrap();

    let mut buffer = message[0].data().to_vec();
    buffer.extend_from_slice(message[1].data());

    let mut message = [
        SecurityBufferRef::stream_buf(&mut buffer),
        SecurityBufferRef::data_buf(&mut []),
    ];

    kerberos_client.decrypt_message(&mut message, 0).unwrap();

    assert_eq!(message[1].data(), plain_message);
}

#[test]
fn secbuffer_readonly_with_checksum() {
    // All values in this test (session keys, sequence number, encrypted and decrypted data) were extracted
    // from the original Windows Kerberos implementation calls.
    // We keep this test to guarantee full compatibility with the original Kerberos.

    let session_key = [
        114, 67, 55, 26, 76, 210, 61, 0, 164, 44, 11, 133, 108, 220, 234, 145, 61, 144, 123, 45, 54, 175, 164, 168, 99,
        18, 99, 240, 242, 157, 95, 134,
    ];
    let sub_session_key = [
        91, 11, 188, 227, 10, 91, 180, 246, 64, 129, 251, 200, 118, 82, 109, 65, 241, 177, 109, 32, 124, 39, 127, 171,
        222, 132, 199, 199, 126, 110, 3, 166,
    ];

    let mut kerberos_server = Kerberos {
        state: KerberosState::Final,
        config: KerberosConfig {
            kdc_url: None,
            client_computer_name: None,
        },
        auth_identity: None,
        encryption_params: EncryptionParams {
            encryption_type: Some(CipherSuite::Aes256CtsHmacSha196),
            session_key: Some(session_key.to_vec()),
            sub_session_key: Some(sub_session_key.to_vec()),
            sspi_encrypt_key_usage: ACCEPTOR_SEAL,
            sspi_decrypt_key_usage: INITIATOR_SEAL,
            ec: 16,
        },
        seq_number: 681238048,
        realm: None,
        kdc_url: None,
        channel_bindings: None,
        dh_parameters: None,
        krb5_user_to_user: false,
        server: Some(Box::new(test_data::fake_server_properties())),
    };

    // RPC header
    let header = [
        5, 0, 0, 3, 16, 0, 0, 0, 60, 1, 76, 0, 1, 0, 0, 0, 208, 0, 0, 0, 0, 0, 0, 0,
    ];
    // RPC security trailer header
    let trailer = [16, 6, 8, 0, 0, 0, 0, 0];
    // Encrypted data in RPC Request
    let enc_data = [
        41, 85, 192, 239, 104, 188, 180, 100, 229, 73, 83, 199, 77, 83, 79, 17, 163, 206, 241, 29, 90, 28, 89, 203, 83,
        176, 160, 252, 197, 221, 76, 113, 185, 141, 16, 200, 149, 55, 32, 96, 29, 49, 57, 124, 181, 147, 110, 198, 125,
        116, 150, 47, 35, 224, 117, 25, 10, 229, 201, 222, 153, 101, 131, 93, 204, 32, 9, 145, 186, 45, 224, 160, 131,
        23, 236, 111, 88, 48, 54, 4, 118, 114, 129, 119, 130, 164, 178, 4, 110, 74, 37, 1, 215, 177, 16, 204, 238, 83,
        255, 40, 240, 32, 209, 213, 90, 19, 126, 58, 34, 33, 72, 15, 206, 96, 67, 15, 169, 248, 176, 9, 173, 196, 159,
        239, 250, 120, 206, 52, 53, 229, 230, 66, 64, 109, 100, 21, 77, 193, 3, 40, 183, 209, 177, 152, 165, 171, 108,
        151, 112, 134, 53, 165, 128, 145, 147, 167, 5, 72, 35, 101, 42, 183, 67, 101, 48, 255, 84, 208, 112, 199, 154,
        62, 185, 87, 204, 228, 45, 30, 184, 47, 129, 145, 245, 168, 118, 174, 48, 98, 174, 167, 208, 0, 113, 246, 219,
        29, 192, 171, 97, 117, 115, 120, 115, 45, 44, 113, 62, 39,
    ];
    // Unencrypted data in RPC Request
    let plaintext = [
        108, 0, 0, 0, 0, 0, 0, 0, 108, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 128, 84, 0, 0, 0, 96, 0, 0, 0, 0, 0, 0, 0, 20, 0,
        0, 0, 2, 0, 64, 0, 2, 0, 0, 0, 0, 0, 36, 0, 3, 0, 0, 0, 1, 5, 0, 0, 0, 0, 0, 5, 21, 0, 0, 0, 223, 243, 137, 88,
        86, 131, 83, 53, 105, 218, 109, 33, 80, 4, 0, 0, 0, 0, 20, 0, 2, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
        1, 1, 0, 0, 0, 0, 0, 5, 18, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 5, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 138, 227, 19, 113, 2, 244, 54, 113, 2, 64, 40, 0,
        96, 89, 120, 185, 79, 82, 223, 17, 139, 109, 131, 220, 222, 215, 32, 133, 1, 0, 0, 0, 51, 5, 113, 113, 186,
        190, 55, 73, 131, 25, 181, 219, 239, 156, 204, 54, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    // RPC Request security trailer data. Basically, it's a GSS API Wrap token
    let security_trailer_data = [
        5, 4, 6, 255, 0, 16, 0, 28, 0, 0, 0, 0, 40, 154, 222, 33, 170, 177, 218, 93, 176, 5, 210, 44, 38, 242, 179,
        168, 249, 202, 242, 199, 63, 162, 33, 40, 106, 186, 187, 28, 11, 229, 207, 219, 66, 86, 243, 16, 158, 100, 133,
        159, 87, 153, 196, 14, 251, 169, 164, 12, 18, 85, 182, 56, 72, 30, 137, 238, 50, 122, 73, 95, 109, 194, 60,
        120,
    ];

    let mut header_data = header.to_vec();
    let mut encrypted_data = enc_data.to_vec();
    let mut trailer_data = trailer.to_vec();
    let mut token_data = security_trailer_data.to_vec();
    let mut message = vec![
        SecurityBufferRef::data_buf(&mut header_data).with_flags(SecurityBufferFlags::SECBUFFER_READONLY_WITH_CHECKSUM),
        SecurityBufferRef::data_buf(&mut encrypted_data),
        SecurityBufferRef::data_buf(&mut trailer_data)
            .with_flags(SecurityBufferFlags::SECBUFFER_READONLY_WITH_CHECKSUM),
        SecurityBufferRef::token_buf(&mut token_data),
    ];

    kerberos_server.decrypt_message(&mut message, 0).unwrap();

    assert_eq!(header[..], message[0].data()[..]);
    assert_eq!(plaintext[..], message[1].data()[..]);
    assert_eq!(trailer[..], message[2].data()[..]);
}

#[test]
fn rpc_request_encryption() {
    let mut kerberos_server = test_data::fake_server();
    let mut kerberos_client = test_data::fake_client();

    // RPC header
    let header = [
        5, 0, 0, 3, 16, 0, 0, 0, 60, 1, 76, 0, 1, 0, 0, 0, 208, 0, 0, 0, 0, 0, 0, 0,
    ];
    // Unencrypted data in RPC Request
    let plaintext = [
        108, 0, 0, 0, 0, 0, 0, 0, 108, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 128, 84, 0, 0, 0, 96, 0, 0, 0, 0, 0, 0, 0, 20, 0,
        0, 0, 2, 0, 64, 0, 2, 0, 0, 0, 0, 0, 36, 0, 3, 0, 0, 0, 1, 5, 0, 0, 0, 0, 0, 5, 21, 0, 0, 0, 223, 243, 137, 88,
        86, 131, 83, 53, 105, 218, 109, 33, 80, 4, 0, 0, 0, 0, 20, 0, 2, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
        1, 1, 0, 0, 0, 0, 0, 5, 18, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 5, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 138, 227, 19, 113, 2, 244, 54, 113, 2, 64, 40, 0,
        96, 89, 120, 185, 79, 82, 223, 17, 139, 109, 131, 220, 222, 215, 32, 133, 1, 0, 0, 0, 51, 5, 113, 113, 186,
        190, 55, 73, 131, 25, 181, 219, 239, 156, 204, 54, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    // RPC security trailer header
    let trailer = [16, 6, 8, 0, 0, 0, 0, 0];

    let mut header_data = header.to_vec();
    let mut data = plaintext.to_vec();
    let mut trailer_data = trailer.to_vec();
    let mut token_data = vec![0; 76];
    let mut message = vec![
        SecurityBufferRef::data_buf(&mut header_data).with_flags(SecurityBufferFlags::SECBUFFER_READONLY_WITH_CHECKSUM),
        SecurityBufferRef::data_buf(&mut data),
        SecurityBufferRef::data_buf(&mut trailer_data)
            .with_flags(SecurityBufferFlags::SECBUFFER_READONLY_WITH_CHECKSUM),
        SecurityBufferRef::token_buf(&mut token_data),
    ];

    kerberos_client
        .encrypt_message(EncryptionFlags::empty(), &mut message, 0)
        .unwrap();

    assert_eq!(header[..], message[0].data()[..]);
    assert_eq!(trailer[..], message[2].data()[..]);

    kerberos_server.decrypt_message(&mut message, 0).unwrap();

    assert_eq!(header[..], message[0].data()[..]);
    assert_eq!(message[1].data(), plaintext);
    assert_eq!(trailer[..], message[2].data()[..]);
}


--- File: src/kerberos/utils.rs ---
use std::io::Write;

use picky_krb::constants::key_usages::INITIATOR_SIGN;
use picky_krb::crypto::aes::{checksum_sha_aes, AesSize};
use picky_krb::gss_api::{MechTypeList, MicToken};
use serde::Serialize;

use crate::kerberos::encryption_params::EncryptionParams;
use crate::{Error, ErrorKind, Result};

pub fn serialize_message<T: ?Sized + Serialize>(v: &T) -> Result<Vec<u8>> {
    let mut data = Vec::new();
    // 4 bytes: length of the message
    data.write_all(&[0, 0, 0, 0])?;

    picky_asn1_der::to_writer(v, &mut data)?;

    let len = data.len() as u32 - 4;
    data[0..4].copy_from_slice(&len.to_be_bytes());

    Ok(data)
}

pub fn validate_mic_token<const IS_SENT_BY_ACCEPTOR: u8>(
    raw_token: &[u8],
    key_usage: i32,
    params: &EncryptionParams,
    mech_types: &MechTypeList,
) -> Result<()> {
    let token = MicToken::decode(raw_token)?;
    let token_flags = token.flags;

    // [Flags Field](https://datatracker.ietf.org/doc/html/rfc4121#section-4.2.2):
    //
    // The meanings of bits in this field (the least significant bit is bit
    // 0) are as follows:
    //        Bit    Name             Description
    //       --------------------------------------------------------------
    //        0   SentByAcceptor   When set, this flag indicates the sender
    //                             is the context acceptor.  When not set,
    //                             it indicates the sender is the context
    //                             initiator.
    if token_flags & 0b01 != IS_SENT_BY_ACCEPTOR {
        return Err(Error::new(
            ErrorKind::InvalidToken,
            "invalid MIC token SentByAcceptor flag",
        ));
    }
    //        1   Sealed           When set in Wrap tokens, this flag
    //                             indicates confidentiality is provided
    //                             for.  It SHALL NOT be set in MIC tokens.
    if token_flags & 0b10 == 0b10 {
        return Err(Error::new(
            ErrorKind::InvalidToken,
            "the Sealed flag has not to be set in the MIC token",
        ));
    }

    let mut payload = picky_asn1_der::to_vec(mech_types)?;
    payload.extend_from_slice(&token.header());

    // The sub-session key is always preferred over the session key.
    let key = if let Some(key) = params.sub_session_key.as_ref() {
        key
    } else if let Some(key) = params.session_key.as_ref() {
        key
    } else {
        return Err(Error::new(ErrorKind::DecryptFailure, "unable to obtain decryption key"));
    };

    let checksum = checksum_sha_aes(key, key_usage, &payload, &params.aes_size().unwrap_or(AesSize::Aes256))?;

    if checksum != token.checksum {
        return Err(Error::new(ErrorKind::MessageAltered, "bad checksum of the mic token"));
    }

    Ok(())
}

pub fn generate_initiator_raw(mut payload: Vec<u8>, seq_number: u64, session_key: &[u8]) -> Result<Vec<u8>> {
    let mut mic_token = MicToken::with_initiator_flags().with_seq_number(seq_number);

    payload.extend_from_slice(&mic_token.header());

    mic_token.set_checksum(checksum_sha_aes(
        session_key,
        INITIATOR_SIGN,
        &payload,
        &AesSize::Aes256,
    )?);

    let mut mic_token_raw = Vec::new();
    mic_token.encode(&mut mic_token_raw)?;

    Ok(mic_token_raw)
}

pub fn unwrap_hostname(hostname: Option<&str>) -> Result<String> {
    if let Some(hostname) = hostname {
        Ok(hostname.into())
    } else {
        Err(Error::new(ErrorKind::InvalidParameter, "the hostname is not provided"))
    }
}


--- File: src/krb.rs ---
#![allow(dead_code)]

use std::fs::File;
use std::io::{BufRead, BufReader};
use std::path::Path;

fn can_skip_line(line: &str) -> bool {
    if let Some(first_char) = line.chars().next() {
        match first_char {
            '#' => true, // comment line
            ';' => true, // comment line
            _ => false,
        }
    } else {
        true // empty line
    }
}

fn is_section_line(line: &str) -> bool {
    if line.trim().is_empty() {
        return false;
    }

    if line.starts_with('[') && line.ends_with(']') {
        return true;
    }

    false
}

fn get_section_name(line: &str) -> Option<String> {
    if !line.trim().is_empty() && line.starts_with('[') && line.ends_with(']') {
        Some(line[1..line.len() - 1].to_string())
    } else {
        None
    }
}

fn try_read_line(reader: &mut impl BufRead, line: &mut String) -> bool {
    line.clear();
    if let Ok(size) = reader.read_line(line) {
        line.truncate(line.trim_end().len());
        size != 0
    } else {
        false
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Krb5Conf {
    pub values: Vec<(String, String)>,
    path: Vec<String>,
}

impl Krb5Conf {
    fn new() -> Self {
        Self {
            values: Vec::new(),
            path: Vec::new(),
        }
    }

    pub fn new_from_file(filename: &Path) -> Option<Self> {
        let file = File::open(filename).ok()?;
        let mut reader = BufReader::new(file);
        let mut config = Krb5Conf::new();
        config.parse_from_reader(&mut reader);
        Some(config)
    }

    pub fn new_from_data(data: &str) -> Option<Self> {
        let mut reader = BufReader::new(data.as_bytes());
        let mut config = Krb5Conf::new();
        config.parse_from_reader(&mut reader);
        Some(config)
    }

    pub fn get_value(&self, path: Vec<&str>) -> Option<String> {
        let path = path.join("|");
        for (key, val) in self.values.iter() {
            if key.eq_ignore_ascii_case(&path) {
                return Some(val.clone());
            }
        }
        None
    }

    pub fn get_values_in_section(&self, path: &[&str]) -> Option<Vec<(&str, &str)>> {
        let mut values = Vec::new();

        let path = path.join("|").to_ascii_lowercase();
        for (key, val) in self.values.iter() {
            if key.to_ascii_lowercase().contains(&path) {
                values.push((&key[path.len() + 1..], val.as_str()));
            }
        }

        if values.is_empty() {
            None
        } else {
            Some(values)
        }
    }

    fn enter_section(&mut self, name: &str) {
        self.path = vec![name.to_owned()];
    }

    fn enter_group(&mut self, name: &str) {
        self.path.truncate(1);
        self.path.push(name.to_owned());
    }

    fn current_path(&mut self, name: Option<String>) -> String {
        let mut current_path = self.path.clone();
        if let Some(name) = name {
            current_path.push(name);
        }
        current_path.join("|")
    }

    fn parse_from_reader(&mut self, reader: &mut impl BufRead) {
        let mut line = String::new();
        while try_read_line(reader, &mut line) {
            if can_skip_line(&line) {
                continue;
            }

            while is_section_line(&line) {
                self.read_section(reader, &mut line);
            }
        }
    }

    fn add_value(&mut self, key: &str, val: &str) {
        let path = self.current_path(Some(key.to_string()));
        self.values.push((path, val.to_owned()));
    }

    fn read_values(&mut self, reader: &mut impl BufRead, line: &mut String) {
        if let Some((lhs, _)) = line.split_once('=') {
            self.enter_group(lhs.trim());

            while try_read_line(reader, line) {
                if can_skip_line(line) {
                    continue;
                }

                if line.ends_with('}') {
                    break;
                }

                self.read_value(reader, line);
            }
        }
    }

    fn read_value(&mut self, reader: &mut impl BufRead, line: &mut String) {
        if line.contains('{') {
            self.read_values(reader, line);
        } else if let Some(section_name) = get_section_name(line) {
            self.enter_section(section_name.as_str());
        } else if let Some((lhs, rhs)) = line.split_once('=') {
            self.add_value(lhs.trim(), rhs.trim());
        }
    }

    fn read_section(&mut self, reader: &mut impl BufRead, line: &mut String) {
        let name = get_section_name(line).unwrap();
        self.enter_section(&name);

        while try_read_line(reader, line) {
            if can_skip_line(line) {
                continue;
            }

            if line.starts_with('[') {
                break;
            }

            self.read_value(reader, line);
        }
    }
}

#[cfg(test)]
mod tests {
    use super::Krb5Conf;
    #[test]
    fn test_parse_krb5_conf() {
        let krb5_conf_data = r#"
[libdefaults]
	default_realm = AD.IT-HELP.NINJA
	udp_preference_limit = 1
	kdc_timesync = 1
	ccache_type = 4
	forwardable = true
	proxiable = true
	fcc-mit-ticketflags = true

[realms]
	AD.IT-HELP.NINJA = {
		kdc = IT-HELP-DC.ad.it-help.ninja:88
		admin_server = IT-HELP-DC.ad.it-help.ninja:88
		default_domain = ad.it-help.ninja
	}
"#;
        let krb5_conf = Krb5Conf::new_from_data(krb5_conf_data).unwrap();

        assert_eq!(
            krb5_conf.get_value(vec!["libdefaults", "default_realm"]),
            Some("AD.IT-HELP.NINJA".to_string())
        );
        assert_eq!(
            krb5_conf.get_value(vec!["realms", "ad.it-help.ninja", "kdc"]),
            Some("IT-HELP-DC.ad.it-help.ninja:88".to_string())
        );
        assert_eq!(
            krb5_conf.get_value(vec!["realms", "ad.it-help.ninja", "admin_server"]),
            Some("IT-HELP-DC.ad.it-help.ninja:88".to_string())
        );
        assert_eq!(
            krb5_conf.get_value(vec!["realms", "ad.it-help.ninja", "default_domain"]),
            Some("ad.it-help.ninja".to_string())
        );
    }
}


--- File: src/lib.rs ---
//! sspi-rs is a Rust implementation of [Security Support Provider Interface (SSPI)](https://docs.microsoft.com/en-us/windows/win32/rpc/security-support-provider-interface-sspi-).
//! It ships with platform-independent implementations of [Security Support Providers (SSP)](https://docs.microsoft.com/en-us/windows/win32/rpc/security-support-providers-ssps-),
//! and is able to utilize native Microsoft libraries when ran under Windows.
//!
//! The purpose of sspi-rs is to clean the original interface from cluttering and provide users with Rust-friendly SSPs for execution under Linux or any other platform that is
//! able to compile Rust.
//!
//! # Getting started
//!
//! Here is a quick example how to start working with the crate. This is the first stage of the client-server authentication performed on the client side.
//!
//! ```rust
//! use sspi::Sspi;
//! use sspi::Username;
//! use sspi::Ntlm;
//! use sspi::builders::EmptyInitializeSecurityContext;
//! use sspi::SspiImpl;
//!
//! let mut ntlm = Ntlm::new();
//!
//! let identity = sspi::AuthIdentity {
//!     username: Username::parse("user").unwrap(),
//!     password: "password".to_string().into(),
//! };
//!
//! let mut acq_creds_handle_result = ntlm
//!     .acquire_credentials_handle()
//!     .with_credential_use(sspi::CredentialUse::Outbound)
//!     .with_auth_data(&identity)
//!     .execute(&mut ntlm)
//!     .expect("AcquireCredentialsHandle resulted in error");
//!
//! let mut output = vec![sspi::SecurityBuffer::new(
//!     Vec::new(),
//!     sspi::BufferType::Token,
//! )];
//!
//! let mut builder = ntlm.initialize_security_context()
//!     .with_credentials_handle(&mut acq_creds_handle_result.credentials_handle)
//!     .with_context_requirements(
//!         sspi::ClientRequestFlags::CONFIDENTIALITY | sspi::ClientRequestFlags::ALLOCATE_MEMORY
//!     )
//!     .with_target_data_representation(sspi::DataRepresentation::Native)
//!     .with_output(&mut output);
//!
//! let result = ntlm.initialize_security_context_impl(&mut builder)
//!     .expect("InitializeSecurityContext resulted in error")
//!     .resolve_to_result()
//!     .expect("InitializeSecurityContext resulted in error");
//!
//! println!("Initialized security context with result status: {:?}", result.status);
//! ```

#[macro_use]
extern crate tracing;

pub mod builders;
pub mod channel_bindings;
pub mod credssp;
pub mod generator;
pub mod kerberos;
pub mod negotiate;
pub mod network_client;
pub mod ntlm;
mod pk_init;
pub mod pku2u;

mod auth_identity;
mod ber;
pub mod cert_utils;
mod crypto;
mod dns;
mod kdc;
mod krb;
mod rustls;
mod secret;
mod security_buffer;
mod smartcard;
mod utils;

#[cfg(all(feature = "tsssp", not(target_os = "windows")))]
compile_error!("tsssp feature should be used only on Windows");

use std::{error, fmt, io, result, str, string};

use bitflags::bitflags;
#[cfg(feature = "tsssp")]
use credssp::sspi_cred_ssp;
pub use generator::NetworkRequest;
use generator::{GeneratorAcceptSecurityContext, GeneratorChangePassword, GeneratorInitSecurityContext};
pub use network_client::NetworkProtocol;
use num_derive::{FromPrimitive, ToPrimitive};
use picky_asn1::restricted_string::CharSetError;
use picky_asn1_der::Asn1DerError;
use picky_asn1_x509::Certificate;
use picky_krb::gss_api::GssApiMessageError;
use picky_krb::messages::KrbError;
#[cfg(feature = "__rustls-used")]
pub use rustls::install_default_crypto_provider_if_necessary;
pub use security_buffer::SecurityBufferRef;
use utils::map_keb_error_code_to_sspi_error;
pub use utils::string_to_utf16;

pub use self::auth_identity::{
    AuthIdentity, AuthIdentityBuffers, Credentials, CredentialsBuffers, SmartCardIdentity, SmartCardIdentityBuffers,
    UserNameFormat, Username,
};
pub use self::builders::{
    AcceptSecurityContextResult, AcquireCredentialsHandleResult, InitializeSecurityContextResult,
};
use self::builders::{
    ChangePassword, FilledAcceptSecurityContext, FilledAcquireCredentialsHandle, FilledInitializeSecurityContext,
};
pub use self::kdc::{detect_kdc_host, detect_kdc_url};
pub use self::kerberos::config::{KerberosConfig, KerberosServerConfig};
pub use self::kerberos::{Kerberos, KerberosState, KERBEROS_VERSION};
pub use self::negotiate::{Negotiate, NegotiateConfig, NegotiatedProtocol};
pub use self::ntlm::Ntlm;
pub use self::pku2u::{Pku2u, Pku2uConfig, Pku2uState};
pub use self::secret::Secret;
use crate::builders::{
    EmptyAcceptSecurityContext, EmptyAcquireCredentialsHandle, EmptyInitializeSecurityContext,
    InitializeSecurityContext,
};

/// Representation of SSPI-related result operation. Makes it easier to return a `Result` with SSPI-related `Error`.
pub type Result<T> = result::Result<T, Error>;
pub type Luid = u64;

const PACKAGE_ID_NONE: u16 = 0xFFFF;

/// Retrieves information about a specified security package. This information includes credentials and contexts.
///
/// # Returns
///
/// * `PackageInfo` containing the information about the security principal upon success
/// * `Error` on error
///
/// # Example
///
/// ```
/// let package_info = sspi::query_security_package_info(sspi::SecurityPackageType::Ntlm)
///     .unwrap();
/// println!("Package info:");
/// println!("Name: {:?}", package_info.name);
/// println!("Comment: {}", package_info.comment);
/// ```
///
/// # MSDN
///
/// * [QuerySecurityPackageInfoW function](https://docs.microsoft.com/en-us/windows/win32/api/sspi/nf-sspi-querysecuritypackageinfow)
pub fn query_security_package_info(package_type: SecurityPackageType) -> Result<PackageInfo> {
    match package_type {
        SecurityPackageType::Ntlm => Ok(ntlm::PACKAGE_INFO.clone()),
        SecurityPackageType::Kerberos => Ok(kerberos::PACKAGE_INFO.clone()),
        SecurityPackageType::Negotiate => Ok(negotiate::PACKAGE_INFO.clone()),
        SecurityPackageType::Pku2u => Ok(pku2u::PACKAGE_INFO.clone()),
        #[cfg(feature = "tsssp")]
        SecurityPackageType::CredSsp => Ok(sspi_cred_ssp::PACKAGE_INFO.clone()),
        SecurityPackageType::Other(s) => Err(Error::new(
            ErrorKind::Unknown,
            format!("queried info about unknown package: {:?}", s),
        )),
    }
}

/// Returns an array of `PackageInfo` structures that provide information about the security packages available to the client.
///
/// # Returns
///
/// * `Vec` of `PackageInfo` structures upon success
/// * `Error` on error
///
/// # Example
///
/// ```
/// let packages = sspi::enumerate_security_packages().unwrap();
///
/// println!("Available packages:");
/// for ssp in packages {
///     println!("{:?}", ssp.name);
/// }
/// ```
///
/// # MSDN
///
/// * [EnumerateSecurityPackagesW function](https://docs.microsoft.com/en-us/windows/win32/api/sspi/nf-sspi-enumeratesecuritypackagesw)
pub fn enumerate_security_packages() -> Result<Vec<PackageInfo>> {
    Ok(vec![
        negotiate::PACKAGE_INFO.clone(),
        kerberos::PACKAGE_INFO.clone(),
        pku2u::PACKAGE_INFO.clone(),
        ntlm::PACKAGE_INFO.clone(),
        #[cfg(feature = "tsssp")]
        credssp::sspi_cred_ssp::PACKAGE_INFO.clone(),
    ])
}

/// This trait provides interface for all available SSPI functions. The `acquire_credentials_handle`,
/// `initialize_security_context`, and `accept_security_context` methods return Builders that make it
/// easier to assemble the list of arguments for the function and then execute it.
///
/// # MSDN
///
/// * [SSPI.h](https://docs.microsoft.com/en-us/windows/win32/api/sspi/)
pub trait Sspi
where
    Self: Sized + SspiImpl,
{
    /// Acquires a handle to preexisting credentials of a security principal. The preexisting credentials are
    /// available only for `sspi::winapi` module. This handle is required by the `initialize_security_context`
    /// and `accept_security_context` functions. These can be either preexisting credentials, which are
    /// established through a system logon, or the caller can provide alternative credentials. Alternative
    /// credentials are always required to specify when using platform independent SSPs.
    ///
    /// # Returns
    ///
    /// * `AcquireCredentialsHandle` builder
    ///
    /// # Requirements for execution
    ///
    /// These methods are required to be called before calling the `execute` method of the `AcquireCredentialsHandle` builder:
    /// * [`with_credential_use`](builders/struct.AcquireCredentialsHandle.html#method.with_credential_use)
    ///
    /// # Example
    ///
    /// ```
    /// use sspi::Sspi;
    /// use sspi::Username;
    ///
    /// let mut ntlm = sspi::Ntlm::new();
    ///
    /// let identity = sspi::AuthIdentity {
    ///     username: Username::parse("user").unwrap(),
    ///     password: "password".to_string().into(),
    /// };
    ///
    /// #[allow(unused_variables)]
    /// let result = ntlm
    ///     .acquire_credentials_handle()
    ///     .with_credential_use(sspi::CredentialUse::Outbound)
    ///     .with_auth_data(&identity)
    ///     .execute(&mut ntlm)
    ///     .unwrap();
    /// ```
    ///
    /// # MSDN
    ///
    /// * [AcquireCredentialshandleW function](https://docs.microsoft.com/en-us/windows/win32/api/sspi/nf-sspi-acquirecredentialshandlew)
    fn acquire_credentials_handle<'a>(
        &mut self,
    ) -> EmptyAcquireCredentialsHandle<'a, Self::CredentialsHandle, Self::AuthenticationData> {
        EmptyAcquireCredentialsHandle::new()
    }

    /// Initiates the client side, outbound security context from a credential handle.
    /// The function is used to build a security context between the client application and a remote peer. The function returns a token
    /// that the client must pass to the remote peer, which the peer in turn submits to the local security implementation through the
    /// `accept_security_context` call.
    ///
    /// # Returns
    ///
    /// * `InitializeSecurityContext` builder
    ///
    /// # Requirements for execution
    ///
    /// These methods are required to be called before calling the `execute` method
    /// * [`with_credentials_handle`](builders/struct.InitializeSecurityContext.html#method.with_credentials_handle)
    /// * [`with_context_requirements`](builders/struct.InitializeSecurityContext.html#method.with_context_requirements)
    /// * [`with_target_data_representation`](builders/struct.InitializeSecurityContext.html#method.with_target_data_representation)
    /// * [`with_output`](builders/struct.InitializeSecurityContext.html#method.with_output)
    ///
    /// # Example
    ///
    /// ```
    /// use sspi::Sspi;
    /// use sspi::Username;
    /// use sspi::builders::EmptyInitializeSecurityContext;
    /// use sspi::SspiImpl;
    ///
    /// let mut ntlm = sspi::Ntlm::new();
    ///
    /// let identity = sspi::AuthIdentity {
    ///     username: Username::new(&whoami::username(), Some(&whoami::hostname())).unwrap(),
    ///     password: String::from("password").into(),
    /// };
    ///
    /// let mut acq_cred_result = ntlm
    ///     .acquire_credentials_handle()
    ///     .with_credential_use(sspi::CredentialUse::Outbound)
    ///     .with_auth_data(&identity)
    ///     .execute(&mut ntlm)
    ///     .unwrap();
    ///
    /// let mut credentials_handle = acq_cred_result.credentials_handle;
    ///
    /// let mut output_buffer = vec![sspi::SecurityBuffer::new(Vec::new(), sspi::BufferType::Token)];
    ///
    /// #[allow(unused_variables)]
    /// let mut builder = ntlm.initialize_security_context()
    ///     .with_credentials_handle(&mut credentials_handle)
    ///     .with_context_requirements(
    ///         sspi::ClientRequestFlags::CONFIDENTIALITY | sspi::ClientRequestFlags::ALLOCATE_MEMORY,
    ///     )
    ///     .with_target_data_representation(sspi::DataRepresentation::Native)
    ///     .with_output(&mut output_buffer);
    ///
    /// let result = ntlm.initialize_security_context_impl(&mut builder)
    ///         .unwrap()
    ///         .resolve_to_result()
    ///         .unwrap();
    /// ```
    ///
    /// # MSDN
    ///
    /// * [InitializeSecurityContextW function](https://docs.microsoft.com/en-us/windows/win32/api/sspi/nf-sspi-initializesecuritycontextw)
    fn initialize_security_context<'a>(&mut self) -> EmptyInitializeSecurityContext<'a, Self::CredentialsHandle> {
        InitializeSecurityContext::new()
    }

    /// Lets the server component of a transport application establish a security context between the server and a remote client.
    /// The remote client calls the `initialize_security_context` function to start the process of establishing a security context.
    /// The server can require one or more reply tokens from the remote client to complete establishing the security context.
    ///
    /// # Returns
    ///
    /// * `AcceptSecurityContext` builder
    ///
    /// # Requirements for execution
    ///
    /// These methods are required to be called before calling the `execute` method of the `AcceptSecurityContext` builder:
    /// * [`with_credentials_handle`](builders/struct.AcceptSecurityContext.html#method.with_credentials_handle)
    /// * [`with_context_requirements`](builders/struct.AcceptSecurityContext.html#method.with_context_requirements)
    /// * [`with_target_data_representation`](builders/struct.AcceptSecurityContext.html#method.with_target_data_representation)
    /// * [`with_output`](builders/struct.AcceptSecurityContext.html#method.with_output)
    ///
    /// # Example
    ///
    /// ```
    /// use sspi::Sspi;
    /// use sspi::Username;
    /// use sspi::builders::EmptyInitializeSecurityContext;
    /// use sspi::SspiImpl;
    ///
    /// let mut client_ntlm = sspi::Ntlm::new();
    ///
    /// let identity = sspi::AuthIdentity {
    ///     username: Username::parse("user").unwrap(),
    ///     password: "password".to_string().into(),
    /// };
    ///
    /// let mut client_acq_cred_result = client_ntlm
    ///     .acquire_credentials_handle()
    ///     .with_credential_use(sspi::CredentialUse::Outbound)
    ///     .with_auth_data(&identity)
    ///     .execute(&mut client_ntlm)
    ///     .unwrap();
    ///
    /// let mut client_output_buffer = vec![sspi::SecurityBuffer::new(Vec::new(), sspi::BufferType::Token)];
    ///
    /// let mut builder = client_ntlm.initialize_security_context()
    ///     .with_credentials_handle(&mut client_acq_cred_result.credentials_handle)
    ///     .with_context_requirements(
    ///         sspi::ClientRequestFlags::CONFIDENTIALITY | sspi::ClientRequestFlags::ALLOCATE_MEMORY,
    ///     )
    ///     .with_target_data_representation(sspi::DataRepresentation::Native)
    ///     .with_target_name("user")
    ///     .with_output(&mut client_output_buffer);
    ///
    /// let _result = client_ntlm.initialize_security_context_impl(&mut builder)
    ///         .unwrap()
    ///         .resolve_to_result()
    ///         .unwrap();
    ///
    /// let mut ntlm = sspi::Ntlm::new();
    /// let mut output_buffer = vec![sspi::SecurityBuffer::new(Vec::new(), sspi::BufferType::Token)];
    ///
    /// let mut server_acq_cred_result = ntlm
    ///     .acquire_credentials_handle()
    ///     .with_credential_use(sspi::CredentialUse::Inbound)
    ///     .with_auth_data(&identity)
    ///     .execute(&mut ntlm)
    ///     .unwrap();
    ///
    /// let mut credentials_handle = server_acq_cred_result.credentials_handle;
    ///
    /// #[allow(unused_variables)]
    /// let result = ntlm
    ///     .accept_security_context()
    ///     .with_credentials_handle(&mut credentials_handle)
    ///     .with_context_requirements(sspi::ServerRequestFlags::ALLOCATE_MEMORY)
    ///     .with_target_data_representation(sspi::DataRepresentation::Native)
    ///     .with_input(&mut client_output_buffer)
    ///     .with_output(&mut output_buffer)
    ///     .execute(&mut ntlm)
    ///     .unwrap();
    /// ```
    ///
    /// # MSDN
    ///
    /// * [AcceptSecurityContext function](https://docs.microsoft.com/en-us/windows/win32/api/sspi/nf-sspi-acceptsecuritycontext)
    fn accept_security_context<'a>(&mut self) -> EmptyAcceptSecurityContext<'a, Self::CredentialsHandle> {
        EmptyAcceptSecurityContext::new()
    }

    /// Completes an authentication token. This function is used by protocols, such as DCE,
    /// that need to revise the security information after the transport application has updated some message parameters.
    ///
    /// # Parameters
    ///
    /// * `token`: `SecurityBufferRef` that contains the buffer descriptor for the entire message
    ///
    /// # Returns
    ///
    /// * `SspiOk` on success
    /// * `Error` on error
    ///
    /// # Example
    ///
    /// ```
    /// use sspi::Sspi;
    /// use sspi::Username;
    /// use sspi::builders::EmptyInitializeSecurityContext;
    /// use sspi::SspiImpl;
    ///
    /// let mut client_ntlm = sspi::Ntlm::new();
    /// let mut ntlm = sspi::Ntlm::new();
    ///
    /// let mut client_output_buffer = vec![sspi::SecurityBuffer::new(Vec::new(), sspi::BufferType::Token)];
    /// let mut output_buffer = vec![sspi::SecurityBuffer::new(Vec::new(), sspi::BufferType::Token)];
    ///
    /// let identity = sspi::AuthIdentity {
    ///     username: Username::parse("user").unwrap(),
    ///     password: "password".to_string().into(),
    /// };
    ///
    /// let mut client_acq_cred_result = client_ntlm
    ///     .acquire_credentials_handle()
    ///     .with_credential_use(sspi::CredentialUse::Outbound)
    ///     .with_auth_data(&identity)
    ///     .execute(&mut ntlm)
    ///     .unwrap();
    ///
    /// let mut server_acq_cred_result = ntlm
    ///     .acquire_credentials_handle()
    ///     .with_credential_use(sspi::CredentialUse::Inbound)
    ///     .with_auth_data(&identity)
    ///     .execute(&mut ntlm)
    ///     .unwrap();
    ///
    /// loop {
    ///     client_output_buffer[0].buffer.clear();
    ///
    ///     let mut builder = client_ntlm.initialize_security_context()
    ///         .with_credentials_handle(&mut client_acq_cred_result.credentials_handle)
    ///         .with_context_requirements(
    ///             sspi::ClientRequestFlags::CONFIDENTIALITY | sspi::ClientRequestFlags::ALLOCATE_MEMORY,
    ///         )
    ///         .with_target_data_representation(sspi::DataRepresentation::Native)
    ///         .with_target_name("user")
    ///         .with_input(&mut output_buffer)
    ///         .with_output(&mut client_output_buffer);
    ///
    ///     let _client_result = client_ntlm.initialize_security_context_impl(&mut builder)
    ///         .unwrap()
    ///         .resolve_to_result()
    ///         .unwrap();
    ///
    ///     let builder = ntlm
    ///         .accept_security_context()
    ///         .with_credentials_handle(&mut server_acq_cred_result.credentials_handle)
    ///         .with_context_requirements(sspi::ServerRequestFlags::ALLOCATE_MEMORY)
    ///         .with_target_data_representation(sspi::DataRepresentation::Native)
    ///         .with_input(&mut client_output_buffer)
    ///         .with_output(&mut output_buffer);
    ///     let server_result = ntlm.accept_security_context_impl(builder)
    ///         .unwrap()
    ///         .resolve_to_result()
    ///         .unwrap();
    ///
    ///     if server_result.status == sspi::SecurityStatus::CompleteAndContinue
    ///         || server_result.status == sspi::SecurityStatus::CompleteNeeded
    ///     {
    ///         break;
    ///     }
    /// }
    ///
    /// #[allow(unused_variables)]
    /// let result = ntlm
    ///     .complete_auth_token(&mut output_buffer)
    ///     .unwrap();
    /// ```
    ///
    /// # MSDN
    ///
    /// * [CompleteAuthToken function](https://docs.microsoft.com/en-us/windows/win32/api/sspi/nf-sspi-completeauthtoken)
    fn complete_auth_token(&mut self, token: &mut [SecurityBuffer]) -> Result<SecurityStatus>;

    /// Encrypts a message to provide privacy. The function allows the application to choose among cryptographic algorithms supported by the chosen mechanism.
    /// Some packages do not have messages to be encrypted or decrypted but rather provide an integrity hash that can be checked.
    ///
    /// # Parameters
    ///
    /// * `flags`: package-specific flags that indicate the quality of protection. A security package can use this parameter to enable the selection of cryptographic algorithms
    /// * `message`: on input, the structure accepts one or more `SecurityBufferRef` structures that can be of type `BufferType::Data`.
    ///   That buffer contains the message to be encrypted. The message is encrypted in place, overwriting the original contents of the structure.
    /// * `sequence_number`: the sequence number that the transport application assigned to the message. If the transport application does not maintain sequence numbers, this parameter must be zero
    ///
    /// # Example
    ///
    /// ```
    /// use sspi::Sspi;
    /// use sspi::Username;
    /// use sspi::builders::EmptyInitializeSecurityContext;
    /// use sspi::SspiImpl;
    ///
    /// let mut client_ntlm = sspi::Ntlm::new();
    /// let mut ntlm = sspi::Ntlm::new();
    ///
    /// let mut client_output_buffer = vec![sspi::SecurityBuffer::new(Vec::new(), sspi::BufferType::Token)];
    /// let mut server_output_buffer = vec![sspi::SecurityBuffer::new(Vec::new(), sspi::BufferType::Token)];
    ///
    /// let identity = sspi::AuthIdentity {
    ///     username: Username::parse("user").unwrap(),
    ///     password: "password".to_string().into(),
    /// };
    ///
    /// let mut client_acq_cred_result = client_ntlm
    ///     .acquire_credentials_handle()
    ///     .with_credential_use(sspi::CredentialUse::Outbound)
    ///     .with_auth_data(&identity)
    ///     .execute(&mut client_ntlm)
    ///     .unwrap();
    ///
    /// let mut server_acq_cred_result = ntlm
    ///     .acquire_credentials_handle()
    ///     .with_credential_use(sspi::CredentialUse::Inbound)
    ///     .with_auth_data(&identity)
    ///     .execute(&mut ntlm)
    ///     .unwrap();
    ///
    /// loop {
    ///     client_output_buffer[0].buffer.clear();
    ///
    ///     let mut builder = client_ntlm.initialize_security_context()
    ///         .with_credentials_handle(&mut client_acq_cred_result.credentials_handle)
    ///         .with_context_requirements(
    ///             sspi::ClientRequestFlags::CONFIDENTIALITY | sspi::ClientRequestFlags::ALLOCATE_MEMORY,
    ///         )
    ///         .with_target_data_representation(sspi::DataRepresentation::Native)
    ///         .with_target_name("user")
    ///         .with_input(&mut server_output_buffer)
    ///         .with_output(&mut client_output_buffer);
    ///
    ///     let _client_result = client_ntlm.initialize_security_context_impl(&mut builder)
    ///         .unwrap()
    ///         .resolve_to_result()
    ///         .unwrap();
    ///
    ///     let builder = ntlm
    ///         .accept_security_context()
    ///         .with_credentials_handle(&mut server_acq_cred_result.credentials_handle)
    ///         .with_context_requirements(sspi::ServerRequestFlags::ALLOCATE_MEMORY)
    ///         .with_target_data_representation(sspi::DataRepresentation::Native)
    ///         .with_input(&mut client_output_buffer)
    ///         .with_output(&mut server_output_buffer);
    ///     let server_result = ntlm.accept_security_context_impl(builder)
    ///         .unwrap()
    ///         .resolve_to_result()
    ///         .unwrap();
    ///
    ///     if server_result.status == sspi::SecurityStatus::CompleteAndContinue
    ///         || server_result.status == sspi::SecurityStatus::CompleteNeeded
    ///     {
    ///         break;
    ///     }
    /// }
    ///
    /// let _result = ntlm
    ///     .complete_auth_token(&mut server_output_buffer)
    ///     .unwrap();
    ///
    /// let mut token = [0; 128];
    /// let mut data = "This is a message".as_bytes().to_vec();
    /// let mut msg_buffer = vec![
    ///     sspi::SecurityBufferRef::token_buf(token.as_mut_slice()),
    ///     sspi::SecurityBufferRef::data_buf(data.as_mut_slice()),
    /// ];
    ///
    /// println!("Unencrypted: {:?}", msg_buffer[1].data());
    ///
    /// # #[allow(unused_variables)]
    /// let result = ntlm
    ///     .encrypt_message(sspi::EncryptionFlags::empty(), &mut msg_buffer, 0).unwrap();
    ///
    /// println!("Encrypted: {:?}", msg_buffer[1].data());
    /// ```
    ///
    /// # Returns
    ///
    /// * `SspiOk` on success
    /// * `Error` on error
    ///
    /// # MSDN
    ///
    /// * [EncryptMessage function](https://docs.microsoft.com/en-us/windows/win32/api/sspi/nf-sspi-encryptmessage)
    fn encrypt_message(
        &mut self,
        flags: EncryptionFlags,
        message: &mut [SecurityBufferRef],
        sequence_number: u32,
    ) -> Result<SecurityStatus>;

    /// Generates a cryptographic checksum of the message, and also includes sequencing information to prevent message loss or insertion.
    /// The function allows the application to choose between several cryptographic algorithms, if supported by the chosen mechanism.
    ///
    /// # Parameters
    /// * `flags`: package-specific flags that indicate the quality of protection. A security package can use this parameter to enable the selection of cryptographic algorithms
    /// * `message`: On input, the structure references one or more `SecurityBufferRef` structures of type `BufferType::Data` that contain the message to be signed,
    ///   and a `SecurityBufferRef` of type `BufferType::Token` that receives the signature.
    /// * `sequence_number`: the sequence number that the transport application assigned to the message. If the transport application does not maintain sequence numbers, this parameter must be zero
    ///
    /// # Returns
    /// * `SspiOk` on success
    /// * `Error` on error
    ///
    /// # Example
    ///
    /// ```
    /// use sspi::Sspi;
    /// use sspi::Username;
    /// use sspi::builders::EmptyInitializeSecurityContext;
    /// use sspi::SspiImpl;
    ///
    /// let mut client_ntlm = sspi::Ntlm::new();
    /// let mut ntlm = sspi::Ntlm::new();
    ///
    /// let mut client_output_buffer = vec![sspi::SecurityBuffer::new(Vec::new(), sspi::BufferType::Token)];
    /// let mut server_output_buffer = vec![sspi::SecurityBuffer::new(Vec::new(), sspi::BufferType::Token)];
    ///
    /// let identity = sspi::AuthIdentity {
    ///     username: Username::parse("user").unwrap(),
    ///     password: "password".to_string().into(),
    /// };
    ///
    /// let mut client_acq_cred_result = client_ntlm
    ///     .acquire_credentials_handle()
    ///     .with_credential_use(sspi::CredentialUse::Outbound)
    ///     .with_auth_data(&identity)
    ///     .execute(&mut client_ntlm)
    ///     .unwrap();
    ///
    /// let mut server_acq_cred_result = ntlm
    ///     .acquire_credentials_handle()
    ///     .with_credential_use(sspi::CredentialUse::Inbound)
    ///     .with_auth_data(&identity)
    ///     .execute(&mut ntlm)
    ///     .unwrap();
    ///
    /// loop {
    ///     client_output_buffer[0].buffer.clear();
    ///
    ///     let mut builder = client_ntlm.initialize_security_context()
    ///         .with_credentials_handle(&mut client_acq_cred_result.credentials_handle)
    ///         .with_context_requirements(
    ///             sspi::ClientRequestFlags::CONFIDENTIALITY | sspi::ClientRequestFlags::ALLOCATE_MEMORY,
    ///         )
    ///         .with_target_data_representation(sspi::DataRepresentation::Native)
    ///         .with_target_name("user")
    ///         .with_input(&mut server_output_buffer)
    ///         .with_output(&mut client_output_buffer);
    ///
    ///     let _client_result = client_ntlm.initialize_security_context_impl(&mut builder)
    ///         .unwrap()
    ///         .resolve_to_result()
    ///         .unwrap();
    ///
    ///     let builder = ntlm
    ///         .accept_security_context()
    ///         .with_credentials_handle(&mut server_acq_cred_result.credentials_handle)
    ///         .with_context_requirements(sspi::ServerRequestFlags::ALLOCATE_MEMORY)
    ///         .with_target_data_representation(sspi::DataRepresentation::Native)
    ///         .with_input(&mut client_output_buffer)
    ///         .with_output(&mut server_output_buffer);
    ///     let server_result = ntlm.accept_security_context_impl(builder)
    ///         .unwrap()
    ///         .resolve_to_result()
    ///         .unwrap();
    ///
    ///     if server_result.status == sspi::SecurityStatus::CompleteAndContinue
    ///         || server_result.status == sspi::SecurityStatus::CompleteNeeded
    ///     {
    ///         break;
    ///     }
    /// }
    ///
    /// let _result = ntlm
    ///     .complete_auth_token(&mut server_output_buffer)
    ///     .unwrap();
    ///
    /// let mut token = [0; 128];
    /// let mut data = "This is a message to be signed".as_bytes().to_vec();
    /// let mut msg_buffer = vec![
    ///     sspi::SecurityBufferRef::token_buf(token.as_mut_slice()),
    ///     sspi::SecurityBufferRef::data_buf(data.as_mut_slice()),
    /// ];
    ///
    /// println!("Input data: {:?}", msg_buffer[1].data());
    ///
    /// #[allow(unused_variables)]
    /// let result = ntlm
    ///     .make_signature(0, &mut msg_buffer, 0).unwrap();
    ///
    /// println!("Data signature: {:?}", msg_buffer[0].data());
    /// ```
    ///
    /// # MSDN
    /// * [MakeSignature function](https://learn.microsoft.com/en-us/windows/win32/api/sspi/nf-sspi-makesignature)
    fn make_signature(
        &mut self,
        flags: u32,
        message: &mut [SecurityBufferRef],
        sequence_number: u32,
    ) -> crate::Result<()>;

    /// Verifies that a message signed by using the `make_signature` function was received in the correct sequence and has not been modified.
    ///
    /// # Parameters
    /// * `message`: On input, the structure references one or more `SecurityBufferRef` structures of type `BufferType::Data` that contain the message to be verified,
    ///   and a `SecurityBufferRef` of type `BufferType::Token` that contains the signature.
    /// * `sequence_number`: the sequence number that the transport application assigned to the message. If the transport application does not maintain sequence numbers, this parameter must be zero
    ///
    /// # Returns
    /// * `u32` package-specific flags that indicate the quality of protection.
    /// * `Error` on error
    ///
    /// # Example
    ///
    /// ```
    /// use sspi::Sspi;
    /// use sspi::Username;
    /// use sspi::builders::EmptyInitializeSecurityContext;
    /// use sspi::SspiImpl;
    ///
    /// let mut ntlm = sspi::Ntlm::new();
    /// let mut server_ntlm = sspi::Ntlm::new();
    ///
    /// let mut client_output_buffer = vec![sspi::SecurityBuffer::new(Vec::new(), sspi::BufferType::Token)];
    /// let mut server_output_buffer = vec![sspi::SecurityBuffer::new(Vec::new(), sspi::BufferType::Token)];
    ///
    /// let identity = sspi::AuthIdentity {
    ///     username: Username::parse("user").unwrap(),
    ///     password: "password".to_string().into(),
    /// };
    ///
    /// let mut client_acq_cred_result = ntlm
    ///     .acquire_credentials_handle()
    ///     .with_credential_use(sspi::CredentialUse::Outbound)
    ///     .with_auth_data(&identity)
    ///     .execute(&mut ntlm)
    ///     .unwrap();
    ///
    /// let mut server_acq_cred_result = server_ntlm
    ///     .acquire_credentials_handle()
    ///     .with_credential_use(sspi::CredentialUse::Inbound)
    ///     .with_auth_data(&identity)
    ///     .execute(&mut server_ntlm)
    ///     .unwrap();
    ///
    /// loop {
    ///     client_output_buffer[0].buffer.clear();
    ///
    ///     let mut builder = ntlm.initialize_security_context()
    ///         .with_credentials_handle(&mut client_acq_cred_result.credentials_handle)
    ///         .with_context_requirements(
    ///             sspi::ClientRequestFlags::CONFIDENTIALITY | sspi::ClientRequestFlags::ALLOCATE_MEMORY,
    ///         )
    ///         .with_target_data_representation(sspi::DataRepresentation::Native)
    ///         .with_target_name("user")
    ///         .with_input(&mut server_output_buffer)
    ///         .with_output(&mut client_output_buffer);
    ///
    ///     let _client_result = ntlm.initialize_security_context_impl(&mut builder)
    ///         .unwrap()
    ///         .resolve_to_result()
    ///         .unwrap();
    ///
    ///     let builder = server_ntlm
    ///         .accept_security_context()
    ///         .with_credentials_handle(&mut server_acq_cred_result.credentials_handle)
    ///         .with_context_requirements(sspi::ServerRequestFlags::ALLOCATE_MEMORY)
    ///         .with_target_data_representation(sspi::DataRepresentation::Native)
    ///         .with_input(&mut client_output_buffer)
    ///         .with_output(&mut server_output_buffer);
    ///     let server_result = server_ntlm.accept_security_context_impl(builder)
    ///         .unwrap()
    ///         .resolve_to_result()
    ///         .unwrap();
    ///
    ///     if server_result.status == sspi::SecurityStatus::CompleteAndContinue
    ///         || server_result.status == sspi::SecurityStatus::CompleteNeeded
    ///     {
    ///         break;
    ///     }
    /// }
    ///
    /// let _result = server_ntlm
    ///     .complete_auth_token(&mut server_output_buffer)
    ///     .unwrap();
    ///
    /// let mut token = [0; 128];
    /// let mut data = "This is a message".as_bytes().to_vec();
    /// let mut msg = [
    ///     sspi::SecurityBufferRef::token_buf(token.as_mut_slice()),
    ///     sspi::SecurityBufferRef::data_buf(data.as_mut_slice()),
    /// ];
    ///
    /// let _result = server_ntlm
    ///     .make_signature(0, &mut msg, 0).unwrap();
    ///
    /// let [mut token, mut data] = msg;
    ///
    /// let mut msg_buffer = vec![
    ///     sspi::SecurityBufferRef::token_buf(token.take_data()),
    ///     sspi::SecurityBufferRef::data_buf(data.take_data()),
    /// ];
    ///
    /// #[allow(unused_variables)]
    /// let signature_flags = ntlm
    ///     .verify_signature(&mut msg_buffer, 0)
    ///     .unwrap();
    ///
    /// println!("Signature calculated and verified.");
    /// ```
    ///
    /// # MSDN
    /// * [VerifySignature function](https://learn.microsoft.com/en-us/windows/win32/api/sspi/nf-sspi-verifysignature)
    fn verify_signature(&mut self, message: &mut [SecurityBufferRef], sequence_number: u32) -> crate::Result<u32>;

    /// Decrypts a message. Some packages do not encrypt and decrypt messages but rather perform and check an integrity hash.
    ///
    /// # Parameters
    ///
    /// * `message`: on input, the structure references one or more `SecurityBufferRef` structures.
    ///   At least one of these must be of type `BufferType::Data`.
    ///   That buffer contains the encrypted message. The encrypted message is decrypted in place, overwriting the original contents of its buffer
    /// * `sequence_number`: the sequence number that the transport application assigned to the message. If the transport application does not maintain sequence numbers, this parameter must be zero
    ///
    /// # Returns
    ///
    /// * `DecryptionFlags` upon success
    /// * `Error` on error
    ///
    /// # Example
    ///
    /// ```
    /// use sspi::Sspi;
    /// use sspi::Username;
    /// use sspi::builders::EmptyInitializeSecurityContext;
    /// use sspi::SspiImpl;
    ///
    /// let mut ntlm = sspi::Ntlm::new();
    /// let mut server_ntlm = sspi::Ntlm::new();
    ///
    /// let mut client_output_buffer = vec![sspi::SecurityBuffer::new(Vec::new(), sspi::BufferType::Token)];
    /// let mut server_output_buffer = vec![sspi::SecurityBuffer::new(Vec::new(), sspi::BufferType::Token)];
    ///
    /// let identity = sspi::AuthIdentity {
    ///     username: Username::parse("user").unwrap(),
    ///     password: "password".to_string().into(),
    /// };
    ///
    /// let mut client_acq_cred_result = ntlm
    ///     .acquire_credentials_handle()
    ///     .with_credential_use(sspi::CredentialUse::Outbound)
    ///     .with_auth_data(&identity)
    ///     .execute(&mut ntlm)
    ///     .unwrap();
    ///
    /// let mut server_acq_cred_result = server_ntlm
    ///     .acquire_credentials_handle()
    ///     .with_credential_use(sspi::CredentialUse::Inbound)
    ///     .with_auth_data(&identity)
    ///     .execute(&mut server_ntlm)
    ///     .unwrap();
    ///
    /// loop {
    ///     client_output_buffer[0].buffer.clear();
    ///
    ///     let mut builder = ntlm.initialize_security_context()
    ///         .with_credentials_handle(&mut client_acq_cred_result.credentials_handle)
    ///         .with_context_requirements(
    ///             sspi::ClientRequestFlags::CONFIDENTIALITY | sspi::ClientRequestFlags::ALLOCATE_MEMORY,
    ///         )
    ///         .with_target_data_representation(sspi::DataRepresentation::Native)
    ///         .with_target_name("user")
    ///         .with_input(&mut server_output_buffer)
    ///         .with_output(&mut client_output_buffer);
    ///
    ///     let _client_result = ntlm.initialize_security_context_impl(&mut builder)
    ///         .unwrap()
    ///         .resolve_to_result()
    ///         .unwrap();
    ///
    ///     let builder = server_ntlm
    ///         .accept_security_context()
    ///         .with_credentials_handle(&mut server_acq_cred_result.credentials_handle)
    ///         .with_context_requirements(sspi::ServerRequestFlags::ALLOCATE_MEMORY)
    ///         .with_target_data_representation(sspi::DataRepresentation::Native)
    ///         .with_input(&mut client_output_buffer)
    ///         .with_output(&mut server_output_buffer);
    ///     let server_result = server_ntlm.accept_security_context_impl(builder)
    ///         .unwrap()
    ///         .resolve_to_result()
    ///         .unwrap();
    ///
    ///     if server_result.status == sspi::SecurityStatus::CompleteAndContinue
    ///         || server_result.status == sspi::SecurityStatus::CompleteNeeded
    ///     {
    ///         break;
    ///     }
    /// }
    ///
    /// let _result = server_ntlm
    ///     .complete_auth_token(&mut server_output_buffer)
    ///     .unwrap();
    ///
    /// let mut token = [0; 128];
    /// let mut data = "This is a message".as_bytes().to_vec();
    /// let mut msg = [
    ///     sspi::SecurityBufferRef::token_buf(token.as_mut_slice()),
    ///     sspi::SecurityBufferRef::data_buf(data.as_mut_slice()),
    /// ];
    ///
    /// let _result = server_ntlm
    ///     .encrypt_message(sspi::EncryptionFlags::empty(), &mut msg, 0).unwrap();
    ///
    /// let [mut token, mut data] = msg;
    ///
    /// let mut msg_buffer = vec![
    ///     sspi::SecurityBufferRef::token_buf(token.take_data()),
    ///     sspi::SecurityBufferRef::data_buf(data.take_data()),
    /// ];
    ///
    /// #[allow(unused_variables)]
    /// let encryption_flags = ntlm
    ///     .decrypt_message(&mut msg_buffer, 0)
    ///     .unwrap();
    ///
    /// println!("Decrypted message: {:?}", msg_buffer[1].data());
    /// ```
    ///
    /// # MSDN
    ///
    /// * [DecryptMessage function](https://docs.microsoft.com/en-us/windows/win32/api/sspi/nf-sspi-decryptmessage)
    fn decrypt_message(&mut self, message: &mut [SecurityBufferRef], sequence_number: u32) -> Result<DecryptionFlags>;

    /// Retrieves information about the bounds of sizes of authentication information of the current security principal.
    ///
    /// # Returns
    ///
    /// * `ContextSizes` upon success
    /// * `Error` on error
    ///
    /// # Example
    ///
    /// ```
    /// use sspi::Sspi;
    /// let mut ntlm = sspi::Ntlm::new();
    /// let sizes = ntlm.query_context_sizes().unwrap();
    /// println!("Max token: {}", sizes.max_token);
    /// println!("Max signature: {}", sizes.max_signature);
    /// println!("Block: {}", sizes.block);
    /// println!("Security trailer: {}", sizes.security_trailer);
    /// ```
    ///
    /// # MSDN
    ///
    /// * [QueryCredentialsAttributesW function](https://docs.microsoft.com/en-us/windows/win32/api/sspi/nf-sspi-querycredentialsattributesw)
    fn query_context_sizes(&mut self) -> Result<ContextSizes>;

    /// Retrieves the username of the credential associated to the context.
    ///
    /// # Returns
    ///
    /// * `ContextNames` upon success
    /// * `Error` on error
    ///
    /// # Example
    ///
    /// ```
    /// use sspi::Sspi;
    /// use sspi::Username;
    ///
    /// let mut ntlm = sspi::Ntlm::new();
    /// let identity = sspi::AuthIdentity {
    ///     username: Username::parse("user").unwrap(),
    ///     password: "password".to_string().into(),
    /// };
    ///
    /// let _acq_cred_result = ntlm
    ///     .acquire_credentials_handle()
    ///     .with_credential_use(sspi::CredentialUse::Inbound)
    ///     .with_auth_data(&identity)
    ///     .execute(&mut ntlm).unwrap();
    ///
    /// let names = ntlm.query_context_names().unwrap();
    /// println!("Username: {:?}", names.username.account_name());
    /// println!("Domain: {:?}", names.username.domain_name());
    /// ```
    ///
    /// # MSDN
    ///
    /// * [QuerySecurityPackageInfoW function](https://docs.microsoft.com/en-us/windows/win32/api/sspi/nf-sspi-querysecuritypackageinfow)
    fn query_context_names(&mut self) -> Result<ContextNames>;

    /// Queries the sizes of the various parts of a stream used in the per-message functions. This function is implemented only for CredSSP security package.
    ///
    /// # MSDN
    ///
    /// * [QuerySecurityPackageInfoW function (`ulAttribute` parameter)](https://learn.microsoft.com/en-us/windows/win32/secauthn/querycontextattributes--schannel)
    fn query_context_stream_sizes(&mut self) -> Result<StreamSizes> {
        Err(Error::new(
            ErrorKind::UnsupportedFunction,
            "query_context_stream_sizes is not supported",
        ))
    }

    /// Retrieves information about the specified security package. This information includes the bounds of sizes of authentication information, credentials, and contexts.
    ///
    /// # Returns
    ///
    /// * `PackageInfo` containing the information about the package
    /// * `Error` on error
    ///
    /// # Example
    ///
    /// ```
    /// use sspi::Sspi;
    /// let mut ntlm = sspi::Ntlm::new();
    /// let info = ntlm.query_context_package_info().unwrap();
    /// println!("Package name: {:?}", info.name);
    /// ```
    ///
    /// # MSDN
    ///
    /// * [QuerySecurityPackageInfoW function](https://docs.microsoft.com/en-us/windows/win32/api/sspi/nf-sspi-querysecuritypackageinfow)
    fn query_context_package_info(&mut self) -> Result<PackageInfo>;

    /// Retrieves the trust information of the certificate.
    ///
    /// # Returns
    ///
    /// * `CertTrustStatus` on success
    ///
    /// # Example
    ///
    /// ```
    /// use sspi::Sspi;
    /// let mut ntlm = sspi::Ntlm::new();
    /// let cert_info = ntlm.query_context_package_info().unwrap();
    /// ```
    ///
    /// # MSDN
    ///
    /// * [QueryContextAttributes (CredSSP) function (`ulAttribute` parameter)](https://docs.microsoft.com/en-us/windows/win32/secauthn/querycontextattributes--credssp)
    fn query_context_cert_trust_status(&mut self) -> Result<CertTrustStatus>;

    /// Retrieves the information about the end certificate supplied by the server. This function is implemented only for CredSSP security package.
    ///
    /// # Returns
    ///
    /// * `CertContext` on success
    ///
    /// # MSDN
    ///
    /// * [QueryContextAttributes (CredSSP) function (`ulAttribute` parameter)](https://docs.microsoft.com/en-us/windows/win32/secauthn/querycontextattributes--credssp)
    fn query_context_remote_cert(&mut self) -> Result<CertContext> {
        Err(Error::new(
            ErrorKind::UnsupportedFunction,
            "query_remote_cert_context is not supported",
        ))
    }

    /// Retrieves the information about the negotiated security package. This function is implemented only for CredSSP security package.
    ///
    /// # Returns
    ///
    /// * `PackageInfo` on success
    ///
    /// # MSDN
    ///
    /// * [QueryContextAttributes (CredSSP) function (`ulAttribute` parameter)](https://learn.microsoft.com/en-us/windows/win32/api/sspi/nf-sspi-querycontextattributesw)
    fn query_context_negotiation_package(&mut self) -> Result<PackageInfo> {
        Err(Error::new(
            ErrorKind::UnsupportedFunction,
            "query_context_negotiation_package is not supported",
        ))
    }

    /// Returns detailed information on the established connection. This function is implemented only for CredSSP security package.
    ///
    /// # Returns
    ///
    /// * `ConnectionInfo` on success
    ///
    /// # MSDN
    ///
    /// * [QueryContextAttributes (CredSSP) function (`ulAttribute` parameter)](https://docs.microsoft.com/en-us/windows/win32/secauthn/querycontextattributes--credssp)
    fn query_context_connection_info(&mut self) -> Result<ConnectionInfo> {
        Err(Error::new(
            ErrorKind::UnsupportedFunction,
            "query_context_connection_info is not supported",
        ))
    }

    /// Returns information about the session key used for the security context.
    ///
    /// # Returns
    ///
    /// * `SessionKeys` on success
    ///
    /// # MSDN
    ///
    /// * [QueryContextAttributes function (`ulAttribute` parameter)](https://docs.microsoft.com/en-us/windows/win32/secauthn/querycontextattributes--general)
    fn query_context_session_key(&self) -> Result<SessionKeys> {
        Err(Error::new(
            ErrorKind::UnsupportedFunction,
            "query_context_session_key is not supported",
        ))
    }

    /// Changes the password for a Windows domain account.
    ///
    /// # Returns
    ///
    /// * `()` on success
    ///
    /// # Example
    ///
    /// ```ignore
    /// use sspi::{Sspi, ChangePasswordBuilder};
    /// let mut ntlm = sspi::Ntlm::new();
    /// let mut output = [];
    /// let cert_info = ntlm.query_context_package_info().unwrap();
    /// let change_password = ChangePasswordBuilder::new()
    ///     .with_domain_name("domain".into())
    ///     .with_account_name("username".into())
    ///     .with_old_password("old_password".into())
    ///     .with_old_password("new_password".into())
    ///     .with_output(&mut output)
    ///     .build()
    ///     .unwrap();
    /// ntlm.change_password(change_password).unwrap();
    /// ```
    ///
    /// # MSDN
    ///
    /// * [ChangeAccountPasswordW function](https://docs.microsoft.com/en-us/windows/win32/api/sspi/nf-sspi-changeaccountpasswordw)
    fn change_password<'a>(&'a mut self, change_password: ChangePassword<'a>) -> Result<GeneratorChangePassword<'a>>;
}

/// Protocol used to establish connection.
///
/// # MSDN
///
/// [SecPkgContext_ConnectionInfo (`dwProtocol` field)](https://learn.microsoft.com/en-us/windows/win32/api/schannel/ns-schannel-secpkgcontext_connectioninfo)
#[derive(Debug, Clone, Eq, PartialEq, FromPrimitive, ToPrimitive)]
pub enum ConnectionProtocol {
    SpProtTls1Client = 0x80,
    SpProtTls1Server = 0x40,
    SpProtSsl3Client = 0x20,
    SpProtSsl3Server = 0x10,
    SpProtTls1_1Client = 0x200,
    SpProtTls1_1Server = 0x100,
    SpProtTls1_2Client = 0x800,
    SpProtTls1_2Server = 0x400,
    SpProtTls1_3Client = 0x00002000,
    SpProtTls1_3Server = 0x00001000,
    SpProtPct1Client = 0x2,
    SpProtPct1Server = 0x1,
    SpProtSsl2Client = 0x8,
    SpProtSsl2Server = 0x4,
}

/// Algorithm identifier for the bulk encryption cipher used by the connection.
///
/// # MSDN
///
/// [SecPkgContext_ConnectionInfo (`aiCipher` field)](https://learn.microsoft.com/en-us/windows/win32/api/schannel/ns-schannel-secpkgcontext_connectioninfo)
#[derive(Debug, Clone, Eq, PartialEq, FromPrimitive, ToPrimitive)]
pub enum ConnectionCipher {
    Calg3des = 26115,
    CalgAes128 = 26126,
    CalgAes256 = 26128,
    CalgDes = 26113,
    CalgRc2 = 26114,
    CalgRc4 = 26625,
    NoEncryption = 0,
}

/// ALG_ID indicating the hash used for generating Message Authentication Codes (MACs).
///
/// # MSDN
///
/// [SecPkgContext_ConnectionInfo (`aiHash` field)](https://learn.microsoft.com/en-us/windows/win32/api/schannel/ns-schannel-secpkgcontext_connectioninfo)
#[derive(Debug, Clone, Eq, PartialEq, FromPrimitive, ToPrimitive)]
pub enum ConnectionHash {
    CalgMd5 = 32771,
    CalgSha = 32772,
}

/// ALG_ID indicating the key exchange algorithm used to generate the shared master secret.
///
/// # MSDN
///
/// [SecPkgContext_ConnectionInfo (`aiExch` field)](https://learn.microsoft.com/en-us/windows/win32/api/schannel/ns-schannel-secpkgcontext_connectioninfo)
#[derive(Debug, Clone, Eq, PartialEq, FromPrimitive, ToPrimitive)]
pub enum ConnectionKeyExchange {
    CalgRsaKeyx = 41984,
    CalgDhEphem = 43522,
}

/// Type of certificate encoding used.
///
/// # MSDN
///
/// [CERT_CONTEXT (`dwCertEncodingType` field)](https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/ns-wincrypt-cert_context)
#[derive(Debug, Clone, Eq, PartialEq, FromPrimitive, ToPrimitive)]
pub enum CertEncodingType {
    Pkcs7AsnEncoding = 65536,
    X509AsnEncoding = 1,
}

/// The CERT_CONTEXT structure contains both the encoded and decoded representations of a certificate.
///
/// # MSDN
///
/// [CERT_CONTEXT](https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/ns-wincrypt-cert_context)
#[derive(Debug, Clone, PartialEq)]
pub struct CertContext {
    pub encoding_type: CertEncodingType,
    pub raw_cert: Vec<u8>,
    pub cert: Certificate,
}

/// This structure contains protocol and cipher information.
///
/// # MSDN
///
/// [SecPkgContext_ConnectionInfo](https://learn.microsoft.com/en-us/windows/win32/api/schannel/ns-schannel-secpkgcontext_connectioninfo)
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ConnectionInfo {
    pub protocol: ConnectionProtocol,
    pub cipher: ConnectionCipher,
    pub cipher_strength: u32,
    pub hash: ConnectionHash,
    pub hash_strength: u32,
    pub key_exchange: ConnectionKeyExchange,
    pub exchange_strength: u32,
}

/// Trait for performing authentication on the client or server side
pub trait SspiImpl {
    /// Represents raw data for authentication
    type CredentialsHandle;
    /// Represents authentication data prepared for the authentication process
    type AuthenticationData;

    fn acquire_credentials_handle_impl(
        &mut self,
        builder: FilledAcquireCredentialsHandle<'_, Self::CredentialsHandle, Self::AuthenticationData>,
    ) -> Result<AcquireCredentialsHandleResult<Self::CredentialsHandle>>;

    fn initialize_security_context_impl<'ctx, 'b, 'g>(
        &'ctx mut self,
        builder: &'b mut FilledInitializeSecurityContext<'ctx, Self::CredentialsHandle>,
    ) -> Result<GeneratorInitSecurityContext<'g>>
    where
        'ctx: 'g,
        'b: 'g;

    fn accept_security_context_impl<'a>(
        &'a mut self,
        builder: FilledAcceptSecurityContext<'a, Self::CredentialsHandle>,
    ) -> Result<GeneratorAcceptSecurityContext<'a>>;
}

pub trait SspiEx
where
    Self: Sized + SspiImpl,
{
    fn custom_set_auth_identity(&mut self, identity: Self::AuthenticationData) -> Result<()>;
}

pub type SspiPackage<'a, CredsHandle, AuthData> =
    &'a mut dyn SspiImpl<CredentialsHandle = CredsHandle, AuthenticationData = AuthData>;

bitflags! {
    /// Indicate the quality of protection. Used in the `encrypt_message` method.
    ///
    /// # MSDN
    ///
    /// * [EncryptMessage function (`fQOP` parameter)](https://docs.microsoft.com/en-us/windows/win32/api/sspi/nf-sspi-encryptmessage)
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct EncryptionFlags: u32 {
        const WRAP_OOB_DATA = 0x4000_0000;
        const WRAP_NO_ENCRYPT = 0x8000_0001;
    }
}

bitflags! {
    /// Indicate the quality of protection. Returned by the `decrypt_message` method.
    ///
    /// # MSDN
    ///
    /// * [DecryptMessage function (`pfQOP` parameter)](https://docs.microsoft.com/en-us/windows/win32/api/sspi/nf-sspi-decryptmessage)
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct DecryptionFlags: u32 {
        const SIGN_ONLY = 0x8000_0000;
        const WRAP_NO_ENCRYPT = 0x8000_0001;
    }
}

bitflags! {
    /// Indicate requests for the context. Not all packages can support all requirements. Bit flags can be combined by using bitwise-OR operations.
    ///
    /// # MSDN
    ///
    /// * [Context Requirements](https://docs.microsoft.com/en-us/windows/win32/secauthn/context-requirements)
    /// * [InitializeSecurityContextW function (fContextReq parameter)](https://docs.microsoft.com/en-us/windows/win32/api/sspi/nf-sspi-initializesecuritycontextw)
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ClientRequestFlags: u32 {
        /// The server can use the context to authenticate to other servers as the client.
        /// The `MUTUAL_AUTH` flag must be set for this flag to work. Valid for Kerberos. Ignore this flag for constrained delegation.
        const DELEGATE = 0x1;
        /// The mutual authentication policy of the service will be satisfied.
        const MUTUAL_AUTH = 0x2;
        /// Detect replayed messages that have been encoded by using the `encrypt_message` or `make_signature` (TBI) functions.
        const REPLAY_DETECT = 0x4;
        /// Detect messages received out of sequence.
        const SEQUENCE_DETECT = 0x8;
        /// Encrypt messages by using the `encrypt_message` function.
        const CONFIDENTIALITY = 0x10;
        /// A new session key must be negotiated. This value is supported only by the Kerberos security package.
        const USE_SESSION_KEY = 0x20;
        const PROMPT_FOR_CREDS = 0x40;
        /// Schannel must not attempt to supply credentials for the client automatically.
        const USE_SUPPLIED_CREDS = 0x80;
        /// The security package allocates output buffers for you.
        const ALLOCATE_MEMORY = 0x100;
        const USE_DCE_STYLE = 0x200;
        const DATAGRAM = 0x400;
        /// The security context will not handle formatting messages. This value is the default for the Kerberos, Negotiate, and NTLM security packages.
        const CONNECTION = 0x800;
        const CALL_LEVEL = 0x1000;
        const FRAGMENT_SUPPLIED = 0x2000;
        /// When errors occur, the remote party will be notified.
        const EXTENDED_ERROR = 0x4000;
        /// Support a stream-oriented connection.
        const STREAM = 0x8000;
        /// Sign messages and verify signatures by using the `encrypt_message` and `make_signature` (TBI) functions.
        const INTEGRITY = 0x0001_0000;
        const IDENTIFY = 0x0002_0000;
        const NULL_SESSION = 0x0004_0000;
        /// Schannel must not authenticate the server automatically.
        const MANUAL_CRED_VALIDATION = 0x0008_0000;
        const RESERVED1 = 0x0010_0000;
        const FRAGMENT_TO_FIT = 0x0020_0000;
        const FORWARD_CREDENTIALS = 0x0040_0000;
        /// If this flag is set, the `Integrity` flag is ignored. This value is supported only by the Negotiate and Kerberos security packages.
        const NO_INTEGRITY = 0x0080_0000;
        const USE_HTTP_STYLE = 0x100_0000;
        const UNVERIFIED_TARGET_NAME = 0x2000_0000;
        const CONFIDENTIALITY_ONLY = 0x4000_0000;
    }
}

bitflags! {
    /// Specify the attributes required by the server to establish the context. Bit flags can be combined by using bitwise-OR operations.
    ///
    /// # MSDN
    ///
    /// * [Context Requirements](https://docs.microsoft.com/en-us/windows/win32/secauthn/context-requirements)
    /// * [AcceptSecurityContext function function (fContextReq parameter)](https://docs.microsoft.com/en-us/windows/win32/api/sspi/nf-sspi-acceptsecuritycontext?redirectedfrom=MSDN)
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ServerRequestFlags: u32 {
        /// The server is allowed to impersonate the client. Ignore this flag for [constrained delegation](https://docs.microsoft.com/windows/desktop/SecGloss/c-gly).
        const DELEGATE = 0x1;
        const MUTUAL_AUTH = 0x2;
        /// Detect replayed packets.
        const REPLAY_DETECT = 0x4;
        /// Detect messages received out of sequence.
        const SEQUENCE_DETECT = 0x8;
        const CONFIDENTIALITY = 0x10;
        const USE_SESSION_KEY = 0x20;
        const SESSION_TICKET = 0x40;
        /// Credential Security Support Provider (CredSSP) will allocate output buffers.
        const ALLOCATE_MEMORY = 0x100;
        const USE_DCE_STYLE = 0x200;
        const DATAGRAM = 0x400;
        /// The security context will not handle formatting messages.
        const CONNECTION = 0x800;
        const CALL_LEVEL = 0x1000;
        const FRAGMENT_SUPPLIED = 0x2000;
        /// When errors occur, the remote party will be notified.
        const EXTENDED_ERROR = 0x8000;
        /// Support a stream-oriented connection.
        const STREAM = 0x0001_0000;
        const INTEGRITY = 0x0002_0000;
        const LICENSING = 0x0004_0000;
        const IDENTIFY = 0x0008_0000;
        const ALLOW_NULL_SESSION = 0x0010_0000;
        const ALLOW_NON_USER_LOGONS = 0x0020_0000;
        const ALLOW_CONTEXT_REPLAY = 0x0040_0000;
        const FRAGMENT_TO_FIT = 0x80_0000;
        const NO_TOKEN = 0x100_0000;
        const PROXY_BINDINGS = 0x400_0000;
        const ALLOW_MISSING_BINDINGS = 0x1000_0000;
    }
}

bitflags! {
    /// Indicate the attributes of the established context.
    ///
    /// # MSDN
    ///
    /// * [Context Requirements](https://docs.microsoft.com/en-us/windows/win32/secauthn/context-requirements)
    /// * [InitializeSecurityContextW function (pfContextAttr parameter)](https://docs.microsoft.com/en-us/windows/win32/api/sspi/nf-sspi-initializesecuritycontextw)
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ClientResponseFlags: u32 {
        /// The server can use the context to authenticate to other servers as the client.
        /// The `MUTUAL_AUTH` flag must be set for this flag to work. Valid for Kerberos. Ignore this flag for constrained delegation.
        const DELEGATE = 0x1;
        /// The mutual authentication policy of the service will be satisfied.
        const MUTUAL_AUTH = 0x2;
        /// Detect replayed messages that have been encoded by using the `encrypt_message` or `make_signature` (TBI) functions.
        const REPLAY_DETECT = 0x4;
        /// Detect messages received out of sequence.
        const SEQUENCE_DETECT = 0x8;
        /// Encrypt messages by using the `encrypt_message` function.
        const CONFIDENTIALITY = 0x10;
        /// A new session key must be negotiated. This value is supported only by the Kerberos security package.
        const USE_SESSION_KEY = 0x20;
        const USED_COLLECTED_CREDS = 0x40;
        /// Schannel must not attempt to supply credentials for the client automatically.
        const USED_SUPPLIED_CREDS = 0x80;
        /// The security package allocates output buffers for you.
        const ALLOCATED_MEMORY = 0x100;
        const USED_DCE_STYLE = 0x200;
        const DATAGRAM = 0x400;
        /// The security context will not handle formatting messages. This value is the default for the Kerberos, Negotiate, and NTLM security packages.
        const CONNECTION = 0x800;
        const INTERMEDIATE_RETURN = 0x1000;
        const CALL_LEVEL = 0x2000;
        /// When errors occur, the remote party will be notified.
        const EXTENDED_ERROR = 0x4000;
        /// Support a stream-oriented connection.
        const STREAM = 0x8000;
        /// Sign messages and verify signatures by using the `encrypt_message` and `make_signature` (TBI) functions.
        const INTEGRITY = 0x0001_0000;
        const IDENTIFY = 0x0002_0000;
        const NULL_SESSION = 0x0004_0000;
        /// Schannel must not authenticate the server automatically.
        const MANUAL_CRED_VALIDATION = 0x0008_0000;
        const RESERVED1 = 0x10_0000;
        const FRAGMENT_ONLY = 0x0020_0000;
        const FORWARD_CREDENTIALS = 0x0040_0000;
        const USED_HTTP_STYLE = 0x100_0000;
        const NO_ADDITIONAL_TOKEN = 0x200_0000;
        const REAUTHENTICATION = 0x800_0000;
        const CONFIDENTIALITY_ONLY = 0x4000_0000;
    }
}

bitflags! {
    /// Indicate the attributes of the established context.
    ///
    /// # MSDN
    ///
    /// * [Context Requirements](https://docs.microsoft.com/en-us/windows/win32/secauthn/context-requirements)
    /// * [AcceptSecurityContext function function (pfContextAttr parameter)](https://docs.microsoft.com/en-us/windows/win32/api/sspi/nf-sspi-acceptsecuritycontext?redirectedfrom=MSDN)
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ServerResponseFlags: u32 {
        /// The server is allowed to impersonate the client. Ignore this flag for [constrained delegation](https://docs.microsoft.com/windows/desktop/SecGloss/c-gly).
        const DELEGATE = 0x1;
        const MUTUAL_AUTH = 0x2;
        /// Detect replayed packets.
        const REPLAY_DETECT = 0x4;
        /// Detect messages received out of sequence.
        const SEQUENCE_DETECT = 0x8;
        const CONFIDENTIALITY = 0x10;
        const USE_SESSION_KEY = 0x20;
        const SESSION_TICKET = 0x40;
        /// Credential Security Support Provider (CredSSP) will allocate output buffers.
        const ALLOCATED_MEMORY = 0x100;
        const USED_DCE_STYLE = 0x200;
        const DATAGRAM = 0x400;
        /// The security context will not handle formatting messages.
        const CONNECTION = 0x800;
        const CALL_LEVEL = 0x2000;
        const THIRD_LEG_FAILED = 0x4000;
        /// When errors occur, the remote party will be notified.
        const EXTENDED_ERROR = 0x8000;
        /// Support a stream-oriented connection.
        const STREAM = 0x0001_0000;
        const INTEGRITY = 0x0002_0000;
        const LICENSING = 0x0004_0000;
        const IDENTIFY = 0x0008_0000;
        const NULL_SESSION = 0x0010_0000;
        const ALLOW_NON_USER_LOGONS = 0x0020_0000;
        const ALLOW_CONTEXT_REPLAY = 0x0040_0000;
        const FRAGMENT_ONLY = 0x0080_0000;
        const NO_TOKEN = 0x100_0000;
        const NO_ADDITIONAL_TOKEN = 0x200_0000;
    }
}

/// The data representation, such as byte ordering, on the target.
///
/// # MSDN
///
/// * [AcceptSecurityContext function (TargetDataRep parameter)](https://docs.microsoft.com/en-us/windows/win32/api/sspi/nf-sspi-acceptsecuritycontext)
#[derive(Debug, Copy, Clone, Eq, PartialEq, FromPrimitive, ToPrimitive)]
pub enum DataRepresentation {
    Network = 0,
    Native = 0x10,
}

/// Describes a buffer allocated by a transport application to pass to a security package.
///
/// # MSDN
///
/// * [SecBuffer structure](https://docs.microsoft.com/en-us/windows/win32/api/sspi/ns-sspi-secbuffer)
#[derive(Clone)]
pub struct SecurityBuffer {
    pub buffer: Vec<u8>,
    pub buffer_type: SecurityBufferType,
}

impl fmt::Debug for SecurityBuffer {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "SecurityBufferRef {{ buffer_type: {:?}, buffer: 0x",
            self.buffer_type
        )?;
        self.buffer.iter().try_for_each(|byte| write!(f, "{byte:02X}"))?;
        write!(f, " }}")?;

        Ok(())
    }
}

impl SecurityBuffer {
    pub fn new(buffer: Vec<u8>, buffer_type: BufferType) -> Self {
        Self {
            buffer,
            buffer_type: SecurityBufferType {
                buffer_type,
                buffer_flags: SecurityBufferFlags::NONE,
            },
        }
    }

    pub fn find_buffer(buffers: &[SecurityBuffer], buffer_type: BufferType) -> Result<&SecurityBuffer> {
        buffers
            .iter()
            .find(|b| b.buffer_type.buffer_type == buffer_type)
            .ok_or_else(|| {
                Error::new(
                    ErrorKind::InvalidToken,
                    format!("no buffer was provided with type {:?}", buffer_type),
                )
            })
    }

    pub fn find_buffer_mut(buffers: &mut [SecurityBuffer], buffer_type: BufferType) -> Result<&mut SecurityBuffer> {
        buffers
            .iter_mut()
            .find(|b| b.buffer_type.buffer_type == buffer_type)
            .ok_or_else(|| {
                Error::new(
                    ErrorKind::InvalidToken,
                    format!("no buffer was provided with type {:?}", buffer_type),
                )
            })
    }
}

/// Bit flags that indicate the type of buffer.
///
/// # MSDN
///
/// * [SecBuffer structure (BufferType parameter)](https://docs.microsoft.com/en-us/windows/win32/api/sspi/ns-sspi-secbuffer)
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Default, FromPrimitive, ToPrimitive)]
pub enum BufferType {
    #[default]
    Empty = 0,
    /// The buffer contains common data. The security package can read and write this data, for example, to encrypt some or all of it.
    Data = 1,
    /// The buffer contains the security token portion of the message. This is read-only for input parameters or read/write for output parameters.
    Token = 2,
    TransportToPackageParameters = 3,
    /// The security package uses this value to indicate the number of missing bytes in a particular message.
    Missing = 4,
    /// The security package uses this value to indicate the number of extra or unprocessed bytes in a message.
    Extra = 5,
    /// The buffer contains a protocol-specific trailer for a particular record. It is not usually of interest to callers.
    StreamTrailer = 6,
    /// The buffer contains a protocol-specific header for a particular record. It is not usually of interest to callers.
    StreamHeader = 7,
    NegotiationInfo = 8,
    Padding = 9,
    Stream = 10,
    ObjectIdsList = 11,
    ObjectIdsListSignature = 12,
    /// This flag is reserved. Do not use it.
    Target = 13,
    /// The buffer contains channel binding information.
    ChannelBindings = 14,
    /// The buffer contains a [DOMAIN_PASSWORD_INFORMATION](https://docs.microsoft.com/en-us/windows/win32/api/ntsecapi/ns-ntsecapi-domain_password_information) structure.
    ChangePasswordResponse = 15,
    /// The buffer specifies the [service principal name (SPN)](https://docs.microsoft.com/en-us/windows/win32/secgloss/s-gly) of the target.
    TargetHost = 16,
    /// The buffer contains an alert message.
    Alert = 17,
    /// The buffer contains a list of application protocol IDs, one list per application protocol negotiation extension type to be enabled.
    ApplicationProtocol = 18,
    /// The buffer contains a bitmask for a `ReadOnly` buffer.
    AttributeMark = 0xF000_0000,
    /// The buffer is read-only with no checksum. This flag is intended for sending header information to the security package for computing the checksum.
    /// The package can read this buffer, but cannot modify it.
    ReadOnly = 0x8000_0000,
    /// The buffer is read-only with a checksum.
    ReadOnlyWithChecksum = 0x1000_0000,
}

bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    /// Security buffer flags.
    ///
    /// [`SecBuffer` structure (sspi.h)](https://learn.microsoft.com/en-us/windows/win32/api/sspi/ns-sspi-secbuffer).
    pub struct SecurityBufferFlags: u32 {
        /// There is no flags for the buffer.
        const NONE = 0x0;
        /// The buffer is read-only with no checksum. This flag is intended for sending header information to the security package for
        /// computing the checksum. The package can read this buffer, but cannot modify it.
        const SECBUFFER_READONLY = 0x80000000;
        /// The buffer is read-only with a checksum.
        const SECBUFFER_READONLY_WITH_CHECKSUM = 0x10000000;
    }
}

/// Security buffer type.
///
/// Contains the actual security buffer type and its flags.
#[derive(Clone, Copy, Eq, PartialEq, Default)]
pub struct SecurityBufferType {
    /// Security buffer type.
    pub buffer_type: BufferType,
    /// Security buffer flags.
    pub buffer_flags: SecurityBufferFlags,
}

impl SecurityBufferType {
    /// The buffer contains a bitmask for a `SECBUFFER_READONLY_WITH_CHECKSUM` buffer.
    ///
    /// [`SecBuffer` structure (sspi.h)](https://learn.microsoft.com/en-us/windows/win32/api/sspi/ns-sspi-secbuffer)
    pub const SECBUFFER_ATTRMASK: u32 = 0xf0000000;
}

impl TryFrom<u32> for SecurityBufferType {
    type Error = Error;

    fn try_from(value: u32) -> Result<Self> {
        use num_traits::cast::FromPrimitive;

        let buffer_type = value & !Self::SECBUFFER_ATTRMASK;
        let buffer_type = BufferType::from_u32(buffer_type).ok_or_else(|| {
            Error::new(
                ErrorKind::InternalError,
                format!("u32({}) to UnflaggedSecurityBuffer conversion error", buffer_type),
            )
        })?;

        let buffer_flags = value & Self::SECBUFFER_ATTRMASK;
        let buffer_flags = SecurityBufferFlags::from_bits(buffer_flags).ok_or_else(|| {
            Error::new(
                ErrorKind::InternalError,
                format!("invalid SecurityBufferFlags: {}", buffer_flags),
            )
        })?;

        Ok(Self {
            buffer_type,
            buffer_flags,
        })
    }
}

impl From<SecurityBufferType> for u32 {
    fn from(value: SecurityBufferType) -> u32 {
        use num_traits::cast::ToPrimitive;

        value.buffer_type.to_u32().unwrap() | value.buffer_flags.bits()
    }
}

impl fmt::Debug for SecurityBufferType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_fmt(format_args!("({:?}, {:?})", self.buffer_type, self.buffer_flags))
    }
}

/// A flag that indicates how the credentials are used.
///
/// # MSDN
///
/// * [AcquireCredentialsHandleW function (fCredentialUse parameter)](https://docs.microsoft.com/en-us/windows/win32/api/sspi/nf-sspi-acquirecredentialshandlew)
#[derive(Debug, Copy, Clone, Eq, PartialEq, FromPrimitive, ToPrimitive)]
pub enum CredentialUse {
    Inbound = 1,
    Outbound = 2,
    Both = 3,
    Default = 4,
}

/// Represents the security principal in use.
#[derive(Debug, Clone)]
pub enum SecurityPackageType {
    Ntlm,
    Kerberos,
    Negotiate,
    Pku2u,
    #[cfg(feature = "tsssp")]
    CredSsp,
    Other(String),
}

impl AsRef<str> for SecurityPackageType {
    fn as_ref(&self) -> &str {
        match self {
            SecurityPackageType::Ntlm => ntlm::PKG_NAME,
            SecurityPackageType::Kerberos => kerberos::PKG_NAME,
            SecurityPackageType::Negotiate => negotiate::PKG_NAME,
            SecurityPackageType::Pku2u => pku2u::PKG_NAME,
            #[cfg(feature = "tsssp")]
            SecurityPackageType::CredSsp => sspi_cred_ssp::PKG_NAME,
            SecurityPackageType::Other(name) => name.as_str(),
        }
    }
}

impl fmt::Display for SecurityPackageType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SecurityPackageType::Ntlm => write!(f, "{}", ntlm::PKG_NAME),
            SecurityPackageType::Kerberos => write!(f, "{}", kerberos::PKG_NAME),
            SecurityPackageType::Negotiate => write!(f, "{}", negotiate::PKG_NAME),
            SecurityPackageType::Pku2u => write!(f, "{}", pku2u::PKG_NAME),
            #[cfg(feature = "tsssp")]
            SecurityPackageType::CredSsp => write!(f, "{}", sspi_cred_ssp::PKG_NAME),
            SecurityPackageType::Other(name) => write!(f, "{name}"),
        }
    }
}

impl str::FromStr for SecurityPackageType {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self> {
        match s {
            ntlm::PKG_NAME => Ok(SecurityPackageType::Ntlm),
            kerberos::PKG_NAME => Ok(SecurityPackageType::Kerberos),
            negotiate::PKG_NAME => Ok(SecurityPackageType::Negotiate),
            pku2u::PKG_NAME => Ok(SecurityPackageType::Pku2u),
            #[cfg(feature = "tsssp")]
            sspi_cred_ssp::PKG_NAME => Ok(SecurityPackageType::CredSsp),
            s => Ok(SecurityPackageType::Other(s.to_string())),
        }
    }
}

/// General security principal information
///
/// Provides general information about a security package, such as its name and capabilities. Returned by `query_security_package_info`.
///
/// # MSDN
///
/// * [SecPkgInfoW structure](https://docs.microsoft.com/en-us/windows/win32/api/sspi/ns-sspi-secpkginfow)
#[derive(Debug, Clone)]
pub struct PackageInfo {
    pub capabilities: PackageCapabilities,
    pub rpc_id: u16,
    pub max_token_len: u32,
    pub name: SecurityPackageType,
    pub comment: String,
}

bitflags! {
    /// Set of bit flags that describes the capabilities of the security package. It is possible to combine them.
    ///
    /// # MSDN
    ///
    /// * [SecPkgInfoW structure (`fCapabilities` parameter)](https://docs.microsoft.com/en-us/windows/win32/api/sspi/ns-sspi-secpkginfow)
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct PackageCapabilities: u32 {
        /// The security package supports the `make_signature` (TBI) and `verify_signature` (TBI) functions.
        const INTEGRITY = 0x1;
        /// The security package supports the `encrypt_message` and `decrypt_message` functions.
        const PRIVACY = 0x2;
        /// The package is interested only in the security-token portion of messages, and will ignore any other buffers. This is a performance-related issue.
        const TOKEN_ONLY = 0x4;
        /// Supports [datagram](https://docs.microsoft.com/en-us/windows/win32/secgloss/d-gly)-style authentication.
        /// For more information, see [SSPI Context Semantics](https://docs.microsoft.com/en-us/windows/win32/secauthn/sspi-context-semantics).
        const DATAGRAM = 0x8;
        /// Supports connection-oriented style authentication. For more information, see [SSPI Context Semantics](https://docs.microsoft.com/en-us/windows/win32/secauthn/sspi-context-semantics).
        const CONNECTION = 0x10;
        /// Multiple legs are required for authentication.
        const MULTI_REQUIRED = 0x20;
        /// Server authentication support is not provided.
        const CLIENT_ONLY = 0x40;
        /// Supports extended error handling. For more information, see [Extended Error Information](https://docs.microsoft.com/en-us/windows/win32/secauthn/extended-error-information).
        const EXTENDED_ERROR = 0x80;
        /// Supports Windows impersonation in server contexts.
        const IMPERSONATION = 0x100;
        /// Understands Windows principal and target names.
        const ACCEPT_WIN32_NAME = 0x200;
        /// Supports stream semantics. For more information, see [SSPI Context Semantics](https://docs.microsoft.com/en-us/windows/win32/secauthn/sspi-context-semantics).
        const STREAM = 0x400;
        /// Can be used by the [Microsoft Negotiate](https://docs.microsoft.com/windows/desktop/SecAuthN/microsoft-negotiate) security package.
        const NEGOTIABLE = 0x800;
        /// Supports GSS compatibility.
        const GSS_COMPATIBLE = 0x1000;
        /// Supports [LsaLogonUser](https://docs.microsoft.com/windows/desktop/api/ntsecapi/nf-ntsecapi-lsalogonuser).
        const LOGON = 0x2000;
        /// Token buffers are in ASCII characters format.
        const ASCII_BUFFERS = 0x4000;
        /// Supports separating large tokens into smaller buffers so that applications can make repeated calls to
        /// `initialize_security_context` and `accept_security_context` with the smaller buffers to complete authentication.
        const FRAGMENT = 0x8000;
        /// Supports mutual authentication.
        const MUTUAL_AUTH = 0x1_0000;
        /// Supports delegation.
        const DELEGATION = 0x2_0000;
        /// The security package supports using a checksum instead of in-place encryption when calling the `encrypt_message` function.
        const READONLY_WITH_CHECKSUM = 0x4_0000;
        /// Supports callers with restricted tokens.
        const RESTRICTED_TOKENS = 0x8_0000;
        /// The security package extends the [Microsoft Negotiate](https://docs.microsoft.com/windows/desktop/SecAuthN/microsoft-negotiate) security package.
        /// There can be at most one package of this type.
        const NEGO_EXTENDER = 0x10_0000;
        /// This package is negotiated by the package of type `NEGO_EXTENDER`.
        const NEGOTIABLE2 = 0x20_0000;
        /// This package receives all calls from app container apps.
        const APP_CONTAINER_PASSTHROUGH = 0x40_0000;
        /// This package receives calls from app container apps if one of the following checks succeeds:
        /// * Caller has default credentials capability
        /// * The target is a proxy server
        /// * The caller has supplied credentials
        const APP_CONTAINER_CHECKS = 0x80_0000;
    }
}

/// Indicates the sizes of the various parts of a stream for use with the message support functions.
/// `query_context_stream_sizes` function returns this structure.
///
/// # MSDN
///
/// * [SecPkgContext_StreamSizes](https://learn.microsoft.com/en-us/windows/win32/api/sspi/ns-sspi-secpkgcontext_streamsizes)
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct StreamSizes {
    pub header: u32,
    pub trailer: u32,
    pub max_message: u32,
    pub buffers: u32,
    pub block_size: u32,
}

/// Indicates the sizes of important structures used in the message support functions.
/// `query_context_sizes` function returns this structure.
///
/// # MSDN
///
/// * [SecPkgContext_Sizes structure](https://docs.microsoft.com/en-us/windows/win32/api/sspi/ns-sspi-secpkgcontext_sizes)
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ContextSizes {
    pub max_token: u32,
    pub max_signature: u32,
    pub block: u32,
    pub security_trailer: u32,
}

/// Contains trust information about a certificate in a certificate chain,
/// summary trust information about a simple chain of certificates, or summary information about an array of simple chains.
/// `query_context_cert_trust_status` function returns this structure.
///
/// # MSDN
///
/// * [CERT_TRUST_STATUS structure](https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/ns-wincrypt-cert_trust_status)
#[derive(Debug, Clone)]
pub struct CertTrustStatus {
    pub error_status: CertTrustErrorStatus,
    pub info_status: CertTrustInfoStatus,
}

bitflags! {
    /// Flags representing the error status codes used in `CertTrustStatus`.
    ///
    /// # MSDN
    ///
    /// * [CERT_TRUST_STATUS structure](https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/ns-wincrypt-cert_trust_status)
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct CertTrustErrorStatus: u32 {
        /// No error found for this certificate or chain.
        const NO_ERROR = 0x0;
        /// This certificate or one of the certificates in the certificate chain is not time valid.
        const IS_NOT_TIME_VALID = 0x1;
        const IS_NOT_TIME_NESTED = 0x2;
        /// Trust for this certificate or one of the certificates in the certificate chain has been revoked.
        const IS_REVOKED = 0x4;
        /// The certificate or one of the certificates in the certificate chain does not have a valid signature.
        const IS_NOT_SIGNATURE_VALID = 0x8;
        /// The certificate or certificate chain is not valid for its proposed usage.
        const IS_NOT_VALID_FOR_USAGE = 0x10;
        /// The certificate or certificate chain is based on an untrusted root.
        const IS_UNTRUSTED_ROOT = 0x20;
        /// The revocation status of the certificate or one of the certificates in the certificate chain is unknown.
        const REVOCATION_STATUS_UNKNOWN = 0x40;
        /// One of the certificates in the chain was issued by a
        /// [`certification authority`](https://docs.microsoft.com/windows/desktop/SecGloss/c-gly)
        /// that the original certificate had certified.
        const IS_CYCLIC = 0x80;
        /// One of the certificates has an extension that is not valid.
        const INVALID_EXTENSION = 0x100;
        /// The certificate or one of the certificates in the certificate chain has a policy constraints extension,
        /// and one of the issued certificates has a disallowed policy mapping extension or does not have a
        /// required issuance policies extension.
        const INVALID_POLICY_CONSTRAINTS = 0x200;
        /// The certificate or one of the certificates in the certificate chain has a basic constraints extension,
        /// and either the certificate cannot be used to issue other certificates, or the chain path length has been exceeded.
        const INVALID_BASIC_CONSTRAINTS = 0x400;
        /// The certificate or one of the certificates in the certificate chain has a name constraints extension that is not valid.
        const INVALID_NAME_CONSTRAINTS = 0x800;
        /// The certificate or one of the certificates in the certificate chain has a name constraints extension that contains
        /// unsupported fields. The minimum and maximum fields are not supported.
        /// Thus minimum must always be zero and maximum must always be absent. Only UPN is supported for an Other Name.
        /// The following alternative name choices are not supported:
        /// * X400 Address
        /// * EDI Party Name
        /// * Registered Id
        const HAS_NOT_SUPPORTED_NAME_CONSTRAINT = 0x1000;
        /// The certificate or one of the certificates in the certificate chain has a name constraints extension and a name
        /// constraint is missing for one of the name choices in the end certificate.
        const HAS_NOT_DEFINED_NAME_CONSTRAINT = 0x2000;
        /// The certificate or one of the certificates in the certificate chain has a name constraints extension,
        /// and there is not a permitted name constraint for one of the name choices in the end certificate.
        const HAS_NOT_PERMITTED_NAME_CONSTRAINT = 0x4000;
        /// The certificate or one of the certificates in the certificate chain has a name constraints extension,
        /// and one of the name choices in the end certificate is explicitly excluded.
        const HAS_EXCLUDED_NAME_CONSTRAINT = 0x8000;
        /// The certificate chain is not complete.
        const IS_PARTIAL_CHAIN = 0x0001_0000;
        /// A [certificate trust list](https://docs.microsoft.com/windows/desktop/SecGloss/c-gly)
        /// (CTL) used to create this chain was not time valid.
        const CTL_IS_NOT_TIME_VALID = 0x0002_0000;
        /// A CTL used to create this chain did not have a valid signature.
        const CTL_IS_NOT_SIGNATURE_VALID = 0x0004_0000;
        /// A CTL used to create this chain is not valid for this usage.
        const CTL_IS_NOT_VALID_FOR_USAGE = 0x0008_0000;
        /// The revocation status of the certificate or one of the certificates in the certificate chain is either offline or stale.
        const IS_OFFLINE_REVOCATION = 0x100_0000;
        /// The end certificate does not have any resultant issuance policies, and one of the issuing
        /// [certification authority](https://docs.microsoft.com/windows/desktop/SecGloss/c-gly)
        /// certificates has a policy constraints extension requiring it.
        const NO_ISSUANCE_CHAIN_POLICY = 0x200_0000;
    }
}

bitflags! {
    /// Flags representing the info status codes used in `CertTrustStatus`.
    ///
    /// # MSDN
    ///
    /// * [CERT_TRUST_STATUS structure](https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/ns-wincrypt-cert_trust_status)
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct CertTrustInfoStatus: u32 {
        /// An exact match issuer certificate has been found for this certificate. This status code applies to certificates only.
        const HAS_EXACT_MATCH_ISSUER = 0x1;
        /// A key match issuer certificate has been found for this certificate. This status code applies to certificates only.
        const HAS_KEY_MATCH_ISSUER = 0x2;
        /// A name match issuer certificate has been found for this certificate. This status code applies to certificates only.
        const HAS_NAME_MATCH_ISSUER = 0x4;
        /// This certificate is self-signed. This status code applies to certificates only.
        const IS_SELF_SIGNED = 0x8;
        const AUTO_UPDATE_CA_REVOCATION = 0x10;
        const AUTO_UPDATE_END_REVOCATION = 0x20;
        const NO_OCSP_FAILOVER_TO_CRL = 0x40;
        const IS_KEY_ROLLOVER = 0x80;
        /// The certificate or chain has a preferred issuer. This status code applies to certificates and chains.
        const HAS_PREFERRED_ISSUER = 0x100;
        /// An issuance chain policy exists. This status code applies to certificates and chains.
        const HAS_ISSUANCE_CHAIN_POLICY = 0x200;
        /// A valid name constraints for all namespaces, including UPN. This status code applies to certificates and chains.
        const HAS_VALID_NAME_CONSTRAINTS = 0x400;
        /// This certificate is peer trusted. This status code applies to certificates only.
        const IS_PEER_TRUSTED = 0x800;
        /// This certificate's [certificate revocation list](https://docs.microsoft.com/windows/desktop/SecGloss/c-gly)
        /// (CRL) validity has been extended. This status code applies to certificates only.
        const HAS_CRL_VALIDITY_EXTENDED = 0x1000;
        const IS_FROM_EXCLUSIVE_TRUST_STORE = 0x2000;
        const IS_CA_TRUSTED = 0x4000;
        const HAS_AUTO_UPDATE_WEAK_SIGNATURE = 0x8000;
        const SSL_HANDSHAKE_OCSP = 0x0004_0000;
        const SSL_TIME_VALID_OCSP = 0x0008_0000;
        const SSL_RECONNECT_OCSP = 0x0010_0000;
        const IS_COMPLEX_CHAIN = 0x0001_0000;
        const HAS_ALLOW_WEAK_SIGNATURE = 0x0002_0000;
        const SSL_TIME_VALID = 0x100_0000;
        const NO_TIME_CHECK = 0x200_0000;
    }
}

/// Indicates the name of the user associated with a security context.
/// `query_context_names` function returns this structure.
///
/// # MSDN
///
/// * [SecPkgContext_NamesW structure](https://docs.microsoft.com/en-us/windows/win32/api/sspi/ns-sspi-secpkgcontext_namesw)
#[derive(Debug, Clone)]
pub struct ContextNames {
    pub username: Username,
}

/// Contains information about the session key used for the security context.
/// `query_context_session_key` function returns this structure.
///
/// # MSDN
///
/// * [SecPkgContext_SessionKey structure](https://learn.microsoft.com/en-us/windows/win32/api/sspi/ns-sspi-secpkgcontext_sessionkey)
#[derive(Debug, Clone)]
pub struct SessionKeys {
    pub session_key: Secret<Vec<u8>>,
}

/// The kind of an SSPI related error. Enables to specify an error based on its type.
///
/// [SSPI Status Codes](https://learn.microsoft.com/en-us/windows/win32/secauthn/sspi-status-codes).
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, FromPrimitive, ToPrimitive)]
pub enum ErrorKind {
    Unknown = 0,
    InsufficientMemory = 0x8009_0300,
    InvalidHandle = 0x8009_0301,
    UnsupportedFunction = 0x8009_0302,
    TargetUnknown = 0x8009_0303,
    /// May correspond to any internal error (I/O error, server error, etc.).
    InternalError = 0x8009_0304,
    SecurityPackageNotFound = 0x8009_0305,
    NotOwned = 0x8009_0306,
    CannotInstall = 0x8009_0307,
    /// Used in cases when supplied data is missing or invalid.
    InvalidToken = 0x8009_0308,
    CannotPack = 0x8009_0309,
    OperationNotSupported = 0x8009_030A,
    NoImpersonation = 0x8009_030B,
    LogonDenied = 0x8009_030C,
    UnknownCredentials = 0x8009_030D,
    NoCredentials = 0x8009_030E,
    /// Used in contexts of supplying invalid credentials.
    MessageAltered = 0x8009_030F,
    /// Used when a required NTLM state does not correspond to the current.
    OutOfSequence = 0x8009_0310,
    NoAuthenticatingAuthority = 0x8009_0311,
    BadPackageId = 0x8009_0316,
    ContextExpired = 0x8009_0317,
    IncompleteMessage = 0x8009_0318,
    IncompleteCredentials = 0x8009_0320,
    BufferTooSmall = 0x8009_0321,
    WrongPrincipalName = 0x8009_0322,
    TimeSkew = 0x8009_0324,
    UntrustedRoot = 0x8009_0325,
    IllegalMessage = 0x8009_0326,
    CertificateUnknown = 0x8009_0327,
    CertificateExpired = 0x8009_0328,
    EncryptFailure = 0x8009_0329,
    DecryptFailure = 0x8009_0330,
    AlgorithmMismatch = 0x8009_0331,
    SecurityQosFailed = 0x8009_0332,
    UnfinishedContextDeleted = 0x8009_0333,
    NoTgtReply = 0x8009_0334,
    NoIpAddress = 0x8009_0335,
    WrongCredentialHandle = 0x8009_0336,
    CryptoSystemInvalid = 0x8009_0337,
    MaxReferralsExceeded = 0x8009_0338,
    MustBeKdc = 0x8009_0339,
    StrongCryptoNotSupported = 0x8009_033A,
    TooManyPrincipals = 0x8009_033B,
    NoPaData = 0x8009_033C,
    PkInitNameMismatch = 0x8009_033D,
    SmartCardLogonRequired = 0x8009_033E,
    ShutdownInProgress = 0x8009_033F,
    KdcInvalidRequest = 0x8009_0340,
    KdcUnknownEType = 0x8009_0341,
    KdcUnknownEType2 = 0x8009_0342,
    UnsupportedPreAuth = 0x8009_0343,
    DelegationRequired = 0x8009_0345,
    BadBindings = 0x8009_0346,
    MultipleAccounts = 0x8009_0347,
    NoKerbKey = 0x8009_0348,
    CertWrongUsage = 0x8009_0349,
    DowngradeDetected = 0x8009_0350,
    SmartCardCertificateRevoked = 0x8009_0351,
    IssuingCAUntrusted = 0x8009_0352,
    RevocationOffline = 0x8009_0353,
    PkInitClientFailure = 0x8009_0354,
    SmartCardCertExpired = 0x8009_0355,
    NoS4uProtSupport = 0x8009_0356,
    CrossRealmDelegationFailure = 0x8009_0357,
    RevocationOfflineKdc = 0x8009_0358,
    IssuingCaUntrustedKdc = 0x8009_0359,
    KdcCertExpired = 0x8009_035A,
    KdcCertRevoked = 0x8009_035B,
    InvalidParameter = 0x8009_035D,
    DelegationPolicy = 0x8009_035E,
    PolicyNtlmOnly = 0x8009_035F,
    NoContext = 0x8009_0361,
    Pku2uCertFailure = 0x8009_0362,
    MutualAuthFailed = 0x8009_0363,
    OnlyHttpsAllowed = 0x8009_0365,
    ApplicationProtocolMismatch = 0x8009_0367,
}

/// Holds the `ErrorKind` and the description of the SSPI-related error.
#[derive(Debug, Clone)]
pub struct Error {
    pub error_type: ErrorKind,
    pub description: String,
    pub nstatus: Option<credssp::NStatusCode>,
}

/// The success status of SSPI-related operation.
#[derive(Debug, Copy, Clone, Eq, PartialEq, FromPrimitive, ToPrimitive)]
pub enum SecurityStatus {
    Ok = 0,
    ContinueNeeded = 0x0009_0312,
    CompleteNeeded = 0x0009_0313,
    CompleteAndContinue = 0x0009_0314,
    LocalLogon = 0x0009_0315,
    ContextExpired = 0x0009_0317,
    IncompleteCredentials = 0x0009_0320,
    Renegotiate = 0x0009_0321,
    NoLsaContext = 0x0009_0323,
}

impl Error {
    /// Allows to fill a new error easily, supplying it with a coherent description.
    pub fn new(error_type: ErrorKind, description: impl ToString) -> Self {
        Self {
            error_type,
            description: description.to_string(),
            nstatus: None,
        }
    }

    pub fn new_with_nstatus(
        error_type: ErrorKind,
        description: impl Into<String>,
        status_code: credssp::NStatusCode,
    ) -> Self {
        Self {
            error_type,
            description: description.into(),
            nstatus: Some(status_code),
        }
    }
}

impl error::Error for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{:?}: {}", self.error_type, self.description)?;

        if let Some(nstatus) = self.nstatus {
            write!(f, "; status is {}", nstatus)?;
        }

        Ok(())
    }
}

impl From<auth_identity::UsernameError> for Error {
    fn from(value: auth_identity::UsernameError) -> Self {
        Error::new(ErrorKind::UnknownCredentials, value)
    }
}

impl From<rsa::Error> for Error {
    fn from(value: rsa::Error) -> Self {
        Error::new(
            ErrorKind::InternalError,
            format!("an unexpected RsaError happened: {}", value),
        )
    }
}

impl From<Asn1DerError> for Error {
    fn from(err: Asn1DerError) -> Self {
        Self::new(ErrorKind::InvalidToken, format!("ASN1 DER error: {:?}", err))
    }
}

impl From<KrbError> for Error {
    fn from(krb_error: KrbError) -> Self {
        let (error_kind, mut description) = map_keb_error_code_to_sspi_error(krb_error.0.error_code.0);

        // https://www.rfc-editor.org/rfc/rfc4120#section-5.9.1

        // This field contains additional text to help explain the error code
        // associated with the failed request
        if let Some(e_text) = krb_error.0.e_text.0 {
            description.push_str(&format!(". Additional error text: {:?}", e_text.0));
        }

        // This field contains additional data about the error for use by the
        // application to help it recover from or handle the error.
        if let Some(e_data) = krb_error.0.e_data.0 {
            description.push_str(&format!(". Additional error data: {:?}", e_data.0));
        }

        Error::new(error_kind, description)
    }
}

impl From<picky_krb::crypto::KerberosCryptoError> for Error {
    fn from(err: picky_krb::crypto::KerberosCryptoError) -> Self {
        use picky_krb::crypto::KerberosCryptoError;

        match err {
            KerberosCryptoError::KeyLength(actual, expected) => Self::new(
                ErrorKind::InvalidParameter,
                format!("invalid key length. actual: {}. expected: {}", actual, expected),
            ),
            KerberosCryptoError::CipherLength(actual, expected) => Self::new(
                ErrorKind::InvalidParameter,
                format!("invalid cipher length. actual: {}. expected: {}", actual, expected),
            ),
            KerberosCryptoError::AlgorithmIdentifier(identifier) => Self::new(
                ErrorKind::InvalidParameter,
                format!("unknown algorithm identifier: {}", identifier),
            ),
            KerberosCryptoError::IntegrityCheck => Self::new(ErrorKind::MessageAltered, err.to_string()),
            KerberosCryptoError::CipherError(description) => Self::new(ErrorKind::InvalidParameter, description),
            KerberosCryptoError::CipherPad(description) => {
                Self::new(ErrorKind::InvalidParameter, description.to_string())
            }
            KerberosCryptoError::CipherUnpad(description) => {
                Self::new(ErrorKind::InvalidParameter, description.to_string())
            }
            KerberosCryptoError::SeedBitLen(description) => Self::new(ErrorKind::InvalidParameter, description),
            KerberosCryptoError::AlgorithmIdentifierData(identifier) => Self::new(
                ErrorKind::InvalidParameter,
                format!("unknown algorithm identifier: {:?}", identifier),
            ),
        }
    }
}

impl From<picky_krb::crypto::diffie_hellman::DiffieHellmanError> for Error {
    fn from(error: picky_krb::crypto::diffie_hellman::DiffieHellmanError) -> Self {
        use picky_krb::crypto::diffie_hellman::DiffieHellmanError;

        match error {
            DiffieHellmanError::BitLen(description) => Self::new(ErrorKind::InternalError, description),
            error => Self::new(ErrorKind::InternalError, error.to_string()),
        }
    }
}

impl From<CharSetError> for Error {
    fn from(err: CharSetError) -> Self {
        Self::new(ErrorKind::InternalError, err.to_string())
    }
}

impl From<GssApiMessageError> for Error {
    fn from(err: GssApiMessageError) -> Self {
        match err {
            GssApiMessageError::IoError(err) => Self::from(err),
            GssApiMessageError::InvalidId(_, _) => Self::new(ErrorKind::InvalidToken, err.to_string()),
            GssApiMessageError::InvalidMicFiller(_) => Self::new(ErrorKind::InvalidToken, err.to_string()),
            GssApiMessageError::InvalidWrapFiller(_) => Self::new(ErrorKind::InvalidToken, err.to_string()),
            GssApiMessageError::Asn1Error(_) => Self::new(ErrorKind::InvalidToken, err.to_string()),
        }
    }
}

impl From<io::Error> for Error {
    fn from(err: io::Error) -> Self {
        Self::new(ErrorKind::InternalError, format!("IO error: {:?}", err))
    }
}

impl From<rand::Error> for Error {
    fn from(err: rand::Error) -> Self {
        Self::new(ErrorKind::InternalError, format!("rand error: {:?}", err))
    }
}

impl From<std::str::Utf8Error> for Error {
    fn from(err: std::str::Utf8Error) -> Self {
        Self::new(ErrorKind::InternalError, err)
    }
}

impl From<std::string::FromUtf8Error> for Error {
    fn from(err: std::string::FromUtf8Error) -> Self {
        Self::new(ErrorKind::InternalError, format!("UTF-8 error: {:?}", err))
    }
}

impl From<string::FromUtf16Error> for Error {
    fn from(err: string::FromUtf16Error) -> Self {
        Self::new(ErrorKind::InternalError, format!("UTF-16 error: {:?}", err))
    }
}

impl From<Error> for io::Error {
    fn from(err: Error) -> io::Error {
        io::Error::new(
            io::ErrorKind::Other,
            format!("{:?}: {}", err.error_type, err.description),
        )
    }
}

impl From<std::num::TryFromIntError> for Error {
    fn from(_: std::num::TryFromIntError) -> Self {
        Self::new(ErrorKind::InternalError, "integer conversion error")
    }
}

impl<T> From<std::sync::PoisonError<T>> for Error {
    fn from(_: std::sync::PoisonError<T>) -> Self {
        Self::new(ErrorKind::InternalError, "can not lock SspiHandle mutex")
    }
}

impl From<picky::key::KeyError> for Error {
    fn from(err: picky::key::KeyError) -> Self {
        Self::new(ErrorKind::InternalError, format!("RSA key error: {:?}", err))
    }
}

#[cfg(feature = "scard")]
impl From<winscard::Error> for Error {
    fn from(value: winscard::Error) -> Self {
        Self::new(
            ErrorKind::InternalError,
            format!("Error while using a smart card: {}", value),
        )
    }
}


--- File: src/negotiate.rs ---
use std::fmt::Debug;
use std::net::IpAddr;
use std::sync::LazyLock;

use crate::generator::{
    GeneratorAcceptSecurityContext, GeneratorChangePassword, GeneratorInitSecurityContext, YieldPointLocal,
};
use crate::kdc::detect_kdc_url;
use crate::kerberos::client::generators::get_client_principal_realm;
use crate::ntlm::NtlmConfig;
#[allow(unused)]
use crate::utils::is_azure_ad_domain;
use crate::{
    builders, kerberos, ntlm, pku2u, AcceptSecurityContextResult, AcquireCredentialsHandleResult, AuthIdentity,
    CertTrustStatus, ContextNames, ContextSizes, CredentialUse, Credentials, CredentialsBuffers, DecryptionFlags,
    Error, ErrorKind, InitializeSecurityContextResult, Kerberos, KerberosConfig, Ntlm, PackageCapabilities,
    PackageInfo, Pku2u, Result, SecurityBuffer, SecurityBufferRef, SecurityPackageType, SecurityStatus, Sspi, SspiEx,
    SspiImpl, PACKAGE_ID_NONE,
};

pub const PKG_NAME: &str = "Negotiate";

pub static PACKAGE_INFO: LazyLock<PackageInfo> = LazyLock::new(|| PackageInfo {
    capabilities: PackageCapabilities::empty(),
    rpc_id: PACKAGE_ID_NONE,
    max_token_len: 0xbb80, // 48 000 bytes: default maximum token len in Windows
    name: SecurityPackageType::Negotiate,
    comment: String::from("Microsoft Package Negotiator"),
});

pub trait ProtocolConfig: Debug + Send + Sync {
    fn new_instance(&self) -> Result<NegotiatedProtocol>;
    fn box_clone(&self) -> Box<dyn ProtocolConfig>;
}

#[derive(Debug)]
pub struct NegotiateConfig {
    pub protocol_config: Box<dyn ProtocolConfig>,
    pub package_list: Option<String>,
    /// Computer name, or "workstation name", of the client machine performing the authentication attempt
    ///
    /// This is also referred to as the "Source Workstation", i.e.: the name of the computer attempting to logon.
    pub client_computer_name: String,
}

impl NegotiateConfig {
    /// package_list format, "kerberos,ntlm,pku2u"
    pub fn new(
        protocol_config: Box<dyn ProtocolConfig + Send>,
        package_list: Option<String>,
        client_computer_name: String,
    ) -> Self {
        Self {
            protocol_config,
            package_list,
            client_computer_name,
        }
    }

    pub fn from_protocol_config(protocol_config: Box<dyn ProtocolConfig + Send>, client_computer_name: String) -> Self {
        Self {
            protocol_config,
            package_list: None,
            client_computer_name,
        }
    }
}

impl Clone for NegotiateConfig {
    fn clone(&self) -> Self {
        Self {
            protocol_config: self.protocol_config.box_clone(),
            package_list: None,
            client_computer_name: self.client_computer_name.clone(),
        }
    }
}

#[allow(clippy::large_enum_variant)]
#[derive(Debug, Clone)]
pub enum NegotiatedProtocol {
    Pku2u(Pku2u),
    Kerberos(Kerberos),
    Ntlm(Ntlm),
}

impl NegotiatedProtocol {
    pub fn protocol_name(&self) -> &str {
        match self {
            NegotiatedProtocol::Pku2u(_) => pku2u::PKG_NAME,
            NegotiatedProtocol::Kerberos(_) => kerberos::PKG_NAME,
            NegotiatedProtocol::Ntlm(_) => ntlm::PKG_NAME,
        }
    }
}

#[derive(Clone, Debug)]
pub struct Negotiate {
    protocol: NegotiatedProtocol,
    package_list: Option<String>,
    auth_identity: Option<CredentialsBuffers>,
    client_computer_name: String,
    is_client: bool,
}

struct PackageListConfig {
    ntlm: bool,
    kerberos: bool,
    pku2u: bool,
}

impl Negotiate {
    pub fn new_client(config: NegotiateConfig) -> Result<Self> {
        let is_client = true;
        let mut protocol = config.protocol_config.new_instance()?;
        if let Some(filtered_protocol) =
            Self::filter_protocol(&protocol, &config.package_list, &config.client_computer_name, is_client)?
        {
            protocol = filtered_protocol;
        }

        Ok(Negotiate {
            protocol,
            package_list: config.package_list,
            auth_identity: None,
            client_computer_name: config.client_computer_name,
            is_client,
        })
    }

    pub fn new_server(config: NegotiateConfig) -> Result<Self> {
        let is_client = false;
        let mut protocol = config.protocol_config.new_instance()?;
        if let Some(filtered_protocol) =
            Self::filter_protocol(&protocol, &config.package_list, &config.client_computer_name, is_client)?
        {
            protocol = filtered_protocol;
        }

        Ok(Negotiate {
            protocol,
            package_list: config.package_list,
            auth_identity: None,
            client_computer_name: config.client_computer_name,
            is_client,
        })
    }

    // negotiates the authorization protocol based on the username and the domain
    // Decision rules:
    // 1) if `self.protocol` is not NTLM then we've already negotiated a suitable protocol. Nothing to do.
    // 2) if the provided domain is Azure AD domain then it'll use Pku2u
    // 3) if the provided username is FQDN and we can resolve KDC then it'll use Kerberos
    // 4) if SSPI_KDC_URL_ENV is set then it'll also use Kerberos
    // 5) in any other cases, it'll use NTLM
    #[instrument(ret, level = "debug", fields(protocol = self.protocol.protocol_name()), skip(self))]
    fn negotiate_protocol(&mut self, username: &str, domain: &str) -> Result<()> {
        let enabled_packages = Self::parse_package_list_config(&self.package_list);

        if let NegotiatedProtocol::Ntlm(_) = &self.protocol {
            #[cfg(target_os = "windows")]
            if enabled_packages.pku2u && is_azure_ad_domain(domain) {
                use super::pku2u::Pku2uConfig;

                debug!("Negotiate: try Pku2u");

                self.protocol = NegotiatedProtocol::Pku2u(Pku2u::new_client_from_config(
                    Pku2uConfig::default_client_config(self.client_computer_name.clone())?,
                )?);
            }

            if enabled_packages.kerberos {
                if let Some(host) = detect_kdc_url(&get_client_principal_realm(username, domain)) {
                    debug!("Negotiate: try Kerberos");

                    self.protocol =
                        NegotiatedProtocol::Kerberos(Kerberos::new_client_from_config(crate::KerberosConfig {
                            kdc_url: Some(host),
                            client_computer_name: Some(self.client_computer_name.clone()),
                        })?);
                }
            }
        }

        if let Some(filtered_protocol) = Self::filter_protocol(
            &self.protocol,
            &self.package_list,
            &self.client_computer_name,
            self.is_client,
        )? {
            self.protocol = filtered_protocol;
        }

        Ok(())
    }

    fn parse_package_list_config(package_list: &Option<String>) -> PackageListConfig {
        let mut ntlm: bool = true;
        let mut kerberos: bool = true;
        let mut pku2u: bool = true;

        if let Some(package_list) = &package_list {
            for package in package_list.split(',') {
                let (package_name, enabled) = if let Some(package_name) = package.strip_prefix('!') {
                    (package_name.to_lowercase(), false)
                } else {
                    let package_name = package.to_lowercase();
                    (package_name, true)
                };

                match package_name.as_str() {
                    "ntlm" => ntlm = enabled,
                    "kerberos" => kerberos = enabled,
                    "pku2u" => pku2u = enabled,
                    _ => eprintln!("unexpected package name: {}", &package_name),
                }
            }
        }

        PackageListConfig { ntlm, kerberos, pku2u }
    }

    fn filter_protocol(
        negotiated_protocol: &NegotiatedProtocol,
        package_list: &Option<String>,
        client_computer_name: &str,
        is_client: bool,
    ) -> Result<Option<NegotiatedProtocol>> {
        let mut filtered_protocol = None;
        let PackageListConfig {
            ntlm: is_ntlm,
            kerberos: is_kerberos,
            pku2u: is_pku2u,
        } = Self::parse_package_list_config(package_list);

        match &negotiated_protocol {
            NegotiatedProtocol::Pku2u(pku2u) => {
                if !is_pku2u {
                    let ntlm_config = NtlmConfig::new(pku2u.config().client_hostname.clone());
                    filtered_protocol = Some(NegotiatedProtocol::Ntlm(Ntlm::with_config(ntlm_config)));
                }
            }
            NegotiatedProtocol::Kerberos(kerberos) => {
                if !is_kerberos {
                    let ntlm_config = kerberos
                        .config()
                        .client_computer_name
                        .clone()
                        .map(NtlmConfig::new)
                        .unwrap_or_default();
                    filtered_protocol = Some(NegotiatedProtocol::Ntlm(Ntlm::with_config(ntlm_config)));
                }
            }
            NegotiatedProtocol::Ntlm(_) => {
                if !is_ntlm {
                    let config = KerberosConfig {
                        client_computer_name: Some(client_computer_name.to_owned()),
                        kdc_url: None,
                    };

                    if is_client {
                        let kerberos_client = Kerberos::new_client_from_config(config)?;
                        filtered_protocol = Some(NegotiatedProtocol::Kerberos(kerberos_client));
                    } else {
                        // Aborting because we need an additional data (ServerProperties object) to create the server-side Kerberos instance.
                        error!(
                            ?package_list,
                            "NTLM protocol has been negotiated but it is disabled in package_list."
                        );

                        return Err(Error::new(
                            ErrorKind::InternalError,
                            "NTLM protocol has been negotiated but it is disabled in package_list",
                        ));
                    }
                }
            }
        }

        Ok(filtered_protocol)
    }

    pub fn negotiated_protocol(&self) -> &NegotiatedProtocol {
        &self.protocol
    }

    fn is_protocol_ntlm(&self) -> bool {
        matches!(&self.protocol, NegotiatedProtocol::Ntlm(_))
    }

    fn can_downgrade_ntlm(&self) -> bool {
        let package_list = Self::parse_package_list_config(&self.package_list);
        package_list.ntlm
    }

    fn is_target_name_ip_address(address: &str) -> bool {
        let stripped_address = address.split('/').next_back().unwrap_or(address);
        stripped_address.parse::<IpAddr>().is_ok()
    }

    fn check_target_name_for_ntlm_downgrade(&mut self, target_name: &str) {
        let should_downgrade = Self::is_target_name_ip_address(target_name);
        let can_downgrade = self.can_downgrade_ntlm();

        if can_downgrade && should_downgrade && !self.is_protocol_ntlm() {
            let ntlm_config = NtlmConfig::new(self.client_computer_name.clone());
            self.protocol = NegotiatedProtocol::Ntlm(Ntlm::with_config(ntlm_config));
        }
    }
}

impl SspiEx for Negotiate {
    #[instrument(ret, level = "debug", fields(protocol = self.protocol.protocol_name()), skip_all)]
    fn custom_set_auth_identity(&mut self, identity: Self::AuthenticationData) -> Result<()> {
        self.auth_identity = Some(identity.clone().try_into().unwrap());

        match &mut self.protocol {
            NegotiatedProtocol::Pku2u(pku2u) => {
                pku2u.custom_set_auth_identity(identity.auth_identity().ok_or_else(|| {
                    Error::new(
                        ErrorKind::IncompleteCredentials,
                        "Provided credentials are not password-based",
                    )
                })?)
            }
            NegotiatedProtocol::Kerberos(kerberos) => kerberos.custom_set_auth_identity(identity),
            NegotiatedProtocol::Ntlm(ntlm) => {
                ntlm.custom_set_auth_identity(identity.auth_identity().ok_or_else(|| {
                    Error::new(
                        ErrorKind::IncompleteCredentials,
                        "Provided credentials are not password-based",
                    )
                })?)
            }
        }
    }
}

impl Sspi for Negotiate {
    #[instrument(ret, level = "debug", fields(protocol = self.protocol.protocol_name()), skip(self))]
    fn complete_auth_token(&mut self, token: &mut [SecurityBuffer]) -> Result<SecurityStatus> {
        match &mut self.protocol {
            NegotiatedProtocol::Pku2u(pku2u) => pku2u.complete_auth_token(token),
            NegotiatedProtocol::Kerberos(kerberos) => kerberos.complete_auth_token(token),
            NegotiatedProtocol::Ntlm(ntlm) => ntlm.complete_auth_token(token),
        }
    }

    #[instrument(ret, level = "debug", fields(protocol = self.protocol.protocol_name()), skip_all)]
    fn encrypt_message(
        &mut self,
        flags: crate::EncryptionFlags,
        message: &mut [SecurityBufferRef],
        sequence_number: u32,
    ) -> Result<SecurityStatus> {
        match &mut self.protocol {
            NegotiatedProtocol::Pku2u(pku2u) => pku2u.encrypt_message(flags, message, sequence_number),
            NegotiatedProtocol::Kerberos(kerberos) => kerberos.encrypt_message(flags, message, sequence_number),
            NegotiatedProtocol::Ntlm(ntlm) => ntlm.encrypt_message(flags, message, sequence_number),
        }
    }

    #[instrument(ret, level = "debug", fields(protocol = self.protocol.protocol_name()), skip_all)]
    fn decrypt_message(
        &mut self,
        message: &mut [SecurityBufferRef<'_>],
        sequence_number: u32,
    ) -> Result<DecryptionFlags> {
        match &mut self.protocol {
            NegotiatedProtocol::Pku2u(pku2u) => pku2u.decrypt_message(message, sequence_number),
            NegotiatedProtocol::Kerberos(kerberos) => kerberos.decrypt_message(message, sequence_number),
            NegotiatedProtocol::Ntlm(ntlm) => ntlm.decrypt_message(message, sequence_number),
        }
    }

    #[instrument(ret, level = "debug", fields(protocol = self.protocol.protocol_name()), skip_all)]
    fn query_context_sizes(&mut self) -> Result<ContextSizes> {
        match &mut self.protocol {
            NegotiatedProtocol::Pku2u(pku2u) => pku2u.query_context_sizes(),
            NegotiatedProtocol::Kerberos(kerberos) => kerberos.query_context_sizes(),
            NegotiatedProtocol::Ntlm(ntlm) => ntlm.query_context_sizes(),
        }
    }

    #[instrument(ret, level = "debug", fields(protocol = self.protocol.protocol_name()), skip_all)]
    fn query_context_names(&mut self) -> Result<ContextNames> {
        match &mut self.protocol {
            NegotiatedProtocol::Pku2u(pku2u) => pku2u.query_context_names(),
            NegotiatedProtocol::Kerberos(kerberos) => kerberos.query_context_names(),
            NegotiatedProtocol::Ntlm(ntlm) => ntlm.query_context_names(),
        }
    }

    #[instrument(ret, level = "debug", fields(protocol = self.protocol.protocol_name()), skip_all)]
    fn query_context_package_info(&mut self) -> Result<PackageInfo> {
        crate::query_security_package_info(SecurityPackageType::Negotiate)
    }

    #[instrument(ret, level = "debug", fields(protocol = self.protocol.protocol_name()), skip_all)]
    fn query_context_negotiation_package(&mut self) -> Result<PackageInfo> {
        match &mut self.protocol {
            NegotiatedProtocol::Pku2u(pku2u) => pku2u.query_context_package_info(),
            NegotiatedProtocol::Kerberos(kerberos) => kerberos.query_context_package_info(),
            NegotiatedProtocol::Ntlm(ntlm) => ntlm.query_context_package_info(),
        }
    }

    #[instrument(ret, level = "debug", fields(protocol = self.protocol.protocol_name()), skip_all)]
    fn query_context_cert_trust_status(&mut self) -> Result<CertTrustStatus> {
        match &mut self.protocol {
            NegotiatedProtocol::Pku2u(pku2u) => pku2u.query_context_cert_trust_status(),
            NegotiatedProtocol::Kerberos(kerberos) => kerberos.query_context_cert_trust_status(),
            NegotiatedProtocol::Ntlm(ntlm) => ntlm.query_context_cert_trust_status(),
        }
    }

    #[instrument(fields(protocol = self.protocol.protocol_name()), skip_all)]
    fn query_context_session_key(&self) -> Result<crate::SessionKeys> {
        match &self.protocol {
            NegotiatedProtocol::Pku2u(pku2u) => pku2u.query_context_session_key(),
            NegotiatedProtocol::Kerberos(kerberos) => kerberos.query_context_session_key(),
            NegotiatedProtocol::Ntlm(ntlm) => ntlm.query_context_session_key(),
        }
    }

    fn change_password<'a>(
        &'a mut self,
        change_password: builders::ChangePassword<'a>,
    ) -> Result<GeneratorChangePassword<'a>> {
        Ok(GeneratorChangePassword::new(move |mut yield_point| async move {
            self.change_password(&mut yield_point, change_password).await
        }))
    }

    fn make_signature(
        &mut self,
        flags: u32,
        message: &mut [SecurityBufferRef],
        sequence_number: u32,
    ) -> crate::Result<()> {
        match &mut self.protocol {
            NegotiatedProtocol::Pku2u(pku2u) => pku2u.make_signature(flags, message, sequence_number),
            NegotiatedProtocol::Kerberos(kerberos) => kerberos.make_signature(flags, message, sequence_number),
            NegotiatedProtocol::Ntlm(ntlm) => ntlm.make_signature(flags, message, sequence_number),
        }
    }

    fn verify_signature(&mut self, message: &mut [SecurityBufferRef], sequence_number: u32) -> crate::Result<u32> {
        match &mut self.protocol {
            NegotiatedProtocol::Pku2u(pku2u) => pku2u.verify_signature(message, sequence_number),
            NegotiatedProtocol::Kerberos(kerberos) => kerberos.verify_signature(message, sequence_number),
            NegotiatedProtocol::Ntlm(ntlm) => ntlm.verify_signature(message, sequence_number),
        }
    }
}

impl SspiImpl for Negotiate {
    type CredentialsHandle = Option<CredentialsBuffers>;
    type AuthenticationData = Credentials;

    #[instrument(ret, level = "debug", fields(protocol = self.protocol.protocol_name()), skip_all)]
    fn acquire_credentials_handle_impl(
        &mut self,
        builder: builders::FilledAcquireCredentialsHandle<'_, Self::CredentialsHandle, Self::AuthenticationData>,
    ) -> Result<AcquireCredentialsHandleResult<Self::CredentialsHandle>> {
        if builder.credential_use == CredentialUse::Outbound && builder.auth_data.is_none() {
            return Err(Error::new(
                ErrorKind::NoCredentials,
                "The client must specify the auth data",
            ));
        }

        if let Some(Credentials::AuthIdentity(identity)) = builder.auth_data {
            let account_name = identity.username.account_name();
            let domain_name = identity.username.domain_name().unwrap_or("");
            self.negotiate_protocol(account_name, domain_name)?;
        }

        self.auth_identity = builder
            .auth_data
            .cloned()
            .map(|auth_data| auth_data.try_into())
            .transpose()?;

        match &mut self.protocol {
            NegotiatedProtocol::Pku2u(pku2u) => {
                let auth_identity = if let Some(Credentials::AuthIdentity(identity)) = builder.auth_data {
                    identity
                } else {
                    return Err(Error::new(
                        ErrorKind::NoCredentials,
                        "Auth identity is not provided for the Pku2u",
                    ));
                };
                let new_builder = builder.full_transform(Some(auth_identity));
                new_builder.execute(pku2u)?;
            }
            NegotiatedProtocol::Kerberos(kerberos) => {
                kerberos.acquire_credentials_handle_impl(builder)?;
            }
            NegotiatedProtocol::Ntlm(ntlm) => {
                let auth_identity = if builder.credential_use == CredentialUse::Outbound {
                    if let Some(Credentials::AuthIdentity(identity)) = builder.auth_data {
                        Some(identity)
                    } else {
                        return Err(Error::new(
                            ErrorKind::NoCredentials,
                            "Auth identity is not provided for the Ntlm",
                        ));
                    }
                } else {
                    None
                };
                let new_builder = builder.full_transform(auth_identity);
                new_builder.execute(ntlm)?;
            }
        };

        Ok(AcquireCredentialsHandleResult {
            credentials_handle: self.auth_identity.clone(),
            expiry: None,
        })
    }

    #[instrument(ret, level = "debug", fields(protocol = self.protocol.protocol_name()), skip_all)]
    fn accept_security_context_impl<'a>(
        &'a mut self,
        builder: builders::FilledAcceptSecurityContext<'a, Self::CredentialsHandle>,
    ) -> Result<GeneratorAcceptSecurityContext<'a>> {
        Ok(GeneratorAcceptSecurityContext::new(move |mut yield_point| async move {
            self.accept_security_context_impl(&mut yield_point, builder).await
        }))
    }

    fn initialize_security_context_impl<'ctx, 'b, 'g>(
        &'ctx mut self,
        builder: &'b mut builders::FilledInitializeSecurityContext<'ctx, Self::CredentialsHandle>,
    ) -> Result<GeneratorInitSecurityContext<'g>>
    where
        'ctx: 'g,
        'b: 'g,
    {
        Ok(GeneratorInitSecurityContext::new(move |mut yield_point| async move {
            self.initialize_security_context_impl(&mut yield_point, builder).await
        }))
    }
}

impl<'a> Negotiate {
    #[instrument(ret, level = "debug", fields(protocol = self.protocol.protocol_name()), skip_all)]
    pub(crate) async fn change_password(
        &'a mut self,
        yield_point: &mut YieldPointLocal,
        change_password: builders::ChangePassword<'a>,
    ) -> Result<()> {
        self.negotiate_protocol(&change_password.account_name, &change_password.domain_name)?;

        match &mut self.protocol {
            NegotiatedProtocol::Kerberos(kerberos) => kerberos.change_password(yield_point, change_password).await,
            _ => Err(crate::Error::new(
                ErrorKind::UnsupportedFunction,
                "cannot change password for this protocol",
            )),
        }
    }

    pub(crate) async fn accept_security_context_impl(
        &mut self,
        yield_point: &mut YieldPointLocal,
        builder: builders::FilledAcceptSecurityContext<'a, <Self as SspiImpl>::CredentialsHandle>,
    ) -> Result<AcceptSecurityContextResult> {
        match &mut self.protocol {
            NegotiatedProtocol::Pku2u(pku2u) => {
                let mut creds_handle = builder
                    .credentials_handle
                    .as_ref()
                    .and_then(|creds| (*creds).clone())
                    .and_then(|creds_handle| creds_handle.auth_identity());
                let new_builder = builder.full_transform(Some(&mut creds_handle));
                pku2u.accept_security_context_impl(yield_point, new_builder).await
            }
            NegotiatedProtocol::Kerberos(kerberos) => kerberos.accept_security_context_impl(yield_point, builder).await,
            NegotiatedProtocol::Ntlm(ntlm) => {
                let mut creds_handle = builder
                    .credentials_handle
                    .as_ref()
                    .and_then(|creds| (*creds).clone())
                    .and_then(|creds_handle| creds_handle.auth_identity());
                let new_builder = builder.full_transform(Some(&mut creds_handle));
                ntlm.accept_security_context_impl(new_builder)
            }
        }
    }

    #[instrument(ret, fields(protocol = self.protocol.protocol_name()), skip_all)]
    pub(crate) async fn initialize_security_context_impl(
        &'a mut self,
        yield_point: &mut YieldPointLocal,
        builder: &'a mut builders::FilledInitializeSecurityContext<'_, <Self as SspiImpl>::CredentialsHandle>,
    ) -> Result<InitializeSecurityContextResult> {
        if let Some(target_name) = &builder.target_name {
            self.check_target_name_for_ntlm_downgrade(target_name);
        }

        if let Some(Some(CredentialsBuffers::AuthIdentity(identity))) = builder.credentials_handle {
            let auth_identity =
                AuthIdentity::try_from(&*identity).map_err(|e| Error::new(ErrorKind::InvalidParameter, e))?;
            let account_name = auth_identity.username.account_name();
            let domain_name = auth_identity.username.domain_name().unwrap_or("");
            self.negotiate_protocol(account_name, domain_name)?;
            self.auth_identity = Some(CredentialsBuffers::AuthIdentity(auth_identity.into()));
        }

        if let Some(Some(CredentialsBuffers::SmartCard(identity))) = builder.credentials_handle {
            if let NegotiatedProtocol::Ntlm(_) = &self.protocol {
                let username = crate::utils::bytes_to_utf16_string(&identity.username);
                let host = detect_kdc_url(&get_client_principal_realm(&username, ""))
                    .ok_or_else(|| Error::new(ErrorKind::NoAuthenticatingAuthority, "can not detect KDC url"))?;
                debug!("Negotiate: try Kerberos");

                let config = crate::KerberosConfig {
                    kdc_url: Some(host),
                    client_computer_name: Some(self.client_computer_name.clone()),
                };

                self.protocol = NegotiatedProtocol::Kerberos(Kerberos::new_client_from_config(config)?);
            }
        }

        if let NegotiatedProtocol::Kerberos(kerberos) = &mut self.protocol {
            match kerberos.initialize_security_context_impl(yield_point, builder).await {
                Result::Err(Error {
                    error_type: ErrorKind::NoCredentials,
                    ..
                }) => {
                    warn!("Negotiate: Fall back to the NTLM");

                    let ntlm_config = kerberos
                        .config()
                        .client_computer_name
                        .clone()
                        .map(NtlmConfig::new)
                        .unwrap_or_default();
                    self.protocol = NegotiatedProtocol::Ntlm(Ntlm::with_auth_identity(
                        self.auth_identity.clone().and_then(|c| c.auth_identity()),
                        ntlm_config,
                    ));
                }
                result => return result,
            };
        }

        match &mut self.protocol {
            NegotiatedProtocol::Pku2u(pku2u) => {
                let mut credentials_handle = self.auth_identity.as_mut().and_then(|c| c.clone().auth_identity());
                let mut transformed_builder = builder.full_transform(Some(&mut credentials_handle));

                pku2u.initialize_security_context_impl(&mut transformed_builder)
            }
            NegotiatedProtocol::Kerberos(kerberos) => {
                kerberos.initialize_security_context_impl(yield_point, builder).await
            }
            NegotiatedProtocol::Ntlm(ntlm) => {
                let mut credentials_handle = self.auth_identity.as_mut().and_then(|c| c.clone().auth_identity());
                let mut transformed_builder = builder.full_transform(Some(&mut credentials_handle));

                ntlm.initialize_security_context_impl(&mut transformed_builder)
            }
        }
    }
}


--- File: src/network_client.rs ---
use std::fmt::Debug;
use std::future::Future;
use std::pin::Pin;

use crate::generator::NetworkRequest;
use crate::Result;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum NetworkProtocol {
    Tcp,
    Udp,
    Http,
    Https,
}

impl NetworkProtocol {
    pub const ALL: &'static [Self] = &[Self::Tcp, Self::Udp, Self::Http, Self::Https];

    pub(crate) fn from_url_scheme(scheme: &str) -> Option<Self> {
        match scheme {
            "tcp" => Some(Self::Tcp),
            "udp" => Some(Self::Udp),
            "http" => Some(Self::Http),
            "https" => Some(Self::Https),
            _ => None,
        }
    }
}

/// Represents an abstract asynchronous network client.
///
/// This trait is primarily used for implementing network clients for WASM target
/// and in other cases where a synchronous network client is not an option.
pub trait AsyncNetworkClient: Send + Sync {
    /// Send request to the server and return the response.
    ///
    /// URL scheme is guaranteed to be the same as specified by `protocol` argument.
    /// `sspi-rs` will call this method only if `NetworkClient::is_protocol_supported`
    /// returned true prior to the call, so unsupported `protocol` values could be marked as `unreachable!`.
    fn send<'a>(
        &'a mut self,
        network_request: &'a NetworkRequest,
    ) -> Pin<Box<dyn Future<Output = Result<Vec<u8>>> + Send + 'a>>;
}

pub trait NetworkClient: Send + Sync {
    /// Send request to the server and return the response. URL scheme is guaranteed to be
    /// the same as specified by `protocol` argument. `sspi-rs` will call this method only if
    /// `NetworkClient::is_protocol_supported` returned true prior to the call, so unsupported
    /// `protocol` values could be marked as `unreachable!`.
    fn send(&self, request: &NetworkRequest) -> Result<Vec<u8>>;
}

#[cfg(feature = "network_client")]
pub mod reqwest_network_client {
    use std::io::{Read, Write};
    use std::net::{IpAddr, Ipv4Addr, TcpStream, UdpSocket};

    use byteorder::{BigEndian, ReadBytesExt};
    use url::Url;

    use super::{NetworkClient, NetworkProtocol};
    use crate::generator::NetworkRequest;
    use crate::{Error, ErrorKind, Result};

    #[derive(Debug, Clone, Default)]
    pub struct ReqwestNetworkClient;

    impl ReqwestNetworkClient {
        fn send_tcp(&self, url: &Url, data: &[u8]) -> Result<Vec<u8>> {
            let addr = format!("{}:{}", url.host_str().unwrap_or_default(), url.port().unwrap_or(88));
            let mut stream = TcpStream::connect(addr)
                .map_err(|e| Error::new(ErrorKind::NoAuthenticatingAuthority, format!("{:?}", e)))?;

            stream
                .write(data)
                .map_err(|e| Error::new(ErrorKind::NoAuthenticatingAuthority, format!("{:?}", e)))?;

            let len = stream
                .read_u32::<BigEndian>()
                .map_err(|e| Error::new(ErrorKind::NoAuthenticatingAuthority, format!("{:?}", e)))?;

            let mut buf = vec![0; len as usize + 4];
            buf[0..4].copy_from_slice(&(len.to_be_bytes()));

            stream
                .read_exact(&mut buf[4..])
                .map_err(|e| Error::new(ErrorKind::NoAuthenticatingAuthority, format!("{:?}", e)))?;

            Ok(buf)
        }

        fn send_udp(&self, url: &Url, data: &[u8]) -> Result<Vec<u8>> {
            let port =
                portpicker::pick_unused_port().ok_or_else(|| Error::new(ErrorKind::InternalError, "No free ports"))?;
            let udp_socket = UdpSocket::bind((IpAddr::V4(Ipv4Addr::LOCALHOST), port))?;

            let addr = format!("{}:{}", url.host_str().unwrap_or_default(), url.port().unwrap_or(88));
            udp_socket.send_to(data, addr)?;

            // 48 000 bytes: default maximum token len in Windows
            let mut buf = vec![0; 0xbb80];

            let n = udp_socket.recv(&mut buf)?;

            let mut reply_buf = Vec::with_capacity(n + 4);
            reply_buf.extend_from_slice(&(n as u32).to_be_bytes());
            reply_buf.extend_from_slice(&buf[0..n]);

            Ok(reply_buf)
        }

        fn send_http(&self, url: &Url, data: &[u8]) -> Result<Vec<u8>> {
            crate::rustls::install_default_crypto_provider_if_necessary().map_err(|()| {
                Error::new(
                    ErrorKind::SecurityPackageNotFound,
                    "failed to install the default crypto provider for TLS",
                )
            })?;

            let client = crate::rustls::load_native_certs(reqwest::blocking::ClientBuilder::new())
                .build()
                .map_err(|e| {
                    Error::new(
                        ErrorKind::NoAuthenticatingAuthority,
                        format!("failed to build reqwest client: {e}"),
                    )
                })?;

            let response = client
                .post(url.clone())
                .body(data.to_vec())
                .send()
                .map_err(|err| match err {
                    err if err.to_string().to_lowercase().contains("certificate") => Error::new(
                        ErrorKind::CertificateUnknown,
                        format!("Invalid certificate data: {:?}", err),
                    ),
                    _ => Error::new(
                        ErrorKind::NoAuthenticatingAuthority,
                        format!("Unable to send the data to the KDC Proxy: {:?}", err),
                    ),
                })?
                .error_for_status()
                .map_err(|err| Error::new(ErrorKind::NoAuthenticatingAuthority, format!("KDC Proxy: {err}")))?;

            let body = response.bytes().map_err(|err| {
                Error::new(
                    ErrorKind::NoAuthenticatingAuthority,
                    format!("Unable to read the response data from the KDC Proxy: {:?}", err),
                )
            })?;

            // The type bytes::Bytes has a special From implementation for Vec<u8>.
            let body = Vec::from(body);

            Ok(body)
        }
    }

    impl NetworkClient for ReqwestNetworkClient {
        fn send(&self, request: &NetworkRequest) -> Result<Vec<u8>> {
            match request.protocol {
                NetworkProtocol::Tcp => self.send_tcp(&request.url, &request.data),
                NetworkProtocol::Udp => self.send_udp(&request.url, &request.data),
                NetworkProtocol::Http | NetworkProtocol::Https => self.send_http(&request.url, &request.data),
            }
        }
    }
}


--- File: src/ntlm/config.rs ---
use crate::negotiate::ProtocolConfig;
use crate::{NegotiatedProtocol, Ntlm, Result};

#[derive(Debug, Clone, Default)]
pub struct NtlmConfig {
    /// Computer name, or "workstation name", of the client machine performing the authentication attempt
    ///
    /// This is also referred to as the "Source Workstation".
    pub client_computer_name: Option<String>,
}

impl NtlmConfig {
    pub fn new(client_machine_name: String) -> Self {
        Self {
            client_computer_name: Some(client_machine_name),
        }
    }
}

impl ProtocolConfig for NtlmConfig {
    fn new_instance(&self) -> Result<NegotiatedProtocol> {
        Ok(NegotiatedProtocol::Ntlm(Ntlm::with_config(Clone::clone(self))))
    }

    fn box_clone(&self) -> Box<dyn ProtocolConfig> {
        Box::new(Clone::clone(self))
    }
}


--- File: src/ntlm/messages/av_pair.rs ---
use std::io;

use bitflags::bitflags;
use byteorder::{LittleEndian, ReadBytesExt, WriteBytesExt};

use crate::crypto::HASH_SIZE;
use crate::ntlm::messages::computations::SINGLE_HOST_DATA_SIZE;

pub const AV_PAIR_ID_BYTES_SIZE: usize = 2;
pub const AV_PAIR_LEN_BYTES_SIZE: usize = 2;

pub const AV_PAIR_EOL: u16 = 0;
pub const AV_PAIR_NB_COMPUTER_NAME: u16 = 1;
pub const AV_PAIR_NB_DOMAIN_NAME: u16 = 2;
pub const AV_PAIR_DNS_COMPUTER_NAME: u16 = 3;
pub const AV_PAIR_DNS_DOMAIN_NAME: u16 = 4;
pub const AV_PAIR_DNS_TREE_NAME: u16 = 5;
pub const AV_PAIR_FLAGS: u16 = 6;
pub const AV_PAIR_TIMESTAMP: u16 = 7;
pub const AV_PAIR_SINGLE_HOST: u16 = 8;
pub const AV_PAIR_TARGET_NAME: u16 = 9;
pub const AV_PAIR_CHANNEL_BINDINGS: u16 = 10;

const AV_PAIR_EOL_SIZE: usize = 0;
const AV_PAIR_FLAGS_SIZE: usize = 4;
const AV_PAIR_TIMESTAMP_SIZE: usize = 8;

#[derive(Clone)]
#[allow(clippy::upper_case_acronyms)]
pub enum AvPair {
    EOL,
    NbComputerName(Vec<u8>),
    NbDomainName(Vec<u8>),
    DnsComputerName(Vec<u8>),
    DnsDomainName(Vec<u8>),
    DnsTreeName(Vec<u8>),
    Flags(u32),
    Timestamp(u64),
    SingleHost([u8; SINGLE_HOST_DATA_SIZE]),
    TargetName(Vec<u8>),
    ChannelBindings([u8; HASH_SIZE]),
}

impl AvPair {
    pub fn from_buffer(mut buffer: impl io::Read) -> io::Result<Self> {
        let av_type = buffer.read_u16::<LittleEndian>()?;
        let len = buffer.read_u16::<LittleEndian>()? as usize;

        match av_type {
            AV_PAIR_EOL => {
                if len != AV_PAIR_EOL_SIZE {
                    Err(io::Error::new(
                        io::ErrorKind::InvalidData,
                        format!("Got EOL AvPair with len {} != {}", len, AV_PAIR_EOL_SIZE),
                    ))
                } else {
                    Ok(AvPair::EOL)
                }
            }
            AV_PAIR_NB_COMPUTER_NAME
            | AV_PAIR_NB_DOMAIN_NAME
            | AV_PAIR_DNS_COMPUTER_NAME
            | AV_PAIR_DNS_DOMAIN_NAME
            | AV_PAIR_DNS_TREE_NAME
            | AV_PAIR_TARGET_NAME => {
                let mut value = vec![0x00; len];
                buffer.read_exact(value.as_mut())?;

                match av_type {
                    AV_PAIR_NB_COMPUTER_NAME => Ok(AvPair::NbComputerName(value)),
                    AV_PAIR_NB_DOMAIN_NAME => Ok(AvPair::NbDomainName(value)),
                    AV_PAIR_DNS_COMPUTER_NAME => Ok(AvPair::DnsComputerName(value)),
                    AV_PAIR_DNS_DOMAIN_NAME => Ok(AvPair::DnsDomainName(value)),
                    AV_PAIR_DNS_TREE_NAME => Ok(AvPair::DnsTreeName(value)),
                    AV_PAIR_TARGET_NAME => Ok(AvPair::TargetName(value)),
                    _ => unreachable!(),
                }
            }
            AV_PAIR_FLAGS => {
                if len != AV_PAIR_FLAGS_SIZE {
                    Err(io::Error::new(
                        io::ErrorKind::InvalidData,
                        format!("Got Flags AvPair with len {} != {}", len, AV_PAIR_FLAGS_SIZE),
                    ))
                } else {
                    Ok(AvPair::Flags(buffer.read_u32::<LittleEndian>()?))
                }
            }
            AV_PAIR_TIMESTAMP => {
                if len != AV_PAIR_TIMESTAMP_SIZE {
                    Err(io::Error::new(
                        io::ErrorKind::InvalidData,
                        format!("Got Timestamp AvPair with len {} != {}", len, AV_PAIR_TIMESTAMP_SIZE),
                    ))
                } else {
                    Ok(AvPair::Timestamp(buffer.read_u64::<LittleEndian>()?))
                }
            }
            AV_PAIR_SINGLE_HOST => {
                if len != SINGLE_HOST_DATA_SIZE {
                    Err(io::Error::new(
                        io::ErrorKind::InvalidData,
                        format!("Got SingleHost AvPair with len {} != {}", len, SINGLE_HOST_DATA_SIZE),
                    ))
                } else {
                    let mut value = [0x00; SINGLE_HOST_DATA_SIZE];
                    buffer.read_exact(value.as_mut())?;

                    Ok(AvPair::SingleHost(value))
                }
            }
            AV_PAIR_CHANNEL_BINDINGS => {
                if len != HASH_SIZE {
                    Err(io::Error::new(
                        io::ErrorKind::InvalidData,
                        format!("Got ChannelBindings AvPair with len {} != {}", len, HASH_SIZE),
                    ))
                } else {
                    let mut value = [0x00; HASH_SIZE];
                    buffer.read_exact(value.as_mut())?;

                    Ok(AvPair::ChannelBindings(value))
                }
            }
            _ => Err(io::Error::new(
                io::ErrorKind::InvalidData,
                format!("Invalid AvType: '{}'", av_type),
            )),
        }
    }
    pub fn buffer_to_av_pairs(mut buffer: &[u8]) -> io::Result<Vec<Self>> {
        let mut av_pairs = Vec::new();
        while !buffer.is_empty() {
            av_pairs.push(AvPair::from_buffer(&mut buffer)?);
        }

        Ok(av_pairs)
    }
    pub fn list_to_buffer(av_pairs: &[AvPair]) -> io::Result<Vec<u8>> {
        let mut buffer = Vec::with_capacity(av_pairs.len() * (AV_PAIR_ID_BYTES_SIZE + AV_PAIR_LEN_BYTES_SIZE));
        for av_pair in av_pairs.iter() {
            av_pair.write_to(&mut buffer)?;
        }

        Ok(buffer)
    }
    pub fn write_to(&self, mut buffer: impl io::Write) -> io::Result<()> {
        let av_type = self.as_u16();
        let (len, value) = match self {
            AvPair::EOL => (AV_PAIR_EOL_SIZE, Vec::new()),
            AvPair::NbComputerName(value)
            | AvPair::NbDomainName(value)
            | AvPair::DnsComputerName(value)
            | AvPair::DnsDomainName(value)
            | AvPair::DnsTreeName(value)
            | AvPair::TargetName(value) => (value.len(), value.clone()),
            AvPair::Flags(value) => (AV_PAIR_FLAGS_SIZE, value.to_le_bytes().to_vec()),
            AvPair::Timestamp(value) => (AV_PAIR_TIMESTAMP_SIZE, value.to_le_bytes().to_vec()),
            AvPair::SingleHost(value) => (SINGLE_HOST_DATA_SIZE, value.to_vec()),
            AvPair::ChannelBindings(value) => (HASH_SIZE, value.to_vec()),
        };
        buffer.write_u16::<LittleEndian>(av_type)?;
        buffer.write_u16::<LittleEndian>(len as u16)?;
        buffer.write_all(value.as_ref())?;

        Ok(())
    }
    pub fn as_u16(&self) -> u16 {
        match self {
            AvPair::EOL => AV_PAIR_EOL,
            AvPair::NbComputerName(_) => AV_PAIR_NB_COMPUTER_NAME,
            AvPair::NbDomainName(_) => AV_PAIR_NB_DOMAIN_NAME,
            AvPair::DnsComputerName(_) => AV_PAIR_DNS_COMPUTER_NAME,
            AvPair::DnsDomainName(_) => AV_PAIR_DNS_DOMAIN_NAME,
            AvPair::DnsTreeName(_) => AV_PAIR_DNS_TREE_NAME,
            AvPair::TargetName(_) => AV_PAIR_TARGET_NAME,
            AvPair::Flags(_) => AV_PAIR_FLAGS,
            AvPair::Timestamp(_) => AV_PAIR_TIMESTAMP,
            AvPair::SingleHost(_) => AV_PAIR_SINGLE_HOST,
            AvPair::ChannelBindings(_) => AV_PAIR_CHANNEL_BINDINGS,
        }
    }
}

bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct MsvAvFlags: u32 {
        const MESSAGE_INTEGRITY_CHECK = 0x0000_0002;
    }
}


--- File: src/ntlm/messages/client.rs ---
mod authenticate;
mod challenge;
mod negotiate;
#[cfg(test)]
mod test;

pub use self::authenticate::write_authenticate;
pub use self::challenge::read_challenge;
pub use self::negotiate::write_negotiate;


--- File: src/ntlm/messages/client/authenticate.rs ---
use std::io;

use byteorder::{LittleEndian, WriteBytesExt};
use rand::rngs::OsRng;
use rand::Rng;

use crate::crypto::Rc4;
use crate::ntlm::messages::computations::*;
use crate::ntlm::messages::{
    MessageFields, MessageTypes, CLIENT_SEAL_MAGIC, CLIENT_SIGN_MAGIC, NTLM_SIGNATURE, NTLM_VERSION_SIZE,
    SERVER_SEAL_MAGIC, SERVER_SIGN_MAGIC,
};
use crate::ntlm::{
    AuthIdentityBuffers, AuthenticateMessage, Mic, NegotiateFlags, Ntlm, NtlmState, ENCRYPTED_RANDOM_SESSION_KEY_SIZE,
    MESSAGE_INTEGRITY_CHECK_SIZE, SESSION_KEY_SIZE,
};
use crate::SecurityStatus;

const MIC_SIZE: usize = 16;
const BASE_OFFSET: usize = 64;
const AUTH_MESSAGE_OFFSET: usize = BASE_OFFSET + NTLM_VERSION_SIZE + MIC_SIZE; // MIC is always used in NTLMv2

struct AuthenticateMessageFields {
    workstation: MessageFields,
    domain_name: MessageFields,
    encrypted_random_session_key: MessageFields,
    user_name: MessageFields,
    lm_challenge_response: MessageFields,
    nt_challenge_response: MessageFields,
}

impl AuthenticateMessageFields {
    pub fn new(
        identity: &AuthIdentityBuffers,
        lm_challenge_response: &[u8],
        nt_challenge_response: &[u8],
        negotiate_flags: NegotiateFlags,
        encrypted_random_session_key_buffer: &[u8],
        offset: u32,
    ) -> Self {
        let mut workstation = MessageFields::new();
        let mut domain_name = MessageFields::with_buffer(identity.domain.clone());
        let mut encrypted_random_session_key = MessageFields::new();
        let mut user_name = MessageFields::with_buffer(identity.user.clone());
        let mut lm_challenge_response = MessageFields::with_buffer(lm_challenge_response.to_vec());
        let mut nt_challenge_response = MessageFields::with_buffer(nt_challenge_response.to_vec());

        if negotiate_flags.contains(NegotiateFlags::NTLM_SSP_NEGOTIATE_KEY_EXCH) {
            encrypted_random_session_key.buffer = encrypted_random_session_key_buffer.to_vec();
        }

        // will not set workstation because it is not used anywhere

        domain_name.buffer_offset = offset;

        user_name.buffer_offset = domain_name.buffer_offset + domain_name.buffer.len() as u32;

        workstation.buffer_offset = user_name.buffer_offset + user_name.buffer.len() as u32;

        lm_challenge_response.buffer_offset = workstation.buffer_offset + workstation.buffer.len() as u32;

        nt_challenge_response.buffer_offset =
            lm_challenge_response.buffer_offset + lm_challenge_response.buffer.len() as u32;

        encrypted_random_session_key.buffer_offset =
            nt_challenge_response.buffer_offset + nt_challenge_response.buffer.len() as u32;

        Self {
            domain_name,
            user_name,
            workstation,
            lm_challenge_response,
            nt_challenge_response,
            encrypted_random_session_key,
        }
    }

    pub fn data_len(&self) -> usize {
        self.encrypted_random_session_key.buffer_offset as usize + self.encrypted_random_session_key.buffer.len()
    }
}

pub fn write_authenticate(
    context: &mut Ntlm,
    credentials: &AuthIdentityBuffers,
    mut transport: impl io::Write,
) -> crate::Result<SecurityStatus> {
    check_state(context.state)?;

    let negotiate_message = context
        .negotiate_message
        .as_ref()
        .expect("negotiate message must be set on negotiate phase");
    let challenge_message = context
        .challenge_message
        .as_ref()
        .expect("challenge message must be set on challenge phase");

    // calculate needed fields
    // NTLMv2
    let target_info = get_authenticate_target_info(
        challenge_message.target_info.as_ref(),
        context.channel_bindings.as_ref(),
        context.send_single_host_data,
    )?;

    let client_challenge = generate_challenge()?;
    let ntlm_v2_hash = compute_ntlm_v2_hash(credentials)?;
    let lm_challenge_response = compute_lm_v2_response(
        client_challenge.as_ref(),
        challenge_message.server_challenge.as_ref(),
        ntlm_v2_hash.as_ref(),
    )?;
    let (nt_challenge_response, key_exchange_key) = compute_ntlm_v2_response(
        client_challenge.as_ref(),
        challenge_message.server_challenge.as_ref(),
        target_info.as_ref(),
        ntlm_v2_hash.as_ref(),
        challenge_message.timestamp,
    )?;
    context.flags = get_flags(context, credentials);

    let session_key = if context.flags.contains(NegotiateFlags::NTLM_SSP_NEGOTIATE_KEY_EXCH) {
        OsRng.gen::<[u8; SESSION_KEY_SIZE]>()
    } else {
        key_exchange_key
    };

    let encrypted_session_key_vec = Rc4::new(&key_exchange_key).process(session_key.as_ref());
    let mut encrypted_session_key = [0x00; ENCRYPTED_RANDOM_SESSION_KEY_SIZE];
    encrypted_session_key.clone_from_slice(encrypted_session_key_vec.as_ref());

    let message_fields = AuthenticateMessageFields::new(
        credentials,
        lm_challenge_response.as_ref(),
        nt_challenge_response.as_ref(),
        context.flags,
        encrypted_session_key.as_ref(),
        AUTH_MESSAGE_OFFSET as u32,
    );

    let mut buffer = Vec::with_capacity(message_fields.data_len());

    write_header(context.flags, context.version.as_ref(), &message_fields, &mut buffer)?;
    write_payload(&message_fields, &mut buffer)?;

    let message = buffer.clone();

    let mut buffer = io::Cursor::new(buffer);
    let mic = write_mic(
        negotiate_message.message.as_ref(),
        challenge_message.message.as_ref(),
        message.as_ref(),
        session_key.as_ref(),
        AUTH_MESSAGE_OFFSET as u8,
        &mut buffer,
    )?;

    transport.write_all(buffer.into_inner().as_slice())?;
    transport.flush()?;

    context.send_signing_key = generate_signing_key(session_key.as_ref(), CLIENT_SIGN_MAGIC);
    context.recv_signing_key = generate_signing_key(session_key.as_ref(), SERVER_SIGN_MAGIC);
    context.send_sealing_key = Some(Rc4::new(&generate_signing_key(session_key.as_ref(), CLIENT_SEAL_MAGIC)));
    context.recv_sealing_key = Some(Rc4::new(&generate_signing_key(session_key.as_ref(), SERVER_SEAL_MAGIC)));
    context.session_key = Some(session_key);

    context.authenticate_message = Some(AuthenticateMessage::new(
        message,
        Some(mic),
        target_info,
        client_challenge,
        Some(encrypted_session_key),
    ));
    context.state = NtlmState::Final;

    Ok(crate::SecurityStatus::Ok)
}

fn check_state(state: NtlmState) -> crate::Result<()> {
    if state != NtlmState::Authenticate {
        Err(crate::Error::new(
            crate::ErrorKind::OutOfSequence,
            String::from("Write authenticate was fired but the state is not an Authenticate"),
        ))
    } else {
        Ok(())
    }
}

fn get_flags(context: &Ntlm, identity: &AuthIdentityBuffers) -> NegotiateFlags {
    // set KEY_EXCH flag if it was in the challenge message
    let mut flags = context.flags & NegotiateFlags::NTLM_SSP_NEGOTIATE_KEY_EXCH;

    if !identity.domain.is_empty() {
        flags |= NegotiateFlags::NTLM_SSP_NEGOTIATE_DOMAIN_SUPPLIED;
    }

    // will not set workstation because it is not used anywhere

    flags |= NegotiateFlags::NTLM_SSP_NEGOTIATE56
        | NegotiateFlags::NTLM_SSP_NEGOTIATE128
        | NegotiateFlags::NTLM_SSP_NEGOTIATE_ALWAYS_SIGN
        | NegotiateFlags::NTLM_SSP_NEGOTIATE_EXTENDED_SESSION_SECURITY
        | NegotiateFlags::NTLM_SSP_NEGOTIATE_NTLM
        | NegotiateFlags::NTLM_SSP_NEGOTIATE_REQUEST_TARGET
        | NegotiateFlags::NTLM_SSP_NEGOTIATE_UNICODE
        | NegotiateFlags::NTLM_SSP_NEGOTIATE_TARGET_INFO
        | NegotiateFlags::NTLM_SSP_NEGOTIATE_VERSION;

    if context.sealing {
        flags |= NegotiateFlags::NTLM_SSP_NEGOTIATE_SEAL;
    }

    if context.signing {
        flags |= NegotiateFlags::NTLM_SSP_NEGOTIATE_SIGN;
    }

    flags
}

fn write_header(
    negotiate_flags: NegotiateFlags,
    version: &[u8],
    message_fields: &AuthenticateMessageFields,
    mut buffer: impl io::Write,
) -> io::Result<()> {
    buffer.write_all(NTLM_SIGNATURE)?; // signature 8 bytes
    buffer.write_u32::<LittleEndian>(MessageTypes::Authenticate as u32)?; // message type 4 bytes
    message_fields.lm_challenge_response.write_to(&mut buffer)?; // LmChallengeResponseFields (8 bytes)
    message_fields.nt_challenge_response.write_to(&mut buffer)?; // NtChallengeResponseFields (8 bytes)
    message_fields.domain_name.write_to(&mut buffer)?; // DomainNameFields (8 bytes)
    message_fields.user_name.write_to(&mut buffer)?; // UserNameFields (8 bytes)
    message_fields.workstation.write_to(&mut buffer)?; // WorkstationFields (8 bytes)
    message_fields.encrypted_random_session_key.write_to(&mut buffer)?; // EncryptedRandomSessionKeyFields (8 bytes)
    buffer.write_u32::<LittleEndian>(negotiate_flags.bits())?; // NegotiateFlags (4 bytes)
    buffer.write_all(version)?;

    // use_mic always true, when ntlm_v2 is true
    // For now, just write zeros to the stream,
    // and write to this position an authenticate_message,
    // when will calc the authenticate_message
    buffer.write_all(&[0x00; MESSAGE_INTEGRITY_CHECK_SIZE])?;

    Ok(())
}

fn write_payload(message_fields: &AuthenticateMessageFields, mut buffer: impl io::Write) -> io::Result<()> {
    message_fields.domain_name.write_buffer_to(&mut buffer)?;
    message_fields.user_name.write_buffer_to(&mut buffer)?;
    message_fields.workstation.write_buffer_to(&mut buffer)?;
    message_fields.lm_challenge_response.write_buffer_to(&mut buffer)?;
    message_fields.nt_challenge_response.write_buffer_to(&mut buffer)?;
    message_fields
        .encrypted_random_session_key
        .write_buffer_to(&mut buffer)?;

    Ok(())
}

fn write_mic(
    negotiate_message: &[u8],
    challenge_message: &[u8],
    authenticate_message: &[u8],
    exported_session_key: &[u8],
    offset: u8,
    mut buffer: impl io::Write + io::Seek,
) -> crate::Result<Mic> {
    let mic = Mic {
        offset: offset - MIC_SIZE as u8,
        value: compute_message_integrity_check(
            negotiate_message,
            challenge_message,
            authenticate_message,
            exported_session_key,
        )?,
    };

    buffer.seek(io::SeekFrom::Start(u64::from(mic.offset)))?;
    buffer.write_all(&mic.value)?;
    buffer.seek(io::SeekFrom::End(0))?;

    Ok(mic)
}


--- File: src/ntlm/messages/client/challenge.rs ---
use std::io;

use byteorder::{LittleEndian, ReadBytesExt};

use crate::ntlm::messages::computations::*;
use crate::ntlm::messages::{read_ntlm_header, try_read_version, MessageFields, MessageTypes};
use crate::ntlm::{ChallengeMessage, NegotiateFlags, Ntlm, NtlmState, CHALLENGE_SIZE};
use crate::SecurityStatus;

const HEADER_SIZE: usize = 48;

struct ChallengeMessageFields {
    target_name: MessageFields,
    target_info: MessageFields,
}

pub fn read_challenge(context: &mut Ntlm, mut stream: impl io::Read) -> crate::Result<SecurityStatus> {
    check_state(context.state)?;

    let mut buffer = Vec::with_capacity(HEADER_SIZE);
    stream.read_to_end(&mut buffer)?;
    let mut buffer = io::Cursor::new(buffer);

    read_ntlm_header(&mut buffer, MessageTypes::Challenge)?;
    let (mut message_fields, flags, server_challenge) = read_header(&mut buffer)?;
    context.flags = flags;
    let _version = try_read_version(context.flags, &mut buffer)?;
    read_payload(&mut message_fields, &mut buffer)?;
    let timestamp = get_challenge_timestamp_from_response(message_fields.target_info.buffer.as_ref())?;

    let message = buffer.into_inner();
    context.challenge_message = Some(ChallengeMessage::new(
        message,
        message_fields.target_info.buffer,
        server_challenge,
        timestamp,
    ));

    context.state = NtlmState::Authenticate;

    Ok(crate::SecurityStatus::ContinueNeeded)
}

fn check_state(state: NtlmState) -> crate::Result<()> {
    if state != NtlmState::Challenge {
        Err(crate::Error::new(
            crate::ErrorKind::OutOfSequence,
            String::from("Read challenge was fired but the state is not a Challenge"),
        ))
    } else {
        Ok(())
    }
}

fn read_header(
    mut buffer: impl io::Read,
) -> crate::Result<(ChallengeMessageFields, NegotiateFlags, [u8; CHALLENGE_SIZE])> {
    let mut target_name = MessageFields::new();
    let mut target_info = MessageFields::new();

    target_name.read_from(&mut buffer)?;
    let negotiate_flags =
        NegotiateFlags::from_bits(buffer.read_u32::<LittleEndian>()?).unwrap_or_else(NegotiateFlags::empty);
    let mut server_challenge = [0x00; CHALLENGE_SIZE];
    buffer.read_exact(&mut server_challenge)?;
    let _reserved = buffer.read_u64::<LittleEndian>()?;
    target_info.read_from(&mut buffer)?;

    let message_fields = ChallengeMessageFields {
        target_name,
        target_info,
    };

    Ok((message_fields, negotiate_flags, server_challenge))
}

fn read_payload(
    message_fields: &mut ChallengeMessageFields,
    mut buffer: impl io::Read + io::Seek,
) -> crate::Result<()> {
    message_fields.target_name.read_buffer_from(&mut buffer)?;
    message_fields.target_info.read_buffer_from(&mut buffer)?;

    Ok(())
}


--- File: src/ntlm/messages/client/negotiate.rs ---
use std::io;

use byteorder::{LittleEndian, WriteBytesExt};

use crate::ntlm::messages::{MessageFields, MessageTypes, NTLM_SIGNATURE, NTLM_VERSION_SIZE};
use crate::ntlm::{NegotiateFlags, NegotiateMessage, Ntlm, NtlmState};
use crate::SecurityStatus;

const HEADER_SIZE: usize = 32;
const NEGO_MESSAGE_OFFSET: usize = HEADER_SIZE + NTLM_VERSION_SIZE;

struct NegotiateMessageFields {
    domain_name: MessageFields,
    workstation: MessageFields,
}

impl NegotiateMessageFields {
    pub fn new(offset: u32, workstation: Option<Vec<u8>>) -> Self {
        let mut domain_name = MessageFields::new();
        let mut workstation = MessageFields::with_buffer(workstation.unwrap_or_default());

        domain_name.buffer_offset = offset;
        workstation.buffer_offset = domain_name.buffer_offset + domain_name.buffer.len() as u32;

        NegotiateMessageFields {
            domain_name,
            workstation,
        }
    }

    pub fn data_len(&self) -> usize {
        self.workstation.buffer_offset as usize + self.workstation.buffer.len()
    }
}

fn check_state(state: NtlmState) -> crate::Result<()> {
    if state != NtlmState::Negotiate {
        Err(crate::Error::new(
            crate::ErrorKind::OutOfSequence,
            String::from("Write negotiate was fired but the state is not a Negotiate"),
        ))
    } else {
        Ok(())
    }
}

pub fn write_negotiate(context: &mut Ntlm, mut transport: impl io::Write) -> crate::Result<SecurityStatus> {
    check_state(context.state)?;

    let negotiate_flags = get_flags(context);
    let message_fields = NegotiateMessageFields::new(
        NEGO_MESSAGE_OFFSET as u32,
        context
            .config
            .client_computer_name
            .as_ref()
            .map(|workstation| workstation.as_bytes().to_vec()),
    );

    let mut buffer = Vec::with_capacity(message_fields.data_len());

    write_header(negotiate_flags, context.version.as_ref(), &message_fields, &mut buffer)?;
    write_payload(&message_fields, &mut buffer)?;
    context.flags = negotiate_flags;

    let message = buffer;

    transport.write_all(message.as_slice())?;
    transport.flush()?;

    context.negotiate_message = Some(NegotiateMessage::new(message));
    context.state = NtlmState::Challenge;

    Ok(crate::SecurityStatus::ContinueNeeded)
}

fn get_flags(context: &Ntlm) -> NegotiateFlags {
    let mut flags = NegotiateFlags::NTLM_SSP_NEGOTIATE56
        | NegotiateFlags::NTLM_SSP_NEGOTIATE_OEM
        | NegotiateFlags::NTLM_SSP_NEGOTIATE128
        | NegotiateFlags::NTLM_SSP_NEGOTIATE_ALWAYS_SIGN
        | NegotiateFlags::NTLM_SSP_NEGOTIATE_EXTENDED_SESSION_SECURITY
        | NegotiateFlags::NTLM_SSP_NEGOTIATE_NTLM
        | NegotiateFlags::NTLM_SSP_NEGOTIATE_REQUEST_TARGET
        | NegotiateFlags::NTLM_SSP_NEGOTIATE_UNICODE
        | NegotiateFlags::NTLM_SSP_NEGOTIATE_VERSION;

    if context.sealing {
        flags |= NegotiateFlags::NTLM_SSP_NEGOTIATE_LM_KEY;
        flags |= NegotiateFlags::NTLM_SSP_NEGOTIATE_SEAL;
        flags |= NegotiateFlags::NTLM_SSP_NEGOTIATE_KEY_EXCH;
    }

    if context.signing {
        flags |= NegotiateFlags::NTLM_SSP_NEGOTIATE_SIGN;
    }

    if context.config().client_computer_name.is_some() {
        flags |= NegotiateFlags::NTLM_SSP_NEGOTIATE_WORKSTATION_SUPPLIED;
    }

    flags
}

fn write_header(
    negotiate_flags: NegotiateFlags,
    version: &[u8],
    message_fields: &NegotiateMessageFields,
    mut buffer: impl io::Write,
) -> io::Result<()> {
    buffer.write_all(NTLM_SIGNATURE)?; // signature 8 bytes
    buffer.write_u32::<LittleEndian>(MessageTypes::Negotiate as u32)?; // message type 4 bytes
    buffer.write_u32::<LittleEndian>(negotiate_flags.bits())?; // negotiate flags 4 bytes
    message_fields.domain_name.write_to(&mut buffer)?; // domain name 8 bytes
    message_fields.workstation.write_to(&mut buffer)?; // workstation 8 bytes
    buffer.write_all(version)?;

    Ok(())
}

fn write_payload(message_fields: &NegotiateMessageFields, mut buffer: impl io::Write) -> io::Result<()> {
    message_fields.domain_name.write_buffer_to(&mut buffer)?;
    message_fields.workstation.write_buffer_to(&mut buffer)?;

    Ok(())
}


--- File: src/ntlm/messages/client/test.rs ---
use super::*;
use crate::ntlm::messages::test::*;
use crate::ntlm::*;

#[test]
fn write_negotiate_writes_correct_signature() {
    let mut context = Ntlm::new();
    context.set_version(LOCAL_NEGOTIATE_VERSION);
    context.state = NtlmState::Negotiate;

    let mut buff = Vec::new();
    write_negotiate(&mut context, &mut buff).unwrap();

    assert_eq!(NTLM_SIGNATURE, buff[SIGNATURE_START..MESSAGE_TYPE_START]);
}

#[test]
fn write_negotiate_writes_correct_message_type() {
    let mut context = Ntlm::new();
    context.set_version(LOCAL_NEGOTIATE_VERSION);
    context.state = NtlmState::Negotiate;

    let mut buff = Vec::new();
    write_negotiate(&mut context, &mut buff).unwrap();

    assert_eq!(NEGOTIATE_MESSAGE_TYPE, buff[MESSAGE_TYPE_START..NEGOTIATE_FLAGS_START]);
}

#[test]
fn write_negotiate_writes_flags() {
    let mut context = Ntlm::new();
    context.set_version(LOCAL_NEGOTIATE_VERSION);
    context.state = NtlmState::Negotiate;

    let mut buff = Vec::new();
    write_negotiate(&mut context, &mut buff).unwrap();

    assert_eq!(
        LOCAL_NEGOTIATE_FLAGS.to_le_bytes(),
        buff[NEGOTIATE_FLAGS_START..NEGOTIATE_DOMAIN_NAME_START]
    );
    assert_eq!(NegotiateFlags::from_bits(LOCAL_NEGOTIATE_FLAGS).unwrap(), context.flags);
}

#[test]
fn write_negotiate_writes_domain_name() {
    let mut context = Ntlm::new();
    context.set_version(LOCAL_NEGOTIATE_VERSION);
    context.state = NtlmState::Negotiate;

    let mut buff = Vec::new();
    write_negotiate(&mut context, &mut buff).unwrap();

    assert_eq!(
        LOCAL_NEGOTIATE_DOMAIN,
        buff[NEGOTIATE_DOMAIN_NAME_START..NEGOTIATE_WORKSTATION_START]
    );
}

#[test]
fn write_negotiate_writes_workstation() {
    let mut context = Ntlm::new();
    context.set_version(LOCAL_NEGOTIATE_VERSION);
    context.state = NtlmState::Negotiate;

    let mut buff = Vec::new();
    write_negotiate(&mut context, &mut buff).unwrap();

    assert_eq!(
        LOCAL_NEGOTIATE_WORKSTATION,
        buff[NEGOTIATE_WORKSTATION_START..NEGOTIATE_VERSION_START]
    );
}

#[test]
fn write_negotiate_writes_version() {
    let mut context = Ntlm::new();
    context.set_version(LOCAL_NEGOTIATE_VERSION);
    context.state = NtlmState::Negotiate;

    let mut buff = Vec::new();
    write_negotiate(&mut context, &mut buff).unwrap();

    assert_eq!(
        LOCAL_NEGOTIATE_VERSION,
        buff[NEGOTIATE_VERSION_START..NEGOTIATE_VERSION_START + NTLM_VERSION_SIZE]
    );
}

#[test]
fn write_negotiate_writes_buffer_to_context() {
    let mut context = Ntlm::new();
    context.set_version(LOCAL_NEGOTIATE_VERSION);
    context.state = NtlmState::Negotiate;

    let mut buff = Vec::new();
    write_negotiate(&mut context, &mut buff).unwrap();

    assert_eq!((*LOCAL_NEGOTIATE_MESSAGE).as_ref(), buff.as_slice());
}

#[test]
fn write_negotiate_changes_context_state_on_success() {
    let mut context = Ntlm::new();
    context.set_version(LOCAL_NEGOTIATE_VERSION);
    context.state = NtlmState::Negotiate;

    let expected_state = NtlmState::Challenge;

    let mut buff = Vec::new();
    write_negotiate(&mut context, &mut buff).unwrap();

    assert_eq!(expected_state, context.state);
}

#[test]
fn write_negotiate_failed_on_incorrect_state() {
    let mut context = Ntlm::new();
    context.set_version(LOCAL_NEGOTIATE_VERSION);
    context.state = NtlmState::Challenge;

    let mut buff = Vec::new();
    assert!(write_negotiate(&mut context, &mut buff).is_err());
}

#[test]
fn read_challenge_does_not_fail_with_correct_header() {
    let mut context = Ntlm::new();
    context.set_version(LOCAL_NEGOTIATE_VERSION);
    context.state = NtlmState::Challenge;
    context.negotiate_message = Some(NegotiateMessage::new(LOCAL_NEGOTIATE_MESSAGE.to_vec()));
    context.flags = NegotiateFlags::from_bits(LOCAL_NEGOTIATE_FLAGS).unwrap();

    let buff = *LOCAL_CHALLENGE_MESSAGE;
    read_challenge(&mut context, buff.as_ref()).unwrap();
}

#[test]
fn read_challenge_fails_with_incorrect_signature() {
    let mut context = Ntlm::new();
    context.set_version(LOCAL_NEGOTIATE_VERSION);
    context.state = NtlmState::Challenge;
    context.negotiate_message = Some(NegotiateMessage::new(LOCAL_NEGOTIATE_MESSAGE.to_vec()));
    context.flags = NegotiateFlags::from_bits(LOCAL_NEGOTIATE_FLAGS).unwrap();

    let mut buff = LOCAL_CHALLENGE_MESSAGE.to_vec();
    buff[1] += 1;
    assert!(read_challenge(&mut context, buff.as_slice()).is_err());
}

#[test]
fn read_challenge_fails_with_incorrect_message_type() {
    let mut context = Ntlm::new();
    context.set_version(LOCAL_NEGOTIATE_VERSION);
    context.state = NtlmState::Challenge;
    context.negotiate_message = Some(NegotiateMessage::new(LOCAL_NEGOTIATE_MESSAGE.to_vec()));
    context.flags = NegotiateFlags::from_bits(LOCAL_NEGOTIATE_FLAGS).unwrap();

    let mut buff = LOCAL_CHALLENGE_MESSAGE.to_vec();
    buff[8] = 3;
    assert!(read_challenge(&mut context, buff.as_slice()).is_err());
}

#[test]
fn read_challenge_reads_correct_flags() {
    let mut context = Ntlm::new();
    context.set_version(LOCAL_NEGOTIATE_VERSION);
    context.state = NtlmState::Challenge;
    context.negotiate_message = Some(NegotiateMessage::new(LOCAL_NEGOTIATE_MESSAGE.to_vec()));
    context.flags = NegotiateFlags::from_bits(LOCAL_NEGOTIATE_FLAGS).unwrap();

    let buff = *LOCAL_CHALLENGE_MESSAGE;
    read_challenge(&mut context, buff.as_ref()).unwrap();

    assert_eq!(
        LOCAL_CHALLENGE_FLAGS.to_le_bytes(),
        buff[CHALLENGE_FLAGS_START..CHALLENGE_SERVER_CHALLENGE_START]
    );
    assert_eq!(NegotiateFlags::from_bits(LOCAL_CHALLENGE_FLAGS).unwrap(), context.flags);
}

#[test]
fn read_challenge_reads_correct_target_info() {
    let mut context = Ntlm::new();
    context.set_version(LOCAL_NEGOTIATE_VERSION);
    context.state = NtlmState::Challenge;
    context.negotiate_message = Some(NegotiateMessage::new(LOCAL_NEGOTIATE_MESSAGE.to_vec()));
    context.flags = NegotiateFlags::from_bits(LOCAL_NEGOTIATE_FLAGS).unwrap();

    let buff = *LOCAL_CHALLENGE_MESSAGE;
    read_challenge(&mut context, buff.as_ref()).unwrap();

    assert_eq!(
        LOCAL_CHALLENGE_TARGET_INFO_BUFFER.as_ref(),
        context.challenge_message.unwrap().target_info.as_slice()
    );
}

#[test]
fn read_challenge_reads_correct_server_challenge() {
    let mut context = Ntlm::new();
    context.set_version(LOCAL_NEGOTIATE_VERSION);
    context.state = NtlmState::Challenge;
    context.negotiate_message = Some(NegotiateMessage::new(LOCAL_NEGOTIATE_MESSAGE.to_vec()));
    context.flags = NegotiateFlags::from_bits(LOCAL_NEGOTIATE_FLAGS).unwrap();

    let buff = *LOCAL_CHALLENGE_MESSAGE;
    read_challenge(&mut context, buff.as_ref()).unwrap();

    assert_eq!(
        LOCAL_CHALLENGE_SERVER_CHALLENGE,
        context.challenge_message.unwrap().server_challenge
    );
}

#[test]
fn read_challenge_reads_correct_timestamp() {
    let mut context = Ntlm::new();
    context.set_version(LOCAL_NEGOTIATE_VERSION);
    context.state = NtlmState::Challenge;
    context.negotiate_message = Some(NegotiateMessage::new(LOCAL_NEGOTIATE_MESSAGE.to_vec()));
    context.flags = NegotiateFlags::from_bits(LOCAL_NEGOTIATE_FLAGS).unwrap();

    let buff = *LOCAL_CHALLENGE_MESSAGE;
    read_challenge(&mut context, buff.as_ref()).unwrap();

    assert_eq!(LOCAL_CHALLENGE_TIMESTAMP, context.challenge_message.unwrap().timestamp);
}

#[test]
fn read_challenge_writes_buffer_to_context() {
    let mut context = Ntlm::new();
    context.set_version(LOCAL_NEGOTIATE_VERSION);
    context.state = NtlmState::Challenge;
    context.negotiate_message = Some(NegotiateMessage::new(LOCAL_NEGOTIATE_MESSAGE.to_vec()));
    context.flags = NegotiateFlags::from_bits(LOCAL_NEGOTIATE_FLAGS).unwrap();

    let buff = *LOCAL_CHALLENGE_MESSAGE;
    read_challenge(&mut context, buff.as_ref()).unwrap();

    assert_eq!(
        (*LOCAL_CHALLENGE_MESSAGE).as_ref(),
        context.challenge_message.unwrap().message.as_slice()
    );
}

#[test]
fn read_challenge_fails_on_incorrect_state() {
    let mut context = Ntlm::new();
    context.set_version(LOCAL_NEGOTIATE_VERSION);
    context.state = NtlmState::Authenticate;
    context.negotiate_message = Some(NegotiateMessage::new(LOCAL_NEGOTIATE_MESSAGE.to_vec()));
    context.flags = NegotiateFlags::from_bits(LOCAL_NEGOTIATE_FLAGS).unwrap();

    let buff = *LOCAL_CHALLENGE_MESSAGE;
    assert!(read_challenge(&mut context, buff.as_ref()).is_err());
}

#[test]
fn write_authenticate_writes_correct_header() {
    let mut context = Ntlm::new();
    context.set_version(NTLM_VERSION);
    context.state = NtlmState::Authenticate;
    context.negotiate_message = Some(NegotiateMessage::new(vec![0x01, 0x02, 0x03]));
    context.challenge_message = Some(ChallengeMessage::new(
        vec![0x04, 0x05, 0x06],
        Vec::new(),
        [0x00; CHALLENGE_SIZE],
        0,
    ));
    let mut buff = Vec::new();
    let expected = [0x4e, 0x54, 0x4c, 0x4d, 0x53, 0x53, 0x50, 0x00, 0x03, 0x00, 0x00, 0x00];

    write_authenticate(&mut context, &TEST_CREDENTIALS, &mut buff).unwrap();

    assert_eq!(
        buff[SIGNATURE_START..AUTHENTICATE_LM_CHALLENGE_RESPONSE_START],
        expected
    );
}

#[test]
fn write_authenticate_changes_context_state_on_success() {
    let mut context = Ntlm::new();
    context.set_version(NTLM_VERSION);
    let mut buff = Vec::new();
    context.negotiate_message = Some(NegotiateMessage::new(vec![0x01, 0x02, 0x03]));
    context.challenge_message = Some(ChallengeMessage::new(
        vec![0x04, 0x05, 0x06],
        Vec::new(),
        [0x00; CHALLENGE_SIZE],
        0,
    ));
    context.state = NtlmState::Authenticate;
    let expected_state = NtlmState::Final;

    write_authenticate(&mut context, &TEST_CREDENTIALS, &mut buff).unwrap();

    assert_eq!(context.state, expected_state);
}

#[test]
fn write_authenticate_correct_writes_domain_name() {
    let expected = [0x0c, 0x00, 0x0c, 0x00, 0x58, 0x00, 0x00, 0x00];
    let expected_buffer = [0x44, 0x00, 0x6f, 0x00, 0x6d, 0x00, 0x61, 0x00, 0x69, 0x00, 0x6e, 0x00];

    let mut context = Ntlm::new();
    context.set_version(NTLM_VERSION);
    context.state = NtlmState::Authenticate;
    context.negotiate_message = Some(NegotiateMessage::new(vec![0x01, 0x02, 0x03]));
    context.challenge_message = Some(ChallengeMessage::new(
        vec![0x04, 0x05, 0x06],
        vec![
            0x2, 0x0, 0x8, 0x0, 0x48, 0x4f, 0x53, 0x54, 0x4e, 0x41, 0x4d, 0x45, 0x1, 0x0, 0x8, 0x0, 0x48, 0x4f, 0x53,
            0x54, 0x4e, 0x41, 0x4d, 0x45, 0x4, 0x0, 0x8, 0x0, 0x48, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x3, 0x0,
            0x8, 0x0, 0x48, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x7, 0x0, 0x8, 0x0, 0x33, 0x57, 0xbd, 0xb1, 0x7,
            0x8b, 0xcf, 0x1, 0x6, 0x0, 0x4, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        ],
        SERVER_CHALLENGE,
        TIMESTAMP,
    ));
    context.flags = NegotiateFlags::NTLM_SSP_NEGOTIATE_KEY_EXCH;

    let mut buff = Vec::new();
    write_authenticate(&mut context, &TEST_CREDENTIALS, &mut buff).unwrap();

    assert_eq!(
        buff[AUTHENTICATE_DOMAIN_NAME_START..AUTHENTICATE_USER_NAME_START],
        expected
    );
    assert_eq!(
        buff[AUTHENTICATE_OFFSET_WITH_MIC..AUTHENTICATE_OFFSET_WITH_MIC + TEST_CREDENTIALS.domain.len()],
        expected_buffer[..]
    );
}

#[test]
fn write_authenticate_correct_writes_user_name() {
    let expected = [0x08, 0x00, 0x08, 0x00, 0x64, 0x00, 0x00, 0x00];
    let expected_buffer = [0x55, 0x00, 0x73, 0x00, 0x65, 0x00, 0x72, 0x00];

    let mut context = Ntlm::new();
    context.set_version(NTLM_VERSION);
    context.state = NtlmState::Authenticate;
    context.negotiate_message = Some(NegotiateMessage::new(vec![0x01, 0x02, 0x03]));
    context.challenge_message = Some(ChallengeMessage::new(
        vec![0x04, 0x05, 0x06],
        vec![
            0x2, 0x0, 0x8, 0x0, 0x48, 0x4f, 0x53, 0x54, 0x4e, 0x41, 0x4d, 0x45, 0x1, 0x0, 0x8, 0x0, 0x48, 0x4f, 0x53,
            0x54, 0x4e, 0x41, 0x4d, 0x45, 0x4, 0x0, 0x8, 0x0, 0x48, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x3, 0x0,
            0x8, 0x0, 0x48, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x7, 0x0, 0x8, 0x0, 0x33, 0x57, 0xbd, 0xb1, 0x7,
            0x8b, 0xcf, 0x1, 0x6, 0x0, 0x4, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        ],
        SERVER_CHALLENGE,
        TIMESTAMP,
    ));
    context.flags = NegotiateFlags::NTLM_SSP_NEGOTIATE_KEY_EXCH;

    let mut buff = Vec::new();
    write_authenticate(&mut context, &TEST_CREDENTIALS, &mut buff).unwrap();

    assert_eq!(
        buff[AUTHENTICATE_USER_NAME_START..AUTHENTICATE_WORKSTATION_START],
        expected
    );
    let offset = AUTHENTICATE_OFFSET_WITH_MIC + TEST_CREDENTIALS.domain.len();
    assert_eq!(buff[offset..offset + TEST_CREDENTIALS.user.len()], expected_buffer[..]);
}

#[test]
fn write_authenticate_fails_on_incorrect_state() {
    let mut context = Ntlm::new();
    context.set_version(NTLM_VERSION);
    context.state = NtlmState::Final;
    context.negotiate_message = Some(NegotiateMessage::new(vec![0x01, 0x02, 0x03]));
    context.challenge_message = Some(ChallengeMessage::new(
        vec![0x04, 0x05, 0x06],
        vec![
            0x2, 0x0, 0x8, 0x0, 0x48, 0x4f, 0x53, 0x54, 0x4e, 0x41, 0x4d, 0x45, 0x1, 0x0, 0x8, 0x0, 0x48, 0x4f, 0x53,
            0x54, 0x4e, 0x41, 0x4d, 0x45, 0x4, 0x0, 0x8, 0x0, 0x48, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x3, 0x0,
            0x8, 0x0, 0x48, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x7, 0x0, 0x8, 0x0, 0x33, 0x57, 0xbd, 0xb1, 0x7,
            0x8b, 0xcf, 0x1, 0x6, 0x0, 0x4, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        ],
        SERVER_CHALLENGE,
        TIMESTAMP,
    ));
    context.flags = NegotiateFlags::NTLM_SSP_NEGOTIATE_KEY_EXCH;

    let mut buff = Vec::new();
    assert!(write_authenticate(&mut context, &TEST_CREDENTIALS, &mut buff).is_err());
}


--- File: src/ntlm/messages/computations.rs ---
#[cfg(test)]
mod test;

use std::io::{self, Read, Write};
use std::sync::LazyLock;

use byteorder::{LittleEndian, ReadBytesExt, WriteBytesExt};
use rand::rngs::OsRng;
use rand::Rng;
use time::OffsetDateTime;

use crate::channel_bindings::ChannelBindings;
use crate::crypto::{compute_hmac_md5, compute_md4, compute_md5, compute_md5_channel_bindings_hash, HASH_SIZE};
use crate::ntlm::messages::av_pair::*;
use crate::ntlm::{
    AuthIdentityBuffers, CHALLENGE_SIZE, LM_CHALLENGE_RESPONSE_BUFFER_SIZE, MESSAGE_INTEGRITY_CHECK_SIZE,
};
use crate::utils;

pub const SSPI_CREDENTIALS_HASH_LENGTH_OFFSET: usize = 512;
pub const SINGLE_HOST_DATA_SIZE: usize = 48;

const NT_V2_RESPONSE_BASE_SIZE: usize = 28;

// The Single_Host_Data structure allows a client to send machine-specific information
// within an authentication exchange to services on the same machine. The client can
// produce additional information to be processed in an implementation-specific way when
// the client and server are on the same host. If the server and client platforms are
// different or if they are on different hosts, then the information MUST be ignored.
// Any fields after the MachineID field MUST be ignored on receipt.
pub static SINGLE_HOST_DATA: LazyLock<[u8; SINGLE_HOST_DATA_SIZE]> = LazyLock::new(|| {
    let mut result = [0x00; SINGLE_HOST_DATA_SIZE];
    let mut buffer = io::Cursor::new(result.as_mut());

    buffer.write_u32::<LittleEndian>(SINGLE_HOST_DATA_SIZE as u32).unwrap(); //size
    buffer.write_u32::<LittleEndian>(0).unwrap(); //z4
    buffer.write_u32::<LittleEndian>(1).unwrap(); //data present
    buffer.write_u32::<LittleEndian>(0x2000).unwrap(); //custom_data
    buffer.write_all([0xaa; 32].as_ref()).unwrap(); //machine_id

    result
});

fn convert_to_file_time(end_date: OffsetDateTime) -> crate::Result<u64> {
    let start_date = time::Date::from_calendar_date(1601, time::Month::January, 1)
        .expect("hardcoded")
        .with_hms(0, 1, 1)
        .expect("hardcoded")
        .assume_utc();

    if start_date > end_date {
        Err(crate::Error::new(
            crate::ErrorKind::InternalError,
            format!(
                "Failed to convert system time to file time, where the start date: {:?}, end date: {:?}",
                start_date, end_date
            ),
        ))
    } else {
        let duration = end_date - start_date;
        let whole_microseconds = duration.whole_microseconds();
        let file_time = u64::try_from(whole_microseconds).expect("whole_microseconds to u64 conversion") * 10;
        Ok(file_time)
    }
}

pub fn get_challenge_target_info(timestamp: u64) -> crate::Result<Vec<u8>> {
    // Windows requires _DomainName, _ComputerName fields, but does not care what they are contain
    let av_pairs = vec![
        AvPair::NbDomainName(Vec::new()),
        AvPair::NbComputerName(Vec::new()),
        AvPair::DnsDomainName(Vec::new()),
        AvPair::DnsComputerName(Vec::new()),
        AvPair::Timestamp(timestamp),
        AvPair::EOL,
    ];

    Ok(AvPair::list_to_buffer(&av_pairs)?)
}

pub fn get_authenticate_target_info(
    target_info: &[u8],
    channel_bindings: Option<&ChannelBindings>,
    send_single_host_data: bool,
) -> crate::Result<Vec<u8>> {
    let mut av_pairs = AvPair::buffer_to_av_pairs(target_info)?;

    av_pairs.retain(|av_pair| av_pair.as_u16() != AV_PAIR_EOL);

    // use_mic always true, when ntlm_v2 is true
    let flags_av_pair = AvPair::Flags(MsvAvFlags::MESSAGE_INTEGRITY_CHECK.bits());
    av_pairs.push(flags_av_pair);

    if send_single_host_data {
        let single_host_av_pair = AvPair::SingleHost(*SINGLE_HOST_DATA);
        av_pairs.push(single_host_av_pair);
    }

    // will not check suppress_extended_protection and
    // will not add channel bindings and service principal name
    // because it is not used anywhere

    if let Some(channel_bindings) = channel_bindings {
        av_pairs.push(AvPair::ChannelBindings(compute_md5_channel_bindings_hash(
            channel_bindings,
        )));
    }

    let mut authenticate_target_info = AvPair::list_to_buffer(&av_pairs)?;

    // NTLMv2
    // unknown 8-byte padding: AvEOL ([0x00; 4]) + reserved ([0x00; 4])
    authenticate_target_info.write_u64::<LittleEndian>(0x00)?;

    Ok(authenticate_target_info)
}

pub fn generate_challenge() -> Result<[u8; CHALLENGE_SIZE], rand::Error> {
    Ok(OsRng.gen::<[u8; CHALLENGE_SIZE]>())
}

pub fn now_file_time_timestamp() -> crate::Result<u64> {
    convert_to_file_time(OffsetDateTime::now_utc())
}

pub fn generate_signing_key(exported_session_key: &[u8], sign_magic: &[u8]) -> [u8; HASH_SIZE] {
    let mut value = exported_session_key.to_vec();
    value.extend_from_slice(sign_magic);
    compute_md5(value.as_ref())
}

pub fn compute_message_integrity_check(
    negotiate_message: &[u8],
    challenge_message: &[u8],
    authenticate_message: &[u8],
    exported_session_key: &[u8],
) -> io::Result<[u8; MESSAGE_INTEGRITY_CHECK_SIZE]> {
    let mut message_integrity_check = negotiate_message.to_vec();
    message_integrity_check.extend_from_slice(challenge_message);
    message_integrity_check.extend_from_slice(authenticate_message);

    compute_hmac_md5(exported_session_key, message_integrity_check.as_ref())
}

pub fn convert_password_hash(identity_password: &[u8]) -> crate::Result<[u8; HASH_SIZE]> {
    if identity_password.len() >= SSPI_CREDENTIALS_HASH_LENGTH_OFFSET + HASH_SIZE * 2 {
        let mut result = [0x00; HASH_SIZE];
        let password_hash =
            &identity_password[0..identity_password.len() - SSPI_CREDENTIALS_HASH_LENGTH_OFFSET].to_ascii_uppercase();

        let magic_transform = |elem: u8| {
            if elem > b'9' {
                elem + 10 - b'A'
            } else {
                elem.wrapping_sub(b'0')
            }
        };

        for (hash_items, res) in password_hash.chunks(2).zip(result.iter_mut()) {
            let hn = magic_transform(*hash_items.first().unwrap());
            let ln = magic_transform(*hash_items.last().unwrap());
            *res = (hn << 4) | ln;
        }

        Ok(result)
    } else {
        Err(crate::Error::new(
            crate::ErrorKind::InvalidToken,
            format!("Got password with a small length: {}", identity_password.len()),
        ))
    }
}

pub fn compute_ntlm_v2_hash(identity: &AuthIdentityBuffers) -> crate::Result<[u8; HASH_SIZE]> {
    if !identity.is_empty() {
        let hmac_key = if identity.password.as_ref().len() > SSPI_CREDENTIALS_HASH_LENGTH_OFFSET {
            convert_password_hash(identity.password.as_ref())?
        } else {
            compute_md4(identity.password.as_ref())
        };

        let user_utf16 = utils::bytes_to_utf16_string(identity.user.as_ref());
        let mut user_uppercase_with_domain = utils::string_to_utf16(user_utf16.to_uppercase().as_str());
        user_uppercase_with_domain.extend(&identity.domain);

        Ok(compute_hmac_md5(&hmac_key, &user_uppercase_with_domain)?)
    } else {
        Err(crate::Error::new(
            crate::ErrorKind::InvalidToken,
            String::from("Got empty identity"),
        ))
    }
    // hash by the callback is not implemented because the callback never sets
}

pub fn compute_lm_v2_response(
    client_challenge: &[u8],
    server_challenge: &[u8],
    ntlm_v2_hash: &[u8],
) -> crate::Result<[u8; LM_CHALLENGE_RESPONSE_BUFFER_SIZE]> {
    let mut lm_challenge_data = [0x00; CHALLENGE_SIZE * 2];
    lm_challenge_data[0..CHALLENGE_SIZE].clone_from_slice(server_challenge);
    lm_challenge_data[CHALLENGE_SIZE..].clone_from_slice(client_challenge);

    let mut lm_challenge_response = [0x00; LM_CHALLENGE_RESPONSE_BUFFER_SIZE];
    lm_challenge_response[0..HASH_SIZE].clone_from_slice(compute_hmac_md5(ntlm_v2_hash, &lm_challenge_data)?.as_ref());
    lm_challenge_response[HASH_SIZE..].clone_from_slice(client_challenge);
    Ok(lm_challenge_response)
}

pub fn compute_ntlm_v2_response(
    client_challenge: &[u8],
    server_challenge: &[u8],
    target_info: &[u8],
    ntlm_v2_hash: &[u8],
    timestamp: u64,
) -> crate::Result<(Vec<u8>, [u8; HASH_SIZE])> {
    let mut ntlm_v2_temp = Vec::with_capacity(NT_V2_RESPONSE_BASE_SIZE);
    ntlm_v2_temp.write_u8(1)?; // RespType 1 byte
    ntlm_v2_temp.write_u8(1)?; // HighRespType 1 byte
    ntlm_v2_temp.write_u16::<LittleEndian>(0)?; // Reserved1 2 bytes
    ntlm_v2_temp.write_u32::<LittleEndian>(0)?; // Reserved2 4 bytes
    ntlm_v2_temp.write_u64::<LittleEndian>(timestamp)?; // Timestamp 8 bytes
    ntlm_v2_temp.extend(client_challenge); // ClientChallenge 8 bytes
    ntlm_v2_temp.write_u32::<LittleEndian>(0)?; // Reserved3 4 bytes
    ntlm_v2_temp.extend(target_info); // TargetInfo

    let mut nt_proof_input = server_challenge.to_vec();
    nt_proof_input.extend(ntlm_v2_temp.as_slice());
    let nt_proof = compute_hmac_md5(ntlm_v2_hash, nt_proof_input.as_ref())?;

    let mut nt_challenge_response = nt_proof.to_vec();
    nt_challenge_response.append(ntlm_v2_temp.as_mut());

    let key_exchange_key = compute_hmac_md5(ntlm_v2_hash, nt_proof.as_ref())?;

    Ok((nt_challenge_response, key_exchange_key))
}

pub fn read_ntlm_v2_response(mut challenge_response: &[u8]) -> io::Result<(Vec<u8>, [u8; CHALLENGE_SIZE])> {
    let mut response = [0x00; HASH_SIZE];
    challenge_response.read_exact(response.as_mut())?;
    let _resp_type = challenge_response.read_u8()?;
    let _hi_resp_type = challenge_response.read_u8()?;
    let _reserved1 = challenge_response.read_u16::<LittleEndian>()?;
    let _reserved2 = challenge_response.read_u32::<LittleEndian>()?;
    let _timestamp = challenge_response.read_u64::<LittleEndian>()?;

    let mut client_challenge = [0x00; CHALLENGE_SIZE];
    challenge_response.read_exact(client_challenge.as_mut())?;
    let _reserved3 = challenge_response.read_u32::<LittleEndian>()?;

    let mut av_pairs = Vec::with_capacity(challenge_response.len());
    challenge_response.read_to_end(&mut av_pairs)?;

    Ok((av_pairs, client_challenge))
}

pub fn get_av_flags_from_response(av_pairs: &[AvPair]) -> io::Result<MsvAvFlags> {
    if let Some(AvPair::Flags(value)) = av_pairs.iter().find(|&av_pair| av_pair.as_u16() == AV_PAIR_FLAGS) {
        Ok(MsvAvFlags::from_bits(*value).unwrap_or_else(MsvAvFlags::empty))
    } else {
        Ok(MsvAvFlags::empty())
    }
}

pub fn get_challenge_timestamp_from_response(target_info: &[u8]) -> crate::Result<u64> {
    let av_pairs = AvPair::buffer_to_av_pairs(target_info)?;

    if let Some(AvPair::Timestamp(value)) = av_pairs.iter().find(|&av_pair| av_pair.as_u16() == AV_PAIR_TIMESTAMP) {
        Ok(*value)
    } else {
        now_file_time_timestamp()
    }
}


--- File: src/ntlm/messages/computations/test.rs ---
use time::{Date, Month, OffsetDateTime};

use crate::ntlm::messages::av_pair::*;
use crate::ntlm::messages::computations::*;
use crate::ntlm::messages::test::*;
use crate::{AuthIdentity, Username};

#[test]
fn get_system_time_as_file_time_test_one_second_diff() {
    let expected = 1000 * 1000 * 10;
    let end_date = Date::from_calendar_date(1601, Month::January, 1)
        .unwrap()
        .with_hms(0, 1, 2)
        .unwrap()
        .assume_utc();
    assert_eq!(convert_to_file_time(end_date).unwrap(), expected);
}

#[test]
fn get_system_time_as_file_time_test_start_date_is_bigger_than_end_date() {
    let end_date = Date::from_calendar_date(1601, Month::January, 1)
        .unwrap()
        .midnight()
        .assume_utc();
    assert!(convert_to_file_time(end_date).is_err());
}

#[test]
fn get_system_time_as_file_time_test_returns_value_in_correct_case() {
    let end_date = OffsetDateTime::now_utc();
    convert_to_file_time(end_date).unwrap();
}

#[test]
fn get_challenge_target_info_correct_writes_needed_values_with_timestamp() {
    let challenge_target_info_buffer = get_challenge_target_info(TIMESTAMP).unwrap();
    let mut av_pairs = AvPair::buffer_to_av_pairs(&challenge_target_info_buffer).unwrap();

    // check that does not have duplicates
    let len = av_pairs.len();
    av_pairs.dedup_by(|a, b| {
        let a: u16 = a.as_u16();
        let b: u16 = b.as_u16();
        a == b
    });
    assert_eq!(len, av_pairs.len());

    for av_pair in av_pairs.iter() {
        match av_pair {
            AvPair::Timestamp(value) => assert_eq!(*value, TIMESTAMP),
            AvPair::EOL => (),
            AvPair::NbDomainName(_value) => (),
            AvPair::NbComputerName(_value) => (),
            AvPair::DnsDomainName(_value) => (),
            AvPair::DnsComputerName(_value) => (),
            _ => unreachable!(),
        };
    }
}

#[test]
fn get_challenge_target_info_correct_writes_needed_values_with_empty_timestamp() {
    let challenge_target_info_buffer = get_challenge_target_info(TIMESTAMP).unwrap();
    let mut av_pairs = AvPair::buffer_to_av_pairs(&challenge_target_info_buffer).unwrap();

    // check that does not have duplicates
    let len = av_pairs.len();
    av_pairs.dedup_by(|a, b| {
        let a: u16 = a.as_u16();
        let b: u16 = b.as_u16();
        a == b
    });
    assert_eq!(len, av_pairs.len());

    for av_pair in av_pairs.iter() {
        match av_pair {
            AvPair::Timestamp(value) => assert_eq!(*value, TIMESTAMP),
            AvPair::EOL => (),
            AvPair::NbDomainName(_value) => (),
            AvPair::NbComputerName(_value) => (),
            AvPair::DnsDomainName(_value) => (),
            AvPair::DnsComputerName(_value) => (),
            _ => unreachable!(),
        };
    }
}

#[test]
fn get_authenticate_target_info_correct_returns_with_use_mic() {
    let send_single_host_data = false;
    let target_info = get_challenge_target_info(TIMESTAMP).unwrap();

    let mut authenticate_target_info =
        get_authenticate_target_info(target_info.as_ref(), None, send_single_host_data).unwrap();

    assert_eq!(
        authenticate_target_info[authenticate_target_info.len() - AUTHENTICATE_TARGET_INFO_PADDING_SIZE..],
        [0x00; AUTHENTICATE_TARGET_INFO_PADDING_SIZE]
    );
    authenticate_target_info.resize(
        authenticate_target_info.len() - AUTHENTICATE_TARGET_INFO_PADDING_SIZE,
        0x00,
    );
    let mut av_pairs = AvPair::buffer_to_av_pairs(&authenticate_target_info).unwrap();

    // check that does not have duplicates
    let len = av_pairs.len();
    av_pairs.dedup_by(|a, b| {
        let a: u16 = a.as_u16();
        let b: u16 = b.as_u16();
        a == b
    });
    assert_eq!(len, av_pairs.len());

    for av_pair in av_pairs.iter() {
        match av_pair {
            AvPair::Timestamp(value) => assert_eq!(*value, TIMESTAMP),
            AvPair::Flags(value) => assert_eq!(*value, MsvAvFlags::MESSAGE_INTEGRITY_CHECK.bits()),
            AvPair::EOL => (),
            AvPair::NbDomainName(_value) => (),
            AvPair::NbComputerName(_value) => (),
            AvPair::DnsDomainName(_value) => (),
            AvPair::DnsComputerName(_value) => (),
            _ => unreachable!(),
        };
    }
}

#[test]
fn get_authenticate_target_info_correct_returns_with_send_single_host_data() {
    let send_single_host_data = true;
    let target_info = get_challenge_target_info(TIMESTAMP).unwrap();

    let mut authenticate_target_info =
        get_authenticate_target_info(target_info.as_ref(), None, send_single_host_data).unwrap();

    assert_eq!(
        authenticate_target_info[authenticate_target_info.len() - AUTHENTICATE_TARGET_INFO_PADDING_SIZE..],
        [0x00; AUTHENTICATE_TARGET_INFO_PADDING_SIZE]
    );
    authenticate_target_info.resize(
        authenticate_target_info.len() - AUTHENTICATE_TARGET_INFO_PADDING_SIZE,
        0x00,
    );
    let mut av_pairs = AvPair::buffer_to_av_pairs(&authenticate_target_info).unwrap();

    // check that does not have duplicates
    let len = av_pairs.len();
    av_pairs.dedup_by(|a, b| {
        let a: u16 = a.as_u16();
        let b: u16 = b.as_u16();
        a == b
    });
    assert_eq!(len, av_pairs.len());

    for av_pair in av_pairs.iter() {
        match av_pair {
            AvPair::Timestamp(value) => assert_eq!(*value, TIMESTAMP),
            AvPair::SingleHost(value) => assert_eq!(value[..], SINGLE_HOST_DATA[..]),
            AvPair::EOL => (),
            AvPair::Flags(value) => assert_eq!(*value, MsvAvFlags::MESSAGE_INTEGRITY_CHECK.bits()),
            AvPair::NbDomainName(_value) => (),
            AvPair::NbComputerName(_value) => (),
            AvPair::DnsDomainName(_value) => (),
            AvPair::DnsComputerName(_value) => (),
            _ => unreachable!(),
        };
    }
}

#[test]
fn get_authenticate_target_info_returns_without_principal_name() {
    let send_single_host_data = false;
    let target_info = get_challenge_target_info(TIMESTAMP).unwrap();

    let mut authenticate_target_info =
        get_authenticate_target_info(target_info.as_ref(), None, send_single_host_data).unwrap();

    assert_eq!(
        authenticate_target_info[authenticate_target_info.len() - AUTHENTICATE_TARGET_INFO_PADDING_SIZE..],
        [0x00; AUTHENTICATE_TARGET_INFO_PADDING_SIZE]
    );
    authenticate_target_info.resize(
        authenticate_target_info.len() - AUTHENTICATE_TARGET_INFO_PADDING_SIZE,
        0x00,
    );
    let mut av_pairs = AvPair::buffer_to_av_pairs(&authenticate_target_info).unwrap();

    // check that does not have duplicates
    let len = av_pairs.len();
    av_pairs.dedup_by(|a, b| {
        let a: u16 = a.as_u16();
        let b: u16 = b.as_u16();
        a == b
    });
    assert_eq!(len, av_pairs.len());

    for av_pair in av_pairs.iter() {
        match av_pair {
            AvPair::Timestamp(value) => assert_eq!(*value, TIMESTAMP),
            AvPair::EOL => (),
            AvPair::Flags(value) => assert_eq!(*value, MsvAvFlags::MESSAGE_INTEGRITY_CHECK.bits()),
            AvPair::NbDomainName(_value) => (),
            AvPair::NbComputerName(_value) => (),
            AvPair::DnsDomainName(_value) => (),
            AvPair::DnsComputerName(_value) => (),
            _ => unreachable!(),
        };
    }
}

#[test]
fn compute_ntlmv2_hash_password_is_less_than_hash_len_offset() {
    let expected = [
        0xc, 0x86, 0x8a, 0x40, 0x3b, 0xfd, 0x7a, 0x93, 0xa3, 0x0, 0x1e, 0xf2, 0x2e, 0xf0, 0x2e, 0x3f,
    ];

    assert_eq!(compute_ntlm_v2_hash(&TEST_CREDENTIALS).unwrap(), expected);
}

#[test]
fn compute_ntlmv2_hash_password_local_logon() {
    let identity = AuthIdentity {
        username: Username::new("username", Some("win7")).unwrap(),
        password: String::from("password").into(),
    }
    .into();

    let expected = [
        0xef, 0xc2, 0xc0, 0x9f, 0x06, 0x11, 0x3d, 0x71, 0x08, 0xd0, 0xd2, 0x29, 0xfa, 0x4d, 0xe6, 0x98,
    ];

    assert_eq!(compute_ntlm_v2_hash(&identity).unwrap(), expected);
}

#[test]
fn compute_ntlmv2_hash_password_domain_logon() {
    let identity = AuthIdentity {
        username: Username::new("Administrator", Some("AWAKECODING")).unwrap(),
        password: String::from("Password123!").into(),
    }
    .into();

    let expected = [
        0xf7, 0x46, 0x48, 0xaa, 0x78, 0x78, 0x2e, 0x92, 0x0f, 0x92, 0x9a, 0xed, 0x7f, 0x1d, 0xd5, 0x23,
    ];

    assert_eq!(compute_ntlm_v2_hash(&identity).unwrap(), expected);
}

#[test]
fn compute_ntlmv2_hash_works_on_empty_password() {
    let identity = AuthIdentity {
        username: Username::new("Administrator", Some("AWAKECODING")).unwrap(),
        password: String::new().into(),
    }
    .into();

    let expected = [
        0xa0, 0x84, 0x29, 0x48, 0xa6, 0xb9, 0xac, 0xa7, 0x6c, 0xf5, 0x54, 0xdb, 0x5e, 0xc3, 0x17, 0x76,
    ];

    assert_eq!(compute_ntlm_v2_hash(&identity).unwrap(), expected);
}

#[test]
fn compute_ntlmv2_hash_with_large_password() {
    let mut password = b"!@#$%^&*()_+{}\"|\\[];:/?.>,<~` -=".to_vec();
    let garbage = [0x00; SSPI_CREDENTIALS_HASH_LENGTH_OFFSET];
    password.extend_from_slice(&garbage);
    let password = String::from_utf8(password).unwrap();

    let identity = AuthIdentity {
        username: Username::new("Administrator", Some("AWAKECODING")).unwrap(),
        password: password.into(),
    }
    .into();

    let expected = [
        0xcb, 0x14, 0x4b, 0x13, 0xe, 0x5e, 0x99, 0x64, 0x19, 0x19, 0x52, 0xb0, 0x55, 0x11, 0xa, 0x22,
    ];

    let ntlm_v2_hash = compute_ntlm_v2_hash(&identity).unwrap();

    assert_eq!(expected, ntlm_v2_hash);
}

#[test]
#[should_panic]
fn compute_ntlmv2_hash_fails_on_empty_identity() {
    assert!(compute_ntlm_v2_hash(&TEST_CREDENTIALS).is_err());
}

#[test]
fn compute_lm_v2_repsonse_correct_computes_response() {
    let ntlm_v2_hash = compute_ntlm_v2_hash(&TEST_CREDENTIALS).unwrap();
    let client_challenge = CLIENT_CHALLENGE.as_ref();
    let server_challenge = SERVER_CHALLENGE.as_ref();

    let mut expected = vec![
        0x5e, 0xc3, 0xc5, 0x2e, 0xe7, 0x5a, 0x23, 0x45, 0x73, 0x72, 0xd8, 0x2b, 0x43, 0xea, 0xc4, 0x26,
    ];
    expected.extend(client_challenge);

    assert_eq!(
        compute_lm_v2_response(client_challenge, server_challenge, ntlm_v2_hash.as_ref()).unwrap(),
        expected.as_slice()
    );
}

#[test]
fn compute_ntlm_v2_repsonse_correct_computes_challenge_response() {
    let server_challenge = SERVER_CHALLENGE;
    let client_challenge = CLIENT_CHALLENGE;
    let target_info = Vec::new();
    let ntlm_v2_hash = compute_ntlm_v2_hash(&TEST_CREDENTIALS).unwrap();
    let timestamp = TIMESTAMP;

    let expected = [
        0xa8, 0x38, 0x98, 0x9e, 0xdc, 0xbe, 0xcf, 0x8d, 0xb7, 0x5c, 0x14, 0x85, 0x26, 0xa0, 0x2a, 0xf9, 0x1, 0x1, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x33, 0x57, 0xbd, 0xb1, 0x7, 0x8b, 0xcf, 0x1, 0x20, 0xc0, 0x2b, 0x3d, 0xc0, 0x61,
        0xa7, 0x73, 0x0, 0x0, 0x0, 0x0,
    ];

    let (nt_challenge_response, _) = compute_ntlm_v2_response(
        client_challenge.as_ref(),
        server_challenge.as_ref(),
        target_info.as_ref(),
        ntlm_v2_hash.as_ref(),
        timestamp,
    )
    .unwrap();
    assert_eq!(nt_challenge_response[..], expected[..]);
}

#[test]
fn compute_ntlm_v2_repsonse_correct_computes_key_exchange_key() {
    let server_challenge = SERVER_CHALLENGE;
    let client_challenge = CLIENT_CHALLENGE;
    let target_info = Vec::new();
    let ntlm_v2_hash = compute_ntlm_v2_hash(&TEST_CREDENTIALS).unwrap();
    let timestamp = TIMESTAMP;

    let expected = [
        0x72, 0xe5, 0x3e, 0x4b, 0x89, 0x18, 0xc9, 0x8f, 0xda, 0xfb, 0xa0, 0x74, 0x6, 0x61, 0xbc, 0x9f,
    ];

    let (_, key_exchange_key) = compute_ntlm_v2_response(
        client_challenge.as_ref(),
        server_challenge.as_ref(),
        target_info.as_ref(),
        ntlm_v2_hash.as_ref(),
        timestamp,
    )
    .unwrap();

    assert_eq!(key_exchange_key, expected);
}

#[test]
fn convert_password_hash_spec_chars() {
    let mut message = b"!@#$%^&*()_+{}\"|\\[];:/?.>,<~` -=".to_vec();
    let garbage = [0x00; SSPI_CREDENTIALS_HASH_LENGTH_OFFSET];
    message.extend_from_slice(&garbage);

    let expected = [
        0x19, 0xF4, 0x77, 0xFA, 0xF9, 0xFB, 0x46, 0x65, 0x74, 0x64, 0xFF, 0xFE, 0xFC, 0x57, 0xF0, 0xD6,
    ];

    assert_eq!(convert_password_hash(&message).unwrap(), expected);
}

#[test]
fn convert_password_hash_simple_chars() {
    let mut message = b"1234567890qwertyuiopasdfghjklzxcvbnm".to_vec();
    let garbage = [0x00; SSPI_CREDENTIALS_HASH_LENGTH_OFFSET];
    message.extend_from_slice(&garbage);

    let expected = [
        0x12, 0x34, 0x56, 0x78, 0x90, 0xA0, 0xFB, 0xF2, 0xF2, 0x99, 0xBC, 0xDF, 0x11, 0x34, 0x73, 0x1C,
    ];

    assert_eq!(convert_password_hash(&message).unwrap(), expected);
}

#[test]
fn convert_password_hash_random_symbols() {
    let mut message = b"epfkwe 2358 $*(@$rg$ 5%*(Efei H!".to_vec();
    let garbage = [0x00; SSPI_CREDENTIALS_HASH_LENGTH_OFFSET];
    message.extend_from_slice(&garbage);

    let expected = [
        0xF9, 0xF4, 0x0E, 0x02, 0x35, 0xF0, 0xFA, 0x89, 0x5B, 0xF4, 0x05, 0xFA, 0x8E, 0xFE, 0xF0, 0xF1,
    ];

    assert_eq!(convert_password_hash(&message).unwrap(), expected);
}

#[test]
fn convert_password_hash_only_spaces() {
    let mut message = [b' '; 32].to_vec();
    let garbage = [0x00; SSPI_CREDENTIALS_HASH_LENGTH_OFFSET];
    message.extend_from_slice(&garbage);

    let expected = [0xF0; 16];

    assert_eq!(convert_password_hash(&message).unwrap(), expected);
}

#[test]
fn get_av_flags_from_response_returns_empty_flags_if_flags_are_absent() {
    let input_flags = vec![AvPair::Timestamp(0), AvPair::EOL];

    let expected_flags = MsvAvFlags::empty();

    let buffer = AvPair::list_to_buffer(input_flags.as_ref()).unwrap();
    let av_pairs = AvPair::buffer_to_av_pairs(&buffer).unwrap();

    let flags = get_av_flags_from_response(&av_pairs).unwrap();

    assert_eq!(expected_flags, flags);
}

#[test]
fn av_pair_list_to_buffer_with_all_possible_pairs() {
    let expected_buffer = [
        0x1, 0x0, 0xe, 0x0, 0x4e, 0x62, 0x43, 0x6f, 0x6d, 0x70, 0x75, 0x74, 0x65, 0x72, 0x4e, 0x61, 0x6d, 0x65, 0x2,
        0x0, 0xc, 0x0, 0x4e, 0x62, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x4e, 0x61, 0x6d, 0x65, 0x3, 0x0, 0xf, 0x0,
        0x44, 0x6e, 0x73, 0x43, 0x6f, 0x6d, 0x70, 0x75, 0x74, 0x65, 0x72, 0x4e, 0x61, 0x6d, 0x65, 0x4, 0x0, 0xd, 0x0,
        0x44, 0x6e, 0x73, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x4e, 0x61, 0x6d, 0x65, 0x5, 0x0, 0xb, 0x0, 0x44, 0x6e,
        0x73, 0x54, 0x72, 0x65, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x6, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0x0, 0x8,
        0x0, 0xd2, 0x2, 0x96, 0x49, 0x0, 0x0, 0x0, 0x0, 0x8, 0x0, 0x30, 0x0, 0x30, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x1, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0x9, 0x0, 0xa, 0x0, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0xa, 0x0,
        0x10, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0,
        0x0, 0x0, 0x0,
    ];

    let nb_computer_name = b"NbComputerName".to_vec();
    let nb_domain_name = b"NbDomainName".to_vec();
    let dns_computer_name = b"DnsComputerName".to_vec();
    let dns_domain_name = b"DnsDomainName".to_vec();
    let dns_tree_name = b"DnsTreeName".to_vec();
    let flags = 0;
    let timestamp = 1_234_567_890;
    let single_host_data = *SINGLE_HOST_DATA;
    let target_name = b"TargetName".to_vec();
    let channel_bindings = [0xff; HASH_SIZE];

    let av_pairs = vec![
        AvPair::NbComputerName(nb_computer_name),
        AvPair::NbDomainName(nb_domain_name),
        AvPair::DnsComputerName(dns_computer_name),
        AvPair::DnsDomainName(dns_domain_name),
        AvPair::DnsTreeName(dns_tree_name),
        AvPair::Flags(flags),
        AvPair::Timestamp(timestamp),
        AvPair::SingleHost(single_host_data),
        AvPair::TargetName(target_name),
        AvPair::ChannelBindings(channel_bindings),
        AvPair::EOL,
    ];

    let av_pairs_buffer = AvPair::list_to_buffer(av_pairs.as_ref()).unwrap();

    assert_eq!(expected_buffer.as_ref(), av_pairs_buffer.as_slice());
}

#[test]
fn av_pair_from_buffer_fails_on_invalid_flags_size() {
    let buffer = [0x6, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0];
    assert!(AvPair::from_buffer(buffer.as_ref()).is_err());
}

#[test]
fn av_pair_from_buffer_fails_on_invalid_timestamp_size() {
    let buffer = [0x7, 0x0, 0x7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0];
    assert!(AvPair::from_buffer(buffer.as_ref()).is_err());
}

#[test]
fn av_pair_from_buffer_fails_on_invalid_eol_size() {
    let buffer = [0x0, 0x0, 0x1, 0x0, 0x0];
    assert!(AvPair::from_buffer(buffer.as_ref()).is_err());
}

#[test]
fn av_pair_from_buffer_fails_on_invalid_single_host_data_size() {
    let buffer = [0x8, 0x0, 0x1, 0x0, 0x0];
    assert!(AvPair::from_buffer(buffer.as_ref()).is_err());
}

#[test]
fn av_pair_from_buffer_fails_on_invalid_channel_bindings_size() {
    let buffer = [0xa0, 0x0, 0x1, 0x0, 0x0];
    assert!(AvPair::from_buffer(buffer.as_ref()).is_err());
}

#[test]
fn av_pair_from_buffer_fails_on_invalid_av_type() {
    let buffer = [0xa1, 0x0, 0x1, 0x0, 0x0];
    assert!(AvPair::from_buffer(buffer.as_ref()).is_err());
}


--- File: src/ntlm/messages/mod.rs ---
pub mod client;
pub mod server;
#[cfg(test)]
pub mod test;

mod av_pair;
mod computations;

use std::io;

use byteorder::{LittleEndian, ReadBytesExt, WriteBytesExt};

use crate::ntlm::{NegotiateFlags, NTLM_VERSION_SIZE};

const NTLM_SIGNATURE: &[u8; NTLM_SIGNATURE_SIZE] = b"NTLMSSP\0";
const NTLM_SIGNATURE_SIZE: usize = 8;

const MAGIC_SIZE: usize = 59;
const CLIENT_SIGN_MAGIC: &[u8; MAGIC_SIZE] = b"session key to client-to-server signing key magic constant\0";
const SERVER_SIGN_MAGIC: &[u8; MAGIC_SIZE] = b"session key to server-to-client signing key magic constant\0";
const CLIENT_SEAL_MAGIC: &[u8; MAGIC_SIZE] = b"session key to client-to-server sealing key magic constant\0";
const SERVER_SEAL_MAGIC: &[u8; MAGIC_SIZE] = b"session key to server-to-client sealing key magic constant\0";

#[derive(Clone, Copy)]
pub enum MessageTypes {
    Negotiate = 1,
    Challenge = 2,
    Authenticate = 3,
}

pub struct MessageFields {
    buffer: Vec<u8>,
    buffer_offset: u32,
}

impl MessageFields {
    fn new() -> Self {
        Self {
            buffer: Vec::new(),
            buffer_offset: 0,
        }
    }
    fn with_buffer(buffer: Vec<u8>) -> Self {
        Self {
            buffer,
            buffer_offset: 0,
        }
    }
    fn write_to(&self, mut buffer: impl io::Write) -> io::Result<()> {
        buffer.write_u16::<LittleEndian>(self.buffer.len() as u16)?; // Len
        buffer.write_u16::<LittleEndian>(self.buffer.len() as u16)?; // MaxLen
        buffer.write_u32::<LittleEndian>(self.buffer_offset)?; // BufferOffset

        Ok(())
    }
    fn write_buffer_to(&self, mut buffer: impl io::Write) -> io::Result<()> {
        buffer.write_all(&self.buffer)?;

        Ok(())
    }
    fn read_from(&mut self, mut buffer: impl io::Read) -> io::Result<()> {
        let len = buffer.read_u16::<LittleEndian>()?; // Len
        let _max_len = buffer.read_u16::<LittleEndian>()?; // MaxLen
        self.buffer_offset = buffer.read_u32::<LittleEndian>()?; // BufferOffset
        self.buffer.resize(len as usize, 0x00);
        Ok(())
    }
    fn read_buffer_from(&mut self, mut cursor: impl io::Read + io::Seek) -> io::Result<()> {
        cursor.seek(io::SeekFrom::Start(u64::from(self.buffer_offset)))?;
        cursor.read_exact(&mut self.buffer)?;

        Ok(())
    }

    fn read_buffer_from_cursor<T>(&mut self, cursor: &mut io::Cursor<T>) -> io::Result<()>
    where
        io::Cursor<T>: io::Read + io::Seek,
    {
        self.read_buffer_from(cursor)
    }
}

fn try_read_version(flags: NegotiateFlags, mut cursor: impl io::Read) -> io::Result<Option<[u8; NTLM_VERSION_SIZE]>> {
    if flags.contains(NegotiateFlags::NTLM_SSP_NEGOTIATE_VERSION) {
        // major version 1 byte
        // minor version 1 byte
        // product build 2 bytes
        // reserved 3 bytes
        // ntlm revision current 1 byte
        let mut version = [0x00; NTLM_VERSION_SIZE];
        cursor.read_exact(version.as_mut())?;

        Ok(Some(version))
    } else {
        Ok(None)
    }
}

pub fn read_ntlm_header(mut stream: impl io::Read, expected_message_type: MessageTypes) -> crate::Result<()> {
    let mut signature = [0x00; NTLM_SIGNATURE_SIZE];
    stream.read_exact(signature.as_mut())?;
    let message_type = stream.read_u32::<LittleEndian>()?;

    if signature.as_ref() != NTLM_SIGNATURE {
        return Err(crate::Error::new(
            crate::ErrorKind::InvalidToken,
            format!("Read NTLM signature is invalid: {:?}", signature),
        ));
    }
    if message_type != expected_message_type as u32 {
        return Err(crate::Error::new(
            crate::ErrorKind::InvalidToken,
            format!(
                "Message type is invalid: {} != expected ({})",
                message_type, expected_message_type as u32
            ),
        ));
    }

    Ok(())
}


--- File: src/ntlm/messages/server.rs ---
mod authenticate;
mod challenge;
mod complete_authenticate;
mod negotiate;
#[cfg(test)]
mod test;

pub use self::authenticate::read_authenticate;
pub use self::challenge::write_challenge;
pub use self::complete_authenticate::complete_authenticate;
pub use self::negotiate::read_negotiate;


--- File: src/ntlm/messages/server/authenticate.rs ---
use std::io::{self, Read};

use byteorder::{LittleEndian, ReadBytesExt};

use crate::crypto::compute_md5_channel_bindings_hash;
use crate::ntlm::messages::av_pair::{AvPair, MsvAvFlags, AV_PAIR_CHANNEL_BINDINGS};
use crate::ntlm::messages::computations::*;
use crate::ntlm::messages::{read_ntlm_header, try_read_version, MessageFields, MessageTypes};
use crate::ntlm::{
    AuthIdentityBuffers, AuthenticateMessage, ChannelBindings, Mic, NegotiateFlags, Ntlm, NtlmState,
    ENCRYPTED_RANDOM_SESSION_KEY_SIZE, MESSAGE_INTEGRITY_CHECK_SIZE,
};
use crate::SecurityStatus;

const HEADER_SIZE: usize = 64;

struct AuthenticateMessageFields {
    workstation: MessageFields,
    domain_name: MessageFields,
    encrypted_random_session_key: MessageFields,
    user_name: MessageFields,
    lm_challenge_response: MessageFields,
    nt_challenge_response: MessageFields,
}

pub fn read_authenticate(context: &mut Ntlm, mut stream: impl io::Read) -> crate::Result<SecurityStatus> {
    check_state(context.state)?;

    let mut buffer = Vec::with_capacity(HEADER_SIZE);
    stream.read_to_end(&mut buffer)?;
    let mut buffer = io::Cursor::new(buffer);

    read_ntlm_header(&mut buffer, MessageTypes::Authenticate)?;
    let (mut message_fields, flags) = read_header(&mut buffer)?;
    context.flags = flags;
    let _version = try_read_version(context.flags, &mut buffer)?;
    let mic = read_payload(flags, &mut message_fields, &mut buffer)?;
    let message = buffer.into_inner();

    let (authenticate_message, updated_identity) = process_message_fields(
        &context.identity,
        message_fields,
        mic,
        message,
        &context.channel_bindings,
    )?;
    context.identity = Some(updated_identity);
    context.authenticate_message = Some(authenticate_message);

    context.state = NtlmState::Completion;

    Ok(crate::SecurityStatus::CompleteNeeded)
}

fn check_state(state: NtlmState) -> crate::Result<()> {
    if state != NtlmState::Authenticate {
        Err(crate::Error::new(
            crate::ErrorKind::OutOfSequence,
            "Read authenticate was fired but the state is not an Authenticate",
        ))
    } else {
        Ok(())
    }
}

fn read_header(mut buffer: impl io::Read) -> crate::Result<(AuthenticateMessageFields, NegotiateFlags)> {
    let mut lm_challenge_response = MessageFields::new();
    let mut nt_challenge_response = MessageFields::new();
    let mut domain_name = MessageFields::new();
    let mut user_name = MessageFields::new();
    let mut workstation = MessageFields::new();
    let mut encrypted_random_session_key = MessageFields::new();

    lm_challenge_response.read_from(&mut buffer)?;
    nt_challenge_response.read_from(&mut buffer)?;
    domain_name.read_from(&mut buffer)?;
    user_name.read_from(&mut buffer)?;
    workstation.read_from(&mut buffer)?;
    encrypted_random_session_key.read_from(&mut buffer)?;
    let negotiate_flags =
        NegotiateFlags::from_bits(buffer.read_u32::<LittleEndian>()?).unwrap_or_else(NegotiateFlags::empty);

    let negotiate_key_exchange = negotiate_flags.contains(NegotiateFlags::NTLM_SSP_NEGOTIATE_KEY_EXCH);
    if negotiate_key_exchange && encrypted_random_session_key.buffer.is_empty()
        || !negotiate_key_exchange && !encrypted_random_session_key.buffer.is_empty()
    {
        return Err(crate::Error::new(
            crate::ErrorKind::InvalidToken,
            "Negotiate key exchange flag is set but encrypted random session key \
                 is empty or the flag is not set but the key is not empty",
        ));
    }

    if negotiate_key_exchange && encrypted_random_session_key.buffer.len() != ENCRYPTED_RANDOM_SESSION_KEY_SIZE {
        return Err(crate::Error::new(
            crate::ErrorKind::InvalidToken,
            "Invalid encrypted random session key",
        ));
    }

    let message_fields = AuthenticateMessageFields {
        workstation,
        domain_name,
        encrypted_random_session_key,
        user_name,
        lm_challenge_response,
        nt_challenge_response,
    };

    Ok((message_fields, negotiate_flags))
}

fn read_payload<T>(
    negotiate_flags: NegotiateFlags,
    message_fields: &mut AuthenticateMessageFields,
    buffer: &mut io::Cursor<T>,
) -> crate::Result<Option<Mic>>
where
    io::Cursor<T>: io::Read + io::Seek,
{
    let mic = if negotiate_flags.contains(NegotiateFlags::NTLM_SSP_NEGOTIATE_TARGET_INFO) {
        let mic_offset = buffer.position() as u8;
        let mut mic_value = [0x00; MESSAGE_INTEGRITY_CHECK_SIZE];
        buffer.read_exact(&mut mic_value)?;
        Some(Mic::new(mic_value, mic_offset))
    } else {
        None
    };

    message_fields.domain_name.read_buffer_from_cursor(buffer)?;
    message_fields.user_name.read_buffer_from_cursor(buffer)?;
    message_fields.workstation.read_buffer_from_cursor(buffer)?;
    message_fields.lm_challenge_response.read_buffer_from_cursor(buffer)?;
    message_fields.nt_challenge_response.read_buffer_from_cursor(buffer)?;
    message_fields
        .encrypted_random_session_key
        .read_buffer_from_cursor(buffer)?;

    Ok(mic)
}

fn process_message_fields(
    identity: &Option<AuthIdentityBuffers>,
    message_fields: AuthenticateMessageFields,
    mic: Option<Mic>,
    authenticate_message: Vec<u8>,
    channel_bindings: &Option<ChannelBindings>,
) -> crate::Result<(AuthenticateMessage, AuthIdentityBuffers)> {
    if message_fields.nt_challenge_response.buffer.is_empty() {
        return Err(crate::Error::new(
            crate::ErrorKind::InvalidToken,
            "NtChallengeResponse cannot be empty",
        ));
    }

    let (target_info, client_challenge) = read_ntlm_v2_response(message_fields.nt_challenge_response.buffer.as_ref())?;

    let av_pairs = AvPair::buffer_to_av_pairs(target_info.as_ref())?;

    let mic = if mic.is_some() {
        let challenge_response_av_flags = get_av_flags_from_response(&av_pairs)?;
        if challenge_response_av_flags.contains(MsvAvFlags::MESSAGE_INTEGRITY_CHECK) {
            mic
        } else {
            None
        }
    } else {
        None
    };

    if let Some(AvPair::ChannelBindings(hash)) = av_pairs
        .iter()
        .find(|av_pair| av_pair.as_u16() == AV_PAIR_CHANNEL_BINDINGS)
    {
        if let Some(channel_bindings) = channel_bindings.as_ref() {
            if compute_md5_channel_bindings_hash(channel_bindings) != *hash {
                return Err(crate::Error::new(
                    crate::ErrorKind::BadBindings,
                    "Channel bindings hash mismatch",
                ));
            }
        }
    }

    // will not set workstation because it is not used anywhere

    let encrypted_random_session_key: Option<[u8; ENCRYPTED_RANDOM_SESSION_KEY_SIZE]> = match message_fields.encrypted_random_session_key.buffer.len() {
      0 => None,
      ENCRYPTED_RANDOM_SESSION_KEY_SIZE => {
        let mut encrypted_random_session_key = [0x00; ENCRYPTED_RANDOM_SESSION_KEY_SIZE];
        encrypted_random_session_key.clone_from_slice(message_fields.encrypted_random_session_key.buffer.as_ref());
        Some(encrypted_random_session_key)
      },
      key_len => {
        return Err(crate::Error::new(
          crate::ErrorKind::InvalidToken,
          format!("Encrypted random session key has wrong length. Expected {ENCRYPTED_RANDOM_SESSION_KEY_SIZE} bytes, got {key_len} bytes."),
        ))
      }
    };

    let mut identity = if let Some(identity) = identity {
        identity.clone()
    } else {
        AuthIdentityBuffers::default()
    };

    if !message_fields.user_name.buffer.is_empty() {
        identity.user = message_fields.user_name.buffer.clone();
    }
    if !message_fields.domain_name.buffer.is_empty() {
        identity.domain = message_fields.domain_name.buffer;
    }

    Ok((
        AuthenticateMessage::new(
            authenticate_message,
            mic,
            target_info,
            client_challenge,
            encrypted_random_session_key,
        ),
        identity,
    ))
}


--- File: src/ntlm/messages/server/challenge.rs ---
use std::io;

use byteorder::{LittleEndian, WriteBytesExt};

use crate::ntlm::messages::computations::*;
use crate::ntlm::messages::{MessageFields, MessageTypes, NTLM_SIGNATURE, NTLM_VERSION_SIZE};
use crate::ntlm::{ChallengeMessage, NegotiateFlags, Ntlm, NtlmState};
use crate::SecurityStatus;

const BASE_OFFSET: usize = 48;
const CHALLENGE_MESSAGE_OFFSET: usize = BASE_OFFSET + NTLM_VERSION_SIZE;

struct ChallengeMessageFields {
    target_name: MessageFields,
    target_info: MessageFields,
}

impl ChallengeMessageFields {
    fn new(target_info: &[u8], offset: u32) -> Self {
        let mut target_info = MessageFields::with_buffer(target_info.to_vec());
        let mut target_name = MessageFields::new();

        // will not set target name because it is not used anywhere

        target_name.buffer_offset = offset;
        target_info.buffer_offset = target_name.buffer_offset + target_name.buffer.len() as u32;

        ChallengeMessageFields {
            target_name,
            target_info,
        }
    }

    fn data_len(&self) -> usize {
        self.target_info.buffer_offset as usize + self.target_info.buffer.len()
    }
}

pub fn write_challenge(context: &mut Ntlm, mut transport: impl io::Write) -> crate::Result<SecurityStatus> {
    check_state(context.state)?;

    let server_challenge = generate_challenge()?;
    let timestamp = now_file_time_timestamp()?;
    let target_info = get_challenge_target_info(timestamp)?;

    context.flags = get_flags(context.flags);
    let message_fields = ChallengeMessageFields::new(target_info.as_ref(), CHALLENGE_MESSAGE_OFFSET as u32);

    let mut buffer = io::Cursor::new(Vec::with_capacity(message_fields.data_len()));

    write_header(
        context.flags,
        server_challenge.as_ref(),
        context.version.as_ref(),
        &message_fields,
        &mut buffer,
    )?;
    write_payload(&message_fields, &mut buffer)?;

    let message = buffer.into_inner();

    transport.write_all(message.as_slice())?;
    transport.flush()?;

    context.challenge_message = Some(ChallengeMessage::new(message, target_info, server_challenge, timestamp));
    context.state = NtlmState::Authenticate;

    Ok(crate::SecurityStatus::ContinueNeeded)
}

fn check_state(state: NtlmState) -> crate::Result<()> {
    if state != NtlmState::Challenge {
        Err(crate::Error::new(
            crate::ErrorKind::OutOfSequence,
            String::from("Write challenge was fired but the state is not a Challenge"),
        ))
    } else {
        Ok(())
    }
}

fn get_flags(negotiate_flags: NegotiateFlags) -> NegotiateFlags {
    negotiate_flags | NegotiateFlags::NTLM_SSP_NEGOTIATE_TARGET_INFO
}

fn write_header(
    negotiate_flags: NegotiateFlags,
    server_challenge: &[u8],
    version: &[u8],
    message_fields: &ChallengeMessageFields,
    mut buffer: impl io::Write,
) -> io::Result<()> {
    buffer.write_all(NTLM_SIGNATURE)?; // signature 8 bytes
    buffer.write_u32::<LittleEndian>(MessageTypes::Challenge as u32)?; // message type 4 bytes
    message_fields.target_name.write_to(&mut buffer)?; // target name fields 8 bytes
    buffer.write_u32::<LittleEndian>(negotiate_flags.bits())?; // negotiate flags 4 bytes
    buffer.write_all(server_challenge)?; // server challenge 8 bytes
    buffer.write_u64::<LittleEndian>(0x00)?; // reserved 8 bytes
    message_fields.target_info.write_to(&mut buffer)?; // target info fields 8 bytes
    buffer.write_all(version)?; // version 8 bytes

    Ok(())
}

fn write_payload(message_fields: &ChallengeMessageFields, mut buffer: impl io::Write) -> io::Result<()> {
    message_fields.target_name.write_buffer_to(&mut buffer)?;
    message_fields.target_info.write_buffer_to(&mut buffer)?;

    Ok(())
}


--- File: src/ntlm/messages/server/complete_authenticate.rs ---
use crate::crypto::{Rc4, HASH_SIZE};
use crate::ntlm::messages::computations::*;
use crate::ntlm::messages::{CLIENT_SEAL_MAGIC, CLIENT_SIGN_MAGIC, SERVER_SEAL_MAGIC, SERVER_SIGN_MAGIC};
use crate::ntlm::{Mic, NegotiateFlags, Ntlm, NtlmState, MESSAGE_INTEGRITY_CHECK_SIZE, SESSION_KEY_SIZE};
use crate::SecurityStatus;

pub fn complete_authenticate(context: &mut Ntlm) -> crate::Result<SecurityStatus> {
    check_state(context.state)?;

    let negotiate_message = context
        .negotiate_message
        .as_ref()
        .expect("negotiate message must be set on negotiate phase");
    let challenge_message = context
        .challenge_message
        .as_ref()
        .expect("challenge message must be set on challenge phase");
    let authenticate_message = context
        .authenticate_message
        .as_ref()
        .expect("authenticate message must be set on authenticate phase");

    let ntlm_v2_hash = compute_ntlm_v2_hash(
        context
            .identity
            .as_ref()
            .expect("Identity must be present on complete_authenticate phase"),
    )?;
    let (_, key_exchange_key) = compute_ntlm_v2_response(
        authenticate_message.client_challenge.as_ref(),
        challenge_message.server_challenge.as_ref(),
        authenticate_message.target_info.as_ref(),
        ntlm_v2_hash.as_ref(),
        challenge_message.timestamp,
    )?;
    let session_key = authenticate_message
        .encrypted_random_session_key
        .map_or(Ok(key_exchange_key), |encrypted_random_session_key| {
            get_session_key(key_exchange_key, &encrypted_random_session_key, context.flags)
        })?;

    context.send_signing_key = generate_signing_key(session_key.as_ref(), SERVER_SIGN_MAGIC);
    context.recv_signing_key = generate_signing_key(session_key.as_ref(), CLIENT_SIGN_MAGIC);
    context.send_sealing_key = Some(Rc4::new(&generate_signing_key(session_key.as_ref(), SERVER_SEAL_MAGIC)));
    context.recv_sealing_key = Some(Rc4::new(&generate_signing_key(session_key.as_ref(), CLIENT_SEAL_MAGIC)));

    check_mic_correctness(
        negotiate_message.message.as_ref(),
        challenge_message.message.as_ref(),
        authenticate_message.message.as_ref(),
        &authenticate_message.mic,
        session_key.as_ref(),
    )?;

    context.session_key = Some(session_key);
    context.state = NtlmState::Final;

    Ok(SecurityStatus::Ok)
}

fn check_state(state: NtlmState) -> crate::Result<()> {
    if state != NtlmState::Completion {
        Err(crate::Error::new(
            crate::ErrorKind::OutOfSequence,
            String::from("Complete authenticate was fired but the state is not a Completion"),
        ))
    } else {
        Ok(())
    }
}

fn check_mic_correctness(
    negotiate_message: &[u8],
    challenge_message: &[u8],
    authenticate_message: &[u8],
    mic: &Option<Mic>,
    exported_session_key: &[u8],
) -> crate::Result<()> {
    if mic.is_some() {
        // Client calculates the MIC with the authenticate message
        // without the MIC ([0x00;16] instead of data),
        // so for check correctness of the MIC,
        // we need empty the MIC part of auth. message and then will come back the MIC.
        let mic = mic.as_ref().unwrap();
        let mut authenticate_message = authenticate_message.to_vec();
        authenticate_message[mic.offset as usize..mic.offset as usize + MESSAGE_INTEGRITY_CHECK_SIZE]
            .clone_from_slice(&[0x00; MESSAGE_INTEGRITY_CHECK_SIZE]);
        let calculated_mic = compute_message_integrity_check(
            negotiate_message,
            challenge_message,
            authenticate_message.as_ref(),
            exported_session_key,
        )?;

        if mic.value != calculated_mic {
            return Err(crate::Error::new(
                crate::ErrorKind::MessageAltered,
                String::from("Message Integrity Check (MIC) verification failed!"),
            ));
        }
    }

    Ok(())
}

fn get_session_key(
    key_exchange_key: [u8; HASH_SIZE],
    encrypted_random_session_key: &[u8],
    flags: NegotiateFlags,
) -> crate::Result<[u8; SESSION_KEY_SIZE]> {
    let session_key = if flags.contains(NegotiateFlags::NTLM_SSP_NEGOTIATE_KEY_EXCH) {
        let mut session_key = [0x00; SESSION_KEY_SIZE];
        session_key.clone_from_slice(
            Rc4::new(key_exchange_key.as_ref())
                .process(encrypted_random_session_key)
                .as_slice(),
        );

        session_key
    } else {
        key_exchange_key
    };

    Ok(session_key)
}


--- File: src/ntlm/messages/server/negotiate.rs ---
use std::io;

use byteorder::{LittleEndian, ReadBytesExt};

use crate::ntlm::messages::{read_ntlm_header, try_read_version, MessageFields, MessageTypes};
use crate::ntlm::{NegotiateFlags, NegotiateMessage, Ntlm, NtlmState};
use crate::SecurityStatus;

const HEADER_SIZE: usize = 32;

pub fn read_negotiate(context: &mut Ntlm, mut stream: impl io::Read) -> crate::Result<SecurityStatus> {
    check_state(context.state)?;

    let mut buffer = Vec::with_capacity(HEADER_SIZE);
    stream.read_to_end(&mut buffer)?;
    let mut buffer = io::Cursor::new(buffer);

    read_ntlm_header(&mut buffer, MessageTypes::Negotiate)?;
    context.flags = read_header(&mut buffer)?;
    let _version = try_read_version(context.flags, &mut buffer)?;

    let message = buffer.into_inner();
    context.negotiate_message = Some(NegotiateMessage::new(message));

    context.state = NtlmState::Challenge;

    Ok(crate::SecurityStatus::ContinueNeeded)
}

fn check_state(state: NtlmState) -> crate::Result<()> {
    if state != NtlmState::Negotiate {
        Err(crate::Error::new(
            crate::ErrorKind::OutOfSequence,
            String::from("Read negotiate was fired but the state is not a Negotiate"),
        ))
    } else {
        Ok(())
    }
}

fn read_header(mut buffer: impl io::Read) -> crate::Result<NegotiateFlags> {
    let mut domain_name = MessageFields::new();
    let mut workstation = MessageFields::new();

    let negotiate_flags =
        NegotiateFlags::from_bits(buffer.read_u32::<LittleEndian>()?).unwrap_or_else(NegotiateFlags::empty);

    if !negotiate_flags.contains(NegotiateFlags::NTLM_SSP_NEGOTIATE_REQUEST_TARGET)
        || !negotiate_flags.contains(NegotiateFlags::NTLM_SSP_NEGOTIATE_NTLM)
        || !negotiate_flags.contains(NegotiateFlags::NTLM_SSP_NEGOTIATE_UNICODE)
    {
        return Err(crate::Error::new(
            crate::ErrorKind::InvalidToken,
            String::from("Negotiate flags do not contain the necessary flags"),
        ));
    }

    domain_name.read_from(&mut buffer)?;
    workstation.read_from(&mut buffer)?;

    Ok(negotiate_flags)
}


--- File: src/ntlm/messages/server/test.rs ---
use super::*;
use crate::ntlm::messages::test::*;
use crate::ntlm::*;

const LOCAL_AUTHENTICATE_MESSAGE: [u8; 312] = [
    0x4e, 0x54, 0x4c, 0x4d, 0x53, 0x53, 0x50, 0x00, 0x03, 0x00, 0x00, 0x00, 0x18, 0x00, 0x18, 0x00, 0x5a, 0x00, 0x00,
    0x00, 0xb6, 0x00, 0xb6, 0x00, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x02, 0x00,
    0x02, 0x00, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00, 0x28,
    0x01, 0x00, 0x00, 0x35, 0x82, 0x88, 0xe2, 0x06, 0x01, 0xb1, 0x1d, 0x00, 0x00, 0x00, 0x0f, 0xec, 0x30, 0xba, 0x0f,
    0x97, 0xba, 0xbd, 0x1e, 0xa6, 0x21, 0x16, 0x5e, 0x92, 0x51, 0xfc, 0xe7, 0x61, 0x00, 0x7f, 0x04, 0x90, 0xe4, 0xe8,
    0xd6, 0xb6, 0x64, 0xbd, 0xaf, 0x3c, 0x47, 0x26, 0x2f, 0xbe, 0x4c, 0xe5, 0x19, 0x6d, 0x0d, 0xd0, 0x4b, 0x3b, 0x90,
    0xde, 0x07, 0x90, 0x05, 0x66, 0x87, 0x79, 0x7b, 0xd4, 0x66, 0xde, 0xc2, 0xf5, 0xc2, 0x70, 0x88, 0x01, 0x01, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xb4, 0x45, 0xc6, 0x13, 0xd0, 0xd4, 0x01, 0xe5, 0x19, 0x6d, 0x0d, 0xd0, 0x4b,
    0x3b, 0x90, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x08, 0x00, 0x56, 0x00, 0x47, 0x00, 0x50, 0x00, 0x43, 0x00, 0x01,
    0x00, 0x08, 0x00, 0x56, 0x00, 0x47, 0x00, 0x50, 0x00, 0x43, 0x00, 0x04, 0x00, 0x08, 0x00, 0x56, 0x00, 0x47, 0x00,
    0x50, 0x00, 0x43, 0x00, 0x03, 0x00, 0x08, 0x00, 0x56, 0x00, 0x47, 0x00, 0x50, 0x00, 0x43, 0x00, 0x07, 0x00, 0x08,
    0x00, 0x80, 0xb4, 0x45, 0xc6, 0x13, 0xd0, 0xd4, 0x01, 0x06, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00, 0x00, 0x0a, 0x00,
    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09,
    0x00, 0x1e, 0x00, 0x54, 0x00, 0x45, 0x00, 0x52, 0x00, 0x4d, 0x00, 0x53, 0x00, 0x52, 0x00, 0x56, 0x00, 0x2f, 0x00,
    0x30, 0x00, 0x2e, 0x00, 0x30, 0x00, 0x2e, 0x00, 0x30, 0x00, 0x2e, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc2, 0x1d, 0xce, 0x10, 0xc5, 0xd1, 0x95, 0x01,
    0x3f, 0xb1, 0x8c, 0x26, 0x70, 0x9f, 0x50, 0x8b,
];
const LOCAL_MIC: [u8; 16] = [
    0xec, 0x30, 0xba, 0x0f, 0x97, 0xba, 0xbd, 0x1e, 0xa6, 0x21, 0x16, 0x5e, 0x92, 0x51, 0xfc, 0xe7,
];
const LOCAL_ENCRYPTED_RANDOM_SESSION_KEY: [u8; 16] = [
    0xc2, 0x1d, 0xce, 0x10, 0xc5, 0xd1, 0x95, 0x1, 0x3f, 0xb1, 0x8c, 0x26, 0x70, 0x9f, 0x50, 0x8b,
];
const LOCAL_USER_NAME: [u8; 2] = [0x61, 0x00];

const DOMAIN_AUTHENTICATE_MESSAGE: [u8; 570] = [
    0x4e, 0x54, 0x4c, 0x4d, 0x53, 0x53, 0x50, 0x00, 0x03, 0x00, 0x00, 0x00, 0x18, 0x00, 0x18, 0x00, 0x98, 0x00, 0x00,
    0x00, 0x7a, 0x01, 0x7a, 0x01, 0xb0, 0x00, 0x00, 0x00, 0x16, 0x00, 0x16, 0x00, 0x58, 0x00, 0x00, 0x00, 0x1a, 0x00,
    0x1a, 0x00, 0x6e, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00, 0x88, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00, 0x2a,
    0x02, 0x00, 0x00, 0x35, 0x82, 0x88, 0xe2, 0x06, 0x01, 0xb0, 0x1d, 0x00, 0x00, 0x00, 0x0f, 0x12, 0x28, 0x00, 0xa0,
    0xb2, 0x29, 0x47, 0x12, 0x1e, 0x8e, 0x54, 0xf8, 0x29, 0xdb, 0x52, 0x1e, 0x41, 0x00, 0x57, 0x00, 0x41, 0x00, 0x4b,
    0x00, 0x45, 0x00, 0x43, 0x00, 0x4f, 0x00, 0x44, 0x00, 0x49, 0x00, 0x4e, 0x00, 0x47, 0x00, 0x41, 0x00, 0x64, 0x00,
    0x6d, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x69, 0x00, 0x73, 0x00, 0x74, 0x00, 0x72, 0x00, 0x61, 0x00, 0x74, 0x00, 0x6f,
    0x00, 0x72, 0x00, 0x57, 0x00, 0x49, 0x00, 0x4e, 0x00, 0x44, 0x00, 0x4f, 0x00, 0x57, 0x00, 0x53, 0x00, 0x37, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xf5, 0x61, 0x4e, 0x2f, 0x00, 0xd0, 0x15, 0xb0, 0x70, 0xb0, 0x3e, 0x82, 0x91, 0x5f,
    0xc7, 0x08, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0xfd, 0xae, 0x48, 0x07, 0xcb, 0xcb, 0x01, 0xa5,
    0x00, 0x28, 0x29, 0xcd, 0x07, 0xe3, 0xbc, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x16, 0x00, 0x41, 0x00, 0x57, 0x00,
    0x41, 0x00, 0x4b, 0x00, 0x45, 0x00, 0x43, 0x00, 0x4f, 0x00, 0x44, 0x00, 0x49, 0x00, 0x4e, 0x00, 0x47, 0x00, 0x01,
    0x00, 0x10, 0x00, 0x57, 0x00, 0x49, 0x00, 0x4e, 0x00, 0x32, 0x00, 0x4b, 0x00, 0x38, 0x00, 0x52, 0x00, 0x32, 0x00,
    0x04, 0x00, 0x24, 0x00, 0x61, 0x00, 0x77, 0x00, 0x61, 0x00, 0x6b, 0x00, 0x65, 0x00, 0x63, 0x00, 0x6f, 0x00, 0x64,
    0x00, 0x69, 0x00, 0x6e, 0x00, 0x67, 0x00, 0x2e, 0x00, 0x61, 0x00, 0x74, 0x00, 0x68, 0x00, 0x2e, 0x00, 0x63, 0x00,
    0x78, 0x00, 0x03, 0x00, 0x36, 0x00, 0x57, 0x00, 0x49, 0x00, 0x4e, 0x00, 0x32, 0x00, 0x4b, 0x00, 0x38, 0x00, 0x52,
    0x00, 0x32, 0x00, 0x2e, 0x00, 0x61, 0x00, 0x77, 0x00, 0x61, 0x00, 0x6b, 0x00, 0x65, 0x00, 0x63, 0x00, 0x6f, 0x00,
    0x64, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x67, 0x00, 0x2e, 0x00, 0x61, 0x00, 0x74, 0x00, 0x68, 0x00, 0x2e, 0x00, 0x63,
    0x00, 0x78, 0x00, 0x05, 0x00, 0x24, 0x00, 0x61, 0x00, 0x77, 0x00, 0x61, 0x00, 0x6b, 0x00, 0x65, 0x00, 0x63, 0x00,
    0x6f, 0x00, 0x64, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x67, 0x00, 0x2e, 0x00, 0x61, 0x00, 0x74, 0x00, 0x68, 0x00, 0x2e,
    0x00, 0x63, 0x00, 0x78, 0x00, 0x07, 0x00, 0x08, 0x00, 0x20, 0xfd, 0xae, 0x48, 0x07, 0xcb, 0xcb, 0x01, 0x06, 0x00,
    0x04, 0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x30, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x7b, 0xd0, 0x9e, 0x33, 0x06, 0x75, 0xe3, 0x3e, 0x52, 0x7b, 0x4a, 0xc4,
    0x75, 0x5f, 0x9b, 0x98, 0x26, 0x5d, 0xcb, 0x05, 0x6a, 0x6a, 0xcc, 0x0f, 0xb8, 0x4f, 0xab, 0x09, 0x22, 0x30, 0x7a,
    0x5d, 0x0a, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x09, 0x00, 0x2a, 0x00, 0x54, 0x00, 0x45, 0x00, 0x52, 0x00, 0x4d, 0x00, 0x53, 0x00, 0x52, 0x00, 0x56,
    0x00, 0x2f, 0x00, 0x31, 0x00, 0x39, 0x00, 0x32, 0x00, 0x2e, 0x00, 0x31, 0x00, 0x36, 0x00, 0x38, 0x00, 0x2e, 0x00,
    0x31, 0x00, 0x2e, 0x00, 0x31, 0x00, 0x35, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x0c, 0x57, 0xc6, 0xb5, 0x0c, 0x14, 0xc1, 0xf0, 0x64, 0xe7, 0xcc, 0x8b, 0xf0, 0x6d, 0x7a, 0x13,
];
const DOMAIN_MIC: [u8; 16] = [
    0x12, 0x28, 0x00, 0xa0, 0xb2, 0x29, 0x47, 0x12, 0x1e, 0x8e, 0x54, 0xf8, 0x29, 0xdb, 0x52, 0x1e,
];
const DOMAIN_USER_NAME: [u8; 26] = [
    0x41, 0x00, 0x64, 0x00, 0x6d, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x69, 0x00, 0x73, 0x00, 0x74, 0x00, 0x72, 0x00, 0x61,
    0x00, 0x74, 0x00, 0x6f, 0x00, 0x72, 0x00,
];
const DOMAIN_DOMAIN_NAME: [u8; 22] = [
    0x41, 0x00, 0x57, 0x00, 0x41, 0x00, 0x4b, 0x00, 0x45, 0x00, 0x43, 0x00, 0x4f, 0x00, 0x44, 0x00, 0x49, 0x00, 0x4e,
    0x00, 0x47, 0x00,
];
const DOMAIN_TARGET_INFO: [u8; 334] = [
    0x02, 0x00, 0x16, 0x00, 0x41, 0x00, 0x57, 0x00, 0x41, 0x00, 0x4b, 0x00, 0x45, 0x00, 0x43, 0x00, 0x4f, 0x00, 0x44,
    0x00, 0x49, 0x00, 0x4e, 0x00, 0x47, 0x00, 0x01, 0x00, 0x10, 0x00, 0x57, 0x00, 0x49, 0x00, 0x4e, 0x00, 0x32, 0x00,
    0x4b, 0x00, 0x38, 0x00, 0x52, 0x00, 0x32, 0x00, 0x04, 0x00, 0x24, 0x00, 0x61, 0x00, 0x77, 0x00, 0x61, 0x00, 0x6b,
    0x00, 0x65, 0x00, 0x63, 0x00, 0x6f, 0x00, 0x64, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x67, 0x00, 0x2e, 0x00, 0x61, 0x00,
    0x74, 0x00, 0x68, 0x00, 0x2e, 0x00, 0x63, 0x00, 0x78, 0x00, 0x03, 0x00, 0x36, 0x00, 0x57, 0x00, 0x49, 0x00, 0x4e,
    0x00, 0x32, 0x00, 0x4b, 0x00, 0x38, 0x00, 0x52, 0x00, 0x32, 0x00, 0x2e, 0x00, 0x61, 0x00, 0x77, 0x00, 0x61, 0x00,
    0x6b, 0x00, 0x65, 0x00, 0x63, 0x00, 0x6f, 0x00, 0x64, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x67, 0x00, 0x2e, 0x00, 0x61,
    0x00, 0x74, 0x00, 0x68, 0x00, 0x2e, 0x00, 0x63, 0x00, 0x78, 0x00, 0x05, 0x00, 0x24, 0x00, 0x61, 0x00, 0x77, 0x00,
    0x61, 0x00, 0x6b, 0x00, 0x65, 0x00, 0x63, 0x00, 0x6f, 0x00, 0x64, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x67, 0x00, 0x2e,
    0x00, 0x61, 0x00, 0x74, 0x00, 0x68, 0x00, 0x2e, 0x00, 0x63, 0x00, 0x78, 0x00, 0x07, 0x00, 0x08, 0x00, 0x20, 0xfd,
    0xae, 0x48, 0x07, 0xcb, 0xcb, 0x01, 0x06, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x30, 0x00, 0x30,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x7b, 0xd0, 0x9e, 0x33,
    0x06, 0x75, 0xe3, 0x3e, 0x52, 0x7b, 0x4a, 0xc4, 0x75, 0x5f, 0x9b, 0x98, 0x26, 0x5d, 0xcb, 0x05, 0x6a, 0x6a, 0xcc,
    0x0f, 0xb8, 0x4f, 0xab, 0x09, 0x22, 0x30, 0x7a, 0x5d, 0x0a, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x2a, 0x00, 0x54, 0x00, 0x45, 0x00, 0x52,
    0x00, 0x4d, 0x00, 0x53, 0x00, 0x52, 0x00, 0x56, 0x00, 0x2f, 0x00, 0x31, 0x00, 0x39, 0x00, 0x32, 0x00, 0x2e, 0x00,
    0x31, 0x00, 0x36, 0x00, 0x38, 0x00, 0x2e, 0x00, 0x31, 0x00, 0x2e, 0x00, 0x31, 0x00, 0x35, 0x00, 0x30, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];

const DOMAIN_CLIENT_CHALLENGE: [u8; 8] = [0xa5, 0x00, 0x28, 0x29, 0xcd, 0x07, 0xe3, 0xbc];

const DOMAIN_ENCRYPTED_SESSION_KEY: [u8; 16] = [
    0x0c, 0x57, 0xc6, 0xb5, 0x0c, 0x14, 0xc1, 0xf0, 0x64, 0xe7, 0xcc, 0x8b, 0xf0, 0x6d, 0x7a, 0x13,
];

#[test]
fn read_negotiate_does_not_fail_with_correct_header() {
    let mut context = Ntlm::new();
    context.state = NtlmState::Negotiate;

    let buff = *LOCAL_NEGOTIATE_MESSAGE;
    read_negotiate(&mut context, buff.as_ref()).unwrap();
}

#[test]
fn read_negotiate_fails_with_incorrect_signature() {
    let mut context = Ntlm::new();
    context.state = NtlmState::Negotiate;

    let mut buff = LOCAL_NEGOTIATE_MESSAGE.to_vec();
    buff[1] += 1;
    assert!(read_negotiate(&mut context, buff.as_slice()).is_err());
}

#[test]
fn read_negotiate_fails_with_incorrect_message_type() {
    let mut context = Ntlm::new();
    context.state = NtlmState::Negotiate;

    let mut buff = LOCAL_NEGOTIATE_MESSAGE.to_vec();
    buff[8] = 2;
    assert!(read_negotiate(&mut context, buff.as_slice()).is_err());
}

#[test]
fn read_negotiate_reads_correct_flags() {
    let mut context = Ntlm::new();

    context.state = NtlmState::Negotiate;

    let expected_flags = NegotiateFlags::from_bits(LOCAL_NEGOTIATE_FLAGS).unwrap();

    let buff = *LOCAL_NEGOTIATE_MESSAGE;
    read_negotiate(&mut context, buff.as_ref()).unwrap();

    assert_eq!(expected_flags, context.flags);
}

#[test]
fn read_negotiate_fails_without_needed_flags() {
    let mut context = Ntlm::new();

    context.state = NtlmState::Negotiate;

    let mut buff = *LOCAL_NEGOTIATE_MESSAGE;
    buff[NEGOTIATE_FLAGS_START..NEGOTIATE_FLAGS_START + NEGOTIATE_FLAGS_SIZE]
        .clone_from_slice([0x00; NEGOTIATE_FLAGS_SIZE].as_ref());
    assert!(read_negotiate(&mut context, buff.as_ref()).is_err());
}

#[test]
fn read_negotiate_writes_buffer_to_context() {
    let mut context = Ntlm::new();

    context.state = NtlmState::Negotiate;

    let buff = *LOCAL_NEGOTIATE_MESSAGE;
    read_negotiate(&mut context, buff.as_ref()).unwrap();

    assert_eq!(
        (*LOCAL_NEGOTIATE_MESSAGE).as_ref(),
        context.negotiate_message.unwrap().message.as_slice()
    );
}

#[test]
fn read_negotiate_changes_context_state_on_success() {
    let mut context = Ntlm::new();

    context.state = NtlmState::Negotiate;

    let expected_state = NtlmState::Challenge;

    let buff = *LOCAL_NEGOTIATE_MESSAGE;
    read_negotiate(&mut context, buff.as_ref()).unwrap();

    assert_eq!(expected_state, context.state);
}

#[test]
fn read_negotiate_fails_on_incorrect_state() {
    let mut context = Ntlm::new();

    context.state = NtlmState::Challenge;

    let buff = *LOCAL_NEGOTIATE_MESSAGE;
    assert!(read_negotiate(&mut context, buff.as_ref()).is_err());
}

#[test]
fn write_challenge_writes_correct_signature() {
    let mut context = Ntlm::new();
    context.set_version(LOCAL_CHALLENGE_VERSION);
    context.state = NtlmState::Challenge;
    context.negotiate_message = Some(NegotiateMessage::new(LOCAL_NEGOTIATE_MESSAGE.to_vec()));
    context.flags = NegotiateFlags::from_bits(LOCAL_NEGOTIATE_FLAGS).unwrap();

    let mut buff = Vec::new();
    write_challenge(&mut context, &mut buff).unwrap();

    assert_eq!(NTLM_SIGNATURE, buff[SIGNATURE_START..MESSAGE_TYPE_START]);
}

#[test]
fn write_challenge_writes_correct_message_type() {
    let mut context = Ntlm::new();
    context.set_version(LOCAL_CHALLENGE_VERSION);
    context.state = NtlmState::Challenge;
    context.negotiate_message = Some(NegotiateMessage::new(LOCAL_NEGOTIATE_MESSAGE.to_vec()));
    context.flags = NegotiateFlags::from_bits(LOCAL_NEGOTIATE_FLAGS).unwrap();

    let mut buff = Vec::new();
    write_challenge(&mut context, &mut buff).unwrap();

    assert_eq!(
        CHALLENGE_MESSAGE_TYPE,
        buff[MESSAGE_TYPE_START..CHALLENGE_TARGET_NAME_START]
    );
}

#[test]
fn write_challenge_writes_correct_target_name() {
    let mut context = Ntlm::new();
    context.set_version(LOCAL_CHALLENGE_VERSION);
    context.state = NtlmState::Challenge;
    context.negotiate_message = Some(NegotiateMessage::new(LOCAL_NEGOTIATE_MESSAGE.to_vec()));
    context.flags = NegotiateFlags::from_bits(LOCAL_NEGOTIATE_FLAGS).unwrap();

    let mut buff = Vec::new();
    write_challenge(&mut context, &mut buff).unwrap();

    assert_eq!(
        LOCAL_CHALLENGE_TARGET_NAME_EMPTY,
        buff[CHALLENGE_TARGET_NAME_START..CHALLENGE_FLAGS_START]
    );
}

#[test]
fn write_challenge_writes_correct_flags() {
    let mut context = Ntlm::new();
    context.set_version(LOCAL_CHALLENGE_VERSION);
    context.state = NtlmState::Challenge;
    context.negotiate_message = Some(NegotiateMessage::new(LOCAL_NEGOTIATE_MESSAGE.to_vec()));
    context.flags = NegotiateFlags::from_bits(LOCAL_NEGOTIATE_FLAGS).unwrap();

    let mut buff = Vec::new();
    write_challenge(&mut context, &mut buff).unwrap();

    assert_eq!(
        LOCAL_CHALLENGE_FLAGS.to_le_bytes(),
        buff[CHALLENGE_FLAGS_START..CHALLENGE_SERVER_CHALLENGE_START]
    );

    assert_eq!(NegotiateFlags::from_bits(LOCAL_CHALLENGE_FLAGS).unwrap(), context.flags);
}

#[test]
fn write_challenge_writes_server_challenge() {
    let mut context = Ntlm::new();
    context.set_version(LOCAL_CHALLENGE_VERSION);
    context.state = NtlmState::Challenge;
    context.negotiate_message = Some(NegotiateMessage::new(LOCAL_NEGOTIATE_MESSAGE.to_vec()));
    context.flags = NegotiateFlags::from_bits(LOCAL_NEGOTIATE_FLAGS).unwrap();

    let mut buff = Vec::new();
    write_challenge(&mut context, &mut buff).unwrap();

    assert_ne!(
        [0x00; CHALLENGE_SIZE],
        context.challenge_message.as_ref().unwrap().server_challenge
    );
    assert_eq!(
        context.challenge_message.unwrap().server_challenge,
        buff[CHALLENGE_SERVER_CHALLENGE_START..CHALLENGE_RESERVED_START]
    );
}

#[test]
fn write_challenge_writes_target_info() {
    let mut context = Ntlm::new();
    context.set_version(LOCAL_CHALLENGE_VERSION);
    context.state = NtlmState::Challenge;
    context.negotiate_message = Some(NegotiateMessage::new(LOCAL_NEGOTIATE_MESSAGE.to_vec()));
    context.flags = NegotiateFlags::from_bits(LOCAL_NEGOTIATE_FLAGS).unwrap();

    let mut buff = Vec::new();
    write_challenge(&mut context, &mut buff).unwrap();

    assert!(!context.challenge_message.as_ref().unwrap().target_info.is_empty());
    assert_eq!(
        context.challenge_message.as_ref().unwrap().target_info,
        buff[CHALLENGE_HEADER_SIZE..].as_ref()
    );
}

#[test]
fn write_challenge_writes_correct_version() {
    let mut context = Ntlm::new();
    context.set_version(LOCAL_CHALLENGE_VERSION);
    context.state = NtlmState::Challenge;
    context.negotiate_message = Some(NegotiateMessage::new(LOCAL_NEGOTIATE_MESSAGE.to_vec()));
    context.flags = NegotiateFlags::from_bits(LOCAL_NEGOTIATE_FLAGS).unwrap();

    let mut buff = Vec::new();
    write_challenge(&mut context, &mut buff).unwrap();

    assert_eq!(
        LOCAL_CHALLENGE_VERSION,
        buff[CHALLENGE_VERSION_START..CHALLENGE_HEADER_SIZE]
    );
}

#[test]
fn write_challenge_writes_timestamp() {
    let mut context = Ntlm::new();
    context.set_version(LOCAL_CHALLENGE_VERSION);
    context.state = NtlmState::Challenge;
    context.negotiate_message = Some(NegotiateMessage::new(LOCAL_NEGOTIATE_MESSAGE.to_vec()));
    context.flags = NegotiateFlags::from_bits(LOCAL_NEGOTIATE_FLAGS).unwrap();

    let mut buff = Vec::new();
    write_challenge(&mut context, &mut buff).unwrap();

    assert_ne!(0, context.challenge_message.unwrap().timestamp);
}

#[test]
fn write_challenge_fails_on_incorrect_state() {
    let mut context = Ntlm::new();
    context.set_version(LOCAL_CHALLENGE_VERSION);
    context.state = NtlmState::Authenticate;
    context.negotiate_message = Some(NegotiateMessage::new(LOCAL_NEGOTIATE_MESSAGE.to_vec()));
    context.flags = NegotiateFlags::from_bits(LOCAL_NEGOTIATE_FLAGS).unwrap();

    let mut buff = Vec::new();
    assert!(write_challenge(&mut context, &mut buff).is_err());
}

#[test]
fn read_authenticate_fail_with_incorrect_signature() {
    let mut context = Ntlm::new();

    context.negotiate_message = Some(NegotiateMessage::new(Vec::new()));
    context.challenge_message = Some(ChallengeMessage::new(
        vec![0x04, 0x05, 0x06],
        Vec::new(),
        [0x00; CHALLENGE_SIZE],
        0,
    ));
    context.state = NtlmState::Authenticate;

    let mut buffer = LOCAL_AUTHENTICATE_MESSAGE.to_vec();
    buffer[3] = 0x00;
    assert!(read_authenticate(&mut context, buffer.as_slice()).is_err());
}

#[test]
fn read_authenticate_fail_with_incorrect_message_type() {
    let mut context = Ntlm::new();

    context.negotiate_message = Some(NegotiateMessage::new(Vec::new()));
    context.challenge_message = Some(ChallengeMessage::new(
        vec![0x04, 0x05, 0x06],
        Vec::new(),
        [0x00; CHALLENGE_SIZE],
        0,
    ));
    context.state = NtlmState::Authenticate;

    let mut buffer = LOCAL_AUTHENTICATE_MESSAGE.to_vec();
    buffer[8] = 0x02;
    assert!(read_authenticate(&mut context, buffer.as_slice()).is_err());
}

#[test]
fn read_authenticate_local_logon_correct_reads_mic() {
    let buffer = LOCAL_AUTHENTICATE_MESSAGE;
    let expected = LOCAL_MIC;
    let mut context = Ntlm::new();

    context.negotiate_message = Some(NegotiateMessage::new(Vec::new()));
    context.challenge_message = Some(ChallengeMessage::new(
        vec![0x04, 0x05, 0x06],
        Vec::new(),
        [0x00; CHALLENGE_SIZE],
        0,
    ));
    context.state = NtlmState::Authenticate;

    authenticate::read_authenticate(&mut context, buffer.as_ref()).unwrap();

    assert_eq!(
        expected.as_ref(),
        context.authenticate_message.unwrap().mic.unwrap().value.as_ref()
    );
}

#[test]
fn read_authenticate_local_logon_correct_reads_encrypted_random_session_key() {
    let buffer = LOCAL_AUTHENTICATE_MESSAGE;
    let expected = LOCAL_ENCRYPTED_RANDOM_SESSION_KEY;
    let mut context = Ntlm::new();

    context.negotiate_message = Some(NegotiateMessage::new(Vec::new()));
    context.challenge_message = Some(ChallengeMessage::new(
        vec![0x04, 0x05, 0x06],
        Vec::new(),
        [0x00; CHALLENGE_SIZE],
        0,
    ));
    context.state = NtlmState::Authenticate;

    authenticate::read_authenticate(&mut context, buffer.as_ref()).unwrap();

    assert_eq!(
        expected.as_ref(),
        context
            .authenticate_message
            .unwrap()
            .encrypted_random_session_key
            .unwrap(),
    );
}

#[test]
fn read_authenticate_local_logon_correct_reads_user_name() {
    let buffer = LOCAL_AUTHENTICATE_MESSAGE;
    let expected = LOCAL_USER_NAME;
    let mut context = Ntlm::new();
    context.negotiate_message = Some(NegotiateMessage::new(Vec::new()));
    context.challenge_message = Some(ChallengeMessage::new(
        vec![0x04, 0x05, 0x06],
        Vec::new(),
        [0x00; CHALLENGE_SIZE],
        0,
    ));
    context.state = NtlmState::Authenticate;

    authenticate::read_authenticate(&mut context, buffer.as_ref()).unwrap();

    assert_eq!(expected.as_ref(), context.identity.as_ref().unwrap().user.as_slice());
}

#[test]
fn read_authenticate_domain_logon_correct_reads_mic() {
    let buffer = DOMAIN_AUTHENTICATE_MESSAGE;
    let expected = DOMAIN_MIC;
    let mut context = Ntlm::new();
    context.negotiate_message = Some(NegotiateMessage::new(Vec::new()));
    context.challenge_message = Some(ChallengeMessage::new(
        vec![0x04, 0x05, 0x06],
        Vec::new(),
        [0x00; CHALLENGE_SIZE],
        0,
    ));
    context.state = NtlmState::Authenticate;

    authenticate::read_authenticate(&mut context, buffer.as_ref()).unwrap();

    assert_eq!(
        expected.as_ref(),
        context.authenticate_message.unwrap().mic.unwrap().value.as_ref()
    );
}

#[test]
fn read_authenticate_domain_logon_correct_reads_user_name() {
    let buffer = DOMAIN_AUTHENTICATE_MESSAGE;
    let expected = DOMAIN_USER_NAME;
    let mut context = Ntlm::new();
    context.negotiate_message = Some(NegotiateMessage::new(Vec::new()));
    context.challenge_message = Some(ChallengeMessage::new(
        vec![0x04, 0x05, 0x06],
        Vec::new(),
        [0x00; CHALLENGE_SIZE],
        0,
    ));
    context.state = NtlmState::Authenticate;

    authenticate::read_authenticate(&mut context, buffer.as_ref()).unwrap();

    assert_eq!(expected.as_ref(), context.identity.as_ref().unwrap().user.as_slice());
}

#[test]
fn read_authenticate_domain_logon_correct_reads_domain_name() {
    let buffer = DOMAIN_AUTHENTICATE_MESSAGE;
    let expected = DOMAIN_DOMAIN_NAME;
    let mut context = Ntlm::new();
    context.negotiate_message = Some(NegotiateMessage::new(Vec::new()));
    context.challenge_message = Some(ChallengeMessage::new(
        vec![0x04, 0x05, 0x06],
        Vec::new(),
        [0x00; CHALLENGE_SIZE],
        0,
    ));
    context.state = NtlmState::Authenticate;

    authenticate::read_authenticate(&mut context, buffer.as_ref()).unwrap();

    assert_eq!(expected.as_ref(), context.identity.as_ref().unwrap().domain.as_slice());
}

#[test]
fn read_authenticate_fails_on_incorrect_state() {
    let buffer = DOMAIN_AUTHENTICATE_MESSAGE;
    let mut context = Ntlm::new();

    context.negotiate_message = Some(NegotiateMessage::new(Vec::new()));
    context.challenge_message = Some(ChallengeMessage::new(
        vec![0x04, 0x05, 0x06],
        Vec::new(),
        [0x00; CHALLENGE_SIZE],
        0,
    ));
    context.state = NtlmState::Completion;

    assert!(read_authenticate(&mut context, buffer.as_ref()).is_err());
}

#[test]
fn read_authenticate_fails_with_incorrect_encrypted_key_size() {
    let mut context = Ntlm::new();

    context.negotiate_message = Some(NegotiateMessage::new(Vec::new()));
    context.challenge_message = Some(ChallengeMessage::new(
        vec![0x04, 0x05, 0x06],
        Vec::new(),
        [0x00; CHALLENGE_SIZE],
        0,
    ));
    context.state = NtlmState::Authenticate;

    let mut buffer = DOMAIN_AUTHENTICATE_MESSAGE.to_vec();
    buffer[AUTHENTICATE_ENCRYPTED_KEY_START..AUTHENTICATE_ENCRYPTED_KEY_START + 4]
        .clone_from_slice([SESSION_KEY_SIZE as u8 - 1, 0x00, SESSION_KEY_SIZE as u8 - 1, 0x00].as_ref());
    buffer.pop();

    assert!(read_authenticate(&mut context, buffer.as_slice()).is_err());
}

#[test]
fn read_authenticate_fails_without_key_exchange_flag() {
    let mut context = Ntlm::new();

    context.negotiate_message = Some(NegotiateMessage::new(Vec::new()));
    context.challenge_message = Some(ChallengeMessage::new(
        vec![0x04, 0x05, 0x06],
        Vec::new(),
        [0x00; CHALLENGE_SIZE],
        0,
    ));
    context.state = NtlmState::Authenticate;

    let mut buffer = DOMAIN_AUTHENTICATE_MESSAGE.to_vec();
    buffer[AUTHENTICATE_FLAGS_START..AUTHENTICATE_FLAGS_START + NEGOTIATE_FLAGS_SIZE]
        .clone_from_slice([0x35, 0xb2, 0x88, 0xa0].as_ref());

    assert!(read_authenticate(&mut context, buffer.as_slice()).is_err());
}

#[test]
fn complete_authenticate_fails_on_incorrect_state() {
    let mut context = Ntlm::new();

    context.state = NtlmState::Authenticate;

    assert!(complete_authenticate(&mut context).is_err());
}

#[test]
fn complete_authenticate_does_not_fail_on_correct_mic() {
    let mut context = Ntlm::new();

    context.identity = Some(TEST_CREDENTIALS.clone());
    context.flags = NegotiateFlags::NTLM_SSP_NEGOTIATE_KEY_EXCH;
    context.state = NtlmState::Completion;
    context.negotiate_message = Some(NegotiateMessage::new(vec![0x01, 0x02, 0x03]));
    context.challenge_message = Some(ChallengeMessage::new(
        vec![0x04, 0x05, 0x06],
        Vec::new(),
        [0x00; CHALLENGE_SIZE],
        0,
    ));
    context.authenticate_message = Some(AuthenticateMessage::new(
        DOMAIN_AUTHENTICATE_MESSAGE.to_vec(),
        Some(Mic::new(
            [
                0xcf, 0x40, 0x63, 0x95, 0xcf, 0xe2, 0x50, 0x4d, 0xbb, 0x1f, 0x7b, 0x3e, 0x7, 0xd4, 0xb6, 0x49,
            ],
            64,
        )),
        DOMAIN_TARGET_INFO.to_vec(),
        DOMAIN_CLIENT_CHALLENGE,
        Some(DOMAIN_ENCRYPTED_SESSION_KEY),
    ));

    complete_authenticate(&mut context).unwrap();
}

#[test]
fn complete_authenticate_fails_on_incorrect_challenge_message() {
    let mut context = Ntlm::new();

    context.identity = Some(TEST_CREDENTIALS.clone());
    context.flags = NegotiateFlags::NTLM_SSP_NEGOTIATE_KEY_EXCH;
    context.state = NtlmState::Completion;
    context.negotiate_message = Some(NegotiateMessage::new(vec![0x01, 0x02, 0x03]));
    context.challenge_message = Some(ChallengeMessage::new(
        vec![0x05, 0x05, 0x06],
        Vec::new(),
        [0x00; CHALLENGE_SIZE],
        0,
    ));
    context.authenticate_message = Some(AuthenticateMessage::new(
        DOMAIN_AUTHENTICATE_MESSAGE.to_vec(),
        Some(Mic::new(
            [
                0xcf, 0x40, 0x63, 0x95, 0xcf, 0xe2, 0x50, 0x4d, 0xbb, 0x1f, 0x7b, 0x3e, 0x7, 0xd4, 0xb6, 0x49,
            ],
            64,
        )),
        DOMAIN_TARGET_INFO.to_vec(),
        DOMAIN_CLIENT_CHALLENGE,
        Some(DOMAIN_ENCRYPTED_SESSION_KEY),
    ));

    assert!(complete_authenticate(&mut context).is_err());
}


--- File: src/ntlm/messages/test.rs ---
use std::sync::LazyLock;

use crate::ntlm::{AuthIdentityBuffers, NTLM_VERSION_SIZE};
use crate::*;

pub const SIGNATURE_SIZE: usize = 8;
pub const MESSAGE_TYPE_SIZE: usize = 4;
pub const NEGOTIATE_FLAGS_SIZE: usize = 4;
pub const MIC_SIZE: usize = 16;
pub const FIELD_SIZE: usize = 8;

pub const SIGNATURE_START: usize = 0;
pub const MESSAGE_TYPE_START: usize = SIGNATURE_START + SIGNATURE_SIZE;

pub const NEGOTIATE_FLAGS_START: usize = MESSAGE_TYPE_START + MESSAGE_TYPE_SIZE;
pub const NEGOTIATE_DOMAIN_NAME_START: usize = NEGOTIATE_FLAGS_START + NEGOTIATE_FLAGS_SIZE;
pub const NEGOTIATE_WORKSTATION_START: usize = NEGOTIATE_DOMAIN_NAME_START + FIELD_SIZE;
pub const NEGOTIATE_VERSION_START: usize = NEGOTIATE_WORKSTATION_START + FIELD_SIZE;

pub const CHALLENGE_TARGET_NAME_START: usize = MESSAGE_TYPE_START + MESSAGE_TYPE_SIZE;
pub const CHALLENGE_FLAGS_START: usize = CHALLENGE_TARGET_NAME_START + FIELD_SIZE;
pub const CHALLENGE_SERVER_CHALLENGE_START: usize = CHALLENGE_FLAGS_START + NEGOTIATE_FLAGS_SIZE;
pub const CHALLENGE_RESERVED_START: usize = CHALLENGE_SERVER_CHALLENGE_START + FIELD_SIZE;
pub const CHALLENGE_TARGET_INFO_START: usize = CHALLENGE_RESERVED_START + FIELD_SIZE;
pub const CHALLENGE_VERSION_START: usize = CHALLENGE_TARGET_INFO_START + FIELD_SIZE;
pub const CHALLENGE_HEADER_SIZE: usize = CHALLENGE_VERSION_START + NTLM_VERSION_SIZE;

pub const AUTHENTICATE_TARGET_INFO_PADDING_SIZE: usize = 8;
pub const AUTHENTICATE_LM_CHALLENGE_RESPONSE_START: usize = MESSAGE_TYPE_START + MESSAGE_TYPE_SIZE;
pub const AUTHENTICATE_NT_CHALLENGE_RESPONSE_START: usize = AUTHENTICATE_LM_CHALLENGE_RESPONSE_START + FIELD_SIZE;
pub const AUTHENTICATE_DOMAIN_NAME_START: usize = AUTHENTICATE_NT_CHALLENGE_RESPONSE_START + FIELD_SIZE;
pub const AUTHENTICATE_USER_NAME_START: usize = AUTHENTICATE_DOMAIN_NAME_START + FIELD_SIZE;
pub const AUTHENTICATE_WORKSTATION_START: usize = AUTHENTICATE_USER_NAME_START + FIELD_SIZE;
pub const AUTHENTICATE_ENCRYPTED_KEY_START: usize = AUTHENTICATE_WORKSTATION_START + FIELD_SIZE;
pub const AUTHENTICATE_FLAGS_START: usize = AUTHENTICATE_ENCRYPTED_KEY_START + FIELD_SIZE;
pub const AUTHENTICATE_OFFSET: usize = 64 + NTLM_VERSION_SIZE;
pub const AUTHENTICATE_OFFSET_WITH_MIC: usize = AUTHENTICATE_OFFSET + MIC_SIZE;

pub const TIMESTAMP: u64 = 130_475_779_380_041_523;
pub const SERVER_CHALLENGE: [u8; 8] = [0xa4, 0xf1, 0xba, 0xa6, 0x7c, 0xdc, 0x1a, 0x12];
pub const CLIENT_CHALLENGE: [u8; 8] = [0x20, 0xc0, 0x2b, 0x3d, 0xc0, 0x61, 0xa7, 0x73];
pub const NTLM_VERSION: [u8; NTLM_VERSION_SIZE] = [0x00; NTLM_VERSION_SIZE];

pub const NTLM_SIGNATURE: [u8; 8] = [0x4e, 0x54, 0x4c, 0x4d, 0x53, 0x53, 0x50, 0x00];
pub const NEGOTIATE_MESSAGE_TYPE: [u8; 4] = [0x01, 0x00, 0x00, 0x00];
pub const CHALLENGE_MESSAGE_TYPE: [u8; 4] = [0x02, 0x00, 0x00, 0x00];

pub const LOCAL_NEGOTIATE_FLAGS: u32 = 0xe208_82b7;
pub const LOCAL_NEGOTIATE_DOMAIN: [u8; 8] = [0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00];
pub const LOCAL_NEGOTIATE_WORKSTATION: [u8; 8] = [0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00];
pub const LOCAL_NEGOTIATE_VERSION: [u8; 8] = [0x05, 0x01, 0x28, 0x0a, 0x00, 0x00, 0x00, 0x0f];
const LOCAL_NEGOTIATE_MESSAGE_SIZE: usize = 40;

pub const LOCAL_CHALLENGE_TARGET_NAME_EMPTY: [u8; 8] = [0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00];
pub const LOCAL_CHALLENGE_TARGET_NAME: [u8; 8] = [0x08, 0x00, 0x08, 0x00, 0x38, 0x00, 0x00, 0x00];
pub const LOCAL_CHALLENGE_FLAGS: u32 = 0xE288_82B7;
pub const LOCAL_CHALLENGE_SERVER_CHALLENGE: [u8; 8] = [0x26, 0x6e, 0xcd, 0x75, 0xaa, 0x41, 0xe7, 0x6f];
pub const LOCAL_CHALLENGE_RESERVED: [u8; 8] = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
pub const LOCAL_CHALLENGE_TARGET_INFO: [u8; 8] = [0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x00, 0x00];
pub const LOCAL_CHALLENGE_VERSION: [u8; 8] = [0x06, 0x01, 0xb0, 0x1d, 0x00, 0x00, 0x00, 0x0f];
pub const LOCAL_CHALLENGE_TARGET_NAME_BUFFER: [u8; 8] = [0x57, 0x00, 0x49, 0x00, 0x4e, 0x00, 0x37, 0x00];
pub const LOCAL_CHALLENGE_TARGET_INFO_BUFFER: [u8; 64] = [
    0x02, 0x00, // AvId (MsvAvNbDomainName)
    0x08, 0x00, // AvLen (8)
    0x57, 0x00, 0x49, 0x00, 0x4e, 0x00, 0x37, 0x00, // "WIN7"
    //
    0x01, 0x00, // AvId (MsvAvNbComputerName)
    0x08, 0x00, // AvLen (8)
    0x57, 0x00, 0x49, 0x00, 0x4e, 0x00, 0x37, 0x00, // "WIN7"
    //
    0x04, 0x00, // AvId (MsvAvDnsDomainName)
    0x08, 0x00, // AvLen (8)
    0x77, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x37, 0x00, // "win7"
    //
    0x03, 0x00, // AvId (MsvAvDnsComputerName)
    0x08, 0x00, // AvLen (8)
    0x77, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x37, 0x00, // "win7"
    //
    0x07, 0x00, // AvId (MsvAvTimestamp)
    0x08, 0x00, // AvLen (8)
    0xa9, 0x8d, 0x9b, 0x1a, 0x6c, 0xb0, 0xcb, 0x01, //
    0x00, 0x00, // AvId (MsvAvEOL)
    0x00, 0x00, // AvLen (0)
];
pub const LOCAL_CHALLENGE_TIMESTAMP: u64 = 0x01cb_b06c_1a9b_8da9;
const LOCAL_CHALLENGE_MESSAGE_SIZE: usize = 128;

pub static LOCAL_NEGOTIATE_MESSAGE: LazyLock<[u8; LOCAL_NEGOTIATE_MESSAGE_SIZE]> = LazyLock::new(|| {
    let mut message = Vec::with_capacity(LOCAL_NEGOTIATE_MESSAGE_SIZE);
    message.extend_from_slice(NTLM_SIGNATURE.as_ref());
    message.extend_from_slice(NEGOTIATE_MESSAGE_TYPE.as_ref());
    message.extend_from_slice(LOCAL_NEGOTIATE_FLAGS.to_le_bytes().as_ref());
    message.extend_from_slice(LOCAL_NEGOTIATE_DOMAIN.as_ref());
    message.extend_from_slice(LOCAL_NEGOTIATE_WORKSTATION.as_ref());
    message.extend_from_slice(LOCAL_NEGOTIATE_VERSION.as_ref());

    let mut result = [0x00; LOCAL_NEGOTIATE_MESSAGE_SIZE];
    result.clone_from_slice(message.as_ref());

    result
});

pub static LOCAL_CHALLENGE_MESSAGE: LazyLock<[u8; LOCAL_CHALLENGE_MESSAGE_SIZE]> = LazyLock::new(|| {
    let mut message = Vec::with_capacity(LOCAL_CHALLENGE_MESSAGE_SIZE);
    message.extend_from_slice(NTLM_SIGNATURE.as_ref());
    message.extend_from_slice(CHALLENGE_MESSAGE_TYPE.as_ref());
    message.extend_from_slice(LOCAL_CHALLENGE_TARGET_NAME.as_ref());
    message.extend_from_slice(LOCAL_CHALLENGE_FLAGS.to_le_bytes().as_ref());
    message.extend_from_slice(LOCAL_CHALLENGE_SERVER_CHALLENGE.as_ref());
    message.extend_from_slice(LOCAL_CHALLENGE_RESERVED.as_ref());
    message.extend_from_slice(LOCAL_CHALLENGE_TARGET_INFO.as_ref());
    message.extend_from_slice(LOCAL_CHALLENGE_VERSION.as_ref());
    message.extend_from_slice(LOCAL_CHALLENGE_TARGET_NAME_BUFFER.as_ref());
    message.extend_from_slice(LOCAL_CHALLENGE_TARGET_INFO_BUFFER.as_ref());

    let mut result = [0x00; LOCAL_CHALLENGE_MESSAGE_SIZE];
    result.clone_from_slice(message.as_ref());

    result
});

pub static TEST_CREDENTIALS: LazyLock<AuthIdentityBuffers> = LazyLock::new(|| {
    AuthIdentity {
        username: Username::new("User", Some("Domain")).unwrap(),
        password: String::from("Password").into(),
    }
    .into()
});


--- File: src/ntlm/mod.rs ---
mod config;
mod messages;
#[cfg(test)]
mod test;

use std::fmt::Debug;
use std::io;
use std::sync::LazyLock;

use bitflags::bitflags;
use byteorder::{LittleEndian, WriteBytesExt};
use messages::{client, server};

pub use self::config::NtlmConfig;
use super::channel_bindings::ChannelBindings;
use crate::crypto::{compute_hmac_md5, Rc4, HASH_SIZE};
use crate::generator::{GeneratorAcceptSecurityContext, GeneratorInitSecurityContext};
use crate::utils::{extract_encrypted_data, save_decrypted_data};
use crate::{
    AcceptSecurityContextResult, AcquireCredentialsHandleResult, AuthIdentity, AuthIdentityBuffers, BufferType,
    CertTrustStatus, ClientRequestFlags, ClientResponseFlags, ContextNames, ContextSizes, CredentialUse,
    DecryptionFlags, EncryptionFlags, Error, ErrorKind, FilledAcceptSecurityContext, FilledAcquireCredentialsHandle,
    FilledInitializeSecurityContext, InitializeSecurityContextResult, PackageCapabilities, PackageInfo, SecurityBuffer,
    SecurityBufferFlags, SecurityBufferRef, SecurityPackageType, SecurityStatus, ServerResponseFlags, Sspi, SspiEx,
    SspiImpl, PACKAGE_ID_NONE,
};

pub const PKG_NAME: &str = "NTLM";
pub const NTLM_VERSION_SIZE: usize = 8;
pub const DEFAULT_NTLM_VERSION: [u8; NTLM_VERSION_SIZE] = [0x0a, 0x00, 0x63, 0x45, 0x00, 0x00, 0x00, 0x0f];

pub const ENCRYPTED_RANDOM_SESSION_KEY_SIZE: usize = 16;
pub const SIGNATURE_SIZE: usize = SIGNATURE_VERSION_SIZE + SIGNATURE_CHECKSUM_SIZE + SIGNATURE_SEQ_NUM_SIZE;

const CHALLENGE_SIZE: usize = 8;
const SESSION_KEY_SIZE: usize = 16;
const MESSAGE_INTEGRITY_CHECK_SIZE: usize = 16;
const LM_CHALLENGE_RESPONSE_BUFFER_SIZE: usize = HASH_SIZE + CHALLENGE_SIZE;

const SIGNATURE_VERSION_SIZE: usize = 4;
const SIGNATURE_SEQ_NUM_SIZE: usize = 4;
const SIGNATURE_CHECKSUM_SIZE: usize = 8;
const MESSAGES_VERSION: u32 = 1;

pub static PACKAGE_INFO: LazyLock<PackageInfo> = LazyLock::new(|| PackageInfo {
    capabilities: PackageCapabilities::empty(),
    rpc_id: PACKAGE_ID_NONE,
    max_token_len: 0xb48,
    name: SecurityPackageType::Ntlm,
    comment: String::from("NTLM Security Package"),
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
enum NtlmState {
    Initial,
    Negotiate,
    Challenge,
    Authenticate,
    Completion,
    Final,
}

/// Specifies the NT LAN Manager (NTLM) Authentication Protocol, used for authentication between clients and servers.
/// NTLM is used by application protocols to authenticate remote users and, optionally, to provide session security when requested by the application.
///
/// # MSDN
///
/// * [[MS-NLMP]: NT LAN Manager (NTLM) Authentication Protocol](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/b38c36ed-2804-4868-a9ff-8dd3182128e4)
#[derive(Debug, Clone)]
pub struct Ntlm {
    config: NtlmConfig,

    negotiate_message: Option<NegotiateMessage>,
    challenge_message: Option<ChallengeMessage>,
    authenticate_message: Option<AuthenticateMessage>,

    channel_bindings: Option<ChannelBindings>,

    state: NtlmState,
    flags: NegotiateFlags,
    identity: Option<AuthIdentityBuffers>,
    version: [u8; NTLM_VERSION_SIZE],

    send_single_host_data: bool,

    signing: bool, // integrity
    sealing: bool, // confidentiality
    send_signing_key: [u8; HASH_SIZE],
    recv_signing_key: [u8; HASH_SIZE],
    send_sealing_key: Option<Rc4>,
    recv_sealing_key: Option<Rc4>,

    session_key: Option<[u8; SESSION_KEY_SIZE]>,
}

#[derive(Debug, Clone)]
struct Mic {
    value: [u8; MESSAGE_INTEGRITY_CHECK_SIZE],
    offset: u8,
}

#[derive(Debug, Clone)]
struct NegotiateMessage {
    message: Vec<u8>,
}

#[derive(Debug, Clone)]
struct ChallengeMessage {
    message: Vec<u8>,
    target_info: Vec<u8>,
    server_challenge: [u8; CHALLENGE_SIZE],
    timestamp: u64,
}

#[derive(Debug, Clone)]
struct AuthenticateMessage {
    message: Vec<u8>,
    mic: Option<Mic>,
    target_info: Vec<u8>,
    client_challenge: [u8; CHALLENGE_SIZE],
    encrypted_random_session_key: Option<[u8; ENCRYPTED_RANDOM_SESSION_KEY_SIZE]>,
}

impl Ntlm {
    pub fn new() -> Self {
        Self {
            config: NtlmConfig::default(),

            negotiate_message: None,
            challenge_message: None,
            authenticate_message: None,

            channel_bindings: None,

            state: NtlmState::Initial,
            flags: NegotiateFlags::empty(),
            identity: None,
            version: DEFAULT_NTLM_VERSION,

            send_single_host_data: false,

            signing: true,
            sealing: true,
            send_signing_key: [0x00; HASH_SIZE],
            recv_signing_key: [0x00; HASH_SIZE],
            send_sealing_key: None,
            recv_sealing_key: None,
            session_key: None,
        }
    }

    pub fn with_config(config: NtlmConfig) -> Self {
        Self {
            config,

            negotiate_message: None,
            challenge_message: None,
            authenticate_message: None,

            channel_bindings: None,

            state: NtlmState::Initial,
            flags: NegotiateFlags::empty(),
            identity: None,
            version: DEFAULT_NTLM_VERSION,

            send_single_host_data: false,

            signing: true,
            sealing: true,
            send_signing_key: [0x00; HASH_SIZE],
            recv_signing_key: [0x00; HASH_SIZE],
            send_sealing_key: None,
            recv_sealing_key: None,
            session_key: None,
        }
    }

    pub fn with_auth_identity(identity: Option<AuthIdentityBuffers>, config: NtlmConfig) -> Self {
        Self {
            config,

            negotiate_message: None,
            challenge_message: None,
            authenticate_message: None,

            channel_bindings: None,

            state: NtlmState::Initial,
            flags: NegotiateFlags::empty(),
            identity,
            version: DEFAULT_NTLM_VERSION,

            send_single_host_data: false,

            signing: true,
            sealing: true,
            send_signing_key: [0x00; HASH_SIZE],
            recv_signing_key: [0x00; HASH_SIZE],
            send_sealing_key: None,
            recv_sealing_key: None,
            session_key: None,
        }
    }

    fn config(&self) -> &NtlmConfig {
        &self.config
    }

    pub fn set_version(&mut self, version: [u8; NTLM_VERSION_SIZE]) {
        self.version = version;
    }

    /// Sets the channel bindings for the session to the appropriately formatted structure
    /// containing the token, passed as the argument, calculated according to the RFC 5929
    /// procedure for the `tls-server-end-point` channel binding type. The MD5 hash of this
    /// structure will be transmitted to the server as an AVPair in the AUTHENTICATE message.
    pub fn set_channel_bindings(&mut self, token: &[u8]) {
        self.channel_bindings = Some(ChannelBindings {
            initiator_addr_type: 0,
            initiator: vec![],
            acceptor_addr_type: 0,
            acceptor: vec![],
            application_data: token.to_vec(),
        });
    }
}

impl Default for Ntlm {
    fn default() -> Self {
        Self::with_config(Default::default())
    }
}

impl SspiImpl for Ntlm {
    type CredentialsHandle = Option<AuthIdentityBuffers>;
    type AuthenticationData = AuthIdentity;

    #[instrument(level = "trace", ret, fields(state = ?self.state), skip(self))]
    fn acquire_credentials_handle_impl(
        &mut self,
        builder: FilledAcquireCredentialsHandle<'_, Self::CredentialsHandle, Self::AuthenticationData>,
    ) -> crate::Result<AcquireCredentialsHandleResult<Self::CredentialsHandle>> {
        if builder.credential_use == CredentialUse::Outbound && builder.auth_data.is_none() {
            return Err(crate::Error::new(
                crate::ErrorKind::NoCredentials,
                "The client must specify the auth data",
            ));
        }

        self.identity = builder.auth_data.cloned().map(AuthIdentityBuffers::from);

        Ok(AcquireCredentialsHandleResult {
            credentials_handle: self.identity.clone(),
            expiry: None,
        })
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip(self, builder))]
    fn accept_security_context_impl<'a>(
        &'a mut self,
        builder: FilledAcceptSecurityContext<'a, Self::CredentialsHandle>,
    ) -> crate::Result<GeneratorAcceptSecurityContext<'a>> {
        Ok(GeneratorAcceptSecurityContext::new(move |_yield_point| async move {
            self.accept_security_context_impl(builder)
        }))
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip_all)]
    fn initialize_security_context_impl<'ctx, 'b, 'g>(
        &'ctx mut self,
        builder: &'b mut FilledInitializeSecurityContext<'ctx, Self::CredentialsHandle>,
    ) -> crate::Result<GeneratorInitSecurityContext<'g>>
    where
        'ctx: 'g,
        'b: 'g,
    {
        Ok(self.initialize_security_context_impl(builder).into())
    }
}

impl Ntlm {
    pub(crate) fn accept_security_context_impl(
        &mut self,
        builder: FilledAcceptSecurityContext<'_, <Self as SspiImpl>::CredentialsHandle>,
    ) -> crate::Result<AcceptSecurityContextResult> {
        let input = builder
            .input
            .ok_or_else(|| crate::Error::new(crate::ErrorKind::InvalidToken, "Input buffers must be specified"))?;
        let status = match self.state {
            NtlmState::Initial => {
                let input_token = SecurityBuffer::find_buffer(input, BufferType::Token)?;
                let output_token = SecurityBuffer::find_buffer_mut(builder.output, BufferType::Token)?;

                self.state = NtlmState::Negotiate;
                server::read_negotiate(self, input_token.buffer.as_slice())?;

                server::write_challenge(self, &mut output_token.buffer)?
            }
            NtlmState::Authenticate => {
                let input_token = SecurityBuffer::find_buffer(input, BufferType::Token)?;

                self.identity = builder.credentials_handle.cloned().flatten();

                if let Ok(sec_buffer) = SecurityBuffer::find_buffer(input, BufferType::ChannelBindings) {
                    self.channel_bindings = Some(ChannelBindings::from_bytes(&sec_buffer.buffer)?);
                }

                server::read_authenticate(self, input_token.buffer.as_slice())?
            }
            _ => {
                return Err(crate::Error::new(
                    crate::ErrorKind::OutOfSequence,
                    format!("got wrong NTLM state: {:?}", self.state),
                ))
            }
        };

        Ok(AcceptSecurityContextResult {
            status,
            flags: ServerResponseFlags::empty(),
            expiry: None,
        })
    }

    pub(crate) fn initialize_security_context_impl(
        &mut self,
        builder: &mut FilledInitializeSecurityContext<'_, <Self as SspiImpl>::CredentialsHandle>,
    ) -> crate::Result<InitializeSecurityContextResult> {
        trace!(?builder);

        let status = match self.state {
            NtlmState::Initial => {
                let output_token = SecurityBuffer::find_buffer_mut(builder.output, BufferType::Token)?;
                self.state = NtlmState::Negotiate;

                self.signing = builder.context_requirements.contains(ClientRequestFlags::INTEGRITY);
                self.sealing = builder
                    .context_requirements
                    .contains(ClientRequestFlags::CONFIDENTIALITY);

                if self.sealing {
                    self.signing = true; // sealing implies signing
                }

                client::write_negotiate(self, &mut output_token.buffer)?
            }
            NtlmState::Challenge => {
                let input = builder.input.as_ref().ok_or_else(|| {
                    crate::Error::new(
                        crate::ErrorKind::InvalidToken,
                        "Input buffers must be specified on subsequent calls",
                    )
                })?;
                let input_token = SecurityBuffer::find_buffer(input, BufferType::Token)?;
                let output_token = SecurityBuffer::find_buffer_mut(builder.output, BufferType::Token)?;

                client::read_challenge(self, input_token.buffer.as_slice())?;

                client::write_authenticate(
                    self,
                    builder
                        .credentials_handle
                        .as_ref()
                        .expect("CredentialsHandle must be passed to the method")
                        .as_ref()
                        .expect("CredentialsHandle must be Some for the client's method"),
                    &mut output_token.buffer,
                )?
            }
            _ => {
                return Err(crate::Error::new(
                    crate::ErrorKind::OutOfSequence,
                    format!("Got wrong NTLM state: {:?}", self.state),
                ))
            }
        };

        trace!(output_buffers = ?builder.output);

        Ok(InitializeSecurityContextResult {
            status,
            flags: ClientResponseFlags::empty(),
            expiry: None,
        })
    }

    fn compute_checksum(
        &mut self,
        message: &mut [SecurityBufferRef],
        sequence_number: u32,
        digest: &[u8; 16],
    ) -> crate::Result<()> {
        let checksum = self
            .send_sealing_key
            .as_mut()
            .unwrap()
            .process(&digest[0..SIGNATURE_CHECKSUM_SIZE]);

        let signature_buffer = SecurityBufferRef::find_buffer_mut(message, BufferType::Token)?;
        if signature_buffer.buf_len() < SIGNATURE_SIZE {
            return Err(Error::new(ErrorKind::BufferTooSmall, "the Token buffer is too small"));
        }
        let signature = compute_signature(&checksum, sequence_number);
        signature_buffer.write_data(signature.as_slice())?;

        Ok(())
    }

    fn check_signature(&mut self, sequence_number: u32, digest: &[u8; 16], signature: &[u8]) -> crate::Result<()> {
        let checksum = self
            .recv_sealing_key
            .as_mut()
            .unwrap()
            .process(&digest[0..SIGNATURE_CHECKSUM_SIZE]);
        let expected_signature = compute_signature(&checksum, sequence_number);

        if signature != expected_signature.as_ref() {
            return Err(Error::new(
                ErrorKind::MessageAltered,
                "signature verification failed, something nasty is going on",
            ));
        }

        Ok(())
    }
}

impl Sspi for Ntlm {
    #[instrument(level = "debug", ret, fields(state = ?self.state), skip_all)]
    fn complete_auth_token(&mut self, _token: &mut [SecurityBuffer]) -> crate::Result<SecurityStatus> {
        server::complete_authenticate(self)
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip(self, _flags))]
    fn encrypt_message(
        &mut self,
        _flags: EncryptionFlags,
        message: &mut [SecurityBufferRef],
        sequence_number: u32,
    ) -> crate::Result<SecurityStatus> {
        if self.send_sealing_key.is_none() {
            self.complete_auth_token(&mut [])?;
        }

        // check if exists
        SecurityBufferRef::find_buffer_mut(message, BufferType::Token)?;
        // Find `Data` buffers (including `Data` buffers with the `READONLY_WITH_CHECKSUM` flag).
        let data_to_sign =
            SecurityBufferRef::buffers_of_type(message, BufferType::Data).fold(Vec::new(), |mut acc, buffer| {
                acc.extend_from_slice(buffer.data());
                acc
            });

        let digest = compute_digest(&self.send_signing_key, sequence_number, &data_to_sign)?;

        // Find `Data` buffers without the `READONLY_WITH_CHECKSUM`/`READONLY` flag.
        let data =
            SecurityBufferRef::buffers_of_type_and_flags_mut(message, BufferType::Data, SecurityBufferFlags::NONE)
                .next()
                .ok_or_else(|| Error::new(ErrorKind::InvalidToken, "no buffer was provided with type Data"))?;

        let encrypted_data = self.send_sealing_key.as_mut().unwrap().process(data.data());
        if encrypted_data.len() < data.buf_len() {
            return Err(Error::new(ErrorKind::BufferTooSmall, "the Data buffer is too small"));
        }
        data.write_data(&encrypted_data)?;

        self.compute_checksum(message, sequence_number, &digest)?;

        Ok(SecurityStatus::Ok)
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip(self, sequence_number))]
    fn decrypt_message(
        &mut self,
        message: &mut [SecurityBufferRef],
        sequence_number: u32,
    ) -> crate::Result<DecryptionFlags> {
        if self.recv_sealing_key.is_none() {
            self.complete_auth_token(&mut [])?;
        }

        let encrypted = extract_encrypted_data(message)?;

        if encrypted.len() < 16 {
            return Err(Error::new(ErrorKind::MessageAltered, "invalid encrypted message size"));
        }

        let (signature, encrypted_message) = encrypted.split_at(16);

        let decrypted = self.recv_sealing_key.as_mut().unwrap().process(encrypted_message);

        save_decrypted_data(&decrypted, message)?;

        // Find `Data` buffers (including `Data` buffers with the `READONLY_WITH_CHECKSUM` flag).
        let data_to_sign =
            SecurityBufferRef::buffers_of_type(message, BufferType::Data).fold(Vec::new(), |mut acc, buffer| {
                if buffer
                    .buffer_flags()
                    .contains(SecurityBufferFlags::SECBUFFER_READONLY_WITH_CHECKSUM)
                {
                    acc.extend_from_slice(buffer.data());
                } else {
                    // The `Data` buffer contains encrypted data, but the checksum was calculated over the decrypted data.
                    // So, we replace encrypted data with decrypted one.
                    acc.extend_from_slice(&decrypted);
                }
                acc
            });
        let digest = compute_digest(&self.recv_signing_key, sequence_number, &data_to_sign)?;
        self.check_signature(sequence_number, &digest, signature)?;

        Ok(DecryptionFlags::empty())
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip(self))]
    fn query_context_sizes(&mut self) -> crate::Result<ContextSizes> {
        Ok(ContextSizes {
            max_token: 2010,
            max_signature: 16,
            block: 0,
            security_trailer: 16,
        })
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip(self))]
    fn query_context_names(&mut self) -> crate::Result<ContextNames> {
        if let Some(identity_buffers) = &self.identity {
            let identity =
                AuthIdentity::try_from(identity_buffers).map_err(|e| Error::new(ErrorKind::InvalidParameter, e))?;

            Ok(ContextNames {
                username: identity.username,
            })
        } else {
            Err(crate::Error::new(
                crate::ErrorKind::NoCredentials,
                "Requested Names, but no credentials were provided",
            ))
        }
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip(self))]
    fn query_context_package_info(&mut self) -> crate::Result<PackageInfo> {
        crate::query_security_package_info(SecurityPackageType::Ntlm)
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip(self))]
    fn query_context_cert_trust_status(&mut self) -> crate::Result<CertTrustStatus> {
        Err(crate::Error::new(
            crate::ErrorKind::UnsupportedFunction,
            "Certificate trust status is not supported",
        ))
    }

    #[instrument(level = "debug", fields(state = ?self.state), skip(self))]
    fn query_context_session_key(&self) -> crate::Result<crate::SessionKeys> {
        if let Some(session_key) = self.session_key {
            Ok(crate::SessionKeys {
                session_key: session_key.to_vec().into(),
            })
        } else {
            Err(Error::new(
                ErrorKind::OutOfSequence,
                "the session key is not established",
            ))
        }
    }

    fn change_password(
        &mut self,
        _: crate::builders::ChangePassword,
    ) -> crate::Result<crate::generator::GeneratorChangePassword> {
        Err(Error::new(
            ErrorKind::UnsupportedFunction,
            "NTLM does not support change pasword",
        ))
    }

    fn make_signature(
        &mut self,
        _flags: u32,
        message: &mut [SecurityBufferRef],
        sequence_number: u32,
    ) -> crate::Result<()> {
        if self.send_sealing_key.is_none() {
            self.complete_auth_token(&mut [])?;
        }

        SecurityBufferRef::find_buffer(message, BufferType::Token)?; // check if exists

        let data = SecurityBufferRef::find_buffer_mut(message, BufferType::Data)?;
        let digest = compute_digest(&self.send_signing_key, sequence_number, data.data())?;

        self.compute_checksum(message, sequence_number, &digest)?;

        Ok(())
    }

    fn verify_signature(&mut self, message: &mut [SecurityBufferRef], sequence_number: u32) -> crate::Result<u32> {
        if self.recv_sealing_key.is_none() {
            self.complete_auth_token(&mut [])?;
        }

        SecurityBufferRef::find_buffer(message, BufferType::Token)?; // check if exists

        let data = SecurityBufferRef::find_buffer(message, BufferType::Data)?;
        let digest = compute_digest(&self.recv_signing_key, sequence_number, data.data())?;

        let signature = SecurityBufferRef::find_buffer(message, BufferType::Token)?;
        self.check_signature(sequence_number, &digest, signature.data())?;

        Ok(0)
    }
}

impl SspiEx for Ntlm {
    #[instrument(level = "trace", ret, fields(state = ?self.state), skip(self))]
    fn custom_set_auth_identity(&mut self, identity: Self::AuthenticationData) -> crate::Result<()> {
        self.identity = Some(identity.into());

        Ok(())
    }
}

impl NegotiateMessage {
    fn new(message: Vec<u8>) -> Self {
        Self { message }
    }
}

impl ChallengeMessage {
    fn new(message: Vec<u8>, target_info: Vec<u8>, server_challenge: [u8; CHALLENGE_SIZE], timestamp: u64) -> Self {
        Self {
            message,
            target_info,
            server_challenge,
            timestamp,
        }
    }
}

impl AuthenticateMessage {
    fn new(
        message: Vec<u8>,
        mic: Option<Mic>,
        target_info: Vec<u8>,
        client_challenge: [u8; CHALLENGE_SIZE],
        encrypted_random_session_key: Option<[u8; ENCRYPTED_RANDOM_SESSION_KEY_SIZE]>,
    ) -> Self {
        Self {
            message,
            mic,
            target_info,
            client_challenge,
            encrypted_random_session_key,
        }
    }
}

impl Mic {
    fn new(value: [u8; MESSAGE_INTEGRITY_CHECK_SIZE], offset: u8) -> Self {
        Self { value, offset }
    }
}

bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    struct NegotiateFlags: u32 {
        /// W-bit
        /// requests 56-bit encryption
        const NTLM_SSP_NEGOTIATE56 = 0x8000_0000;

        /// V-bit
        /// requests explicit key exchange
        const NTLM_SSP_NEGOTIATE_KEY_EXCH = 0x4000_0000;

        /// U-bit
        /// requests an 128 bit session key
        const NTLM_SSP_NEGOTIATE128 = 0x2000_0000;

        /// r1
        const NTLM_SSP_NEGOTIATE_RESERVED1  = 0x1000_0000;

        /// r2
        const NTLM_SSP_NEGOTIATE_RESERVED2 = 0x0800_0000;

        /// r3
        const NTLM_SSP_NEGOTIATE_RESERVED3 = 0x0400_0000;

        /// r6
        const NTLM_SSP_NEGOTIATE_VERSION = 0x0200_0000;

        /// r4
        const NTLM_SSP_NEGOTIATE_RESERVED4 = 0x0100_0000;

        /// S-bit
        const NTLM_SSP_NEGOTIATE_TARGET_INFO = 0x0080_0000;

        /// R
        const NTLM_SSP_NEGOTIATE_REQUEST_NON_NT_SESSION_KEY = 0x0040_0000;

        /// r5
        const NTLM_SSP_NEGOTIATE_RESERVED5 = 0x0020_0000;

        /// Q
        const NTLM_SSP_NEGOTIATE_IDENTIFY = 0x0010_0000;

        /// P-bit
        /// NTLMv2 Session Security
        const NTLM_SSP_NEGOTIATE_EXTENDED_SESSION_SECURITY = 0x0008_0000;

        /// r6
        const NTLM_SSP_NEGOTIATE_RESERVED6 = 0x0004_0000;

        /// O
        const NTLM_SSP_NEGOTIATE_TARGET_TYPE_SERVER = 0x0002_0000;

        /// N
        const NTLM_SSP_NEGOTIATE_TARGET_TYPE_DOMAIN = 0x0001_0000;

        /// M-bit
        /// requests a signature block
        const NTLM_SSP_NEGOTIATE_ALWAYS_SIGN = 0x0000_8000;

        /// r7
        const NTLM_SSP_NEGOTIATE_RESERVED7 = 0x0000_4000;

        /// L-bit
        const NTLM_SSP_NEGOTIATE_WORKSTATION_SUPPLIED = 0x0000_2000;

        /// K-bit
        const NTLM_SSP_NEGOTIATE_DOMAIN_SUPPLIED = 0x0000_1000;

        /// J
        const NTLM_SSP_NEGOTIATE_ANONYMOUS = 0x0000_0800;

        /// r8
        const NTLM_SSP_NEGOTIATE_RESERVED8 = 0x0000_0400;

        /// H-bit
        /// NTLMv1 Session Security, deprecated, insecure and not supported by us
        const NTLM_SSP_NEGOTIATE_NTLM = 0x0000_0200;

        /// r9
        const NTLM_SSP_NEGOTIATE_RESERVED9 = 0x0000_0100;

        /// G-bit
        /// LM Session Security, deprecated, insecure and not supported by us
        const NTLM_SSP_NEGOTIATE_LM_KEY = 0x0000_0080;

        /// F
        const NTLM_SSP_NEGOTIATE_DATAGRAM = 0x0000_0040;

        /// E-bit
        /// session key negotiation with message confidentiality
        const NTLM_SSP_NEGOTIATE_SEAL = 0x0000_0020;

        /// D-bit
        const NTLM_SSP_NEGOTIATE_SIGN = 0x0000_0010;

        /// r10
        const NTLM_SSP_NEGOTIATE_SIGN_RESERVED10 = 0x0000_0008;

        /// C-bit
        const NTLM_SSP_NEGOTIATE_REQUEST_TARGET = 0x0000_0004;

        /// B-bit
        const NTLM_SSP_NEGOTIATE_OEM = 0x0000_0002;

        /// A-bit
        const NTLM_SSP_NEGOTIATE_UNICODE = 0x0000_0001;
    }
}

fn compute_digest(key: &[u8], seq_num: u32, data: &[u8]) -> io::Result<[u8; 16]> {
    let mut digest_data = Vec::with_capacity(SIGNATURE_SEQ_NUM_SIZE + data.len());
    digest_data.write_u32::<LittleEndian>(seq_num)?;
    digest_data.extend_from_slice(data);

    compute_hmac_md5(key, &digest_data)
}

fn compute_signature(checksum: &[u8], seq_num: u32) -> [u8; SIGNATURE_SIZE] {
    let mut signature = [0x00; SIGNATURE_SIZE];
    signature[..SIGNATURE_VERSION_SIZE].clone_from_slice(&MESSAGES_VERSION.to_le_bytes());
    signature[SIGNATURE_VERSION_SIZE..SIGNATURE_VERSION_SIZE + SIGNATURE_CHECKSUM_SIZE].clone_from_slice(checksum);
    signature[SIGNATURE_VERSION_SIZE + SIGNATURE_CHECKSUM_SIZE..].clone_from_slice(&seq_num.to_le_bytes());

    signature
}


--- File: src/ntlm/test.rs ---
use crate::crypto::{Rc4, HASH_SIZE};
use crate::ntlm::messages::test::TEST_CREDENTIALS;
use crate::ntlm::{
    AuthenticateMessage, ChallengeMessage, Mic, NegotiateFlags, NegotiateMessage, Ntlm, NtlmState, CHALLENGE_SIZE,
    SIGNATURE_SIZE,
};
use crate::*;

const TEST_SEQ_NUM: u32 = 1_234_567_890;
const SEALING_KEY: [u8; HASH_SIZE] = [
    0xa4, 0xf1, 0xba, 0xa6, 0x7c, 0xdc, 0x1a, 0x12, 0x20, 0xc0, 0x2b, 0x3d, 0xc0, 0x61, 0xa7, 0x73,
];
const SIGNING_KEY: [u8; HASH_SIZE] = [
    0x20, 0xc0, 0x2b, 0x3d, 0xc0, 0x61, 0xa7, 0x73, 0xa4, 0xf1, 0xba, 0xa6, 0x7c, 0xdc, 0x1a, 0x12,
];

pub const TEST_DATA: &[u8] = b"Hello, World!!!";

pub const ENCRYPTED_TEST_DATA: [u8; 15] = [
    0x20, 0x2e, 0xdd, 0xd9, 0x56, 0x5e, 0xc4, 0x59, 0x42, 0xdb, 0x94, 0xfd, 0x6b, 0xf3, 0x11,
];

pub const DIGEST_FOR_TEST_DATA: [u8; 8] = [0x58, 0x27, 0x4d, 0x35, 0x1f, 0x2d, 0x3c, 0xfd];

pub const SIGNATURE_FOR_TEST_DATA: [u8; 16] = [
    0x1, 0x0, 0x0, 0x0, 0x58, 0x27, 0x4d, 0x35, 0x1f, 0x2d, 0x3c, 0xfd, 0xd2, 0x2, 0x96, 0x49,
];

#[test]
fn encrypt_message_crypts_data() {
    let mut context = Ntlm::new();
    context.send_sealing_key = Some(Rc4::new(&SEALING_KEY));

    let mut token = [0; 100];
    let mut data = TEST_DATA.to_vec();
    let mut buffers = vec![
        SecurityBufferRef::token_buf(token.as_mut_slice()),
        SecurityBufferRef::data_buf(data.as_mut_slice()),
    ];
    let expected = &ENCRYPTED_TEST_DATA;

    let result = context
        .encrypt_message(EncryptionFlags::empty(), &mut buffers, 0)
        .unwrap();
    let output = SecurityBufferRef::find_buffer(&buffers, BufferType::Data).unwrap();

    assert_eq!(result, SecurityStatus::Ok);
    assert_eq!(expected, output.data());
}

#[test]
fn encrypt_message_correct_computes_digest() {
    let mut context = Ntlm::new();
    context.send_signing_key = SIGNING_KEY;
    context.send_sealing_key = Some(Rc4::new(&SEALING_KEY));

    let mut token = [0; 100];
    let mut data = TEST_DATA.to_vec();
    let mut buffers = vec![
        SecurityBufferRef::token_buf(token.as_mut_slice()),
        SecurityBufferRef::data_buf(data.as_mut_slice()),
    ];
    let expected = &DIGEST_FOR_TEST_DATA;

    let result = context
        .encrypt_message(EncryptionFlags::empty(), &mut buffers, TEST_SEQ_NUM)
        .unwrap();
    let signature = SecurityBufferRef::find_buffer(&buffers, BufferType::Token).unwrap();

    assert_eq!(result, SecurityStatus::Ok);
    assert_eq!(expected, &signature.data()[4..12]);
}

#[test]
fn encrypt_message_writes_seq_num_to_signature() {
    let mut context = Ntlm::new();
    context.send_signing_key = SIGNING_KEY;
    context.send_sealing_key = Some(Rc4::new(&SEALING_KEY));

    let mut token = [0; 100];
    let mut data = TEST_DATA.to_vec();
    let mut buffers = vec![
        SecurityBufferRef::token_buf(token.as_mut_slice()),
        SecurityBufferRef::data_buf(data.as_mut_slice()),
    ];
    let expected = TEST_SEQ_NUM.to_le_bytes();

    let result = context
        .encrypt_message(EncryptionFlags::empty(), &mut buffers, TEST_SEQ_NUM)
        .unwrap();
    let signature = SecurityBufferRef::find_buffer(&buffers, BufferType::Token).unwrap();

    assert_eq!(result, SecurityStatus::Ok);
    assert_eq!(expected, signature.data()[12..SIGNATURE_SIZE]);
}

#[test]
fn decrypt_message_decrypts_data() {
    let mut context = Ntlm::new();
    context.recv_signing_key = SIGNING_KEY;
    context.recv_sealing_key = Some(Rc4::new(&SEALING_KEY));

    let mut encrypted_test_data = ENCRYPTED_TEST_DATA.to_vec();
    let mut signature_test_data = SIGNATURE_FOR_TEST_DATA.to_vec();

    let mut buffers = vec![
        SecurityBufferRef::data_buf(&mut encrypted_test_data),
        SecurityBufferRef::token_buf(&mut signature_test_data),
    ];
    let expected = TEST_DATA;

    context.decrypt_message(&mut buffers, TEST_SEQ_NUM).unwrap();
    let data = SecurityBufferRef::find_buffer(&buffers, BufferType::Data).unwrap();

    assert_eq!(expected, data.data());
}

#[test]
fn decrypt_message_does_not_fail_on_correct_signature() {
    let mut context = Ntlm::new();
    context.recv_signing_key = SIGNING_KEY;
    context.recv_sealing_key = Some(Rc4::new(&SEALING_KEY));

    let mut encrypted_test_data = ENCRYPTED_TEST_DATA.to_vec();
    let mut signature_test_data = SIGNATURE_FOR_TEST_DATA.to_vec();

    let mut buffers = vec![
        SecurityBufferRef::data_buf(&mut encrypted_test_data),
        SecurityBufferRef::token_buf(&mut signature_test_data),
    ];

    context.decrypt_message(&mut buffers, TEST_SEQ_NUM).unwrap();
}

#[test]
fn decrypt_message_fails_on_incorrect_version() {
    let mut context = Ntlm::new();
    context.recv_signing_key = SIGNING_KEY;
    context.recv_sealing_key = Some(Rc4::new(&SEALING_KEY));

    let mut encrypted_test_data = ENCRYPTED_TEST_DATA.to_vec();
    let mut token = [
        0x02, 0x00, 0x00, 0x00, 0x2e, 0xdf, 0xf2, 0x61, 0x29, 0xd6, 0x4d, 0xa9, 0xd2, 0x02, 0x96, 0x49,
    ];

    let mut buffers = vec![
        SecurityBufferRef::data_buf(&mut encrypted_test_data),
        SecurityBufferRef::token_buf(&mut token),
    ];

    assert!(context.decrypt_message(&mut buffers, TEST_SEQ_NUM).is_err());
}

#[test]
fn decrypt_message_fails_on_incorrect_checksum() {
    let mut context = Ntlm::new();
    context.recv_signing_key = SIGNING_KEY;
    context.recv_sealing_key = Some(Rc4::new(&SEALING_KEY));

    let mut encrypted_test_data = ENCRYPTED_TEST_DATA.to_vec();
    let mut token = [
        0x01, 0x00, 0x00, 0x00, 0x2e, 0xdf, 0xff, 0x61, 0x29, 0xd6, 0x4d, 0xa9, 0xd2, 0x02, 0x96, 0x49,
    ];

    let mut buffers = vec![
        SecurityBufferRef::data_buf(&mut encrypted_test_data),
        SecurityBufferRef::token_buf(&mut token),
    ];

    assert!(context.decrypt_message(&mut buffers, TEST_SEQ_NUM).is_err());
}

#[test]
fn decrypt_message_fails_on_incorrect_seq_num() {
    let mut context = Ntlm::new();
    context.recv_signing_key = SIGNING_KEY;
    context.recv_sealing_key = Some(Rc4::new(&SEALING_KEY));

    let mut encrypted_test_data = ENCRYPTED_TEST_DATA.to_vec();
    let mut token = [
        0x01, 0x00, 0x00, 0x00, 0x2e, 0xdf, 0xf2, 0x61, 0x29, 0xd6, 0x4d, 0xa9, 0xd2, 0x02, 0x96, 0x40,
    ];

    let mut buffers = vec![
        SecurityBufferRef::data_buf(&mut encrypted_test_data),
        SecurityBufferRef::token_buf(&mut token),
    ];

    assert!(context.decrypt_message(&mut buffers, TEST_SEQ_NUM).is_err());
}

#[test]
fn decrypt_message_fails_on_incorrect_signing_key() {
    let mut context = Ntlm::new();

    context.recv_signing_key = SEALING_KEY;
    context.recv_sealing_key = Some(Rc4::new(&SEALING_KEY));

    let mut encrypted_test_data = ENCRYPTED_TEST_DATA.to_vec();
    let mut signature_test_data = SIGNATURE_FOR_TEST_DATA.to_vec();

    let mut buffers = vec![
        SecurityBufferRef::data_buf(&mut encrypted_test_data),
        SecurityBufferRef::token_buf(&mut signature_test_data),
    ];

    assert!(context.decrypt_message(&mut buffers, TEST_SEQ_NUM).is_err());
}

#[test]
fn decrypt_message_fails_on_incorrect_sealing_key() {
    let mut context = Ntlm::new();

    context.recv_signing_key = SIGNING_KEY;
    context.recv_sealing_key = Some(Rc4::new(&SIGNING_KEY));

    let mut encrypted_test_data = ENCRYPTED_TEST_DATA.to_vec();
    let mut signature_test_data = SIGNATURE_FOR_TEST_DATA.to_vec();

    let mut buffers = vec![
        SecurityBufferRef::data_buf(&mut encrypted_test_data),
        SecurityBufferRef::token_buf(&mut signature_test_data),
    ];

    assert!(context.decrypt_message(&mut buffers, TEST_SEQ_NUM).is_err());
}

#[test]
fn make_signature_verified_by_verify_signature() {
    let mut sender = Ntlm::new();
    let mut reciever = Ntlm::new();

    sender.send_signing_key = SIGNING_KEY;
    sender.send_sealing_key = Some(Rc4::new(&SEALING_KEY));

    reciever.recv_signing_key = SIGNING_KEY;
    reciever.recv_sealing_key = Some(Rc4::new(&SEALING_KEY));

    let mut plain_test_data = TEST_DATA.to_vec();
    let mut signature_test_data = [0u8; 16];
    let mut make_signature_buffers = vec![
        SecurityBufferRef::data_buf(&mut plain_test_data),
        SecurityBufferRef::token_buf(&mut signature_test_data),
    ];
    assert!(sender
        .make_signature(0, &mut make_signature_buffers, TEST_SEQ_NUM)
        .is_ok());

    let mut verify_signature_buffers = vec![
        SecurityBufferRef::data_buf(&mut plain_test_data),
        SecurityBufferRef::token_buf(&mut signature_test_data),
    ];
    assert!(reciever
        .verify_signature(&mut verify_signature_buffers, TEST_SEQ_NUM)
        .is_ok());
}

#[test]
fn verify_signature_fails_on_invalid_signature() {
    let mut context = Ntlm::new();

    context.recv_signing_key = SIGNING_KEY;
    context.recv_sealing_key = Some(Rc4::new(&SEALING_KEY));

    let mut test_data = TEST_DATA.to_vec();
    let mut token = [
        0x01, 0x00, 0x00, 0x00, 0x2e, 0xdf, 0xff, 0x61, 0x29, 0xd6, 0x4d, 0xa9, 0xd2, 0x02, 0x96, 0x49,
    ];

    let mut verify_signature_buffers = vec![
        SecurityBufferRef::data_buf(&mut test_data),
        SecurityBufferRef::token_buf(&mut token),
    ];
    assert!(context
        .verify_signature(&mut verify_signature_buffers, TEST_SEQ_NUM)
        .is_err());
}

#[test]
fn initialize_security_context_wrong_state_negotiate() {
    let mut context = Ntlm::new();
    context.state = NtlmState::Negotiate;

    let mut output = vec![SecurityBuffer::new(Vec::new(), BufferType::Token)];
    let mut credentials = Some(TEST_CREDENTIALS.clone());

    let mut builder = context
        .initialize_security_context()
        .with_credentials_handle(&mut credentials)
        .with_context_requirements(ClientRequestFlags::empty())
        .with_target_data_representation(DataRepresentation::Native)
        .with_output(&mut output);

    assert!(context.initialize_security_context_impl(&mut builder).is_err());
    assert_eq!(context.state, NtlmState::Negotiate);
}

#[test]
fn initialize_security_context_wrong_state_authenticate() {
    let mut context = Ntlm::new();
    context.state = NtlmState::Authenticate;

    let mut output = vec![SecurityBuffer::new(Vec::new(), BufferType::Token)];
    let mut credentials = Some(TEST_CREDENTIALS.clone());

    let mut builder = context
        .initialize_security_context()
        .with_credentials_handle(&mut credentials)
        .with_context_requirements(ClientRequestFlags::empty())
        .with_target_data_representation(DataRepresentation::Native)
        .with_output(&mut output);

    assert!(context.initialize_security_context_impl(&mut builder).is_err());
    assert_eq!(context.state, NtlmState::Authenticate);
}

#[test]
fn initialize_security_context_wrong_state_completion() {
    let mut context = Ntlm::new();
    context.state = NtlmState::Completion;

    let mut output = vec![SecurityBuffer::new(Vec::new(), BufferType::Token)];
    let mut credentials = Some(TEST_CREDENTIALS.clone());

    let mut builder = context
        .initialize_security_context()
        .with_credentials_handle(&mut credentials)
        .with_context_requirements(ClientRequestFlags::empty())
        .with_target_data_representation(DataRepresentation::Native)
        .with_output(&mut output);

    assert!(context.initialize_security_context_impl(&mut builder).is_err());
    assert_eq!(context.state, NtlmState::Completion);
}

#[test]
fn initialize_security_context_wrong_state_final() {
    let mut context = Ntlm::new();
    context.state = NtlmState::Final;

    let mut output = vec![SecurityBuffer::new(Vec::new(), BufferType::Token)];
    let mut credentials = Some(TEST_CREDENTIALS.clone());

    let mut builder = context
        .initialize_security_context()
        .with_credentials_handle(&mut credentials)
        .with_context_requirements(ClientRequestFlags::empty())
        .with_target_data_representation(DataRepresentation::Native)
        .with_output(&mut output);

    assert!(context.initialize_security_context_impl(&mut builder).is_err());
    assert_eq!(context.state, NtlmState::Final);
}

#[test]
fn initialize_security_context_writes_negotiate_message() {
    let mut context = Ntlm::new();

    context.state = NtlmState::Initial;

    let mut output = vec![SecurityBuffer::new(Vec::with_capacity(1024), BufferType::Token)];
    let mut credentials = Some(TEST_CREDENTIALS.clone());

    let mut builder = context
        .initialize_security_context()
        .with_credentials_handle(&mut credentials)
        .with_context_requirements(ClientRequestFlags::empty())
        .with_target_data_representation(DataRepresentation::Native)
        .with_output(&mut output);

    let result = context.initialize_security_context_impl(&mut builder).unwrap();

    assert_eq!(result.status, SecurityStatus::ContinueNeeded);
    let output = SecurityBuffer::find_buffer(&output, BufferType::Token).unwrap();
    assert_eq!(context.state, NtlmState::Challenge);
    assert!(!output.buffer.is_empty());
}

#[test]
fn initialize_security_context_reads_challenge_message() {
    let mut context = Ntlm::new();

    context.state = NtlmState::Challenge;
    context.negotiate_message = Some(NegotiateMessage::new(Vec::new()));

    let mut input = [SecurityBuffer::new(
        vec![
            0x4e, 0x54, 0x4c, 0x4d, 0x53, 0x53, 0x50, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x30, 0x00,
            0x00, 0x00, 0x97, 0x82, 0x88, 0xe0, 0xfe, 0x14, 0x51, 0x74, 0x06, 0x57, 0x92, 0x8a, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00,
        ],
        BufferType::Token,
    )];
    let mut output = vec![SecurityBuffer::new(Vec::with_capacity(1024), BufferType::Token)];
    let mut credentials = Some(TEST_CREDENTIALS.clone());

    let mut builder = context
        .initialize_security_context()
        .with_credentials_handle(&mut credentials)
        .with_context_requirements(ClientRequestFlags::empty())
        .with_target_data_representation(DataRepresentation::Native)
        .with_output(&mut output)
        .with_input(&mut input);

    let result = context.initialize_security_context_impl(&mut builder).unwrap();
    assert_eq!(result.status, SecurityStatus::Ok);
    assert_ne!(context.state, NtlmState::Challenge);
}

#[test]
fn initialize_security_context_writes_authenticate_message() {
    let mut context = Ntlm::new();
    context.state = NtlmState::Challenge;
    context.negotiate_message = Some(NegotiateMessage::new(Vec::new()));

    let mut input = [SecurityBuffer::new(
        vec![
            0x4e, 0x54, 0x4c, 0x4d, 0x53, 0x53, 0x50, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x30, 0x00,
            0x00, 0x00, 0x97, 0x82, 0x88, 0xe0, 0xfe, 0x14, 0x51, 0x74, 0x06, 0x57, 0x92, 0x8a, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00,
        ],
        BufferType::Token,
    )];
    let mut output = vec![SecurityBuffer::new(Vec::with_capacity(1024), BufferType::Token)];
    let mut credentials = Some(TEST_CREDENTIALS.clone());

    let mut builder = context
        .initialize_security_context()
        .with_credentials_handle(&mut credentials)
        .with_context_requirements(ClientRequestFlags::empty())
        .with_target_data_representation(DataRepresentation::Native)
        .with_output(&mut output)
        .with_input(&mut input);

    let result = context.initialize_security_context_impl(&mut builder).unwrap();

    assert_eq!(result.status, SecurityStatus::Ok);
    let output = SecurityBuffer::find_buffer(&output, BufferType::Token).unwrap();
    assert_eq!(context.state, NtlmState::Final);
    assert!(!output.buffer.is_empty());
}

#[test]
fn initialize_security_context_fails_on_empty_output_on_challenge_state() {
    let mut context = Ntlm::new();
    context.state = NtlmState::Challenge;

    let mut output = vec![SecurityBuffer::new(Vec::with_capacity(1024), BufferType::Token)];
    let mut credentials = Some(TEST_CREDENTIALS.clone());

    let mut builder = context
        .initialize_security_context()
        .with_credentials_handle(&mut credentials)
        .with_context_requirements(ClientRequestFlags::empty())
        .with_target_data_representation(DataRepresentation::Native)
        .with_output(&mut output);

    assert!(context.initialize_security_context_impl(&mut builder).is_err());
}

#[test]
fn accept_security_context_wrong_state_negotiate() {
    let mut context = Ntlm::new();
    context.state = NtlmState::Negotiate;

    let mut output = vec![SecurityBuffer::new(Vec::new(), BufferType::Token)];
    let mut credentials = Some(TEST_CREDENTIALS.clone());
    let builder = context
        .accept_security_context()
        .with_credentials_handle(&mut credentials)
        .with_context_requirements(ServerRequestFlags::empty())
        .with_target_data_representation(DataRepresentation::Native)
        .with_output(&mut output);

    assert!(context.accept_security_context_impl(builder).is_err());
    assert_eq!(context.state, NtlmState::Negotiate);
}

#[test]
fn accept_security_context_wrong_state_challenge() {
    let mut context = Ntlm::new();
    context.state = NtlmState::Challenge;

    let mut output = vec![SecurityBuffer::new(Vec::new(), BufferType::Token)];
    let mut credentials = Some(TEST_CREDENTIALS.clone());
    let builder = context
        .accept_security_context()
        .with_credentials_handle(&mut credentials)
        .with_context_requirements(ServerRequestFlags::empty())
        .with_target_data_representation(DataRepresentation::Native)
        .with_output(&mut output);

    assert!(context.accept_security_context_impl(builder).is_err());
    assert_eq!(context.state, NtlmState::Challenge);
}

#[test]
fn accept_security_context_wrong_state_completion() {
    let mut context = Ntlm::new();
    context.state = NtlmState::Completion;

    let mut output = vec![SecurityBuffer::new(Vec::new(), BufferType::Token)];
    let mut credentials = Some(TEST_CREDENTIALS.clone());
    let builder = context
        .accept_security_context()
        .with_credentials_handle(&mut credentials)
        .with_context_requirements(ServerRequestFlags::empty())
        .with_target_data_representation(DataRepresentation::Native)
        .with_output(&mut output);

    assert!(context.accept_security_context_impl(builder).is_err());
    assert_eq!(context.state, NtlmState::Completion);
}

#[test]
fn accept_security_context_wrong_state_final() {
    let mut context = Ntlm::new();
    context.state = NtlmState::Final;

    let mut output = vec![SecurityBuffer::new(Vec::new(), BufferType::Token)];
    let mut credentials = Some(TEST_CREDENTIALS.clone());
    let builder = context
        .accept_security_context()
        .with_credentials_handle(&mut credentials)
        .with_context_requirements(ServerRequestFlags::empty())
        .with_target_data_representation(DataRepresentation::Native)
        .with_output(&mut output);

    assert!(context.accept_security_context_impl(builder).is_err());
    assert_eq!(context.state, NtlmState::Final);
}

#[test]
fn accept_security_context_reads_negotiate_message() {
    let mut context = Ntlm::new();
    context.state = NtlmState::Initial;

    let mut input = [SecurityBuffer::new(
        vec![
            0x4e, 0x54, 0x4c, 0x4d, 0x53, 0x53, 0x50, 0x00, 0x01, 0x00, 0x00, 0x00, 0x97, 0x82, 0x08, 0xe0, 0x00, 0x00,
            0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
        ],
        BufferType::Token,
    )];
    let mut output = vec![SecurityBuffer::new(Vec::with_capacity(1024), BufferType::Token)];
    let mut credentials = Some(TEST_CREDENTIALS.clone());
    let builder = context
        .accept_security_context()
        .with_credentials_handle(&mut credentials)
        .with_context_requirements(ServerRequestFlags::empty())
        .with_target_data_representation(DataRepresentation::Native)
        .with_output(&mut output)
        .with_input(&mut input);

    let result = context.accept_security_context_impl(builder).unwrap();
    assert_eq!(result.status, SecurityStatus::ContinueNeeded);
    assert_ne!(context.state, NtlmState::Challenge);
}

#[test]
fn accept_security_context_writes_challenge_message() {
    let mut context = Ntlm::new();
    context.state = NtlmState::Initial;

    let mut input = [SecurityBuffer::new(
        vec![
            0x4e, 0x54, 0x4c, 0x4d, 0x53, 0x53, 0x50, 0x00, 0x01, 0x00, 0x00, 0x00, 0x97, 0x82, 0x08, 0xe0, 0x00, 0x00,
            0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
        ],
        BufferType::Token,
    )];
    let mut output = vec![SecurityBuffer::new(Vec::with_capacity(1024), BufferType::Token)];
    let mut credentials = Some(TEST_CREDENTIALS.clone());
    let builder = context
        .accept_security_context()
        .with_credentials_handle(&mut credentials)
        .with_context_requirements(ServerRequestFlags::empty())
        .with_target_data_representation(DataRepresentation::Native)
        .with_output(&mut output)
        .with_input(&mut input);

    let result = context.accept_security_context_impl(builder).unwrap();
    assert_eq!(result.status, SecurityStatus::ContinueNeeded);
    let output = SecurityBuffer::find_buffer(&output, BufferType::Token).unwrap();
    assert_eq!(context.state, NtlmState::Authenticate);
    assert!(!output.buffer.is_empty());
}

#[test]
fn accept_security_context_reads_authenticate() {
    let mut context = Ntlm::new();
    context.state = NtlmState::Authenticate;
    context.negotiate_message = Some(NegotiateMessage::new(vec![0x01, 0x02, 0x03]));
    context.challenge_message = Some(ChallengeMessage::new(
        vec![0x04, 0x05, 0x06],
        Vec::new(),
        [0x00; CHALLENGE_SIZE],
        0,
    ));

    let mut input = [SecurityBuffer::new(
        vec![
            0x4e, 0x54, 0x4c, 0x4d, 0x53, 0x53, 0x50, 0x00, // signature
            0x03, 0x00, 0x00, 0x00, // message type
            0x18, 0x00, 0x18, 0x00, 0x55, 0x00, 0x00, 0x00, // LmChallengeResponseFields
            0x30, 0x00, 0x30, 0x00, 0x6d, 0x00, 0x00, 0x00, // NtChallengeResponseFields
            0x06, 0x00, 0x06, 0x00, 0x40, 0x00, 0x00, 0x00, // DomainNameFields
            0x04, 0x00, 0x04, 0x00, 0x46, 0x00, 0x00, 0x00, // UserNameFields
            0x0b, 0x00, 0x0b, 0x00, 0x4a, 0x00, 0x00, 0x00, // WorkstationFields
            0x10, 0x00, 0x10, 0x00, 0x9d, 0x00, 0x00, 0x00, // EncryptedRandomSessionKeyFields
            0x35, 0xb2, 0x08, 0xe0, // NegotiateFlags
            0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, // domain
            0x55, 0x73, 0x65, 0x72, // user
            0x57, 0x6f, 0x72, 0x6b, 0x73, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, // workstation
            0x13, 0x23, 0x04, 0xd8, 0x5f, 0x66, 0x52, 0xce, 0x41, 0xd6, 0xa9, 0x98, 0xf6, 0xbc, 0x73, 0x1b, 0x04, 0xd8,
            0x5f, 0x41, 0xd6, 0xa9, 0x5f, 0x66, // lm challenge
            0x1f, 0x7b, 0x1d, 0x2a, 0x15, 0xf5, 0x5d, 0x95, 0xc3, 0xce, 0x90, 0xbd, 0x10, 0x1e, 0xe3, 0xa8, 0x01, 0x01,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x57, 0xbd, 0xb1, 0x07, 0x8b, 0xcf, 0x01, 0x20, 0xc0, 0x2b, 0x3d,
            0xc0, 0x61, 0xa7, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // nt challenge
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
            0x0f, // encrypted key
        ],
        BufferType::Token,
    )];
    let mut output = vec![SecurityBuffer::new(Vec::with_capacity(1024), BufferType::Token)];
    let mut credentials = Some(TEST_CREDENTIALS.clone());
    let builder = context
        .accept_security_context()
        .with_credentials_handle(&mut credentials)
        .with_context_requirements(ServerRequestFlags::empty())
        .with_target_data_representation(DataRepresentation::Native)
        .with_output(&mut output)
        .with_input(&mut input);

    let result = context.accept_security_context_impl(builder).unwrap();
    assert_eq!(result.status, SecurityStatus::CompleteNeeded);
    assert_eq!(context.state, NtlmState::Completion);
}

#[test]
fn accept_security_context_fails_on_empty_output_on_negotiate_state() {
    let mut context = Ntlm::new();

    context.state = NtlmState::Initial;

    let mut output = vec![SecurityBuffer::new(Vec::new(), BufferType::Token)];
    let mut credentials = Some(TEST_CREDENTIALS.clone());
    let builder = context
        .accept_security_context()
        .with_credentials_handle(&mut credentials)
        .with_context_requirements(ServerRequestFlags::empty())
        .with_target_data_representation(DataRepresentation::Native)
        .with_output(&mut output);

    assert!(context.accept_security_context_impl(builder).is_err());
}

#[test]
fn complete_auth_token_fails_on_incorrect_state() {
    let mut context = Ntlm::new();
    context.state = NtlmState::Authenticate;

    assert!(context.complete_auth_token(&mut []).is_err());
}

#[test]
fn complete_auth_token_changes_state() {
    let mut context = Ntlm::new();
    context.flags = NegotiateFlags::NTLM_SSP_NEGOTIATE_KEY_EXCH;
    context.state = NtlmState::Completion;
    context.identity = Some(TEST_CREDENTIALS.clone());
    context.negotiate_message = Some(NegotiateMessage::new(vec![0x01, 0x02, 0x03]));
    context.challenge_message = Some(ChallengeMessage::new(
        vec![0x04, 0x05, 0x06],
        Vec::new(),
        [0x00; CHALLENGE_SIZE],
        0,
    ));
    context.authenticate_message = Some(AuthenticateMessage::new(
        vec![
            0x4e, 0x54, 0x4c, 0x4d, 0x53, 0x53, 0x50, 0x00, 0x03, 0x00, 0x00, 0x00, 0x18, 0x00, 0x18, 0x00, 0x98, 0x00,
            0x00, 0x00, 0x7a, 0x01, 0x7a, 0x01, 0xb0, 0x00, 0x00, 0x00, 0x16, 0x00, 0x16, 0x00, 0x58, 0x00, 0x00, 0x00,
            0x1a, 0x00, 0x1a, 0x00, 0x6e, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00, 0x88, 0x00, 0x00, 0x00, 0x10, 0x00,
            0x10, 0x00, 0x2a, 0x02, 0x00, 0x00, 0x35, 0x82, 0x88, 0xe2, 0x06, 0x01, 0xb0, 0x1d, 0x00, 0x00, 0x00, 0x0f,
            0x12, 0x28, 0x00, 0xa0, 0xb2, 0x29, 0x47, 0x12, 0x1e, 0x8e, 0x54, 0xf8, 0x29, 0xdb, 0x52, 0x1e, 0x41, 0x00,
            0x57, 0x00, 0x41, 0x00, 0x4b, 0x00, 0x45, 0x00, 0x43, 0x00, 0x4f, 0x00, 0x44, 0x00, 0x49, 0x00, 0x4e, 0x00,
            0x47, 0x00, 0x41, 0x00, 0x64, 0x00, 0x6d, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x69, 0x00, 0x73, 0x00, 0x74, 0x00,
            0x72, 0x00, 0x61, 0x00, 0x74, 0x00, 0x6f, 0x00, 0x72, 0x00, 0x57, 0x00, 0x49, 0x00, 0x4e, 0x00, 0x44, 0x00,
            0x4f, 0x00, 0x57, 0x00, 0x53, 0x00, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf5, 0x61, 0x4e, 0x2f,
            0x00, 0xd0, 0x15, 0xb0, 0x70, 0xb0, 0x3e, 0x82, 0x91, 0x5f, 0xc7, 0x08, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x20, 0xfd, 0xae, 0x48, 0x07, 0xcb, 0xcb, 0x01, 0xa5, 0x00, 0x28, 0x29, 0xcd, 0x07, 0xe3, 0xbc,
            0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x16, 0x00, 0x41, 0x00, 0x57, 0x00, 0x41, 0x00, 0x4b, 0x00, 0x45, 0x00,
            0x43, 0x00, 0x4f, 0x00, 0x44, 0x00, 0x49, 0x00, 0x4e, 0x00, 0x47, 0x00, 0x01, 0x00, 0x10, 0x00, 0x57, 0x00,
            0x49, 0x00, 0x4e, 0x00, 0x32, 0x00, 0x4b, 0x00, 0x38, 0x00, 0x52, 0x00, 0x32, 0x00, 0x04, 0x00, 0x24, 0x00,
            0x61, 0x00, 0x77, 0x00, 0x61, 0x00, 0x6b, 0x00, 0x65, 0x00, 0x63, 0x00, 0x6f, 0x00, 0x64, 0x00, 0x69, 0x00,
            0x6e, 0x00, 0x67, 0x00, 0x2e, 0x00, 0x61, 0x00, 0x74, 0x00, 0x68, 0x00, 0x2e, 0x00, 0x63, 0x00, 0x78, 0x00,
            0x03, 0x00, 0x36, 0x00, 0x57, 0x00, 0x49, 0x00, 0x4e, 0x00, 0x32, 0x00, 0x4b, 0x00, 0x38, 0x00, 0x52, 0x00,
            0x32, 0x00, 0x2e, 0x00, 0x61, 0x00, 0x77, 0x00, 0x61, 0x00, 0x6b, 0x00, 0x65, 0x00, 0x63, 0x00, 0x6f, 0x00,
            0x64, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x67, 0x00, 0x2e, 0x00, 0x61, 0x00, 0x74, 0x00, 0x68, 0x00, 0x2e, 0x00,
            0x63, 0x00, 0x78, 0x00, 0x05, 0x00, 0x24, 0x00, 0x61, 0x00, 0x77, 0x00, 0x61, 0x00, 0x6b, 0x00, 0x65, 0x00,
            0x63, 0x00, 0x6f, 0x00, 0x64, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x67, 0x00, 0x2e, 0x00, 0x61, 0x00, 0x74, 0x00,
            0x68, 0x00, 0x2e, 0x00, 0x63, 0x00, 0x78, 0x00, 0x07, 0x00, 0x08, 0x00, 0x20, 0xfd, 0xae, 0x48, 0x07, 0xcb,
            0xcb, 0x01, 0x06, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x30, 0x00, 0x30, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x7b, 0xd0, 0x9e, 0x33, 0x06, 0x75,
            0xe3, 0x3e, 0x52, 0x7b, 0x4a, 0xc4, 0x75, 0x5f, 0x9b, 0x98, 0x26, 0x5d, 0xcb, 0x05, 0x6a, 0x6a, 0xcc, 0x0f,
            0xb8, 0x4f, 0xab, 0x09, 0x22, 0x30, 0x7a, 0x5d, 0x0a, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x2a, 0x00, 0x54, 0x00, 0x45, 0x00,
            0x52, 0x00, 0x4d, 0x00, 0x53, 0x00, 0x52, 0x00, 0x56, 0x00, 0x2f, 0x00, 0x31, 0x00, 0x39, 0x00, 0x32, 0x00,
            0x2e, 0x00, 0x31, 0x00, 0x36, 0x00, 0x38, 0x00, 0x2e, 0x00, 0x31, 0x00, 0x2e, 0x00, 0x31, 0x00, 0x35, 0x00,
            0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x57, 0xc6, 0xb5,
            0x0c, 0x14, 0xc1, 0xf0, 0x64, 0xe7, 0xcc, 0x8b, 0xf0, 0x6d, 0x7a, 0x13,
        ],
        Some(Mic::new(
            [
                0xcf, 0x40, 0x63, 0x95, 0xcf, 0xe2, 0x50, 0x4d, 0xbb, 0x1f, 0x7b, 0x3e, 0x7, 0xd4, 0xb6, 0x49,
            ],
            64,
        )),
        vec![
            0x02, 0x00, 0x16, 0x00, 0x41, 0x00, 0x57, 0x00, 0x41, 0x00, 0x4b, 0x00, 0x45, 0x00, 0x43, 0x00, 0x4f, 0x00,
            0x44, 0x00, 0x49, 0x00, 0x4e, 0x00, 0x47, 0x00, 0x01, 0x00, 0x10, 0x00, 0x57, 0x00, 0x49, 0x00, 0x4e, 0x00,
            0x32, 0x00, 0x4b, 0x00, 0x38, 0x00, 0x52, 0x00, 0x32, 0x00, 0x04, 0x00, 0x24, 0x00, 0x61, 0x00, 0x77, 0x00,
            0x61, 0x00, 0x6b, 0x00, 0x65, 0x00, 0x63, 0x00, 0x6f, 0x00, 0x64, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x67, 0x00,
            0x2e, 0x00, 0x61, 0x00, 0x74, 0x00, 0x68, 0x00, 0x2e, 0x00, 0x63, 0x00, 0x78, 0x00, 0x03, 0x00, 0x36, 0x00,
            0x57, 0x00, 0x49, 0x00, 0x4e, 0x00, 0x32, 0x00, 0x4b, 0x00, 0x38, 0x00, 0x52, 0x00, 0x32, 0x00, 0x2e, 0x00,
            0x61, 0x00, 0x77, 0x00, 0x61, 0x00, 0x6b, 0x00, 0x65, 0x00, 0x63, 0x00, 0x6f, 0x00, 0x64, 0x00, 0x69, 0x00,
            0x6e, 0x00, 0x67, 0x00, 0x2e, 0x00, 0x61, 0x00, 0x74, 0x00, 0x68, 0x00, 0x2e, 0x00, 0x63, 0x00, 0x78, 0x00,
            0x05, 0x00, 0x24, 0x00, 0x61, 0x00, 0x77, 0x00, 0x61, 0x00, 0x6b, 0x00, 0x65, 0x00, 0x63, 0x00, 0x6f, 0x00,
            0x64, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x67, 0x00, 0x2e, 0x00, 0x61, 0x00, 0x74, 0x00, 0x68, 0x00, 0x2e, 0x00,
            0x63, 0x00, 0x78, 0x00, 0x07, 0x00, 0x08, 0x00, 0x20, 0xfd, 0xae, 0x48, 0x07, 0xcb, 0xcb, 0x01, 0x06, 0x00,
            0x04, 0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x30, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x01, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x7b, 0xd0, 0x9e, 0x33, 0x06, 0x75, 0xe3, 0x3e, 0x52, 0x7b,
            0x4a, 0xc4, 0x75, 0x5f, 0x9b, 0x98, 0x26, 0x5d, 0xcb, 0x05, 0x6a, 0x6a, 0xcc, 0x0f, 0xb8, 0x4f, 0xab, 0x09,
            0x22, 0x30, 0x7a, 0x5d, 0x0a, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x2a, 0x00, 0x54, 0x00, 0x45, 0x00, 0x52, 0x00, 0x4d, 0x00,
            0x53, 0x00, 0x52, 0x00, 0x56, 0x00, 0x2f, 0x00, 0x31, 0x00, 0x39, 0x00, 0x32, 0x00, 0x2e, 0x00, 0x31, 0x00,
            0x36, 0x00, 0x38, 0x00, 0x2e, 0x00, 0x31, 0x00, 0x2e, 0x00, 0x31, 0x00, 0x35, 0x00, 0x30, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ],
        [0xa5, 0x00, 0x28, 0x29, 0xcd, 0x07, 0xe3, 0xbc],
        Some([
            0x0c, 0x57, 0xc6, 0xb5, 0x0c, 0x14, 0xc1, 0xf0, 0x64, 0xe7, 0xcc, 0x8b, 0xf0, 0x6d, 0x7a, 0x13,
        ]),
    ));

    context.complete_auth_token(&mut []).unwrap();
    assert_eq!(context.state, NtlmState::Final);
}


--- File: src/pk_init.rs ---
use oid::ObjectIdentifier;
use picky_asn1::bit_string::BitString;
use picky_asn1::date::GeneralizedTime;
use picky_asn1::wrapper::{
    Asn1SequenceOf, Asn1SetOf, BitStringAsn1, ExplicitContextTag0, ExplicitContextTag1, ExplicitContextTag2,
    ExplicitContextTag3, ImplicitContextTag0, IntegerAsn1, ObjectIdentifierAsn1, OctetStringAsn1, Optional,
};
use picky_asn1_der::Asn1RawDer;
use picky_asn1_x509::cmsversion::CmsVersion;
use picky_asn1_x509::content_info::{ContentValue, EncapsulatedContentInfo};
use picky_asn1_x509::oids::PKINIT_DH_KEY_DATA;
use picky_asn1_x509::signed_data::{
    CertificateChoices, CertificateSet, DigestAlgorithmIdentifiers, SignedData, SignersInfos,
};
use picky_asn1_x509::signer_info::{
    Attributes, CertificateSerialNumber, DigestAlgorithmIdentifier, IssuerAndSerialNumber,
    SignatureAlgorithmIdentifier, SignatureValue, SignerIdentifier, SignerInfo, UnsignedAttributes,
};
use picky_asn1_x509::{oids, AlgorithmIdentifier, Attribute, AttributeValues, Certificate, ShaVariant};
use picky_krb::constants::types::{PA_PAC_REQUEST_TYPE, PA_PK_AS_REQ};
use picky_krb::crypto::diffie_hellman::compute_public_key;
use picky_krb::data_types::{KerbPaPacRequest, KerberosTime, PaData};
use picky_krb::messages::KdcReqBody;
use picky_krb::pkinit::{
    AuthPack, DhDomainParameters, DhReqInfo, DhReqKeyInfo, KdcDhKeyInfo, PaPkAsReq, PkAuthenticator,
};
use serde::{Deserialize, Serialize};
use sha1::{Digest, Sha1};
use time::OffsetDateTime;

use crate::kerberos::client::generators::MAX_MICROSECONDS;
use crate::{Error, ErrorKind, Result};

/// [Generation of Client Request](https://www.rfc-editor.org/rfc/rfc4556.html#section-3.2.1)
/// 9. This nonce string MUST be as long as the longest key length of the symmetric key types that the client supports.
/// Key length of Aes256 is equal to 32
pub const DH_NONCE_LEN: usize = 32;

#[derive(Debug, Clone)]
pub struct DhParameters {
    // g
    pub base: Vec<u8>,
    // p
    pub modulus: Vec<u8>,
    //
    pub q: Vec<u8>,
    // generated private key
    pub private_key: Vec<u8>,
    // received public key
    pub other_public_key: Option<Vec<u8>>,
    pub client_nonce: Option<[u8; DH_NONCE_LEN]>,
    pub server_nonce: Option<[u8; DH_NONCE_LEN]>,
}

// PA_DATAs in the Kerberos smart card logon is packed into a wrapper with OID.
// It's very similar to the `EncapsulatedContentInfo` structure, but the content field has another type.
#[derive(Serialize, Deserialize)]
pub struct Wrapper<T> {
    pub content_info: ObjectIdentifierAsn1,
    pub content: ExplicitContextTag0<T>,
}

pub type SignDataFn = Box<dyn Fn(&[u8]) -> Result<Vec<u8>> + Send>;

pub struct GenerateAsPaDataOptions<'a> {
    pub p2p_cert: Certificate,
    pub kdc_req_body: &'a KdcReqBody,
    pub dh_parameters: DhParameters,
    pub sign_data: SignDataFn,
    pub with_pre_auth: bool,
    pub authenticator_nonce: [u8; 4],
}

#[instrument(level = "trace", skip_all, ret)]
pub fn generate_pa_datas_for_as_req(options: &GenerateAsPaDataOptions<'_>) -> Result<Vec<PaData>> {
    let GenerateAsPaDataOptions {
        p2p_cert,
        kdc_req_body,
        dh_parameters,
        sign_data,
        with_pre_auth,
        authenticator_nonce,
    } = options;

    if !with_pre_auth {
        return Ok(vec![
            PaData {
                padata_type: ExplicitContextTag1::from(IntegerAsn1::from(vec![0x00, 0x96])),
                padata_data: ExplicitContextTag2::from(OctetStringAsn1::from(Vec::new())),
            },
            PaData {
                padata_type: ExplicitContextTag1::from(IntegerAsn1::from(PA_PAC_REQUEST_TYPE.to_vec())),
                padata_data: ExplicitContextTag2::from(OctetStringAsn1::from(picky_asn1_der::to_vec(
                    &KerbPaPacRequest {
                        include_pac: ExplicitContextTag0::from(true),
                    },
                )?)),
            },
        ]);
    }

    let current_date = OffsetDateTime::now_utc();
    let mut microseconds = current_date.microsecond();
    if microseconds > MAX_MICROSECONDS {
        microseconds = MAX_MICROSECONDS;
    }

    // [Generation of Client Request](https://www.rfc-editor.org/rfc/rfc4556.html#section-3.2.1)
    // paChecksum: Contains the SHA1 checksum, performed over KDC-REQ-BODY.
    let encoded_kdc_req_body = picky_asn1_der::to_vec(&kdc_req_body)?;
    trace!(?kdc_req_body, "Encoded KdcReqBody");

    let mut sha1 = Sha1::new();
    sha1.update(&encoded_kdc_req_body);

    let kdc_req_body_sha1_hash = sha1.finalize().to_vec();

    let public_value = compute_public_key(&dh_parameters.private_key, &dh_parameters.modulus, &dh_parameters.base);

    let auth_pack = AuthPack {
        pk_authenticator: ExplicitContextTag0::from(PkAuthenticator {
            cusec: ExplicitContextTag0::from(IntegerAsn1::from(microseconds.to_be_bytes().to_vec())),
            ctime: ExplicitContextTag1::from(KerberosTime::from(GeneralizedTime::from(current_date))),
            nonce: ExplicitContextTag2::from(IntegerAsn1::from(authenticator_nonce.to_vec())),
            pa_checksum: Optional::from(Some(ExplicitContextTag3::from(OctetStringAsn1::from(
                kdc_req_body_sha1_hash,
            )))),
        }),
        client_public_value: Optional::from(Some(ExplicitContextTag1::from(DhReqInfo {
            key_info: DhReqKeyInfo {
                identifier: ObjectIdentifierAsn1::from(oids::diffie_hellman()),
                key_info: DhDomainParameters {
                    p: IntegerAsn1::from(dh_parameters.modulus.clone()),
                    g: IntegerAsn1::from(dh_parameters.base.clone()),
                    q: IntegerAsn1::from(dh_parameters.q.clone()),
                    j: Optional::from(None),
                    validation_params: Optional::from(None),
                },
            },
            key_value: BitStringAsn1::from(BitString::with_bytes(picky_asn1_der::to_vec(&IntegerAsn1::from(
                public_value,
            ))?)),
        }))),
        supported_cms_types: Optional::from(Some(ExplicitContextTag2::from(Asn1SequenceOf::from(Vec::new())))),
        client_dh_nonce: Optional::from(
            dh_parameters
                .client_nonce
                .as_ref()
                .map(|nonce| ExplicitContextTag3::from(OctetStringAsn1::from(nonce.to_vec()))),
        ),
    };

    let encoded_auth_pack = picky_asn1_der::to_vec(&auth_pack)?;
    trace!(?encoded_auth_pack, "Encoded auth pack");

    let mut sha1 = Sha1::new();
    sha1.update(&encoded_auth_pack);

    let digest = sha1.finalize().to_vec();

    let signed_data = SignedData {
        version: CmsVersion::V3,
        digest_algorithms: DigestAlgorithmIdentifiers(Asn1SetOf::from(vec![AlgorithmIdentifier::new_sha1()])),
        content_info: EncapsulatedContentInfo::new(oids::pkinit_auth_data(), Some(encoded_auth_pack)),
        certificates: Optional::from(CertificateSet(vec![CertificateChoices::Certificate(Asn1RawDer(
            picky_asn1_der::to_vec(p2p_cert)?,
        ))])),
        crls: None,
        signers_infos: SignersInfos(Asn1SetOf::from(vec![generate_signer_info(
            p2p_cert, digest, sign_data,
        )?])),
    };

    let e = Wrapper {
        content_info: ObjectIdentifierAsn1::from(oids::signed_data()),
        content: ExplicitContextTag0::from(signed_data),
    };

    let pa_pk_as_req = PaPkAsReq {
        signed_auth_pack: ImplicitContextTag0::from(OctetStringAsn1::from(picky_asn1_der::to_vec(&e)?)),
        trusted_certifiers: Optional::from(None),
        kdc_pk_id: Optional::from(None),
    };

    Ok(vec![
        PaData {
            padata_type: ExplicitContextTag1::from(IntegerAsn1::from(PA_PK_AS_REQ.to_vec())),
            padata_data: ExplicitContextTag2::from(OctetStringAsn1::from(picky_asn1_der::to_vec(&pa_pk_as_req)?)),
        },
        PaData {
            padata_type: ExplicitContextTag1::from(IntegerAsn1::from(vec![0x12])),
            padata_data: ExplicitContextTag2::from(OctetStringAsn1::from(Vec::new())),
        },
        PaData {
            padata_type: ExplicitContextTag1::from(IntegerAsn1::from(PA_PAC_REQUEST_TYPE.to_vec())),
            padata_data: ExplicitContextTag2::from(OctetStringAsn1::from(picky_asn1_der::to_vec(&KerbPaPacRequest {
                include_pac: ExplicitContextTag0::from(true),
            })?)),
        },
    ])
}

pub fn generate_signer_info(
    p2p_cert: &Certificate,
    digest: Vec<u8>,
    sign_data: &dyn Fn(&[u8]) -> Result<Vec<u8>>,
) -> Result<SignerInfo> {
    let signed_attributes = Asn1SetOf::from(vec![
        Attribute {
            ty: ObjectIdentifierAsn1::from(oids::content_type()),
            value: AttributeValues::ContentType(Asn1SetOf::from(vec![ObjectIdentifierAsn1::from(
                oids::pkinit_auth_data(),
            )])),
        },
        Attribute {
            ty: ObjectIdentifierAsn1::from(oids::message_digest()),
            value: AttributeValues::MessageDigest(Asn1SetOf::from(vec![OctetStringAsn1::from(digest)])),
        },
    ]);

    let encoded_signed_attributes = picky_asn1_der::to_vec(&signed_attributes)?;

    let signature = sign_data(&encoded_signed_attributes)?;

    trace!(?encoded_signed_attributes, ?signature, "Signed attributes",);

    Ok(SignerInfo {
        version: CmsVersion::V1,
        sid: SignerIdentifier::IssuerAndSerialNumber(IssuerAndSerialNumber {
            issuer: p2p_cert.tbs_certificate.issuer.clone(),
            serial_number: CertificateSerialNumber(p2p_cert.tbs_certificate.serial_number.clone()),
        }),
        digest_algorithm: DigestAlgorithmIdentifier(AlgorithmIdentifier::new_sha(ShaVariant::SHA1)),
        signed_attrs: Optional::from(Attributes(Asn1SequenceOf::from(signed_attributes.0))),
        signature_algorithm: SignatureAlgorithmIdentifier(AlgorithmIdentifier::new_rsa_encryption()),
        signature: SignatureValue(OctetStringAsn1::from(signature)),
        unsigned_attrs: Optional::from(UnsignedAttributes(Vec::new())),
    })
}

#[instrument(level = "trace", ret)]
pub fn extract_server_dh_public_key(signed_data: &SignedData) -> Result<Vec<u8>> {
    let pkinit_dh_key_data = ObjectIdentifier::try_from(PKINIT_DH_KEY_DATA).unwrap();
    if signed_data.content_info.content_type.0 != pkinit_dh_key_data {
        return Err(Error::new(
            ErrorKind::InvalidToken,
            format!(
                "Invalid content info identifier: {:?}. Expected: {:?}",
                signed_data.content_info.content_type.0, pkinit_dh_key_data
            ),
        ));
    }

    let dh_key_info_data = match &signed_data
        .content_info
        .content
        .as_ref()
        .ok_or_else(|| Error::new(ErrorKind::InvalidToken, "content info is not present"))?
        .0
    {
        ContentValue::OctetString(data) => &data.0,
        content_value => {
            error!(
                ?content_value,
                "The server has sent KDC DH key info in unsupported format. Only ContentValue::OctetString is supported",
            );

            return Err(Error::new(ErrorKind::InvalidToken, "unexpected content info"));
        }
    };

    let dh_key_info: KdcDhKeyInfo = picky_asn1_der::from_bytes(dh_key_info_data)?;

    let key: IntegerAsn1 = picky_asn1_der::from_bytes(dh_key_info.subject_public_key.0.payload_view())?;

    Ok(key.as_unsigned_bytes_be().to_vec())
}

#[cfg(test)]
mod tests {
    use picky_asn1::wrapper::{Asn1SetOf, ObjectIdentifierAsn1, OctetStringAsn1};
    use picky_asn1_x509::{oids, Attribute, AttributeValues};

    #[test]
    fn signing() {
        let digest = vec![
            22, 144, 59, 22, 68, 47, 213, 64, 69, 126, 237, 38, 151, 109, 213, 92, 122, 198, 202, 21,
        ];
        let signed_attributes = Asn1SetOf::from(vec![
            Attribute {
                ty: ObjectIdentifierAsn1::from(oids::content_type()),
                value: AttributeValues::ContentType(Asn1SetOf::from(vec![ObjectIdentifierAsn1::from(
                    oids::pkinit_auth_data(),
                )])),
            },
            Attribute {
                ty: ObjectIdentifierAsn1::from(oids::message_digest()),
                value: AttributeValues::MessageDigest(Asn1SetOf::from(vec![OctetStringAsn1::from(digest)])),
            },
        ]);
        let encoded_signed_attributes = picky_asn1_der::to_vec(&signed_attributes).unwrap();
        println!("{:?}", encoded_signed_attributes);
    }
}


--- File: src/pku2u/cert_utils/mod.rs ---
pub mod validation;
#[cfg(target_os = "windows")]
pub mod win_extraction;

#[cfg(target_os = "windows")]
pub use win_extraction as extraction;


--- File: src/pku2u/cert_utils/validation.rs ---
use num_bigint_dig::BigUint;
use picky::key::PublicKey as RsaPublicKey;
use picky_asn1_x509::signed_data::{CertificateChoices, SignedData};
use picky_asn1_x509::{Certificate, PublicKey};

use crate::{Error, ErrorKind, Result};

/// validates server's p2p certificate.
/// If certificate is valid then return its public key.
#[instrument(level = "trace", ret)]
pub fn validate_server_p2p_certificate(signed_data: &SignedData) -> Result<RsaPublicKey> {
    let certificates = &signed_data.certificates.0 .0;

    if let Some(certificate) = certificates.iter().next() {
        let cert: Certificate = match certificate {
            CertificateChoices::Certificate(cert) => picky_asn1_der::from_bytes(&cert.0)?,
            cert => {
                error!(?cert, "Server sent unsupported certificate format");

                return Err(Error::new(
                    ErrorKind::Pku2uCertFailure,
                    "Received unknown certificate format",
                ));
            }
        };

        let public_key = match cert.tbs_certificate.subject_public_key_info.subject_public_key {
            PublicKey::Rsa(rsa) => rsa,
            public_key => {
                error!(
                    ?public_key,
                    "Server sent unsupported public key type. Only RSA keys supported",
                );

                return Err(Error::new(
                    ErrorKind::Pku2uCertFailure,
                    "Received certificate has unsupported public key type. Only RSA is supported",
                ));
            }
        }
        .0;

        return Ok(RsaPublicKey::from_rsa_components(
            &BigUint::from_bytes_be(&public_key.modulus.0),
            &BigUint::from_bytes_be(&public_key.public_exponent.0),
        ));
    }

    Err(Error::new(
        ErrorKind::Pku2uCertFailure,
        "Received invalid server certificates",
    ))
}


--- File: src/pku2u/cert_utils/win_extraction.rs ---
use std::ffi::c_void;
use std::io::Read;
use std::ptr::{null, null_mut};
use std::slice::from_raw_parts;

use byteorder::{LittleEndian, ReadBytesExt};
use num_bigint_dig::BigUint;
use picky::key::PrivateKey;
use picky_asn1_x509::{oids, AttributeTypeAndValueParameters, Certificate, ExtensionView};
use windows_sys::Win32::Foundation;
use windows_sys::Win32::Security::Cryptography::{
    CertCloseStore, CertEnumCertificatesInStore, CertFreeCertificateContext, CertOpenStore,
    CryptAcquireCertificatePrivateKey, NCryptExportKey, NCryptFreeObject, BCRYPT_RSAFULLPRIVATE_BLOB,
    BCRYPT_RSAFULLPRIVATE_MAGIC, CERT_CONTEXT, CERT_KEY_SPEC, CERT_STORE_PROV_SYSTEM_W,
    CERT_SYSTEM_STORE_CURRENT_USER_ID, CERT_SYSTEM_STORE_LOCATION_SHIFT, CRYPT_ACQUIRE_ONLY_NCRYPT_KEY_FLAG,
    HCRYPTPROV_OR_NCRYPT_KEY_HANDLE,
};

use crate::{Error, ErrorKind, Result};

/// [BCRYPT_RSAKEY_BLOB](https://learn.microsoft.com/en-us/windows/win32/api/bcrypt/ns-bcrypt-bcrypt_rsakey_blob)
/// ```not_rust
/// typedef struct _BCRYPT_RSAKEY_BLOB {
///   ULONG Magic;
///   ULONG BitLength;
///   ULONG cbPublicExp;
///   ULONG cbModulus;
///   ULONG cbPrime1;
///   ULONG cbPrime2;
/// } BCRYPT_RSAKEY_BLOB;
/// ```
#[derive(Debug)]
struct BcryptRsaKeyBlob {
    pub magic: u32,
    pub bit_len: u32,
    pub public_exp: u32,
    pub modulus: u32,
    pub prime1: u32,
    pub prime2: u32,
}

impl BcryptRsaKeyBlob {
    pub fn from_read(mut data: impl Read) -> Result<Self> {
        Ok(Self {
            magic: data.read_u32::<LittleEndian>()?,
            bit_len: data.read_u32::<LittleEndian>()?,
            public_exp: data.read_u32::<LittleEndian>()?,
            modulus: data.read_u32::<LittleEndian>()?,
            prime1: data.read_u32::<LittleEndian>()?,
            prime2: data.read_u32::<LittleEndian>()?,
        })
    }
}

fn decode_private_key(mut buffer: impl Read) -> Result<PrivateKey> {
    let rsa_key_blob = BcryptRsaKeyBlob::from_read(&mut buffer)?;

    if rsa_key_blob.magic != BCRYPT_RSAFULLPRIVATE_MAGIC {
        debug!(
            expected = BCRYPT_RSAFULLPRIVATE_MAGIC,
            actual = rsa_key_blob.magic,
            "Invalid RSA key blob magic",
        );

        return Err(Error::new(
            ErrorKind::InternalError,
            "Cannot extract certificate private key: invalid key blob magic",
        ));
    }

    let mut public_exp = vec![0; rsa_key_blob.public_exp as usize];
    buffer.read_exact(&mut public_exp)?;

    let mut modulus = vec![0; rsa_key_blob.modulus as usize];
    buffer.read_exact(&mut modulus)?;

    let mut prime1 = vec![0; rsa_key_blob.prime1 as usize];
    buffer.read_exact(&mut prime1)?;

    let mut prime2 = vec![0; rsa_key_blob.prime2 as usize];
    buffer.read_exact(&mut prime2)?;

    let mut exp = vec![0; rsa_key_blob.prime1 as usize];
    buffer.read_exact(&mut exp)?;

    let mut exp = vec![0; rsa_key_blob.prime2 as usize];
    buffer.read_exact(&mut exp)?;

    let mut coef = vec![0; rsa_key_blob.prime1 as usize];
    buffer.read_exact(&mut coef)?;

    let mut private_exp = vec![0; (rsa_key_blob.bit_len / 8) as usize];
    buffer.read_exact(&mut private_exp)?;

    debug!("RSA private key components are decoded successfully");

    let rsa_private_key = PrivateKey::from_rsa_components(
        &BigUint::from_bytes_be(&modulus),
        &BigUint::from_bytes_be(&public_exp),
        &BigUint::from_bytes_be(&private_exp),
        &[BigUint::from_bytes_be(&prime1), BigUint::from_bytes_be(&prime2)],
    )
    .map_err(|err| {
        Error::new(
            ErrorKind::InternalError,
            format!("Can not create a private from components: {:?}", err),
        )
    })?;

    Ok(rsa_private_key)
}

/// Validates the device certificate
/// Requirements for the device certificate:
/// 1. Issuer CN starts with 'MS-Organization-P2P-Access'
/// 2. ClientAuth extended key usage present
fn validate_client_p2p_certificate(certificate: &Certificate) -> bool {
    let mut cn = false;

    for attr_type_and_value in certificate.tbs_certificate.issuer.0 .0.iter() {
        for v in attr_type_and_value.0.iter() {
            if v.ty.0 == oids::at_common_name() {
                if let AttributeTypeAndValueParameters::CommonName(name) = &v.value {
                    if name.to_utf8_lossy().starts_with("MS-Organization-P2P-Access") {
                        cn = true;
                    }
                }
            }
        }
    }

    if !cn {
        return false;
    }

    let mut client_auth = false;

    for extension in &certificate.tbs_certificate.extensions.0 .0 {
        if extension.extn_id().0 == oids::extended_key_usage() {
            if let ExtensionView::ExtendedKeyUsage(ext_key_usage) = extension.extn_value() {
                if ext_key_usage.contains(oids::kp_client_auth()) {
                    client_auth = true;
                }
            }
        }
    }

    client_auth
}

unsafe fn export_certificate_private_key(cert: *const CERT_CONTEXT) -> Result<PrivateKey> {
    let mut private_key_handle = HCRYPTPROV_OR_NCRYPT_KEY_HANDLE::default();
    let mut spec = CERT_KEY_SPEC::default();
    let mut free = windows_sys::core::BOOL::default();

    let status = CryptAcquireCertificatePrivateKey(
        cert,
        CRYPT_ACQUIRE_ONLY_NCRYPT_KEY_FLAG,
        null_mut(),
        &mut private_key_handle,
        &mut spec,
        &mut free,
    );

    if status == 0 || private_key_handle == 0 {
        error!(
            ?status,
            private_key_handle, "Cannot acquire certificate private key handle",
        );

        return Err(Error::new(
            ErrorKind::InvalidHandle,
            "Cannot extract certificate private key: invalid handle",
        ));
    }

    let mut private_key_buffer_len = 0;

    // The first call need to determine the size of the needed buffer for the private key
    // https://learn.microsoft.com/en-us/windows/win32/api/ncrypt/nf-ncrypt-ncryptexportkey
    // If pbOutput parameter is NULL, this function will place the required size in the pcbResult parameter.
    let status = NCryptExportKey(
        private_key_handle as _,
        0,
        BCRYPT_RSAFULLPRIVATE_BLOB,
        null(),
        null_mut::<u8>(),
        0,
        &mut private_key_buffer_len,
        0,
    );

    if status != 0 {
        NCryptFreeObject(private_key_handle);

        return match status {
            Foundation::NTE_BAD_TYPE => Err(Error::new(
                ErrorKind::InvalidParameter,
                format!(
                    "Cannot extract certificate private key: provided key cannot be exported into the specified BLOB type: {:x?}",
                    status
                ),
            )),
            Foundation::NTE_INVALID_HANDLE => Err(Error::new(
                ErrorKind::InvalidHandle,
                format!(
                    "Cannot extract certificate private key: key or export key handle is invalid: {:x?}",
                    status
                ),
            )),
            Foundation::NTE_INVALID_PARAMETER => Err(Error::new(
                ErrorKind::InvalidParameter,
                format!(
                    "Cannot extract certificate private key: invalid parameter: {:x?}",
                    status
                ),
            )),
            _ => Err(Error::new(
                ErrorKind::InternalError,
                format!(
                    "Cannot extract certificate private key: unsuccessful extraction: {:x?}",
                    status
                ),
            )),
        };
    }

    let mut private_key_blob = vec![0; private_key_buffer_len as usize];

    let status = NCryptExportKey(
        private_key_handle as _,
        0,
        BCRYPT_RSAFULLPRIVATE_BLOB,
        null(),
        private_key_blob.as_mut_ptr(),
        private_key_blob.len() as _,
        &mut private_key_buffer_len,
        0,
    );

    NCryptFreeObject(private_key_handle);

    if status != 0 {
        return match status {
            Foundation::NTE_BAD_TYPE => Err(Error::new(
                ErrorKind::InvalidParameter,
                format!(
                    "Cannot extract certificate private key: provided key cannot be exported into the specified BLOB type: {:x?}",
                    status
                ),
            )),
            Foundation::NTE_INVALID_HANDLE => Err(Error::new(
                ErrorKind::InvalidHandle,
                format!(
                    "Cannot extract certificate private key: key or export key handle is invalid: {:x?}",
                    status
                ),
            )),
            Foundation::NTE_INVALID_PARAMETER => Err(Error::new(
                ErrorKind::InvalidParameter,
                format!(
                    "Cannot extract certificate private key: invalid parameter: {:x?}",
                    status
                ),
            )),
            _ => Err(Error::new(
                ErrorKind::InternalError,
                format!(
                    "Cannot extract certificate private key: unsuccessful extraction: {:x?}",
                    status
                ),
            )),
        };
    }

    debug!("The certificate private key exported");

    let private_key = decode_private_key(&private_key_blob[0..private_key_buffer_len as usize])?;

    Ok(private_key)
}

unsafe fn extract_client_p2p_certificate(cert_store: *mut c_void) -> Result<(Certificate, PrivateKey)> {
    let mut certificate = CertEnumCertificatesInStore(cert_store, null_mut());

    while !certificate.is_null() {
        let cert_der = from_raw_parts((*certificate).pbCertEncoded, (*certificate).cbCertEncoded as usize);
        let cert: Certificate = picky_asn1_der::from_bytes(cert_der)?;

        if !validate_client_p2p_certificate(&cert) {
            let next_certificate = CertEnumCertificatesInStore(cert_store, certificate);

            certificate = next_certificate;

            continue;
        }

        debug!(
            serial_number = ?cert.tbs_certificate.serial_number.0,
            "Found suitable client p2p certificate",
        );

        let private_key = export_certificate_private_key(certificate);

        CertFreeCertificateContext(certificate);

        return Ok((cert, private_key?));
    }

    Err(Error::new(
        ErrorKind::InternalError,
        "Cannot find appropriate device certificate",
    ))
}

// There is no specification/documentation that said where the P2P certificates should be installed.
// During dev testing, we notice that they always are in the Personal folder.
// So we assume that the needed certificates are placed in this folder
// It uses the "My" certificates store that has access to the Personal folder in order to extract those certificates.
pub fn extract_client_p2p_cert_and_key() -> Result<(Certificate, PrivateKey)> {
    unsafe {
        // "My\0" encoded as a wide string.
        // More info: https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-certopenstore#remarks
        let my: [u16; 3] = [77, 121, 0];
        let cert_store = CertOpenStore(
            CERT_STORE_PROV_SYSTEM_W,
            0,
            0,
            CERT_SYSTEM_STORE_CURRENT_USER_ID << CERT_SYSTEM_STORE_LOCATION_SHIFT,
            my.as_ptr() as *const _,
        );

        if cert_store.is_null() {
            return Err(Error::new(
                ErrorKind::InternalError,
                "Cannot initialize certificate store: permission denied",
            ));
        }

        let cert_and_key = extract_client_p2p_certificate(cert_store);

        CertCloseStore(cert_store, 0);

        cert_and_key
    }
}

#[cfg(test)]
mod tests {
    use picky_asn1_x509::Certificate;

    use super::validate_client_p2p_certificate;

    #[test]
    fn test_client_p2p_certificate_validation() {
        let certificate: Certificate = picky_asn1_der::from_bytes(&[
            48, 130, 3, 213, 48, 130, 2, 189, 160, 3, 2, 1, 2, 2, 16, 51, 247, 184, 98, 224, 162, 21, 50, 174, 177,
            189, 96, 58, 124, 107, 164, 48, 13, 6, 9, 42, 134, 72, 134, 247, 13, 1, 1, 11, 5, 0, 48, 77, 49, 75, 48,
            73, 6, 3, 85, 4, 3, 30, 66, 0, 77, 0, 83, 0, 45, 0, 79, 0, 114, 0, 103, 0, 97, 0, 110, 0, 105, 0, 122, 0,
            97, 0, 116, 0, 105, 0, 111, 0, 110, 0, 45, 0, 80, 0, 50, 0, 80, 0, 45, 0, 65, 0, 99, 0, 99, 0, 101, 0, 115,
            0, 115, 0, 32, 0, 91, 0, 50, 0, 48, 0, 50, 0, 50, 0, 93, 48, 30, 23, 13, 50, 50, 49, 48, 50, 54, 49, 51,
            50, 51, 53, 56, 90, 23, 13, 50, 50, 49, 48, 50, 54, 49, 52, 50, 56, 53, 56, 90, 48, 129, 142, 49, 52, 48,
            50, 6, 10, 9, 146, 38, 137, 147, 242, 44, 100, 1, 25, 22, 36, 97, 57, 50, 53, 50, 52, 52, 56, 45, 57, 97,
            98, 55, 45, 52, 57, 98, 48, 45, 98, 98, 53, 99, 45, 102, 50, 102, 57, 50, 51, 99, 56, 52, 54, 55, 50, 49,
            61, 48, 59, 6, 3, 85, 4, 3, 12, 52, 83, 45, 49, 45, 49, 50, 45, 49, 45, 51, 54, 53, 51, 50, 49, 49, 48, 50,
            50, 45, 49, 51, 51, 57, 48, 48, 54, 52, 50, 50, 45, 50, 54, 50, 55, 53, 55, 51, 57, 48, 48, 45, 49, 53, 54,
            48, 55, 51, 52, 57, 49, 57, 49, 23, 48, 21, 6, 3, 85, 4, 3, 12, 14, 115, 55, 64, 100, 97, 116, 97, 97, 110,
            115, 46, 99, 111, 109, 48, 130, 1, 34, 48, 13, 6, 9, 42, 134, 72, 134, 247, 13, 1, 1, 1, 5, 0, 3, 130, 1,
            15, 0, 48, 130, 1, 10, 2, 130, 1, 1, 0, 199, 60, 253, 49, 157, 172, 15, 185, 180, 104, 241, 218, 22, 185,
            120, 213, 135, 223, 222, 100, 75, 148, 218, 177, 71, 131, 140, 8, 195, 173, 7, 244, 41, 200, 45, 77, 173,
            68, 205, 213, 27, 72, 246, 147, 167, 184, 52, 81, 44, 28, 143, 238, 201, 186, 143, 111, 62, 224, 73, 86,
            69, 249, 239, 44, 79, 115, 37, 185, 243, 1, 23, 234, 116, 28, 244, 221, 99, 62, 177, 39, 128, 239, 115, 47,
            184, 135, 25, 43, 109, 246, 200, 11, 116, 38, 99, 167, 136, 48, 59, 187, 188, 40, 216, 85, 133, 246, 5,
            130, 177, 220, 6, 210, 34, 164, 15, 207, 125, 223, 42, 190, 77, 109, 69, 224, 132, 147, 115, 110, 39, 205,
            112, 140, 44, 215, 43, 252, 206, 89, 55, 161, 210, 166, 234, 223, 0, 198, 24, 70, 158, 56, 78, 23, 76, 249,
            86, 198, 95, 207, 53, 220, 75, 246, 91, 138, 99, 193, 186, 97, 57, 207, 115, 14, 1, 251, 111, 180, 121, 41,
            132, 254, 82, 109, 66, 202, 11, 20, 14, 31, 242, 55, 225, 112, 210, 220, 229, 155, 152, 202, 92, 54, 223,
            38, 153, 248, 173, 168, 180, 70, 146, 219, 186, 166, 251, 234, 149, 41, 18, 61, 227, 148, 13, 141, 229, 1,
            49, 212, 128, 67, 225, 120, 7, 122, 41, 102, 241, 223, 249, 198, 117, 89, 37, 177, 142, 85, 24, 136, 230,
            160, 136, 43, 89, 66, 41, 220, 85, 85, 2, 3, 1, 0, 1, 163, 111, 48, 109, 48, 14, 6, 3, 85, 29, 15, 1, 1,
            255, 4, 4, 3, 2, 5, 160, 48, 41, 6, 3, 85, 29, 17, 4, 34, 48, 32, 160, 30, 6, 10, 43, 6, 1, 4, 1, 130, 55,
            20, 2, 3, 160, 16, 12, 14, 115, 55, 64, 100, 97, 116, 97, 97, 110, 115, 46, 99, 111, 109, 48, 19, 6, 3, 85,
            29, 37, 4, 12, 48, 10, 6, 8, 43, 6, 1, 5, 5, 7, 3, 2, 48, 27, 6, 9, 43, 6, 1, 4, 1, 130, 55, 21, 10, 4, 14,
            48, 12, 48, 10, 6, 8, 43, 6, 1, 5, 5, 7, 3, 2, 48, 13, 6, 9, 42, 134, 72, 134, 247, 13, 1, 1, 11, 5, 0, 3,
            130, 1, 1, 0, 71, 217, 65, 65, 121, 161, 60, 132, 114, 210, 31, 169, 34, 170, 87, 169, 50, 137, 52, 187,
            116, 98, 61, 8, 255, 89, 197, 131, 73, 33, 17, 136, 188, 42, 180, 22, 239, 101, 126, 28, 138, 35, 108, 101,
            138, 50, 54, 5, 105, 17, 85, 172, 239, 78, 21, 202, 246, 237, 51, 210, 17, 184, 39, 190, 135, 109, 73, 210,
            243, 138, 142, 72, 67, 206, 58, 129, 133, 215, 161, 103, 57, 97, 99, 131, 85, 45, 160, 129, 144, 5, 184,
            191, 7, 114, 24, 7, 237, 81, 246, 242, 94, 232, 161, 230, 108, 97, 184, 185, 182, 200, 178, 44, 7, 76, 10,
            47, 156, 88, 110, 198, 193, 125, 190, 84, 225, 93, 53, 87, 183, 14, 49, 118, 233, 217, 171, 139, 75, 131,
            8, 222, 241, 87, 3, 146, 243, 55, 69, 62, 204, 146, 92, 118, 241, 104, 209, 178, 228, 246, 199, 220, 104,
            32, 189, 125, 84, 82, 250, 215, 218, 10, 9, 21, 185, 251, 180, 51, 254, 67, 144, 78, 230, 201, 78, 127, 92,
            159, 26, 51, 223, 195, 192, 177, 251, 137, 234, 64, 37, 65, 76, 246, 118, 216, 224, 83, 152, 110, 67, 117,
            201, 2, 253, 173, 128, 73, 76, 26, 179, 93, 24, 227, 242, 121, 254, 170, 226, 31, 88, 196, 194, 58, 86,
            255, 192, 36, 221, 100, 20, 198, 221, 242, 249, 196, 211, 98, 111, 198, 220, 135, 239, 82, 74, 139, 243, 2,
            25, 215,
        ])
        .unwrap();

        assert!(validate_client_p2p_certificate(&certificate));
    }
}


--- File: src/pku2u/config.rs ---
use picky::key::PrivateKey;
use picky_asn1_x509::Certificate;

use crate::negotiate::{NegotiatedProtocol, ProtocolConfig};
use crate::secret::SecretPrivateKey;
use crate::{Pku2u, Result};

#[derive(Debug, Clone)]
pub struct Pku2uConfig {
    pub p2p_certificate: Certificate,
    pub private_key: SecretPrivateKey,
    pub client_hostname: String,
}

impl Pku2uConfig {
    pub fn new(p2p_certificate: Certificate, private_key: PrivateKey, client_hostname: String) -> Self {
        Self {
            p2p_certificate,
            private_key: private_key.into(),
            client_hostname,
        }
    }

    #[cfg(target_os = "windows")]
    pub fn default_client_config(client_hostname: String) -> Result<Self> {
        use super::cert_utils::extraction::extract_client_p2p_cert_and_key;

        let (p2p_certificate, private_key) = extract_client_p2p_cert_and_key()?;

        Ok(Self {
            p2p_certificate,
            private_key: private_key.into(),
            client_hostname,
        })
    }
}

impl ProtocolConfig for Pku2uConfig {
    fn new_instance(&self) -> Result<NegotiatedProtocol> {
        Ok(NegotiatedProtocol::Pku2u(Pku2u::new_client_from_config(Clone::clone(
            self,
        ))?))
    }

    fn box_clone(&self) -> Box<dyn ProtocolConfig> {
        Box::new(Clone::clone(self))
    }
}


--- File: src/pku2u/extractors.rs ---
use std::convert::TryInto;

use picky_asn1_der::application_tag::ApplicationTag;
use picky_asn1_der::Asn1RawDer;
use picky_krb::constants::key_usages::AS_REP_ENC;
use picky_krb::constants::types::PA_PK_AS_REP;
use picky_krb::messages::{AsRep, EncAsRepPart};
use picky_krb::pkinit::{DhRepInfo, PaPkAsRep};
use serde::Deserialize;

use crate::kerberos::{EncryptionParams, DEFAULT_ENCRYPTION_TYPE};
use crate::pk_init::DH_NONCE_LEN;
use crate::{Error, ErrorKind, Result};

pub fn extract_krb_rep<'a, T: Deserialize<'a>>(mut data: &'a [u8]) -> Result<(T, &'a [u8])> {
    let _oid: ApplicationTag<Asn1RawDer, 0> = picky_asn1_der::from_reader(&mut data)?;

    Ok((picky_asn1_der::from_bytes(data)?, data))
}

#[instrument(level = "trace", ret)]
pub fn extract_pa_pk_as_rep(as_rep: &AsRep) -> Result<PaPkAsRep> {
    Ok(picky_asn1_der::from_bytes(
        &as_rep
            .0
            .padata
            .0
            .as_ref()
            .ok_or_else(|| Error::new(ErrorKind::InvalidToken, "pa-datas is not present in as-rep"))?
            .iter()
            .find(|pa_data| pa_data.padata_type.0 .0 == PA_PK_AS_REP)
            .ok_or_else(|| {
                Error::new(
                    ErrorKind::InvalidToken,
                    "PA_PK_AS_REP is not present in pa-datas of the as-rep",
                )
            })?
            .padata_data
            .0
             .0,
    )?)
}

#[instrument(level = "trace", ret)]
pub fn extract_server_nonce(dh_rep_info: &DhRepInfo) -> Result<[u8; DH_NONCE_LEN]> {
    let nonce = dh_rep_info
        .server_dh_nonce
        .0
        .as_ref()
        .map(|nonce| nonce.0 .0.clone())
        .ok_or_else(|| Error::new(ErrorKind::InvalidToken, "DH server nonce is not present"))?;

    if nonce.len() != DH_NONCE_LEN {
        return Err(Error::new(
            ErrorKind::InvalidToken,
            format!(
                "invalid server dh nonce length: {}. Expected: {}",
                nonce.len(),
                DH_NONCE_LEN
            ),
        ));
    }

    Ok(nonce.try_into().unwrap())
}

#[instrument(level = "trace", ret)]
pub fn extract_session_key_from_as_rep(as_rep: &AsRep, key: &[u8], enc_params: &EncryptionParams) -> Result<Vec<u8>> {
    let cipher = enc_params
        .encryption_type
        .as_ref()
        .unwrap_or(&DEFAULT_ENCRYPTION_TYPE)
        .cipher();

    let enc_data = cipher.decrypt(key, AS_REP_ENC, &as_rep.0.enc_part.0.cipher.0 .0)?;
    trace!(?enc_data, "Plain AsRep::EncData");

    let enc_as_rep_part: EncAsRepPart = picky_asn1_der::from_bytes(&enc_data)?;

    Ok(enc_as_rep_part.0.key.0.key_value.0.to_vec())
}


--- File: src/pku2u/generators.rs ---
use std::fmt::Debug;
use std::str::FromStr;

use picky_asn1::date::GeneralizedTime;
use picky_asn1::restricted_string::IA5String;
use picky_asn1::wrapper::{
    Asn1SequenceOf, ExplicitContextTag0, ExplicitContextTag1, ExplicitContextTag2, ExplicitContextTag3,
    ExplicitContextTag4, ExplicitContextTag5, ExplicitContextTag6, ExplicitContextTag7, ExplicitContextTag8,
    ImplicitContextTag0, IntegerAsn1, ObjectIdentifierAsn1, OctetStringAsn1, Optional,
};
use picky_asn1_der::application_tag::ApplicationTag;
use picky_asn1_der::Asn1RawDer;
use picky_asn1_x509::{oids, AttributeTypeAndValueParameters, Certificate};
use picky_krb::constants::gss_api::{ACCEPT_INCOMPLETE, AUTHENTICATOR_CHECKSUM_TYPE};
use picky_krb::constants::key_usages::KEY_USAGE_FINISHED;
use picky_krb::constants::types::NT_SRV_INST;
use picky_krb::crypto::diffie_hellman::generate_private_key;
use picky_krb::crypto::ChecksumSuite;
use picky_krb::data_types::{
    Authenticator, AuthenticatorInner, AuthorizationData, AuthorizationDataInner, Checksum, EncryptionKey,
    KerbAdRestrictionEntry, KerberosStringAsn1, KerberosTime, LsapTokenInfoIntegrity, PrincipalName, Realm,
};
use picky_krb::gss_api::{
    ApplicationTag0, GssApiNegInit, KrbMessage, MechType, MechTypeList, NegTokenInit, NegTokenTarg,
};
use picky_krb::negoex::RANDOM_ARRAY_SIZE;
use picky_krb::pkinit::{KrbFinished, Pku2uNegoBody, Pku2uNegoReq, Pku2uNegoReqMetadata};
use rand::rngs::OsRng;
use rand::Rng;
use time::OffsetDateTime;

use super::Pku2uConfig;
use crate::crypto::compute_md5_channel_bindings_hash;
use crate::kerberos::client::generators::{
    AuthenticatorChecksumExtension, ChecksumOptions, EncKey, GenerateAuthenticatorOptions, MAX_MICROSECONDS,
};
use crate::pk_init::DhParameters;
use crate::{Error, ErrorKind, Result, KERBEROS_VERSION};

/// [The PKU2U Realm Name](https://datatracker.ietf.org/doc/html/draft-zhu-pku2u-09#section-3)
/// The PKU2U realm name is defined as a reserved Kerberos realm name, and it has the value of "WELLKNOWN:PKU2U".
pub const WELLKNOWN_REALM: &str = "WELLKNOWN:PKU2U";

/// [The GSS-API Binding for PKU2U](https://datatracker.ietf.org/doc/html/draft-zhu-pku2u-04#section-6)
/// The type for the checksum extension.
/// GSS_EXTS_FINISHED 2
const GSS_EXTS_FINISHED: u32 = 2;

/// [2.2.5 LSAP_TOKEN_INFO_INTEGRITY](https://winprotocoldoc.blob.core.windows.net/productionwindowsarchives/MS-KILE/%5bMS-KILE%5d.pdf)
/// indicating the token information type
/// 0x00000001 = User Account Control (UAC) restricted token
const LSAP_TOKEN_INFO_INTEGRITY_FLAG: u32 = 1;
/// [2.2.5 LSAP_TOKEN_INFO_INTEGRITY](https://winprotocoldoc.blob.core.windows.net/productionwindowsarchives/MS-KILE/%5bMS-KILE%5d.pdf)
/// indicating the integrity level of the calling process
/// 0x00002000 = Medium.
const LSAP_TOKEN_INFO_INTEGRITY_TOKEN_IL: u32 = 0x00002000;
/// [3.1.1.4 Machine ID](https://winprotocoldoc.blob.core.windows.net/productionwindowsarchives/MS-KILE/%5bMS-KILE%5d.pdf)
/// KILE implements a 32-byte binary random string machine ID.
const MACHINE_ID: [u8; 32] = [
    92, 95, 64, 72, 191, 160, 228, 23, 98, 35, 78, 151, 207, 227, 96, 126, 97, 180, 15, 98, 127, 211, 90, 177, 119,
    132, 45, 113, 206, 90, 169, 124,
];

// returns supported authentication types
pub fn get_mech_list() -> MechTypeList {
    MechTypeList::from(vec![MechType::from(oids::negoex()), MechType::from(oids::ntlm_ssp())])
}

#[instrument(level = "debug", ret)]
pub fn generate_pku2u_nego_req(service_names: &[&str], config: &Pku2uConfig) -> Result<Pku2uNegoReq> {
    let mut snames = Vec::with_capacity(service_names.len());
    for sname in service_names {
        snames.push(KerberosStringAsn1::from(IA5String::from_str(sname)?));
    }

    Ok(Pku2uNegoReq {
        metadata: ExplicitContextTag0::from(Asn1SequenceOf::from(vec![Pku2uNegoReqMetadata {
            inner: ImplicitContextTag0::from(OctetStringAsn1::from(picky_asn1_der::to_vec(
                &config.p2p_certificate.tbs_certificate.issuer,
            )?)),
        }])),
        body: ExplicitContextTag1::from(Pku2uNegoBody {
            realm: ExplicitContextTag0::from(Realm::from(IA5String::from_str(WELLKNOWN_REALM)?)),
            sname: ExplicitContextTag1::from(PrincipalName {
                name_type: ExplicitContextTag0::from(IntegerAsn1::from(vec![NT_SRV_INST])),
                name_string: ExplicitContextTag1::from(Asn1SequenceOf::from(snames)),
            }),
        }),
    })
}

#[instrument(level = "trace", ret)]
pub fn generate_neg_token_init(mech_token: Vec<u8>) -> Result<ApplicationTag0<GssApiNegInit>> {
    Ok(ApplicationTag0(GssApiNegInit {
        oid: ObjectIdentifierAsn1::from(oids::spnego()),
        neg_token_init: ExplicitContextTag0::from(NegTokenInit {
            mech_types: Optional::from(Some(ExplicitContextTag0::from(get_mech_list()))),
            req_flags: Optional::from(None),
            mech_token: Optional::from(Some(ExplicitContextTag2::from(OctetStringAsn1::from(mech_token)))),
            mech_list_mic: Optional::from(None),
        }),
    }))
}

#[instrument(level = "trace", ret)]
pub fn generate_neg_token_targ(token: Vec<u8>) -> Result<ExplicitContextTag1<NegTokenTarg>> {
    Ok(ExplicitContextTag1::from(NegTokenTarg {
        neg_result: Optional::from(Some(ExplicitContextTag0::from(Asn1RawDer(ACCEPT_INCOMPLETE.to_vec())))),
        supported_mech: Optional::from(None),
        response_token: Optional::from(Some(ExplicitContextTag2::from(OctetStringAsn1::from(token)))),
        mech_list_mic: Optional::from(None),
    }))
}

/// returns (p, g, q)
pub fn get_default_parameters() -> (Vec<u8>, Vec<u8>, Vec<u8>) {
    (
        vec![
            0, 255, 255, 255, 255, 255, 255, 255, 255, 201, 15, 218, 162, 33, 104, 194, 52, 196, 198, 98, 139, 128,
            220, 28, 209, 41, 2, 78, 8, 138, 103, 204, 116, 2, 11, 190, 166, 59, 19, 155, 34, 81, 74, 8, 121, 142, 52,
            4, 221, 239, 149, 25, 179, 205, 58, 67, 27, 48, 43, 10, 109, 242, 95, 20, 55, 79, 225, 53, 109, 109, 81,
            194, 69, 228, 133, 181, 118, 98, 94, 126, 198, 244, 76, 66, 233, 166, 55, 237, 107, 11, 255, 92, 182, 244,
            6, 183, 237, 238, 56, 107, 251, 90, 137, 159, 165, 174, 159, 36, 17, 124, 75, 31, 230, 73, 40, 102, 81,
            236, 228, 91, 61, 194, 0, 124, 184, 161, 99, 191, 5, 152, 218, 72, 54, 28, 85, 211, 154, 105, 22, 63, 168,
            253, 36, 207, 95, 131, 101, 93, 35, 220, 163, 173, 150, 28, 98, 243, 86, 32, 133, 82, 187, 158, 213, 41, 7,
            112, 150, 150, 109, 103, 12, 53, 78, 74, 188, 152, 4, 241, 116, 108, 8, 202, 24, 33, 124, 50, 144, 94, 70,
            46, 54, 206, 59, 227, 158, 119, 44, 24, 14, 134, 3, 155, 39, 131, 162, 236, 7, 162, 143, 181, 197, 93, 240,
            111, 76, 82, 201, 222, 43, 203, 246, 149, 88, 23, 24, 57, 149, 73, 124, 234, 149, 106, 229, 21, 210, 38,
            24, 152, 250, 5, 16, 21, 114, 142, 90, 138, 172, 170, 104, 255, 255, 255, 255, 255, 255, 255, 255,
        ],
        vec![2],
        vec![
            127, 255, 255, 255, 255, 255, 255, 255, 228, 135, 237, 81, 16, 180, 97, 26, 98, 99, 49, 69, 192, 110, 14,
            104, 148, 129, 39, 4, 69, 51, 230, 58, 1, 5, 223, 83, 29, 137, 205, 145, 40, 165, 4, 60, 199, 26, 2, 110,
            247, 202, 140, 217, 230, 157, 33, 141, 152, 21, 133, 54, 249, 47, 138, 27, 167, 240, 154, 182, 182, 168,
            225, 34, 242, 66, 218, 187, 49, 47, 63, 99, 122, 38, 33, 116, 211, 27, 246, 181, 133, 255, 174, 91, 122, 3,
            91, 246, 247, 28, 53, 253, 173, 68, 207, 210, 215, 79, 146, 8, 190, 37, 143, 243, 36, 148, 51, 40, 246,
            114, 45, 158, 225, 0, 62, 92, 80, 177, 223, 130, 204, 109, 36, 27, 14, 42, 233, 205, 52, 139, 31, 212, 126,
            146, 103, 175, 193, 178, 174, 145, 238, 81, 214, 203, 14, 49, 121, 171, 16, 66, 169, 93, 207, 106, 148,
            131, 184, 75, 75, 54, 179, 134, 26, 167, 37, 94, 76, 2, 120, 186, 54, 4, 101, 12, 16, 190, 25, 72, 47, 35,
            23, 27, 103, 29, 241, 207, 59, 150, 12, 7, 67, 1, 205, 147, 193, 209, 118, 3, 209, 71, 218, 226, 174, 248,
            55, 166, 41, 100, 239, 21, 229, 251, 74, 172, 11, 140, 28, 202, 164, 190, 117, 74, 181, 114, 138, 233, 19,
            12, 76, 125, 2, 136, 10, 185, 71, 45, 69, 86, 85, 52, 127, 255, 255, 255, 255, 255, 255, 255,
        ],
    )
}

pub fn generate_server_dh_parameters(rng: &mut OsRng) -> Result<DhParameters> {
    Ok(DhParameters {
        base: Vec::new(),
        modulus: Vec::new(),
        q: Vec::new(),
        private_key: Vec::new(),
        other_public_key: None,
        server_nonce: Some(rng.gen::<[u8; RANDOM_ARRAY_SIZE]>()),
        client_nonce: None,
    })
}

pub fn generate_client_dh_parameters(rng: &mut OsRng) -> Result<DhParameters> {
    let (p, g, q) = get_default_parameters();

    let private_key = generate_private_key(&q, rng);

    Ok(DhParameters {
        base: g,
        modulus: p,
        q,
        private_key,
        other_public_key: None,
        client_nonce: Some(rng.gen::<[u8; RANDOM_ARRAY_SIZE]>()),
        server_nonce: None,
    })
}

pub fn generate_neg<T: Debug + PartialEq + Clone>(
    krb_msg: T,
    krb5_token_id: [u8; 2],
) -> ApplicationTag<KrbMessage<T>, 0> {
    ApplicationTag::from(KrbMessage {
        krb5_oid: ObjectIdentifierAsn1::from(oids::gss_pku2u()),
        krb5_token_id,
        krb_msg,
    })
}

pub fn generate_authenticator_extension(key: &[u8], payload: &[u8]) -> Result<AuthenticatorChecksumExtension> {
    let hasher = ChecksumSuite::HmacSha196Aes256.hasher();

    let krb_finished = KrbFinished {
        gss_mic: ExplicitContextTag1::from(Checksum {
            cksumtype: ExplicitContextTag0::from(IntegerAsn1::from(vec![ChecksumSuite::HmacSha196Aes256.into()])),
            checksum: ExplicitContextTag1::from(OctetStringAsn1::from(hasher.checksum(
                key,
                KEY_USAGE_FINISHED,
                payload,
            )?)),
        }),
    };

    Ok(AuthenticatorChecksumExtension {
        extension_type: GSS_EXTS_FINISHED,
        extension_value: picky_asn1_der::to_vec(&krb_finished)?,
    })
}

#[instrument(level = "trace", ret)]
pub fn generate_authenticator(options: GenerateAuthenticatorOptions) -> Result<Authenticator> {
    let GenerateAuthenticatorOptions {
        kdc_rep,
        seq_num,
        sub_key,
        checksum,
        channel_bindings,
        extensions,
    } = options;

    let current_date = OffsetDateTime::now_utc();
    let mut microseconds = current_date.microsecond();
    if microseconds > MAX_MICROSECONDS {
        microseconds = MAX_MICROSECONDS;
    }

    let lsap_token = LsapTokenInfoIntegrity {
        flags: LSAP_TOKEN_INFO_INTEGRITY_FLAG,
        token_il: LSAP_TOKEN_INFO_INTEGRITY_TOKEN_IL,
        machine_id: MACHINE_ID,
    };

    let mut encoded_lsap_token = Vec::with_capacity(40);
    lsap_token.encode(&mut encoded_lsap_token)?;

    let restriction_entry = KerbAdRestrictionEntry {
        restriction_type: ExplicitContextTag0::from(IntegerAsn1::from(vec![0])),
        restriction: ExplicitContextTag1::from(OctetStringAsn1::from(encoded_lsap_token)),
    };

    let authorization_data = Optional::from(Some(ExplicitContextTag8::from(AuthorizationData::from(vec![
        AuthorizationDataInner {
            ad_type: ExplicitContextTag0::from(IntegerAsn1::from(vec![0x01])),
            ad_data: ExplicitContextTag1::from(OctetStringAsn1::from(picky_asn1_der::to_vec(&Asn1SequenceOf::from(
                vec![AuthorizationDataInner {
                    ad_type: ExplicitContextTag0::from(IntegerAsn1::from(vec![0x00, 0x8d])),
                    ad_data: ExplicitContextTag1::from(OctetStringAsn1::from(picky_asn1_der::to_vec(
                        &Asn1SequenceOf::from(vec![restriction_entry]),
                    )?)),
                }],
            ))?)),
        },
    ]))));

    let cksum = if let Some(ChecksumOptions {
        checksum_type,
        checksum_value,
    }) = checksum
    {
        let mut checksum_value = checksum_value.into_inner();
        if checksum_type == AUTHENTICATOR_CHECKSUM_TYPE && channel_bindings.is_some() {
            if checksum_value.len() < 20 {
                return Err(Error::new(
                    ErrorKind::InvalidParameter,
                    format!(
                        "Invalid authenticator checksum length: expected >= 20 but got {}. ",
                        checksum_value.len()
                    ),
                ));
            }
            // [Authenticator Checksum](https://datatracker.ietf.org/doc/html/rfc4121#section-4.1.1)
            // 4..19 - Channel binding information (19 inclusive).
            checksum_value[4..20]
                .copy_from_slice(&compute_md5_channel_bindings_hash(channel_bindings.as_ref().unwrap()));
        }

        for extension in extensions {
            checksum_value.extend_from_slice(&extension.extension_type.to_be_bytes());
            checksum_value.extend_from_slice(&(extension.extension_value.len() as u32).to_be_bytes());
            checksum_value.extend_from_slice(&extension.extension_value);
        }

        Optional::from(Some(ExplicitContextTag3::from(Checksum {
            cksumtype: ExplicitContextTag0::from(IntegerAsn1::from(checksum_type)),
            checksum: ExplicitContextTag1::from(OctetStringAsn1::from(checksum_value)),
        })))
    } else {
        Optional::from(None)
    };

    Ok(Authenticator::from(AuthenticatorInner {
        authenticator_vno: ExplicitContextTag0::from(IntegerAsn1::from(vec![KERBEROS_VERSION])),
        crealm: ExplicitContextTag1::from(kdc_rep.crealm.0.clone()),
        cname: ExplicitContextTag2::from(kdc_rep.cname.0.clone()),
        cksum,
        cusec: ExplicitContextTag4::from(IntegerAsn1::from(microseconds.to_be_bytes().to_vec())),
        ctime: ExplicitContextTag5::from(KerberosTime::from(GeneralizedTime::from(current_date))),
        subkey: Optional::from(sub_key.map(|EncKey { key_type, key_value }| {
            ExplicitContextTag6::from(EncryptionKey {
                key_type: ExplicitContextTag0::from(IntegerAsn1::from(vec![key_type.into()])),
                key_value: ExplicitContextTag1::from(OctetStringAsn1::from(key_value)),
            })
        })),
        seq_number: Optional::from(seq_num.map(|seq_num| {
            ExplicitContextTag7::from(IntegerAsn1::from_bytes_be_unsigned(seq_num.to_be_bytes().to_vec()))
        })),
        authorization_data,
    }))
}

pub fn generate_as_req_username_from_certificate(certificate: &Certificate) -> Result<String> {
    let mut username = "AzureAD\\".to_owned();

    let mut issuer = false;
    for attr_type_and_value in certificate.tbs_certificate.issuer.0 .0.iter() {
        for v in attr_type_and_value.0.iter() {
            if v.ty.0 == oids::at_common_name() {
                if let AttributeTypeAndValueParameters::CommonName(name) = &v.value {
                    issuer = true;
                    username.push_str(&name.to_utf8_lossy());
                }
            }
        }
    }

    if !issuer {
        return Err(Error::new(
            ErrorKind::Pku2uCertFailure,
            "Bad client certificate: cannot find common name of the issuer",
        ));
    }

    username.push('\\');

    let mut subject = false;
    for attr_type_and_value in certificate.tbs_certificate.subject.0 .0.iter() {
        for v in attr_type_and_value.0.iter() {
            if v.ty.0 == oids::at_common_name() {
                if let AttributeTypeAndValueParameters::CommonName(name) = &v.value {
                    subject = true;
                    username.push_str(&name.to_utf8_lossy());
                }
            }
        }
    }

    if !subject {
        return Err(Error::new(
            ErrorKind::Pku2uCertFailure,
            "Bad client certificate: cannot find appropriate common name of the subject",
        ));
    }

    Ok(username)
}


--- File: src/pku2u/macros.rs ---
macro_rules! check_conversation_id {
    ($actual:expr, $expected:expr) => {
        if $actual != $expected {
            return Err(Error::new(
                ErrorKind::InvalidToken,
                format!(
                    "Server sent invalid conversation id. Got {:?} but expected {:?}",
                    $actual, $expected
                ),
            ));
        }
    };
}

macro_rules! check_auth_scheme {
    ($actual:expr, $expected:expr) => {
        if $expected.is_none() {
            return Err(Error::new(ErrorKind::InvalidParameter, "auth scheme id is not set"));
        }

        if $actual != $expected.unwrap() {
            return Err(Error::new(
                ErrorKind::InvalidToken,
                format!(
                    "Server sent invalid conversation id. Got {:?} but expected {:?}",
                    $actual,
                    $expected.unwrap()
                ),
            ));
        }
    };
}

macro_rules! check_sequence_number {
    ($actual:expr, $expected:expr) => {
        if $actual != $expected {
            return Err(Error::new(
                ErrorKind::OutOfSequence,
                format!(
                    "Server sent invalid sequence number. Got {:?} but expected {:?}",
                    $actual, $expected
                ),
            ));
        }
    };
}

#[macro_export]
macro_rules! check_if_empty {
    ($actual:expr, $msg:expr) => {
        $actual.ok_or_else(|| Error::new(ErrorKind::InternalError, $msg))?
    };
}


--- File: src/pku2u/mod.rs ---
mod cert_utils;
mod config;
mod extractors;
mod generators;
#[macro_use]
pub mod macros;
mod validate;

use std::io::Write;
use std::str::FromStr;
use std::sync::LazyLock;

pub use cert_utils::validation::validate_server_p2p_certificate;
pub use config::Pku2uConfig;
pub use extractors::{extract_pa_pk_as_rep, extract_server_nonce, extract_session_key_from_as_rep};
pub use generators::{generate_authenticator, generate_authenticator_extension, generate_client_dh_parameters};
use picky::hash::HashAlgorithm;
use picky::signature::SignatureAlgorithm;
use picky_asn1_x509::signed_data::SignedData;
use picky_krb::constants::gss_api::{AP_REQ_TOKEN_ID, AS_REQ_TOKEN_ID, AUTHENTICATOR_CHECKSUM_TYPE};
use picky_krb::constants::key_usages::{ACCEPTOR_SIGN, INITIATOR_SIGN};
use picky_krb::crypto::diffie_hellman::{generate_key, DhNonce};
use picky_krb::crypto::{ChecksumSuite, CipherSuite};
use picky_krb::gss_api::{NegTokenTarg1, WrapToken};
use picky_krb::messages::{ApRep, AsRep};
use picky_krb::negoex::data_types::MessageType;
use picky_krb::negoex::messages::{Exchange, Nego, Verify};
use picky_krb::negoex::{NegoexMessage, RANDOM_ARRAY_SIZE};
use picky_krb::pkinit::PaPkAsRep;
use rand::rngs::OsRng;
use rand::Rng;
use uuid::Uuid;
pub use validate::validate_signed_data;

use self::generators::{
    generate_neg, generate_neg_token_init, generate_neg_token_targ, generate_pku2u_nego_req,
    generate_server_dh_parameters, WELLKNOWN_REALM,
};
use crate::builders::{ChangePassword, FilledAcceptSecurityContext};
use crate::generator::{GeneratorAcceptSecurityContext, GeneratorInitSecurityContext, YieldPointLocal};
use crate::kerberos::client::extractors::extract_sub_session_key_from_ap_rep;
use crate::kerberos::client::generators::{
    generate_ap_req, generate_as_req, generate_as_req_kdc_body, ChecksumOptions, EncKey, GenerateAsReqOptions,
    GenerateAuthenticatorOptions,
};
use crate::kerberos::{EncryptionParams, DEFAULT_ENCRYPTION_TYPE, MAX_SIGNATURE, RRC, SECURITY_TRAILER};
use crate::pk_init::{
    extract_server_dh_public_key, generate_pa_datas_for_as_req, DhParameters, GenerateAsPaDataOptions,
};
use crate::pku2u::extractors::extract_krb_rep;
use crate::pku2u::generators::generate_as_req_username_from_certificate;
use crate::utils::{extract_encrypted_data, generate_random_symmetric_key, get_encryption_key, save_decrypted_data};
use crate::{
    AcceptSecurityContextResult, AcquireCredentialsHandleResult, AuthIdentity, AuthIdentityBuffers, BufferType,
    CertTrustStatus, ClientResponseFlags, ContextNames, ContextSizes, CredentialUse, DecryptionFlags, EncryptionFlags,
    Error, ErrorKind, InitializeSecurityContextResult, PackageCapabilities, PackageInfo, Result, SecurityBuffer,
    SecurityBufferRef, SecurityPackageType, SecurityStatus, Sspi, SspiEx, SspiImpl, PACKAGE_ID_NONE,
};

pub const PKG_NAME: &str = "Pku2u";

pub const AZURE_AD_DOMAIN: &str = "AzureAD";

/// [Authenticator Checksum](https://datatracker.ietf.org/doc/html/rfc4121#section-4.1.1)
const AUTHENTICATOR_DEFAULT_CHECKSUM: [u8; 24] = [
    16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 62, 64, 0, 0,
];

/// Default NEGOEX authentication scheme
pub const DEFAULT_NEGOEX_AUTH_SCHEME: &str = "0d53335c-f9ea-4d0d-b2ec-4ae3786ec308";

/// sealed = true
/// other flags = false
pub const CLIENT_WRAP_TOKEN_FLAGS: u8 = 2;
/// sealed = true
/// send by acceptor = true
/// acceptor subkey = false
pub const SERVER_WRAP_TOKEN_FLAGS: u8 = 3;

pub static PACKAGE_INFO: LazyLock<PackageInfo> = LazyLock::new(|| PackageInfo {
    capabilities: PackageCapabilities::empty(),
    rpc_id: PACKAGE_ID_NONE,
    max_token_len: 0xbb80, // 48 000 bytes: default maximum token len in Windows
    name: SecurityPackageType::Pku2u,
    comment: String::from("Pku2u Security Package"),
});

#[derive(Debug, Clone)]
pub enum Pku2uState {
    Negotiate,
    Preauthentication,
    AsExchange,
    ApExchange,
    PubKeyAuth,
    Credentials,
    Final,
}

#[derive(Debug, Clone)]
enum Pku2uMode {
    Client,
    Server,
}

#[derive(Debug, Clone)]
pub struct Pku2u {
    mode: Pku2uMode,
    config: Pku2uConfig,
    state: Pku2uState,
    encryption_params: EncryptionParams,
    auth_identity: Option<AuthIdentityBuffers>,
    conversation_id: Uuid,
    auth_scheme: Option<Uuid>,
    seq_number: u32,
    dh_parameters: DhParameters,
    // all sent and received NEGOEX messages concatenated in one vector
    // we need it for the further checksum calculation
    // https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-negoex/9de2cde2-bd98-40a4-9efa-0f5a1d6cc88e
    // The checksum is performed on all previous NEGOEX messages in the context negotiation.
    negoex_messages: Vec<u8>,
    // two last GSS-API messages concatenated in one vector
    // we need it for the further authenticator checksum calculation
    // https://datatracker.ietf.org/doc/html/draft-zhu-pku2u-04#section-6
    // The checksum is performed on all previous NEGOEX messages in the context negotiation.
    gss_api_messages: Vec<u8>,
    negoex_random: [u8; RANDOM_ARRAY_SIZE],
}

impl Pku2u {
    pub fn new_server_from_config(config: Pku2uConfig) -> Result<Self> {
        let mut rng = OsRng;

        Ok(Self {
            mode: Pku2uMode::Server,
            config,
            state: Pku2uState::Preauthentication,
            encryption_params: EncryptionParams::default_for_server(),
            auth_identity: None,
            conversation_id: Uuid::default(),
            auth_scheme: Some(Uuid::from_str(DEFAULT_NEGOEX_AUTH_SCHEME).unwrap()),
            seq_number: 2,
            // https://www.rfc-editor.org/rfc/rfc4556.html#section-3.2.3
            // Contains the nonce in the pkAuthenticator field in the request if the DH keys are NOT reused,
            // 0 otherwise.
            // generate dh parameters at the start in order to not waste time during authorization
            dh_parameters: generate_server_dh_parameters(&mut rng)?,
            negoex_messages: Vec::new(),
            gss_api_messages: Vec::new(),
            negoex_random: rng.gen::<[u8; RANDOM_ARRAY_SIZE]>(),
        })
    }

    pub fn new_client_from_config(config: Pku2uConfig) -> Result<Self> {
        let mut rng = OsRng;

        Ok(Self {
            mode: Pku2uMode::Client,
            config,
            state: Pku2uState::Negotiate,
            encryption_params: EncryptionParams::default_for_client(),
            auth_identity: None,
            conversation_id: Uuid::new_v4(),
            auth_scheme: None,
            seq_number: 0,
            // https://www.rfc-editor.org/rfc/rfc4556.html#section-3.2.3
            // Contains the nonce in the pkAuthenticator field in the request if the DH keys are NOT reused,
            // 0 otherwise.
            // generate dh parameters at the start in order to not waste time during authorization
            dh_parameters: generate_client_dh_parameters(&mut rng)?,
            negoex_messages: Vec::new(),
            gss_api_messages: Vec::new(),
            negoex_random: rng.gen::<[u8; RANDOM_ARRAY_SIZE]>(),
        })
    }

    pub fn config(&self) -> &Pku2uConfig {
        &self.config
    }

    pub fn next_seq_number(&mut self) -> u32 {
        let seq_num = self.seq_number;
        self.seq_number += 1;

        seq_num
    }
}

impl Sspi for Pku2u {
    #[instrument(level = "debug", ret, fields(state = ?self.state), skip_all)]
    fn complete_auth_token(&mut self, _token: &mut [SecurityBuffer]) -> Result<SecurityStatus> {
        Ok(SecurityStatus::Ok)
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip(self, _flags))]
    fn encrypt_message(
        &mut self,
        _flags: EncryptionFlags,
        message: &mut [SecurityBufferRef],
        sequence_number: u32,
    ) -> Result<SecurityStatus> {
        trace!(encryption_params = ?self.encryption_params);

        // checks if the Token buffer present
        let _ = SecurityBufferRef::find_buffer(message, BufferType::Token)?;
        let data_buffer = SecurityBufferRef::find_buffer_mut(message, BufferType::Data)?;

        let cipher = self
            .encryption_params
            .encryption_type
            .as_ref()
            .unwrap_or(&DEFAULT_ENCRYPTION_TYPE)
            .cipher();

        let key = get_encryption_key(&self.encryption_params)?;
        let key_usage = self.encryption_params.sspi_encrypt_key_usage;

        let mut wrap_token = WrapToken::with_seq_number(sequence_number as u64);
        wrap_token.flags = match self.mode {
            Pku2uMode::Client => CLIENT_WRAP_TOKEN_FLAGS,
            Pku2uMode::Server => SERVER_WRAP_TOKEN_FLAGS,
        };

        let mut payload = data_buffer.data().to_vec();
        payload.extend_from_slice(&wrap_token.header());

        let mut checksum = cipher.encrypt(key, key_usage, &payload)?;
        checksum.rotate_right(RRC.into());

        wrap_token.set_rrc(RRC);
        wrap_token.set_checksum(checksum);

        let mut raw_wrap_token = Vec::with_capacity(92);
        wrap_token.encode(&mut raw_wrap_token)?;

        match self.state {
            Pku2uState::PubKeyAuth | Pku2uState::Credentials | Pku2uState::Final => {
                if raw_wrap_token.len() < SECURITY_TRAILER {
                    return Err(Error::new(ErrorKind::EncryptFailure, "Cannot encrypt the data"));
                }

                let (token, data) = raw_wrap_token.split_at(SECURITY_TRAILER);
                data_buffer.write_data(data)?;
                let token_buffer = SecurityBufferRef::find_buffer_mut(message, BufferType::Token)?;
                token_buffer.write_data(token)?;
            }
            _ => {
                return Err(Error::new(
                    ErrorKind::OutOfSequence,
                    "Pku2u context is not established".to_owned(),
                ))
            }
        };

        Ok(SecurityStatus::Ok)
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip(self, _sequence_number))]
    fn decrypt_message(&mut self, message: &mut [SecurityBufferRef], _sequence_number: u32) -> Result<DecryptionFlags> {
        trace!(encryption_params = ?self.encryption_params);

        let encrypted = extract_encrypted_data(message)?;

        let cipher = self
            .encryption_params
            .encryption_type
            .as_ref()
            .unwrap_or(&DEFAULT_ENCRYPTION_TYPE)
            .cipher();

        let key = get_encryption_key(&self.encryption_params)?;
        let key_usage = self.encryption_params.sspi_decrypt_key_usage;

        let mut wrap_token = WrapToken::decode(encrypted.as_slice())?;
        wrap_token.checksum.rotate_left(RRC.into());

        let mut decrypted = cipher.decrypt(key, key_usage, &wrap_token.checksum)?;

        // remove wrap token header
        decrypted.truncate(decrypted.len() - WrapToken::header_len());

        save_decrypted_data(&decrypted, message)?;

        match self.state {
            Pku2uState::PubKeyAuth => {
                self.state = Pku2uState::Credentials;
                Ok(DecryptionFlags::empty())
            }
            Pku2uState::Credentials => {
                self.state = Pku2uState::Final;
                Ok(DecryptionFlags::empty())
            }
            _ => Ok(DecryptionFlags::empty()),
        }
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip(self))]
    fn query_context_sizes(&mut self) -> Result<ContextSizes> {
        Ok(ContextSizes {
            max_token: PACKAGE_INFO.max_token_len,
            max_signature: MAX_SIGNATURE as u32,
            block: 0,
            security_trailer: SECURITY_TRAILER as u32,
        })
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip(self))]
    fn query_context_names(&mut self) -> Result<ContextNames> {
        if let Some(identity_buffers) = &self.auth_identity {
            let identity =
                AuthIdentity::try_from(identity_buffers).map_err(|e| Error::new(ErrorKind::InvalidParameter, e))?;

            Ok(ContextNames {
                username: identity.username,
            })
        } else {
            Err(crate::Error::new(
                crate::ErrorKind::NoCredentials,
                String::from("Requested Names, but no credentials were provided"),
            ))
        }
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip(self))]
    fn query_context_package_info(&mut self) -> Result<PackageInfo> {
        crate::query_security_package_info(SecurityPackageType::Pku2u)
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip(self))]
    fn query_context_cert_trust_status(&mut self) -> Result<CertTrustStatus> {
        Err(Error::new(
            ErrorKind::UnsupportedFunction,
            "Certificate trust status is not supported".to_owned(),
        ))
    }

    #[instrument(level = "debug", fields(state = ?self.state), skip(self))]
    fn query_context_session_key(&self) -> Result<crate::SessionKeys> {
        let session_key = get_encryption_key(&self.encryption_params)?;

        Ok(crate::SessionKeys {
            session_key: session_key.to_vec().into(),
        })
    }

    fn change_password(&mut self, _: ChangePassword) -> Result<crate::generator::GeneratorChangePassword> {
        Err(Error::new(
            ErrorKind::UnsupportedFunction,
            "Pku2u does not support change pasword",
        ))
    }

    fn make_signature(
        &mut self,
        _flags: u32,
        _message: &mut [SecurityBufferRef],
        _sequence_number: u32,
    ) -> crate::Result<()> {
        Err(Error::new(
            ErrorKind::UnsupportedFunction,
            "make_signature is not supported",
        ))
    }

    fn verify_signature(&mut self, _message: &mut [SecurityBufferRef], _sequence_number: u32) -> crate::Result<u32> {
        Err(Error::new(
            ErrorKind::UnsupportedFunction,
            "verify_signature is not supported",
        ))
    }
}

impl SspiImpl for Pku2u {
    type CredentialsHandle = Option<AuthIdentityBuffers>;

    type AuthenticationData = AuthIdentity;

    #[instrument(level = "trace", ret, fields(state = ?self.state), skip(self))]
    fn acquire_credentials_handle_impl(
        &mut self,
        builder: crate::builders::FilledAcquireCredentialsHandle<'_, Self::CredentialsHandle, Self::AuthenticationData>,
    ) -> Result<AcquireCredentialsHandleResult<Self::CredentialsHandle>> {
        if builder.credential_use == CredentialUse::Outbound && builder.auth_data.is_none() {
            return Err(Error::new(
                ErrorKind::NoCredentials,
                String::from("The client must specify the auth data"),
            ));
        }

        self.auth_identity = builder.auth_data.cloned().map(AuthIdentityBuffers::from);

        Ok(AcquireCredentialsHandleResult {
            credentials_handle: self.auth_identity.clone(),
            expiry: None,
        })
    }

    #[instrument(level = "debug", ret, fields(state = ?self.state), skip(self, builder))]
    fn accept_security_context_impl<'a>(
        &'a mut self,
        builder: crate::builders::FilledAcceptSecurityContext<'a, Self::CredentialsHandle>,
    ) -> Result<GeneratorAcceptSecurityContext<'a>> {
        Ok(GeneratorAcceptSecurityContext::new(move |mut yield_point| async move {
            self.accept_security_context_impl(&mut yield_point, builder).await
        }))
    }

    fn initialize_security_context_impl<'ctx, 'b, 'g>(
        &'ctx mut self,
        builder: &'b mut crate::builders::FilledInitializeSecurityContext<'ctx, Self::CredentialsHandle>,
    ) -> Result<GeneratorInitSecurityContext<'g>>
    where
        'ctx: 'g,
        'b: 'g,
    {
        Ok(self.initialize_security_context_impl(builder).into())
    }
}

impl Pku2u {
    pub(crate) async fn accept_security_context_impl(
        &mut self,
        _yield_point: &mut YieldPointLocal,
        _builder: FilledAcceptSecurityContext<'_, <Self as SspiImpl>::CredentialsHandle>,
    ) -> crate::Result<AcceptSecurityContextResult> {
        Err(Error::new(
            ErrorKind::UnsupportedFunction,
            "accept_security_context_impl is not implemented yet",
        ))
    }

    #[instrument(ret, level = "debug", fields(state = ?self.state), skip_all)]
    pub(crate) fn initialize_security_context_impl(
        &mut self,
        builder: &mut crate::builders::FilledInitializeSecurityContext<'_, <Self as SspiImpl>::CredentialsHandle>,
    ) -> Result<InitializeSecurityContextResult> {
        trace!(?builder);

        let status = match self.state {
            Pku2uState::Negotiate => {
                let auth_scheme = Uuid::from_str(DEFAULT_NEGOEX_AUTH_SCHEME).unwrap();

                let mut mech_token = Vec::new();

                let snames = check_if_empty!(builder.target_name, "service target name is not provided")
                    .split('/')
                    .collect::<Vec<_>>();
                debug!(names = ?snames, "Service principal names");

                let nego = Nego::new(
                    MessageType::InitiatorNego,
                    self.conversation_id,
                    self.next_seq_number(),
                    self.negoex_random,
                    vec![auth_scheme],
                    vec![],
                );
                nego.encode(&mut mech_token)?;

                let exchange = Exchange::new(
                    MessageType::InitiatorMetaData,
                    self.conversation_id,
                    self.next_seq_number(),
                    auth_scheme,
                    picky_asn1_der::to_vec(&generate_pku2u_nego_req(&snames, &self.config)?)?,
                );
                exchange.encode(&mut mech_token)?;

                self.negoex_messages.extend_from_slice(&mech_token);

                let encoded_neg_token_init = picky_asn1_der::to_vec(&generate_neg_token_init(mech_token)?)?;

                let output_token = SecurityBuffer::find_buffer_mut(builder.output, BufferType::Token)?;
                output_token.buffer.write_all(&encoded_neg_token_init)?;

                self.state = Pku2uState::Preauthentication;

                SecurityStatus::ContinueNeeded
            }
            Pku2uState::Preauthentication => {
                let input = builder
                    .input
                    .as_ref()
                    .ok_or_else(|| Error::new(ErrorKind::InvalidToken, "Input buffers must be specified"))?;
                let input_token = SecurityBuffer::find_buffer(input, BufferType::Token)?;

                let neg_token_targ: NegTokenTarg1 = picky_asn1_der::from_bytes(&input_token.buffer)?;
                let buffer = neg_token_targ
                    .0
                    .response_token
                    .0
                    .ok_or_else(|| Error::new(ErrorKind::InvalidToken, "Missing response_token in NegTokenTarg"))?
                    .0
                     .0;

                self.negoex_messages.extend_from_slice(&buffer);

                let acceptor_nego = Nego::decode(&buffer)?;
                trace!(?acceptor_nego, "NEGOEX ACCEPTOR NEGOTIATE");

                check_conversation_id!(acceptor_nego.header.conversation_id, self.conversation_id);
                check_sequence_number!(acceptor_nego.header.sequence_num, self.next_seq_number());

                // We support only one auth scheme. So the server must choose it otherwise it's an invalid behaviour
                if let Some(auth_scheme) = acceptor_nego.auth_schemes.first() {
                    if *auth_scheme == Uuid::from_str(DEFAULT_NEGOEX_AUTH_SCHEME).unwrap() {
                        self.auth_scheme = Some(*auth_scheme);
                    } else {
                        return
                        Err(Error::new(
                            ErrorKind::InvalidToken,
                            format!(
                                "The server selected unsupported auth scheme {:?}. The only one supported auth scheme: {}",
                                auth_scheme, DEFAULT_NEGOEX_AUTH_SCHEME)
                        ));
                    }
                } else {
                    return Err(Error::new(
                        ErrorKind::InvalidToken,
                        "Server didn't send any auth scheme",
                    ));
                }

                if buffer.len() < acceptor_nego.header.header_len as usize {
                    return Err(Error::new(ErrorKind::InvalidToken, "NEGOEX buffer is too short"));
                }

                let acceptor_exchange_data = &buffer[(acceptor_nego.header.message_len as usize)..];
                let acceptor_exchange = Exchange::decode(acceptor_exchange_data)?;
                trace!(?acceptor_exchange, "NEGOEX ACCEPTOR EXCHANGE");

                check_conversation_id!(acceptor_exchange.header.conversation_id, self.conversation_id);
                check_sequence_number!(acceptor_exchange.header.sequence_num, self.next_seq_number());
                check_auth_scheme!(acceptor_exchange.auth_scheme, self.auth_scheme);

                let mut mech_token = Vec::new();

                let snames = check_if_empty!(builder.target_name, "service target name is not provided")
                    .split('/')
                    .collect::<Vec<_>>();
                debug!(names = ?snames, "Service principal names");

                let next_seq_number = self.next_seq_number();
                let kdc_req_body = generate_as_req_kdc_body(&GenerateAsReqOptions {
                    realm: WELLKNOWN_REALM,
                    username: &generate_as_req_username_from_certificate(&self.config.p2p_certificate)?,
                    cname_type: 0x80,
                    snames: &snames,
                    // we don't need the nonce in Pku2u
                    nonce: &[0],
                    hostname: &self.config.client_hostname,
                    context_requirements: builder.context_requirements,
                })?;
                let private_key = self.config.private_key.clone();
                let pa_datas = generate_pa_datas_for_as_req(&GenerateAsPaDataOptions {
                    p2p_cert: self.config.p2p_certificate.clone(),
                    kdc_req_body: &kdc_req_body,
                    dh_parameters: self.dh_parameters.clone(),
                    sign_data: Box::new(move |data_to_sign| {
                        SignatureAlgorithm::RsaPkcs1v15(HashAlgorithm::SHA1)
                            .sign(data_to_sign, private_key.as_ref())
                            .map_err(|err| {
                                Error::new(
                                    ErrorKind::InternalError,
                                    format!("Cannot calculate signer info signature: {:?}", err),
                                )
                            })
                    }),
                    with_pre_auth: true,
                    authenticator_nonce: Default::default(),
                })?;
                let as_req = generate_as_req(pa_datas, kdc_req_body);

                let exchange_data = picky_asn1_der::to_vec(&generate_neg(as_req, AS_REQ_TOKEN_ID))?;
                self.gss_api_messages.extend_from_slice(&exchange_data);

                let exchange = Exchange::new(
                    MessageType::ApRequest,
                    self.conversation_id,
                    next_seq_number,
                    check_if_empty!(self.auth_scheme, "auth scheme is not set"),
                    exchange_data,
                );
                exchange.encode(&mut mech_token)?;

                self.negoex_messages.extend_from_slice(&mech_token);

                let response_token = picky_asn1_der::to_vec(&generate_neg_token_targ(mech_token)?)?;

                let output_token = SecurityBuffer::find_buffer_mut(builder.output, BufferType::Token)?;
                output_token.buffer.write_all(&response_token)?;

                self.state = Pku2uState::AsExchange;

                SecurityStatus::ContinueNeeded
            }
            Pku2uState::AsExchange => {
                let input = builder
                    .input
                    .as_ref()
                    .ok_or_else(|| Error::new(ErrorKind::InvalidToken, "Input buffers must be specified"))?;
                let input_token = SecurityBuffer::find_buffer(input, BufferType::Token)?;

                let neg_token_targ: NegTokenTarg1 = picky_asn1_der::from_bytes(&input_token.buffer)?;
                let buffer = neg_token_targ
                    .0
                    .response_token
                    .0
                    .ok_or_else(|| Error::new(ErrorKind::InvalidToken, "Missing response_token in NegTokenTarg"))?
                    .0
                     .0;

                self.negoex_messages.extend_from_slice(&buffer);

                let acceptor_exchange = Exchange::decode(&buffer)?;
                trace!(?acceptor_exchange, "NEGOEX ACCEPTOR EXCHANGE MESSAGE");

                check_conversation_id!(acceptor_exchange.header.conversation_id, self.conversation_id);
                check_sequence_number!(acceptor_exchange.header.sequence_num, self.next_seq_number());
                check_auth_scheme!(acceptor_exchange.auth_scheme, self.auth_scheme);

                self.gss_api_messages.extend_from_slice(&acceptor_exchange.exchange);

                let (as_rep, _): (AsRep, _) = extract_krb_rep(&acceptor_exchange.exchange)?;

                let dh_rep_info = match extract_pa_pk_as_rep(&as_rep)? {
                    PaPkAsRep::DhInfo(dh) => dh.0,
                    PaPkAsRep::EncKeyPack(_) => {
                        return Err(Error::new(
                            ErrorKind::OperationNotSupported,
                            "encKeyPack is not supported for the PA-PK-AS-REP",
                        ))
                    }
                };

                let server_nonce = extract_server_nonce(&dh_rep_info)?;
                self.dh_parameters.server_nonce = Some(server_nonce);

                let signed_data: SignedData = picky_asn1_der::from_bytes(&dh_rep_info.dh_signed_data.0)?;

                let rsa_public_key = validate_server_p2p_certificate(&signed_data)?;
                validate_signed_data(&signed_data, &rsa_public_key)?;

                let public_key = extract_server_dh_public_key(&signed_data)?;
                self.dh_parameters.other_public_key = Some(public_key);

                self.encryption_params.encryption_type =
                    Some(CipherSuite::try_from(as_rep.0.enc_part.0.etype.0 .0.as_slice())?);

                let session_key = generate_key(
                    check_if_empty!(self.dh_parameters.other_public_key.as_ref(), "dh public key is not set"),
                    &self.dh_parameters.private_key,
                    &self.dh_parameters.modulus,
                    Some(DhNonce {
                        client_nonce: check_if_empty!(
                            self.dh_parameters.client_nonce.as_ref(),
                            "dh client none is not set"
                        ),
                        server_nonce: check_if_empty!(
                            self.dh_parameters.server_nonce.as_ref(),
                            "dh server nonce is not set"
                        ),
                    }),
                    check_if_empty!(
                        self.encryption_params.encryption_type.as_ref(),
                        "encryption type is not set"
                    )
                    .cipher()
                    .as_ref(),
                )?;
                trace!(?session_key, "Session key generated from DH components");

                let session_key = extract_session_key_from_as_rep(&as_rep, &session_key, &self.encryption_params)?;
                self.encryption_params.session_key = Some(session_key);

                let exchange_seq_number = self.next_seq_number();
                let verify_seq_number = self.next_seq_number();

                let enc_type = self
                    .encryption_params
                    .encryption_type
                    .as_ref()
                    .unwrap_or(&DEFAULT_ENCRYPTION_TYPE);
                let authenticator_sub_key = generate_random_symmetric_key(enc_type, &mut OsRng);

                let authenticator = generate_authenticator(GenerateAuthenticatorOptions {
                    kdc_rep: &as_rep.0,
                    seq_num: Some(exchange_seq_number),
                    sub_key: Some(EncKey {
                        key_type: enc_type.clone(),
                        key_value: authenticator_sub_key.clone(),
                    }),
                    checksum: Some(ChecksumOptions {
                        checksum_type: AUTHENTICATOR_CHECKSUM_TYPE.to_vec(),
                        checksum_value: AUTHENTICATOR_DEFAULT_CHECKSUM.into(),
                    }),
                    channel_bindings: None,
                    extensions: vec![generate_authenticator_extension(
                        &authenticator_sub_key,
                        &self.gss_api_messages,
                    )?],
                })?;

                let ap_req = generate_ap_req(
                    as_rep.0.ticket.0,
                    check_if_empty!(self.encryption_params.session_key.as_ref(), "session key is not set"),
                    &authenticator,
                    &self.encryption_params,
                    builder.context_requirements.into(),
                )?;

                let mut mech_token = Vec::new();

                let exchange = Exchange::new(
                    MessageType::ApRequest,
                    self.conversation_id,
                    exchange_seq_number,
                    check_if_empty!(self.auth_scheme, "auth_scheme is not set"),
                    picky_asn1_der::to_vec(&generate_neg(ap_req, AP_REQ_TOKEN_ID))?,
                );
                exchange.encode(&mut mech_token)?;

                exchange.encode(&mut self.negoex_messages)?;

                let verify = Verify::new(
                    MessageType::Verify,
                    self.conversation_id,
                    verify_seq_number,
                    check_if_empty!(self.auth_scheme, "auth_scheme is not set"),
                    ChecksumSuite::HmacSha196Aes256.into(),
                    ChecksumSuite::HmacSha196Aes256.hasher().checksum(
                        &authenticator_sub_key,
                        INITIATOR_SIGN,
                        &self.negoex_messages,
                    )?,
                );
                verify.encode(&mut mech_token)?;

                verify.encode(&mut self.negoex_messages)?;

                let encoded_neg_token_targ = picky_asn1_der::to_vec(&generate_neg_token_targ(mech_token)?)?;

                let output_token = SecurityBuffer::find_buffer_mut(builder.output, BufferType::Token)?;
                output_token.buffer.write_all(&encoded_neg_token_targ)?;

                self.state = Pku2uState::ApExchange;

                SecurityStatus::ContinueNeeded
            }
            Pku2uState::ApExchange => {
                let input = builder
                    .input
                    .as_ref()
                    .ok_or_else(|| Error::new(ErrorKind::InvalidToken, "Input buffers must be specified"))?;
                let input_token = SecurityBuffer::find_buffer(input, BufferType::Token)?;

                let neg_token_targ: NegTokenTarg1 = picky_asn1_der::from_bytes(&input_token.buffer)?;

                let buffer = neg_token_targ
                    .0
                    .response_token
                    .0
                    .ok_or_else(|| Error::new(ErrorKind::InvalidToken, "Missing response_token in NegTokenTarg"))?
                    .0
                     .0;

                let acceptor_exchange = Exchange::decode(&buffer)?;
                trace!(?acceptor_exchange, "NEGOEX ACCEPTOR EXCHANGE MESSAGE");

                check_conversation_id!(acceptor_exchange.header.conversation_id, self.conversation_id);
                check_sequence_number!(acceptor_exchange.header.sequence_num, self.next_seq_number());
                check_auth_scheme!(acceptor_exchange.auth_scheme, self.auth_scheme);

                if buffer.len() < acceptor_exchange.header.header_len as usize {
                    return Err(Error::new(ErrorKind::InvalidToken, "NEGOEX buffer is too short"));
                }

                self.negoex_messages
                    .extend_from_slice(&buffer[0..(acceptor_exchange.header.message_len as usize)]);

                let acceptor_verify_data = &buffer[(acceptor_exchange.header.message_len as usize)..];
                let acceptor_verify = Verify::decode(acceptor_verify_data)?;
                trace!(?acceptor_exchange, "NEGOEX ACCEPTOR VERIFY MESSAGE");

                check_conversation_id!(acceptor_verify.header.conversation_id, self.conversation_id);
                check_sequence_number!(acceptor_verify.header.sequence_num, self.next_seq_number());
                check_auth_scheme!(acceptor_verify.auth_scheme, self.auth_scheme);

                let (ap_rep, _): (ApRep, _) = extract_krb_rep(&acceptor_exchange.exchange)?;

                let sub_session_key = extract_sub_session_key_from_ap_rep(
                    &ap_rep,
                    check_if_empty!(self.encryption_params.session_key.as_ref(), "session key is not set"),
                    &self.encryption_params,
                )?;

                self.encryption_params.sub_session_key = Some(sub_session_key);

                let acceptor_checksum = ChecksumSuite::try_from(acceptor_verify.checksum.checksum_type as usize)?
                    .hasher()
                    .checksum(
                        check_if_empty!(
                            self.encryption_params.sub_session_key.as_ref(),
                            "sub-session key is not set"
                        ),
                        ACCEPTOR_SIGN,
                        &self.negoex_messages,
                    )?;
                if acceptor_verify.checksum.checksum_value != acceptor_checksum {
                    return Err(Error::new(
                        ErrorKind::MessageAltered,
                        "bad verify message signature from server",
                    ));
                }

                self.state = Pku2uState::PubKeyAuth;

                SecurityStatus::Ok
            }
            _ => {
                return Err(Error::new(
                    ErrorKind::OutOfSequence,
                    format!("Got wrong PKU2U state: {:?}", self.state),
                ))
            }
        };

        trace!(output_buffers = ?builder.output);

        Ok(InitializeSecurityContextResult {
            status,
            flags: ClientResponseFlags::empty(),
            expiry: None,
        })
    }
}

impl SspiEx for Pku2u {
    #[instrument(level = "trace", ret, fields(state = ?self.state), skip(self))]
    fn custom_set_auth_identity(&mut self, identity: Self::AuthenticationData) -> Result<()> {
        self.auth_identity = Some(identity.into());

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use picky::key::PrivateKey;
    use picky_asn1_x509::Certificate;
    use picky_krb::constants::key_usages::{ACCEPTOR_SEAL, INITIATOR_SEAL};
    use picky_krb::crypto::CipherSuite;
    use picky_krb::negoex::RANDOM_ARRAY_SIZE;
    use rand::rngs::OsRng;
    use rand::Rng;
    use uuid::Uuid;

    use super::generators::{generate_client_dh_parameters, generate_server_dh_parameters};
    use super::Pku2uMode;
    use crate::kerberos::EncryptionParams;
    use crate::{EncryptionFlags, Pku2u, Pku2uConfig, Pku2uState, SecurityBufferRef, Sspi};

    #[test]
    fn stream_buffer_decryption() {
        let session_key = vec![
            137, 60, 120, 245, 164, 179, 76, 200, 242, 96, 57, 174, 111, 209, 90, 76, 58, 117, 55, 138, 81, 75, 110,
            235, 80, 228, 14, 238, 76, 128, 139, 81,
        ];
        let sub_session_key = vec![
            35, 147, 211, 63, 83, 48, 241, 34, 97, 95, 27, 106, 195, 18, 95, 91, 17, 45, 187, 6, 26, 195, 16, 108, 123,
            119, 121, 155, 58, 142, 204, 74,
        ];

        let mut rng = OsRng;

        let p2p_certificate: Certificate = picky_asn1_der::from_bytes(&[
            48, 130, 3, 213, 48, 130, 2, 189, 160, 3, 2, 1, 2, 2, 16, 32, 99, 134, 91, 60, 164, 166, 93, 186, 47, 71,
            107, 255, 241, 24, 166, 48, 13, 6, 9, 42, 134, 72, 134, 247, 13, 1, 1, 11, 5, 0, 48, 77, 49, 75, 48, 73, 6,
            3, 85, 4, 3, 30, 66, 0, 77, 0, 83, 0, 45, 0, 79, 0, 114, 0, 103, 0, 97, 0, 110, 0, 105, 0, 122, 0, 97, 0,
            116, 0, 105, 0, 111, 0, 110, 0, 45, 0, 80, 0, 50, 0, 80, 0, 45, 0, 65, 0, 99, 0, 99, 0, 101, 0, 115, 0,
            115, 0, 32, 0, 91, 0, 50, 0, 48, 0, 50, 0, 50, 0, 93, 48, 30, 23, 13, 50, 51, 48, 49, 50, 57, 49, 53, 52,
            57, 52, 57, 90, 23, 13, 50, 51, 48, 49, 50, 57, 49, 54, 53, 52, 52, 57, 90, 48, 129, 142, 49, 52, 48, 50,
            6, 10, 9, 146, 38, 137, 147, 242, 44, 100, 1, 25, 22, 36, 97, 57, 50, 53, 50, 52, 52, 56, 45, 57, 97, 98,
            55, 45, 52, 57, 98, 48, 45, 98, 98, 53, 99, 45, 102, 50, 102, 57, 50, 51, 99, 56, 52, 54, 55, 50, 49, 61,
            48, 59, 6, 3, 85, 4, 3, 12, 52, 83, 45, 49, 45, 49, 50, 45, 49, 45, 51, 56, 48, 51, 49, 54, 49, 53, 57, 51,
            45, 49, 51, 51, 49, 50, 56, 56, 57, 56, 50, 45, 50, 48, 56, 52, 57, 49, 53, 56, 52, 51, 45, 51, 50, 50, 57,
            49, 49, 53, 52, 57, 56, 49, 23, 48, 21, 6, 3, 85, 4, 3, 12, 14, 115, 57, 64, 100, 97, 116, 97, 97, 110,
            115, 46, 99, 111, 109, 48, 130, 1, 34, 48, 13, 6, 9, 42, 134, 72, 134, 247, 13, 1, 1, 1, 5, 0, 3, 130, 1,
            15, 0, 48, 130, 1, 10, 2, 130, 1, 1, 0, 213, 241, 189, 199, 35, 187, 172, 209, 113, 53, 145, 42, 93, 142,
            53, 223, 26, 208, 110, 226, 178, 54, 187, 237, 181, 246, 230, 65, 42, 101, 36, 177, 121, 74, 97, 222, 146,
            163, 254, 112, 155, 150, 227, 182, 123, 122, 251, 64, 119, 186, 229, 68, 157, 67, 211, 189, 241, 217, 197,
            194, 143, 86, 210, 86, 178, 232, 140, 59, 99, 9, 98, 8, 164, 181, 4, 194, 5, 101, 191, 137, 140, 13, 158,
            67, 216, 195, 67, 112, 162, 234, 81, 168, 198, 255, 40, 90, 165, 5, 155, 231, 80, 238, 124, 43, 98, 117,
            181, 159, 195, 246, 146, 183, 221, 215, 129, 237, 67, 119, 100, 159, 35, 246, 189, 204, 50, 29, 25, 214,
            121, 69, 120, 253, 143, 248, 219, 162, 32, 205, 111, 13, 76, 123, 158, 242, 60, 0, 233, 159, 17, 143, 199,
            243, 230, 213, 14, 193, 148, 12, 27, 11, 7, 90, 140, 253, 72, 229, 24, 69, 40, 59, 2, 243, 194, 41, 248,
            204, 92, 102, 189, 220, 19, 185, 227, 113, 192, 162, 86, 132, 88, 233, 191, 131, 215, 219, 5, 63, 163, 34,
            55, 9, 209, 94, 255, 37, 32, 165, 163, 167, 133, 49, 105, 19, 85, 147, 227, 77, 189, 125, 140, 171, 127,
            121, 249, 217, 216, 226, 253, 190, 105, 234, 99, 129, 100, 135, 231, 3, 237, 88, 81, 102, 67, 17, 147, 84,
            233, 75, 124, 179, 16, 160, 203, 202, 196, 235, 191, 209, 2, 3, 1, 0, 1, 163, 111, 48, 109, 48, 14, 6, 3,
            85, 29, 15, 1, 1, 255, 4, 4, 3, 2, 5, 160, 48, 41, 6, 3, 85, 29, 17, 4, 34, 48, 32, 160, 30, 6, 10, 43, 6,
            1, 4, 1, 130, 55, 20, 2, 3, 160, 16, 12, 14, 115, 57, 64, 100, 97, 116, 97, 97, 110, 115, 46, 99, 111, 109,
            48, 19, 6, 3, 85, 29, 37, 4, 12, 48, 10, 6, 8, 43, 6, 1, 5, 5, 7, 3, 2, 48, 27, 6, 9, 43, 6, 1, 4, 1, 130,
            55, 21, 10, 4, 14, 48, 12, 48, 10, 6, 8, 43, 6, 1, 5, 5, 7, 3, 2, 48, 13, 6, 9, 42, 134, 72, 134, 247, 13,
            1, 1, 11, 5, 0, 3, 130, 1, 1, 0, 162, 35, 243, 146, 152, 98, 219, 208, 111, 136, 212, 0, 12, 134, 196, 6,
            96, 113, 172, 17, 243, 26, 152, 107, 97, 89, 98, 235, 162, 130, 189, 228, 248, 44, 19, 41, 203, 8, 185, 83,
            207, 142, 69, 242, 172, 137, 162, 78, 54, 219, 47, 213, 113, 120, 143, 177, 44, 242, 7, 79, 88, 71, 26,
            134, 120, 77, 93, 81, 134, 253, 155, 50, 160, 79, 113, 196, 96, 53, 87, 132, 132, 117, 9, 202, 38, 15, 47,
            4, 247, 57, 153, 145, 211, 181, 46, 92, 232, 219, 186, 226, 12, 7, 52, 61, 104, 55, 136, 170, 53, 57, 95,
            224, 35, 39, 192, 47, 11, 75, 37, 117, 205, 1, 76, 242, 4, 96, 203, 50, 254, 239, 253, 27, 23, 73, 159,
            110, 232, 164, 119, 55, 207, 77, 66, 95, 23, 202, 149, 245, 235, 57, 80, 50, 171, 183, 15, 27, 223, 7, 32,
            155, 101, 139, 95, 167, 214, 90, 58, 199, 250, 127, 131, 12, 97, 61, 212, 12, 10, 245, 34, 136, 11, 215,
            25, 168, 55, 120, 187, 5, 219, 220, 205, 45, 242, 237, 227, 43, 43, 164, 247, 181, 194, 251, 14, 153, 222,
            33, 157, 8, 228, 144, 87, 207, 135, 243, 223, 233, 114, 139, 94, 122, 228, 80, 237, 90, 53, 83, 60, 251,
            11, 179, 147, 227, 101, 85, 96, 80, 44, 176, 158, 85, 102, 31, 228, 24, 117, 230, 26, 202, 127, 121, 177,
            26, 62, 17, 96, 9,
        ])
        .unwrap();
        let private_key = PrivateKey::from_pem_str(
            "-----BEGIN PRIVATE KEY-----
MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDV8b3HI7us0XE1
kSpdjjXfGtBu4rI2u+219uZBKmUksXlKYd6So/5wm5bjtnt6+0B3uuVEnUPTvfHZ
xcKPVtJWsuiMO2MJYgiktQTCBWW/iYwNnkPYw0NwoupRqMb/KFqlBZvnUO58K2J1
tZ/D9pK33deB7UN3ZJ8j9r3MMh0Z1nlFeP2P+NuiIM1vDUx7nvI8AOmfEY/H8+bV
DsGUDBsLB1qM/UjlGEUoOwLzwin4zFxmvdwTueNxwKJWhFjpv4PX2wU/oyI3CdFe
/yUgpaOnhTFpE1WT4029fYyrf3n52dji/b5p6mOBZIfnA+1YUWZDEZNU6Ut8sxCg
y8rE67/RAgMBAAECggEAERzG6zjGeCpAfeJgmx8W3AOPDG+BhbM+bkGTZT743Bh9
9R8i6GPJpEQtq4UbF1klbO48DGLv2+3jfGG/ECwHovuoch8F6ug2fMYl3UcFPm7I
DwbLsnjb2hSN3X48fIhDx9NNBxGIIdJui6+9WbVNQvuxkyjhLpmTyRKhV8XiYgCK
OkfCfBWOt/WTGdtuwPtDnvtZOA8Qm3L9Yf0BuqLQAqNZ6fihhwfi1bwLwzRTzC3x
rAfxCMv4dLdYCTee9/6fUWGwJ4SKYqlolVbcZmpFJ7/ByRzfgq0etVJJxKIDOZ8y
ba/bw8eLypdo4I9SSch/5x/WAS45bMarX4nmJKwUyQKBgQDxCHKmUdwuz1SDhYX/
H/Si87uZ31Hs/Spjp/mUumwuEgtkmm2hlgtQXmbYnc47nIQqWOu/L0Z9//2D5WHU
lhYk6S8xAN3dKyGPrYKaBzrh5FCzolprz0YK/N1do9Yu0hkshs73isMbpVHPTI9l
WuzDqsqfz27VS4XovZJQfjL2+wKBgQDjOq5l5rFkLbeHxEoIFoMdEQnRrr1bXkrj
Vf0QWN2fi4Y8/RVLUVNifkjoo4Aj3D7sgyT8ItCDyXtj9Rt5swKUW+rywgI44Fr2
DuOAyAXhzFd7GLw0HnE9jeKMQyeXW5igAppXWOMgS6eAo25vIIRL4UBaIC4/WVCz
jJ/aprkaowKBgQDR46ZauJwA0yBoKySlJkGUiKPLeVFRCqAYCdTnM3MypxnusB9Z
f1w4zwvGA5zsAf6BFc+sO1GqNPmhGmUXht6fo8Mpa/THPGDMSa6ZzEP1Iyk3U+Bj
UypONSXa/elr+h5bzMR7gQUnlM1ps+SGwSe9t4McqLh92ncwVawMlehxcwKBgBcG
jj+TNeyR2WQvltTk+xpJ7LXLwDJvBqWsw/0RFDwjllG9z5eXQRzc8SRp1QVNPy8W
RvwpxvljxFYns0YMxrkj61X4JOOAkJcYgSM+oaH04/R8WC3r28vCAe/2qh9jT77/
JIavYiyWnf2iEgG+yMkrpSq80hLnSQ84s8YjWOSDAoGBAOaVvL6VVq2BawI+Qt3s
9DlgTNtzpiJJCmUfwNd2yOPQJVq5trdA0DZeCQEc/psPWXBoyT01ptgcGHP+C/Da
xFnLp2UBrhxA9GYrpJ5i0onRmexQnTVSl5DDq07s+3dbr9YAKjrg9IDZYqLbdwP1
1pNtUBlMx+0X6wxVjMYulkRH
-----END PRIVATE KEY-----",
        )
        .unwrap();

        let mut pku2u_server = Pku2u {
            mode: Pku2uMode::Server,
            config: Pku2uConfig {
                p2p_certificate: p2p_certificate.clone(),
                private_key: private_key.clone().into(),
                client_hostname: "hostname".into(),
            },
            state: Pku2uState::Final,
            encryption_params: EncryptionParams {
                encryption_type: Some(CipherSuite::Aes256CtsHmacSha196),
                session_key: Some(session_key.clone()),
                sub_session_key: Some(sub_session_key.clone()),
                sspi_encrypt_key_usage: INITIATOR_SEAL,
                sspi_decrypt_key_usage: ACCEPTOR_SEAL,
                ec: 0,
            },
            auth_identity: None,
            conversation_id: Uuid::new_v4(),
            auth_scheme: None,
            seq_number: 0,
            dh_parameters: generate_server_dh_parameters(&mut rng).unwrap(),
            negoex_messages: Vec::new(),
            gss_api_messages: Vec::new(),
            negoex_random: rng.gen::<[u8; RANDOM_ARRAY_SIZE]>(),
        };

        let mut pku2u_client = Pku2u {
            mode: Pku2uMode::Client,
            config: Pku2uConfig {
                p2p_certificate,
                private_key: private_key.into(),
                client_hostname: "hostname".into(),
            },
            state: Pku2uState::Final,
            encryption_params: EncryptionParams {
                encryption_type: Some(CipherSuite::Aes256CtsHmacSha196),
                session_key: Some(session_key),
                sub_session_key: Some(sub_session_key),
                sspi_encrypt_key_usage: ACCEPTOR_SEAL,
                sspi_decrypt_key_usage: INITIATOR_SEAL,
                ec: 0,
            },
            auth_identity: None,
            conversation_id: Uuid::new_v4(),
            auth_scheme: None,
            seq_number: 0,
            dh_parameters: generate_client_dh_parameters(&mut rng).unwrap(),
            negoex_messages: Vec::new(),
            gss_api_messages: Vec::new(),
            negoex_random: rng.gen::<[u8; RANDOM_ARRAY_SIZE]>(),
        };

        let plain_message = b"some plain message";

        let mut token = [0; 1024];
        let mut data = plain_message.to_vec();
        let mut message = [
            SecurityBufferRef::token_buf(token.as_mut_slice()),
            SecurityBufferRef::data_buf(data.as_mut_slice()),
        ];

        pku2u_server
            .encrypt_message(EncryptionFlags::empty(), &mut message, 0)
            .unwrap();

        let mut buffer = message[0].data().to_vec();
        buffer.extend_from_slice(message[1].data());

        let mut message = [
            SecurityBufferRef::stream_buf(&mut buffer),
            SecurityBufferRef::data_buf(&mut []),
        ];

        pku2u_client.decrypt_message(&mut message, 0).unwrap();

        assert_eq!(message[1].data(), plain_message);
    }
}


--- File: src/pku2u/validate.rs ---
use picky::hash::HashAlgorithm;
use picky::key::PublicKey as RsaPublicKey;
use picky::signature::SignatureAlgorithm;
use picky_asn1::wrapper::Asn1SetOf;
use picky_asn1_x509::signed_data::SignedData;

use crate::{Error, ErrorKind, Result};

pub fn validate_signed_data(signed_data: &SignedData, rsa_public_key: &RsaPublicKey) -> Result<()> {
    let signer_info = signed_data
        .signers_infos
        .0
         .0
        .first()
        .ok_or_else(|| Error::new(ErrorKind::InvalidToken, "Missing signers_infos in signed data"))?;

    let signed_attributes = Asn1SetOf::from(signer_info.signed_attrs.0 .0 .0.clone());
    let encoded_signed_attributes = picky_asn1_der::to_vec(&signed_attributes)?;

    SignatureAlgorithm::RsaPkcs1v15(HashAlgorithm::SHA1)
        .verify(rsa_public_key, &encoded_signed_attributes, &signer_info.signature.0 .0)
        .map_err(|_| Error::new(ErrorKind::InvalidToken, "Invalid signed data signature"))
}


--- File: src/rustls.rs ---
#![cfg(feature = "__rustls-used")]

/// Call this before using rustls.
#[doc(hidden)]
#[allow(clippy::result_unit_err)]
pub fn install_default_crypto_provider_if_necessary() -> Result<(), ()> {
    #[cfg(feature = "__install-crypto-provider")]
    {
        static INSTALL: std::sync::OnceLock<Result<(), ()>> = std::sync::OnceLock::new();

        let result = INSTALL.get_or_init(|| {
            // A crypto provider is already installed.
            if rustls::crypto::CryptoProvider::get_default().is_some() {
                return Ok(());
            }

            #[cfg(feature = "aws-lc-rs")]
            {
                rustls::crypto::aws_lc_rs::default_provider()
                    .install_default()
                    .map_err(|_| ())
            }

            #[cfg(all(not(feature = "aws-lc-rs"), feature = "ring"))]
            {
                rustls::crypto::ring::default_provider()
                    .install_default()
                    .map_err(|_| ())
            }
        });

        *result
    }

    #[cfg(not(feature = "__install-crypto-provider"))]
    {
        Ok(())
    }
}

#[cfg(feature = "network_client")]
pub(crate) fn load_native_certs(builder: reqwest::blocking::ClientBuilder) -> reqwest::blocking::ClientBuilder {
    #[cfg(feature = "aws-lc-rs")]
    {
        let mut builder = builder;

        let result = rustls_native_certs::load_native_certs();

        for error in result.errors {
            debug!(%error, "native root CA certificate loading error");
        }

        for cert in result.certs {
            // Continue on parsing errors, as native stores often include ancient or syntactically
            // invalid certificates, like root certificates without any X509 extensions.
            // Inspiration: https://github.com/rustls/rustls/blob/633bf4ba9d9521a95f68766d04c22e2b01e68318/rustls/src/anchors.rs#L105-L112
            match reqwest::Certificate::from_der(&cert) {
                Ok(cert) => builder = builder.add_root_certificate(cert),
                Err(error) => {
                    debug!(%error, "failed to parse native certificate");
                }
            };
        }

        builder
    }

    // We enable the rustls-tls-native-roots feature of reqwest when ring is used.
    #[cfg(all(not(feature = "aws-lc-rs"), feature = "ring"))]
    {
        builder
    }
}


--- File: src/secret.rs ---
use std::fmt;

use picky::key::PrivateKey;
use serde::{Deserialize, Serialize};
use zeroize::{Zeroize, ZeroizeOnDrop};

#[derive(Zeroize, ZeroizeOnDrop, Eq, PartialEq, Default, Clone, Serialize, Deserialize)]
pub struct Secret<T: Zeroize>(T);

impl<T: Zeroize> Secret<T> {
    pub fn new(inner: T) -> Self {
        Self(inner)
    }
}

impl<T: Zeroize> fmt::Debug for Secret<T> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Secret")?;

        Ok(())
    }
}

impl<T: Zeroize> fmt::Display for Secret<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "(secret)")?;

        Ok(())
    }
}

impl<T: Zeroize> AsRef<T> for Secret<T> {
    fn as_ref(&self) -> &T {
        &self.0
    }
}

impl<T: Zeroize> AsMut<T> for Secret<T> {
    fn as_mut(&mut self) -> &mut T {
        &mut self.0
    }
}

impl<T: Zeroize> From<T> for Secret<T> {
    fn from(inner: T) -> Self {
        Self(inner)
    }
}

#[derive(Clone, PartialEq)]
pub struct SecretPrivateKey(PrivateKey);

impl SecretPrivateKey {
    pub fn new(inner: PrivateKey) -> Self {
        Self(inner)
    }
}

impl fmt::Debug for SecretPrivateKey {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "SecretPrivateKey")?;

        Ok(())
    }
}

impl fmt::Display for SecretPrivateKey {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "(secret private key)")?;

        Ok(())
    }
}

impl AsRef<PrivateKey> for SecretPrivateKey {
    fn as_ref(&self) -> &PrivateKey {
        &self.0
    }
}

impl From<PrivateKey> for SecretPrivateKey {
    fn from(inner: PrivateKey) -> Self {
        Self(inner)
    }
}


--- File: src/security_buffer.rs ---
use std::fmt;
use std::mem::take;

use crate::{BufferType, Error, ErrorKind, Result, SecurityBufferFlags, SecurityBufferType};

/// A security buffer type with a mutable reference to the buffer data.
/// unflagged
/// Basically, it is a security buffer but without buffer flags.
#[non_exhaustive]
enum UnflaggedSecurityBuffer<'data> {
    Data(&'data mut [u8]),
    Token(&'data mut [u8]),
    StreamHeader(&'data mut [u8]),
    StreamTrailer(&'data mut [u8]),
    Stream(&'data mut [u8]),
    Extra(&'data mut [u8]),
    Padding(&'data mut [u8]),
    Missing(usize),
    Empty,
}

/// A special security buffer type is used for the data decryption. Basically, it's almost the same
/// as `SecurityBuffer` but for decryption.
///
/// [DecryptMessage](https://learn.microsoft.com/en-us/windows/win32/secauthn/decryptmessage--general)
/// "The encrypted message is decrypted in place, overwriting the original contents of its buffer."
///
/// So, the already defined `SecurityBuffer` is not suitable for decryption because it uses [Vec] inside.
/// We use reference in the [SecurityBufferRef] structure to avoid data cloning as much as possible.
/// Decryption/encryption input buffers can be very large. Even up to 32 KiB if we are using this crate as a TSSSP(CREDSSP)
/// security package.
pub struct SecurityBufferRef<'data> {
    buffer_type: UnflaggedSecurityBuffer<'data>,
    buffer_flags: SecurityBufferFlags,
}

impl<'data> SecurityBufferRef<'data> {
    /// Creates a [SecurityBufferRef] with a `Data` buffer type and empty buffer flags.
    pub fn data_buf(data: &mut [u8]) -> SecurityBufferRef {
        SecurityBufferRef {
            buffer_type: UnflaggedSecurityBuffer::Data(data),
            buffer_flags: Default::default(),
        }
    }

    /// Creates a [SecurityBufferRef] with a `Token` buffer type and empty buffer flags.
    pub fn token_buf(data: &mut [u8]) -> SecurityBufferRef {
        SecurityBufferRef {
            buffer_type: UnflaggedSecurityBuffer::Token(data),
            buffer_flags: Default::default(),
        }
    }

    /// Creates a [SecurityBufferRef] with a `StreamHeader` buffer type and empty buffer flags.
    pub fn stream_header_buf(data: &mut [u8]) -> SecurityBufferRef {
        SecurityBufferRef {
            buffer_type: UnflaggedSecurityBuffer::StreamHeader(data),
            buffer_flags: Default::default(),
        }
    }

    /// Creates a [SecurityBufferRef] with a `StreamTrailer` buffer type and empty buffer flags.
    pub fn stream_trailer_buf(data: &mut [u8]) -> SecurityBufferRef {
        SecurityBufferRef {
            buffer_type: UnflaggedSecurityBuffer::StreamTrailer(data),
            buffer_flags: Default::default(),
        }
    }

    /// Creates a [SecurityBufferRef] with a `Stream` buffer type and empty buffer flags.
    pub fn stream_buf(data: &mut [u8]) -> SecurityBufferRef {
        SecurityBufferRef {
            buffer_type: UnflaggedSecurityBuffer::Stream(data),
            buffer_flags: Default::default(),
        }
    }

    /// Creates a [SecurityBufferRef] with a `Extra` buffer type and empty buffer flags.
    pub fn extra_buf(data: &mut [u8]) -> SecurityBufferRef {
        SecurityBufferRef {
            buffer_type: UnflaggedSecurityBuffer::Extra(data),
            buffer_flags: Default::default(),
        }
    }

    /// Creates a [SecurityBufferRef] with a `Padding` buffer type and empty buffer flags.
    pub fn padding_buf(data: &mut [u8]) -> SecurityBufferRef {
        SecurityBufferRef {
            buffer_type: UnflaggedSecurityBuffer::Padding(data),
            buffer_flags: Default::default(),
        }
    }

    /// Creates a [SecurityBufferRef] with a `Missing` buffer type and empty buffer flags.
    pub fn missing_buf<'a>(count: usize) -> SecurityBufferRef<'a> {
        SecurityBufferRef {
            buffer_type: UnflaggedSecurityBuffer::Missing(count),
            buffer_flags: Default::default(),
        }
    }

    /// Set buffer flags.
    pub fn with_flags(self, buffer_flags: SecurityBufferFlags) -> Self {
        let Self {
            buffer_type,
            buffer_flags: _,
        } = self;

        Self {
            buffer_type,
            buffer_flags,
        }
    }

    /// Creates a [SecurityBufferRef] from based on provided [BufferType].
    ///
    /// Inner buffers will be empty.
    pub fn with_security_buffer_type(security_buffer_type: BufferType) -> Result<Self> {
        Ok(Self {
            buffer_type: match security_buffer_type {
                BufferType::Empty => UnflaggedSecurityBuffer::Empty,
                BufferType::Data => UnflaggedSecurityBuffer::Data(&mut []),
                BufferType::Token => UnflaggedSecurityBuffer::Token(&mut []),
                BufferType::Missing => UnflaggedSecurityBuffer::Missing(0),
                BufferType::Extra => UnflaggedSecurityBuffer::Extra(&mut []),
                BufferType::Padding => UnflaggedSecurityBuffer::Padding(&mut []),
                BufferType::StreamTrailer => UnflaggedSecurityBuffer::StreamTrailer(&mut []),
                BufferType::StreamHeader => UnflaggedSecurityBuffer::StreamHeader(&mut []),
                BufferType::Stream => UnflaggedSecurityBuffer::Stream(&mut []),
                _ => return Err(Error::new(ErrorKind::UnsupportedFunction, "")),
            },
            buffer_flags: SecurityBufferFlags::NONE,
        })
    }

    /// Created a [SecurityBufferRef] from based on provided [BufferType].
    ///
    /// Inner buffers will be empty.
    pub fn with_owned_security_buffer_type(security_buffer_type: SecurityBufferType) -> Result<Self> {
        Ok(Self {
            buffer_type: match security_buffer_type.buffer_type {
                BufferType::Empty => UnflaggedSecurityBuffer::Empty,
                BufferType::Data => UnflaggedSecurityBuffer::Data(&mut []),
                BufferType::Token => UnflaggedSecurityBuffer::Token(&mut []),
                BufferType::Missing => UnflaggedSecurityBuffer::Missing(0),
                BufferType::Extra => UnflaggedSecurityBuffer::Extra(&mut []),
                BufferType::Padding => UnflaggedSecurityBuffer::Padding(&mut []),
                BufferType::StreamTrailer => UnflaggedSecurityBuffer::StreamTrailer(&mut []),
                BufferType::StreamHeader => UnflaggedSecurityBuffer::StreamHeader(&mut []),
                BufferType::Stream => UnflaggedSecurityBuffer::Stream(&mut []),
                _ => return Err(Error::new(ErrorKind::UnsupportedFunction, "")),
            },
            buffer_flags: security_buffer_type.buffer_flags,
        })
    }

    /// Creates a new [SecurityBufferRef] with the provided buffer data saving the old buffer type.
    ///
    /// *Attention*: the buffer type must not be [BufferType::Missing].
    pub fn with_data(self, data: &'data mut [u8]) -> Result<Self> {
        Ok(Self {
            buffer_type: match &self.buffer_type {
                UnflaggedSecurityBuffer::Data(_) => UnflaggedSecurityBuffer::Data(data),
                UnflaggedSecurityBuffer::Token(_) => UnflaggedSecurityBuffer::Token(data),
                UnflaggedSecurityBuffer::StreamHeader(_) => UnflaggedSecurityBuffer::StreamHeader(data),
                UnflaggedSecurityBuffer::StreamTrailer(_) => UnflaggedSecurityBuffer::StreamTrailer(data),
                UnflaggedSecurityBuffer::Stream(_) => UnflaggedSecurityBuffer::Stream(data),
                UnflaggedSecurityBuffer::Extra(_) => UnflaggedSecurityBuffer::Extra(data),
                UnflaggedSecurityBuffer::Padding(_) => UnflaggedSecurityBuffer::Padding(data),
                UnflaggedSecurityBuffer::Missing(_) => {
                    return Err(Error::new(
                        ErrorKind::InternalError,
                        "the missing buffer type does not hold any buffers inside",
                    ))
                }
                UnflaggedSecurityBuffer::Empty => UnflaggedSecurityBuffer::Empty,
            },
            buffer_flags: self.buffer_flags,
        })
    }

    /// Sets the buffer data.
    ///
    /// *Attention*: the buffer type must not be [BufferType::Missing].
    pub fn set_data(&mut self, buf: &'data mut [u8]) -> Result<()> {
        match &mut self.buffer_type {
            UnflaggedSecurityBuffer::Data(data) => *data = buf,
            UnflaggedSecurityBuffer::Token(data) => *data = buf,
            UnflaggedSecurityBuffer::StreamHeader(data) => *data = buf,
            UnflaggedSecurityBuffer::StreamTrailer(data) => *data = buf,
            UnflaggedSecurityBuffer::Stream(data) => *data = buf,
            UnflaggedSecurityBuffer::Extra(data) => *data = buf,
            UnflaggedSecurityBuffer::Padding(data) => *data = buf,
            UnflaggedSecurityBuffer::Missing(_) => {
                return Err(Error::new(
                    ErrorKind::InternalError,
                    "the missing buffer type does not hold any buffers inside",
                ))
            }
            UnflaggedSecurityBuffer::Empty => {}
        };
        Ok(())
    }

    /// Determines the [BufferType] of security buffer.
    pub fn buffer_type(&self) -> BufferType {
        match &self.buffer_type {
            UnflaggedSecurityBuffer::Data(_) => BufferType::Data,
            UnflaggedSecurityBuffer::Token(_) => BufferType::Token,
            UnflaggedSecurityBuffer::StreamHeader(_) => BufferType::StreamHeader,
            UnflaggedSecurityBuffer::StreamTrailer(_) => BufferType::StreamTrailer,
            UnflaggedSecurityBuffer::Stream(_) => BufferType::Stream,
            UnflaggedSecurityBuffer::Extra(_) => BufferType::Extra,
            UnflaggedSecurityBuffer::Padding(_) => BufferType::Padding,
            UnflaggedSecurityBuffer::Missing(_) => BufferType::Missing,
            UnflaggedSecurityBuffer::Empty => BufferType::Empty,
        }
    }

    pub fn buffer_flags(&self) -> SecurityBufferFlags {
        self.buffer_flags
    }

    pub fn owned_security_buffer_type(&self) -> SecurityBufferType {
        let buffer_type = match &self.buffer_type {
            UnflaggedSecurityBuffer::Data(_) => BufferType::Data,
            UnflaggedSecurityBuffer::Token(_) => BufferType::Token,
            UnflaggedSecurityBuffer::StreamHeader(_) => BufferType::StreamHeader,
            UnflaggedSecurityBuffer::StreamTrailer(_) => BufferType::StreamTrailer,
            UnflaggedSecurityBuffer::Stream(_) => BufferType::Stream,
            UnflaggedSecurityBuffer::Extra(_) => BufferType::Extra,
            UnflaggedSecurityBuffer::Padding(_) => BufferType::Padding,
            UnflaggedSecurityBuffer::Missing(_) => BufferType::Missing,
            UnflaggedSecurityBuffer::Empty => BufferType::Empty,
        };

        SecurityBufferType {
            buffer_type,
            buffer_flags: self.buffer_flags,
        }
    }

    /// Returns the immutable reference to the [SecurityBufferRef] with specified buffer type.
    ///
    /// If a slice contains more than one buffer with a specified buffer type, then the first one will be returned.
    pub fn find_buffer<'a>(
        buffers: &'a [SecurityBufferRef<'data>],
        buffer_type: BufferType,
    ) -> Result<&'a SecurityBufferRef<'data>> {
        buffers.iter().find(|b| b.buffer_type() == buffer_type).ok_or_else(|| {
            Error::new(
                ErrorKind::InvalidToken,
                format!("no buffer was provided with type {:?}", buffer_type),
            )
        })
    }

    /// Returns the vector of immutable references to the [SecurityBufferRef] with specified buffer type.
    pub fn buffers_of_type<'a>(
        buffers: &'a [SecurityBufferRef<'data>],
        buffer_type: BufferType,
    ) -> impl Iterator<Item = &'a SecurityBufferRef<'data>> {
        buffers.iter().filter(move |b| b.buffer_type() == buffer_type)
    }

    /// Returns the vector of immutable references to the [SecurityBufferRef] with specified buffer type.
    pub fn buffers_of_type_mut<'a>(
        buffers: &'a mut [SecurityBufferRef<'data>],
        buffer_type: BufferType,
    ) -> impl Iterator<Item = &'a mut SecurityBufferRef<'data>> {
        buffers.iter_mut().filter(move |b| b.buffer_type() == buffer_type)
    }

    /// Returns the vector of immutable references to the [SecurityBufferRef] with specified buffer type and flags.
    pub fn buffers_of_type_and_flags<'a>(
        buffers: &'a [SecurityBufferRef<'data>],
        buffer_type: BufferType,
        buffer_flags: SecurityBufferFlags,
    ) -> impl Iterator<Item = &'a SecurityBufferRef<'data>> {
        buffers
            .iter()
            .filter(move |b| b.buffer_type() == buffer_type && b.buffer_flags() == buffer_flags)
    }

    /// Returns the vector of immutable references to the [SecurityBufferRef] with specified buffer type and flags.
    pub fn buffers_of_type_and_flags_mut<'a>(
        buffers: &'a mut [SecurityBufferRef<'data>],
        buffer_type: BufferType,
        buffer_flags: SecurityBufferFlags,
    ) -> impl Iterator<Item = &'a mut SecurityBufferRef<'data>> {
        buffers
            .iter_mut()
            .filter(move |b| b.buffer_type() == buffer_type && b.buffer_flags() == buffer_flags)
    }

    /// Returns the mutable reference to the [SecurityBufferRef] with specified buffer type.
    ///
    /// If a slice contains more than one buffer with a specified buffer type, then the first one will be returned.
    pub fn find_buffer_mut<'a>(
        buffers: &'a mut [SecurityBufferRef<'data>],
        buffer_type: BufferType,
    ) -> Result<&'a mut SecurityBufferRef<'data>> {
        buffers
            .iter_mut()
            .find(|b| b.buffer_type() == buffer_type)
            .ok_or_else(|| {
                Error::new(
                    ErrorKind::InvalidToken,
                    format!("no buffer was provided with type {:?}", buffer_type),
                )
            })
    }

    /// Returns the immutable reference to the inner buffer data.
    pub fn buf_data<'a>(buffers: &'a [SecurityBufferRef<'a>], buffer_type: BufferType) -> Result<&'a [u8]> {
        Ok(SecurityBufferRef::find_buffer(buffers, buffer_type)?.data())
    }

    /// Returns the immutable reference to the inner data.
    ///
    /// Some buffer types can not hold the data, so the empty slice will be returned.
    pub fn data(&self) -> &[u8] {
        match &self.buffer_type {
            UnflaggedSecurityBuffer::Data(data) => data,
            UnflaggedSecurityBuffer::Token(data) => data,
            UnflaggedSecurityBuffer::StreamHeader(data) => data,
            UnflaggedSecurityBuffer::StreamTrailer(data) => data,
            UnflaggedSecurityBuffer::Stream(data) => data,
            UnflaggedSecurityBuffer::Extra(data) => data,
            UnflaggedSecurityBuffer::Padding(data) => data,
            UnflaggedSecurityBuffer::Missing(_) => &[],
            UnflaggedSecurityBuffer::Empty => &[],
        }
    }

    /// Calculates the buffer data length.
    pub fn buf_len(&self) -> usize {
        match &self.buffer_type {
            UnflaggedSecurityBuffer::Data(data) => data.len(),
            UnflaggedSecurityBuffer::Token(data) => data.len(),
            UnflaggedSecurityBuffer::StreamHeader(data) => data.len(),
            UnflaggedSecurityBuffer::StreamTrailer(data) => data.len(),
            UnflaggedSecurityBuffer::Stream(data) => data.len(),
            UnflaggedSecurityBuffer::Extra(data) => data.len(),
            UnflaggedSecurityBuffer::Padding(data) => data.len(),
            UnflaggedSecurityBuffer::Missing(needed_bytes_amount) => *needed_bytes_amount,
            UnflaggedSecurityBuffer::Empty => 0,
        }
    }

    /// Returns the mutable reference to the inner buffer data leaving the empty buffer on its place.
    pub fn take_buf_data_mut<'a>(
        buffers: &'a mut [SecurityBufferRef<'data>],
        buffer_type: BufferType,
    ) -> Result<&'data mut [u8]> {
        Ok(SecurityBufferRef::find_buffer_mut(buffers, buffer_type)?.take_data())
    }

    /// Returns the mutable reference to the inner data leaving the empty buffer on its place.
    ///
    /// Some buffer types can not hold the data, so the empty slice will be returned.
    pub fn take_data(&mut self) -> &'data mut [u8] {
        match &mut self.buffer_type {
            UnflaggedSecurityBuffer::Data(data) => take(data),
            UnflaggedSecurityBuffer::Token(data) => take(data),
            UnflaggedSecurityBuffer::StreamHeader(data) => take(data),
            UnflaggedSecurityBuffer::StreamTrailer(data) => take(data),
            UnflaggedSecurityBuffer::Stream(data) => take(data),
            UnflaggedSecurityBuffer::Extra(data) => take(data),
            UnflaggedSecurityBuffer::Padding(data) => take(data),
            UnflaggedSecurityBuffer::Missing(_) => &mut [],
            UnflaggedSecurityBuffer::Empty => &mut [],
        }
    }

    /// Writes the provided data into the inner buffer.
    ///
    /// Returns error if the inner buffer is not big enough. If the inner buffer is larger than
    /// provided data, then it'll be shrunk to the size of the data.
    pub fn write_data(&mut self, data: &[u8]) -> Result<()> {
        let data_len = data.len();

        if self.buf_len() < data_len {
            return Err(Error::new(
                ErrorKind::BufferTooSmall,
                "provided data can not fit in the destination buffer",
            ));
        }

        let mut buf = self.take_data();
        buf = &mut buf[0..data_len];
        buf.copy_from_slice(data);

        self.set_data(buf)
    }
}

impl fmt::Debug for SecurityBufferRef<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "SecurityBufferRef {{ ")?;
        f.write_fmt(format_args!("{:?},", self.buffer_flags))?;
        match &self.buffer_type {
            UnflaggedSecurityBuffer::Data(data) => write_buffer(data, "Data", f)?,
            UnflaggedSecurityBuffer::Token(data) => write_buffer(data, "Token", f)?,
            UnflaggedSecurityBuffer::StreamHeader(data) => write_buffer(data, "StreamHeader", f)?,
            UnflaggedSecurityBuffer::StreamTrailer(data) => write_buffer(data, "StreamTrailer", f)?,
            UnflaggedSecurityBuffer::Stream(data) => write_buffer(data, "Stream", f)?,
            UnflaggedSecurityBuffer::Extra(data) => write_buffer(data, "Extra", f)?,
            UnflaggedSecurityBuffer::Padding(data) => write_buffer(data, "Padding", f)?,
            UnflaggedSecurityBuffer::Missing(needed_bytes_amount) => write!(f, "Missing({})", *needed_bytes_amount)?,
            UnflaggedSecurityBuffer::Empty => f.write_str("Empty")?,
        };
        write!(f, " }}")
    }
}

fn write_buffer(buf: &[u8], buf_name: &str, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    write!(f, "{}: ", buf_name)?;
    f.write_str("0x")?;
    buf.iter().try_for_each(|byte| write!(f, "{byte:02X}"))
}


--- File: src/smartcard.rs ---
#![cfg(feature = "scard")]

use std::borrow::Cow;
use std::fmt;

use picky::key::PrivateKey;
use winscard::SmartCard as PivSmartCard;

use crate::Result;

pub enum SmartCardApi {
    PivSmartCard(Box<PivSmartCard<'static>>),
}

impl fmt::Debug for SmartCardApi {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::PivSmartCard { .. } => f.write_str("SmartCardApi::PivSmartCard"),
        }
    }
}

#[derive(Debug)]
pub struct SmartCard {
    smart_card_type: SmartCardApi,
    pin: Vec<u8>,
}

impl SmartCard {
    // FIXME: This code will be used when support for system-provided smart cards is added
    #[allow(dead_code)]
    pub fn new_emulated(
        reader_name: Cow<'_, str>,
        pin: Vec<u8>,
        private_key_pem: &str,
        auth_cert_der: Vec<u8>,
    ) -> Result<Self> {
        let owned_reader_name = match reader_name {
            Cow::Borrowed(name) => Cow::Owned(name.to_owned()),
            Cow::Owned(name) => Cow::Owned(name),
        };
        let private_key = PrivateKey::from_pem_str(private_key_pem)?;
        let scard = PivSmartCard::new(owned_reader_name, pin.clone(), auth_cert_der, private_key)?;
        Ok(Self {
            smart_card_type: SmartCardApi::PivSmartCard(Box::new(scard)),
            pin,
        })
    }

    // FIXME: This code will be used when support for system-provided smart cards is added
    #[allow(dead_code)]
    pub fn sign(&mut self, data: impl AsRef<[u8]>) -> Result<Vec<u8>> {
        match self.smart_card_type {
            SmartCardApi::PivSmartCard(ref mut scard) => {
                scard.verify_pin(&self.pin)?;
                Ok(scard.sign_hashed(data)?)
            }
        }
    }
}


--- File: src/utils.rs ---
use byteorder::{LittleEndian, ReadBytesExt};
use picky_krb::crypto::CipherSuite;
use rand::rngs::OsRng;
use rand::Rng;

use crate::kerberos::EncryptionParams;
use crate::{BufferType, Error, ErrorKind, Result, SecurityBufferFlags, SecurityBufferRef};

pub fn string_to_utf16(value: impl AsRef<str>) -> Vec<u8> {
    value
        .as_ref()
        .encode_utf16()
        .flat_map(|i| i.to_le_bytes().to_vec())
        .collect::<Vec<u8>>()
}

pub fn bytes_to_utf16_string(mut value: &[u8]) -> String {
    let mut value_u16 = vec![0x00; value.len() / 2];
    value
        .read_u16_into::<LittleEndian>(value_u16.as_mut())
        .expect("read_u16_into cannot fail at this point");

    String::from_utf16_lossy(value_u16.as_ref())
}

#[cfg_attr(not(target_os = "windows"), allow(unused))]
pub fn is_azure_ad_domain(domain: &str) -> bool {
    domain == crate::pku2u::AZURE_AD_DOMAIN
}

pub fn utf16_bytes_to_utf8_string(data: &[u8]) -> String {
    debug_assert_eq!(data.len() % 2, 0);
    String::from_utf16_lossy(
        &data
            .chunks(2)
            .map(|c| u16::from_le_bytes(c.try_into().unwrap()))
            .collect::<Vec<u16>>(),
    )
}

pub fn generate_random_symmetric_key(cipher: &CipherSuite, rnd: &mut OsRng) -> Vec<u8> {
    let key_size = cipher.cipher().key_size();
    let mut key = Vec::with_capacity(key_size);

    for _ in 0..key_size {
        key.push(rnd.gen());
    }

    key
}

pub fn map_keb_error_code_to_sspi_error(krb_error_code: u32) -> (ErrorKind, String) {
    use picky_krb::constants::error_codes::*;

    match krb_error_code {
        KDC_ERR_NONE => (ErrorKind::Unknown, "No error".into()),
        KDC_ERR_NAME_EXP => (
            ErrorKind::InvalidParameter,
            "client's entry in database has expired".into(),
        ),
        KDC_ERR_SERVICE_EXP => (
            ErrorKind::InvalidParameter,
            "server's entry in database has expired".into(),
        ),
        KDC_ERR_BAD_PVNO => (
            ErrorKind::KdcInvalidRequest,
            "requested protocol version number not supported".into(),
        ),
        KDC_ERR_C_OLD_MAST_KVNO => (
            ErrorKind::EncryptFailure,
            "client's key encrypted in old master key".into(),
        ),
        KDC_ERR_S_OLD_MAST_KVNO => (
            ErrorKind::EncryptFailure,
            "server's key encrypted in old master key".into(),
        ),
        KDC_ERR_C_PRINCIPAL_UNKNOWN => (
            ErrorKind::UnknownCredentials,
            "client not found in Kerberos database".into(),
        ),
        KDC_ERR_S_PRINCIPAL_UNKNOWN => (
            ErrorKind::UnknownCredentials,
            "server not found in Kerberos database".into(),
        ),
        KDC_ERR_PRINCIPAL_NOT_UNIQUE => (
            ErrorKind::TooManyPrincipals,
            "multiple principal entries database".into(),
        ),
        KDC_ERR_NULL_KEY => (ErrorKind::EncryptFailure, "the client or server has null key".into()),
        KDC_ERR_CANNOT_POSTDATE => (
            ErrorKind::KdcInvalidRequest,
            "ticket not eligible for postdating".into(),
        ),
        KDC_ERR_NEVER_VALID => (
            ErrorKind::KdcInvalidRequest,
            "requested starttime is later than end time".into(),
        ),
        KDC_ERR_POLICY => (ErrorKind::KdcInvalidRequest, "KDC policy rejects request".into()),
        KDC_ERR_BADOPTION => (
            ErrorKind::KdcInvalidRequest,
            "KDC cannot accommodate request option".into(),
        ),
        KDC_ERR_ETYPE_NOSUPP => (
            ErrorKind::OperationNotSupported,
            "KDC has no support for encryption type".into(),
        ),
        KDC_ERR_SUMTYPE_NOSUPP => (
            ErrorKind::KdcInvalidRequest,
            "KDC has no support for checksum type".into(),
        ),
        KDC_ERR_PADATA_TYPE_NOSUPP => (
            ErrorKind::KdcInvalidRequest,
            "KDC has no support for padata type".into(),
        ),
        KDC_ERR_TRTYPE_NOSUPP => (
            ErrorKind::KdcInvalidRequest,
            "KDC has no support for transited type".into(),
        ),
        KDC_ERR_CLIENT_REVOKED => (
            ErrorKind::UnknownCredentials,
            "clients credentials have been revoked".into(),
        ),
        KDC_ERR_SERVICE_REVOKED => (
            ErrorKind::UnknownCredentials,
            "credentials for server have been revoked".into(),
        ),
        KDC_ERR_TGT_REVOKED => (ErrorKind::UnknownCredentials, "TGT has been revoked".into()),
        KDC_ERR_CLIENT_NOTYET => (
            ErrorKind::UnknownCredentials,
            "client not yet valid; try again later".into(),
        ),
        KDC_ERR_SERVICE_NOTYET => (
            ErrorKind::UnknownCredentials,
            "server not yet valid; try again later".into(),
        ),
        KDC_ERR_KEY_EXPIRED => (
            ErrorKind::InvalidParameter,
            "password has expired; change password to reset".into(),
        ),
        KDC_ERR_PREAUTH_FAILED => (
            ErrorKind::KdcInvalidRequest,
            "pre-authentication information was invalid".into(),
        ),
        KDC_ERR_PREAUTH_REQUIRED => (
            ErrorKind::KdcInvalidRequest,
            "additional preauthentication required".into(),
        ),
        KDC_ERR_SERVER_NOMATCH => (
            ErrorKind::KdcInvalidRequest,
            "requested server and ticket don't match".into(),
        ),
        KDC_ERR_MUST_USE_USER2USER => (
            ErrorKind::KdcInvalidRequest,
            "server principal valid for user2user only".into(),
        ),
        KDC_ERR_PATH_NOT_ACCEPTED => (ErrorKind::KdcInvalidRequest, "KDC Policy rejects transited path".into()),
        KDC_ERR_SVC_UNAVAILABLE => (ErrorKind::KdcInvalidRequest, "a service is not available".into()),
        KRB_AP_ERR_BAD_INTEGRITY => (
            ErrorKind::MessageAltered,
            "integrity check on decrypted field failed".into(),
        ),
        KRB_AP_ERR_TKT_EXPIRED => (ErrorKind::ContextExpired, "ticket expired".into()),
        KRB_AP_ERR_TKT_NYV => (ErrorKind::InvalidToken, "ticket not yet valid".into()),
        KRB_AP_ERR_REPEAT => (ErrorKind::KdcInvalidRequest, "request is a replay".into()),
        KRB_AP_ERR_NOT_US => (ErrorKind::InvalidToken, "the ticket isn't for us".into()),
        KRB_AP_ERR_BADMATCH => (
            ErrorKind::KdcInvalidRequest,
            "ticket and authenticator don't match".into(),
        ),
        KRB_AP_ERR_SKEW => (ErrorKind::TimeSkew, "clock skew too great".into()),
        KRB_AP_ERR_BADADDR => (ErrorKind::InvalidParameter, "incorrect net address".into()),
        KRB_AP_ERR_BADVERSION => (ErrorKind::KdcInvalidRequest, "protocol version mismatch".into()),
        KRB_AP_ERR_MSG_TYPE => (ErrorKind::InvalidToken, "invalid msg type".into()),
        KRB_AP_ERR_MODIFIED => (ErrorKind::MessageAltered, "message stream modified".into()),
        KRB_AP_ERR_BADORDER => (ErrorKind::OutOfSequence, "message out of order".into()),
        KRB_AP_ERR_BADKEYVER => (
            ErrorKind::KdcInvalidRequest,
            "specified version of key is not available".into(),
        ),
        KRB_AP_ERR_NOKEY => (ErrorKind::NoKerbKey, "service key not available".into()),
        KRB_AP_ERR_MUT_FAIL => (ErrorKind::MutualAuthFailed, "mutual authentication failed".into()),
        KRB_AP_ERR_BADDIRECTION => (ErrorKind::OutOfSequence, "incorrect message direction".into()),
        KRB_AP_ERR_METHOD => (
            ErrorKind::InvalidToken,
            "alternative authentication method required".into(),
        ),
        KRB_AP_ERR_BADSEQ => (ErrorKind::OutOfSequence, "incorrect sequence number in message".into()),
        KRB_AP_ERR_INAPP_CKSUM => (
            ErrorKind::InvalidToken,
            "inappropriate type of checksum in message".into(),
        ),
        KRB_AP_PATH_NOT_ACCEPTED => (ErrorKind::KdcInvalidRequest, "policy rejects transited path".into()),
        KRB_ERR_RESPONSE_TOO_BIG => (
            ErrorKind::InvalidParameter,
            "response too big for UDP; retry with TC".into(),
        ),
        KRB_ERR_GENERIC => (ErrorKind::InternalError, "generic error (description in e-text)".into()),
        KRB_ERR_FIELD_TOOLONG => (
            ErrorKind::KdcInvalidRequest,
            "field is too long for this implementation".into(),
        ),
        KDC_ERROR_CLIENT_NOT_TRUSTED => (ErrorKind::InvalidParameter, "client is not trusted".into()),
        KDC_ERROR_KDC_NOT_TRUSTED => (ErrorKind::InvalidParameter, "KDC is not trusted".into()),
        KDC_ERROR_INVALID_SIG => (ErrorKind::MessageAltered, "invalid signature".into()),
        KDC_ERR_KEY_TOO_WEAK => (ErrorKind::EncryptFailure, "key is too weak".into()),
        KDC_ERR_CERTIFICATE_MISMATCH => (ErrorKind::InvalidParameter, "certificated mismatch".into()),
        KRB_AP_ERR_NO_TGT => (
            ErrorKind::NoTgtReply,
            "no TGT available to validate USER-TO-USER".into(),
        ),
        KDC_ERR_WRONG_REALM => (ErrorKind::InvalidParameter, "wrong Realm".into()),
        KRB_AP_ERR_USER_TO_USER_REQUIRED => (ErrorKind::KdcInvalidRequest, "ticket must be for USER-TO-USER".into()),
        KDC_ERR_CANT_VERIFY_CERTIFICATE => (
            ErrorKind::KdcInvalidRequest,
            "KDC can not verify the certificate".into(),
        ),
        KDC_ERR_INVALID_CERTIFICATE => (ErrorKind::InvalidParameter, "invalid certificate".into()),
        KDC_ERR_REVOKED_CERTIFICATE => (ErrorKind::KdcCertRevoked, "revoked certificate".into()),
        KDC_ERR_REVOCATION_STATUS_UNKNOWN => (ErrorKind::InternalError, "revoked status unknown".into()),
        KDC_ERR_REVOCATION_STATUS_UNAVAILABLE => (ErrorKind::InternalError, "revoked status unavailable".into()),
        KDC_ERR_CLIENT_NAME_MISMATCH => (ErrorKind::InvalidParameter, "client name mismatch".into()),
        KDC_ERR_KDC_NAME_MISMATCH => (ErrorKind::InvalidParameter, "KDC name mismatch".into()),
        code => (ErrorKind::Unknown, format!("unknown Kerberos error: {}", code)),
    }
}

pub fn get_encryption_key(enc_params: &EncryptionParams) -> Result<&[u8]> {
    // the sub-session key is always preferred over the session key
    if let Some(key) = enc_params.sub_session_key.as_ref() {
        debug!("Encryption using sub-session key");

        Ok(key)
    } else if let Some(key) = enc_params.session_key.as_ref() {
        warn!("Encryption using session key (not sub-session key)");

        Ok(key)
    } else {
        error!("No encryption keys in the krb context. Maybe security context is not established, but encryption key is requested");

        Err(Error::new(
            ErrorKind::OutOfSequence,
            "encryption key has not been found: no security context keys have been established",
        ))
    }
}

/// Copies a decrypted data into the [BufferType::Data] or [BufferType::Stream].
///
/// There are two choices for how we should save the decrypted data in security buffers:
/// * If the `SECBUFFER_STREAM` is present, we should save all data in the `SECBUFFER_DATA` buffer.
///   But in such a case, the `SECBUFFER_DATA` buffer is empty. So, we take the inner buffer from
///   the `SECBUFFER_STREAM` buffer, write decrypted data into it, and assign it to the `SECBUFFER_DATA` buffer.
/// * If the `SECBUFFER_STREAM` is not present, we should just save all data in the `SECBUFFER_DATA` buffer.
pub fn save_decrypted_data<'a>(decrypted: &'a [u8], buffers: &'a mut [SecurityBufferRef]) -> Result<()> {
    if let Ok(buffer) = SecurityBufferRef::find_buffer_mut(buffers, BufferType::Stream) {
        let decrypted_len = decrypted.len();

        if buffer.buf_len() < decrypted_len {
            return Err(Error::new(
                ErrorKind::DecryptFailure,
                format!(
                    "decrypted data length ({}) does not match the stream buffer length ({})",
                    decrypted_len,
                    buffer.buf_len(),
                ),
            ));
        }

        let stream_buffer = buffer.take_data();
        let stream_buffer_len = stream_buffer.len();

        let data_buffer = SecurityBufferRef::find_buffer_mut(buffers, BufferType::Data)?;

        let data = &mut stream_buffer[stream_buffer_len - decrypted_len..];
        data.copy_from_slice(decrypted);

        data_buffer.set_data(data)
    } else {
        let mut data_buffers =
            SecurityBufferRef::buffers_of_type_and_flags_mut(buffers, BufferType::Data, SecurityBufferFlags::NONE);
        let data_buffer = data_buffers.next().ok_or_else(|| {
            Error::new(
                ErrorKind::InvalidToken,
                "no buffer was provided with type Data and without READONLY_WITH_CHECKSUM flag",
            )
        })?;

        if data_buffer.buf_len() < decrypted.len() {
            return Err(Error::new(
                ErrorKind::DecryptFailure,
                format!(
                    "decrypted data length ({}) does not match the data buffer length ({})",
                    decrypted.len(),
                    data_buffer.buf_len(),
                ),
            ));
        }

        data_buffer.write_data(decrypted)
    }
}

/// Extracts data to decrypt from the incoming buffers.
///
/// Data to decrypt is `Token` + `Stream`/`Data` buffers concatenated together.
pub fn extract_encrypted_data(buffers: &[SecurityBufferRef]) -> Result<Vec<u8>> {
    let mut encrypted = SecurityBufferRef::buf_data(buffers, BufferType::Token)
        .unwrap_or_default()
        .to_vec();

    encrypted.extend_from_slice(
        if let Ok(buffer) = SecurityBufferRef::buf_data(buffers, BufferType::Stream) {
            buffer
        } else {
            use crate::SecurityBufferFlags;

            // Find `Data` buffers but skip `Data` buffers with the `READONLY_WITH_CHECKSUM`/`READONLY` flag.
            SecurityBufferRef::buffers_of_type_and_flags(buffers, BufferType::Data, SecurityBufferFlags::NONE)
                .next()
                .ok_or_else(|| Error::new(ErrorKind::InvalidToken, "no buffer was provided with type Data"))?
                .data()
        },
    );

    Ok(encrypted)
}

pub fn parse_target_name(target_name: &str) -> Result<(&str, &str)> {
    let divider = target_name.find('/').ok_or_else(|| {
        Error::new(
            ErrorKind::InvalidParameter,
            "invalid service principal name: missing '/'",
        )
    })?;

    if divider == 0 || divider == target_name.len() - 1 {
        return Err(Error::new(
            ErrorKind::InvalidParameter,
            "invalid service principal name",
        ));
    }

    let service_name = &target_name[0..divider];
    // `divider + 1` - do not include '/' char
    let service_principal_name = &target_name[(divider + 1)..];

    Ok((service_name, service_principal_name))
}

#[cfg(test)]
mod tests {
    use super::parse_target_name;

    #[test]
    fn parse_valid_target_name() {
        assert_eq!(("EXAMPLE", "p10"), parse_target_name("EXAMPLE/p10").unwrap());
        assert_eq!(("E", "p10"), parse_target_name("E/p10").unwrap());
        assert_eq!(("EXAMPLE", "p"), parse_target_name("EXAMPLE/p").unwrap());
    }

    #[test]
    fn parse_invalid_target_name() {
        assert!(parse_target_name("EXAMPLEp10").is_err());
        assert!(parse_target_name("EXAMPLE/").is_err());
        assert!(parse_target_name("/p10").is_err());
        assert!(parse_target_name("/").is_err());
        assert!(parse_target_name("").is_err());
    }
}


--- File: test_assets/krb5.conf ---
[libdefaults]
        default_realm = TBT.COM

# The following krb5.conf variables are only for MIT Kerberos.
        kdc_timesync = 1
        ccache_type = 4
        forwardable = true
        proxiable = true

# The following encryption type specification will be used by MIT Kerberos
# if uncommented.  In general, the defaults in the MIT Kerberos code are
# correct and overriding these specifications only serves to disable new
# encryption types as they are added, creating interoperability problems.
#
# The only time when you might need to uncomment these lines and change
# the enctypes is if you have local software that will break on ticket
# caches containing ticket encryption types it doesn't know about (such as
# old versions of Sun Java).

#       default_tgs_enctypes = des3-hmac-sha1
#       default_tkt_enctypes = des3-hmac-sha1
#       permitted_enctypes = des3-hmac-sha1

# The following libdefaults parameters are only for Heimdal Kerberos.
        fcc-mit-ticketflags = true

[realms]
        TBT.COM = {
                kdc = WIN-956CQOSSJTF.tbt.com
                kdc = tbt.com
                admin_server = WIN-956CQOSSJTF.tbt.com
                default_domain = WIN-956CQOSSJTF.tbt.com
        }

[domain_realm]
        .tbt.com = TBT.COM
        tbt.com = TBT.COM

--- File: test_assets/pw11.cer ---
-----BEGIN CERTIFICATE-----
MIIF7DCCBNSgAwIBAgITfgAAAAj4QosOKRg46QAAAAAACDANBgkqhkiG9w0BAQsF
ADBTMRMwEQYKCZImiZPyLGQBGRYDY29tMRcwFQYKCZImiZPyLGQBGRYHZXhhbXBs
ZTEjMCEGA1UEAxMaZXhhbXBsZS1XSU4tSVZDRjQ4Nk8wM1MtQ0EwHhcNMjMwNjE5
MDkwODU1WhcNMjUwNjE5MDkxODU1WjBNMRMwEQYKCZImiZPyLGQBGRYDY29tMRcw
FQYKCZImiZPyLGQBGRYHZXhhbXBsZTEOMAwGA1UEAxMFVXNlcnMxDTALBgNVBAMT
BHB3MTEwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC89JkTzo3zAbjv
AUuicoFICUb7bLQcehCZ+lmrLmjs8eJ5TY8grD/yxLEFCmvly2Hilmjs4+Ecir1s
zZQfZ5CJI+YZ22cKNuGb4lrfDXND+lvHnry47b4nvEXbYjBR9Cj1dyCQ5hdS3PlJ
Vxbui+zbcvN3JUVV5wupXWK0PKzoB/sP+5SOyLub/3QGOJOFZvYvDJQUBoQ3HGBS
lXAzfuXJvjvkMUfB1FaD+XXHGwDJKaHDEmd4qlHHQtslfOgXq7i6rYG3gM42VKRu
By7c1udTR9Mzw42mbKNvkrp87NR+fP0YtAGwtHLkxSpyNu71tzt1vIEkZg9Kqgk3
oYFibu3JAgMBAAGjggK9MIICuTA8BgkrBgEEAYI3FQcELzAtBiUrBgEEAYI3FQiE
wbxjg/SXIIe1lRWE8OQ+h7mXUk6DnepVnL1uAgFkAgECMB8GA1UdJQQYMBYGCisG
AQQBgjcUAgIGCCsGAQUFBwMCMA4GA1UdDwEB/wQEAwIFoDApBgkrBgEEAYI3FQoE
HDAaMAwGCisGAQQBgjcUAgIwCgYIKwYBBQUHAwIwHQYDVR0OBBYEFERdkI6e2JjU
60OG3MWhEcnNMbcaMB8GA1UdIwQYMBaAFEnLXthGACosdnBKTWb6r4Z75rlnMIHg
BgNVHR8EgdgwgdUwgdKggc+ggcyGgclsZGFwOi8vL0NOPWV4YW1wbGUtV0lOLUlW
Q0Y0ODZPMDNTLUNBLENOPVdJTi1JVkNGNDg2TzAzUyxDTj1DRFAsQ049UHVibGlj
JTIwS2V5JTIwU2VydmljZXMsQ049U2VydmljZXMsQ049Q29uZmlndXJhdGlvbixE
Qz1leGFtcGxlLERDPWNvbT9jZXJ0aWZpY2F0ZVJldm9jYXRpb25MaXN0P2Jhc2U/
b2JqZWN0Q2xhc3M9Y1JMRGlzdHJpYnV0aW9uUG9pbnQwgcwGCCsGAQUFBwEBBIG/
MIG8MIG5BggrBgEFBQcwAoaBrGxkYXA6Ly8vQ049ZXhhbXBsZS1XSU4tSVZDRjQ4
Nk8wM1MtQ0EsQ049QUlBLENOPVB1YmxpYyUyMEtleSUyMFNlcnZpY2VzLENOPVNl
cnZpY2VzLENOPUNvbmZpZ3VyYXRpb24sREM9ZXhhbXBsZSxEQz1jb20/Y0FDZXJ0
aWZpY2F0ZT9iYXNlP29iamVjdENsYXNzPWNlcnRpZmljYXRpb25BdXRob3JpdHkw
KwYDVR0RBCQwIqAgBgorBgEEAYI3FAIDoBIMEHB3MTFAZXhhbXBsZS5jb20wDQYJ
KoZIhvcNAQELBQADggEBAEjdKUfHodjVNJheABu6TyPL3gL0+S355EMYDpTU6ho0
6+a1IWDbR5vUZMePzc8Ow4DW7V/GybwS8PcDMsK+MsVhLL4KB/uP0BFNUPjHjJno
i1tmt4C5YpqjPW3biFvIOSjtuZ49t1xbkmj9SO2cc8/mOmCI9WN/sX8Y0JXOnD7y
1XE6oQUxKNjEaN7aJ3juvsFsxBhGB8FH2DjOqMLykOlu26lJQCmLBSWoNCWR3J1N
F1Eu/p5VLx6ivM739+AAVT7ZzkPFjBbk4fkmSCw9MGV1Vk8Vp8elMFyD3j1QA1gP
smepITG7yGbxcn8ct4dmvew/73ebjk7YA8WhHVeWKhc=
-----END CERTIFICATE-----


--- File: tests/sspi/client_server/credssp.rs ---
use std::collections::HashSet;
use std::mem;

use picky_krb::gss_api::MechTypeList;
use sspi::credssp::{
    ClientMode, ClientState, CredSspClient, CredSspMode, CredSspServer, ServerMode, ServerState, TsRequest,
};
use sspi::kerberos::ServerProperties;
use sspi::network_client::NetworkClient;
use sspi::ntlm::NtlmConfig;
use sspi::{AuthIdentity, Credentials, CredentialsBuffers, KerberosConfig, Secret, Username};
use url::Url;

use super::kerberos::kdc::{KdcMock, Validators, CLIENT_COMPUTER_NAME, KDC_URL, MAX_TIME_SKEW};
use super::kerberos::network_client::NetworkClientMock;
use super::kerberos::{init_krb_environment, KrbEnvironment};
use crate::common::CredentialsProxyImpl;

const PUBLIC_KEY: &[u8] = &[
    48, 130, 2, 34, 48, 13, 6, 9, 42, 134, 72, 134, 247, 13, 1, 1, 1, 5, 0, 3, 130, 2, 15, 0, 48, 130, 2, 10, 2, 130,
    2, 1, 0, 153, 85, 210, 206, 231, 176, 16, 84, 146, 20, 255, 201, 74, 62, 122, 183, 157, 210, 202, 111, 17, 50, 30,
    181, 14, 13, 193, 242, 152, 41, 178, 93, 237, 151, 133, 122, 29, 233, 73, 139, 182, 23, 93, 149, 119, 56, 5, 156,
    180, 217, 84, 109, 88, 242, 117, 103, 167, 173, 81, 14, 171, 69, 18, 6, 149, 163, 35, 39, 128, 183, 73, 157, 200,
    229, 17, 156, 115, 197, 187, 141, 211, 156, 148, 207, 94, 14, 119, 210, 166, 59, 242, 214, 224, 159, 51, 41, 55,
    78, 250, 170, 175, 133, 213, 24, 173, 39, 234, 10, 216, 60, 238, 204, 157, 149, 186, 144, 203, 231, 241, 239, 41,
    118, 35, 14, 245, 183, 29, 229, 209, 198, 182, 174, 34, 66, 146, 20, 214, 109, 119, 19, 8, 207, 231, 222, 119, 155,
    192, 76, 15, 221, 210, 78, 132, 112, 33, 213, 87, 153, 25, 38, 190, 161, 178, 130, 108, 140, 75, 75, 22, 74, 28, 0,
    164, 72, 103, 14, 57, 202, 58, 91, 94, 235, 177, 68, 209, 252, 254, 173, 97, 101, 156, 128, 139, 58, 140, 226, 73,
    26, 232, 234, 178, 220, 193, 89, 196, 236, 89, 173, 235, 92, 39, 13, 1, 0, 93, 43, 252, 89, 236, 123, 140, 108,
    144, 215, 171, 46, 211, 144, 236, 202, 59, 87, 177, 225, 162, 70, 144, 109, 113, 237, 2, 152, 115, 52, 166, 112,
    249, 30, 53, 62, 239, 228, 226, 97, 56, 246, 27, 64, 43, 153, 195, 79, 176, 38, 178, 188, 192, 207, 0, 179, 255,
    17, 173, 250, 152, 140, 8, 198, 9, 2, 50, 151, 16, 176, 125, 175, 161, 118, 185, 166, 34, 217, 189, 160, 27, 145,
    91, 113, 71, 71, 220, 4, 195, 210, 242, 185, 14, 108, 61, 61, 5, 45, 27, 38, 56, 245, 49, 55, 196, 230, 22, 8, 155,
    27, 3, 79, 252, 108, 199, 189, 29, 98, 220, 118, 212, 5, 0, 129, 59, 110, 131, 188, 159, 249, 56, 37, 69, 106, 185,
    215, 38, 54, 36, 196, 28, 39, 81, 27, 255, 249, 155, 197, 237, 125, 92, 147, 108, 248, 238, 115, 101, 170, 27, 203,
    193, 180, 33, 146, 208, 216, 113, 174, 158, 84, 100, 32, 200, 49, 30, 28, 31, 112, 247, 68, 190, 181, 247, 54, 117,
    131, 215, 100, 13, 170, 52, 12, 137, 61, 253, 114, 120, 116, 124, 238, 3, 234, 95, 242, 208, 224, 96, 132, 150,
    152, 186, 81, 85, 50, 179, 216, 191, 125, 25, 148, 232, 235, 234, 193, 150, 186, 41, 18, 38, 220, 144, 104, 97,
    127, 215, 215, 49, 92, 81, 21, 232, 67, 145, 164, 179, 156, 220, 175, 154, 70, 144, 218, 31, 106, 84, 78, 218, 238,
    15, 29, 207, 34, 33, 68, 121, 213, 114, 203, 80, 32, 42, 224, 115, 86, 161, 42, 78, 246, 183, 203, 213, 198, 110,
    71, 22, 137, 164, 4, 163, 206, 239, 57, 197, 112, 179, 191, 160, 5, 2, 3, 1, 0, 1,
];

fn run_credssp(
    client: &mut CredSspClient,
    server: &mut CredSspServer<CredentialsProxyImpl<'_>>,
    auth_identity: &AuthIdentity,
    network_client: &mut dyn NetworkClient,
) {
    let mut ts_request = TsRequest::default();

    for _ in 0..4 {
        ts_request = match client
            .process(mem::take(&mut ts_request))
            .resolve_with_client(network_client)
            .unwrap()
        {
            ClientState::ReplyNeeded(ts_request) => ts_request,
            ClientState::FinalMessage(ts_request) => ts_request,
        };

        match server.process(ts_request).resolve_with_client(network_client).unwrap() {
            ServerState::ReplyNeeded(server_ts_request) => ts_request = server_ts_request,
            ServerState::Finished(received_auth_identity) => {
                assert_eq!(*auth_identity, received_auth_identity);
                return;
            }
        };
    }

    panic!("CredSSP authentication should not exceed 4 steps")
}

#[test]
fn credssp_ntlm() {
    let auth_identity = AuthIdentity {
        username: Username::parse("test_user").unwrap(),
        password: Secret::from("test_password".to_owned()),
    };
    let credentials = Credentials::AuthIdentity(auth_identity.clone());

    let mut client = CredSspClient::new(
        PUBLIC_KEY.to_vec(),
        credentials.clone(),
        CredSspMode::WithCredentials,
        ClientMode::Ntlm(NtlmConfig {
            client_computer_name: Some("DESKTOP-3D83IAN.example.com".to_owned()),
        }),
        "TERMSRV/DESKTOP-8F33RFH.example.com".to_owned(),
    )
    .unwrap();

    let mut server = CredSspServer::new(
        PUBLIC_KEY.to_vec(),
        CredentialsProxyImpl::new(&auth_identity),
        ServerMode::Ntlm(NtlmConfig {
            client_computer_name: Some("DESKTOP-3D83IAN.example.com".to_owned()),
        }),
    )
    .unwrap();

    let mut network_client = NetworkClientMock { kdc: KdcMock::empty() };

    run_credssp(&mut client, &mut server, &auth_identity, &mut network_client);
}

#[test]
fn credssp_kerberos() {
    let KrbEnvironment {
        realm,
        credentials,
        keys,
        users,
        target_name,
        target_service_name,
    } = init_krb_environment();
    let auth_identity = credentials.clone().auth_identity().unwrap();

    let kdc = KdcMock::new(realm, keys, users, Validators::default());
    let mut network_client = NetworkClientMock { kdc };

    let client_config = KerberosConfig {
        kdc_url: Some(Url::parse(KDC_URL).unwrap()),
        client_computer_name: Some(CLIENT_COMPUTER_NAME.into()),
    };

    let server_config = KerberosConfig {
        kdc_url: Some(Url::parse(KDC_URL).unwrap()),
        client_computer_name: Some(CLIENT_COMPUTER_NAME.into()),
    };
    let server_properties = ServerProperties {
        mech_types: MechTypeList::from(Vec::new()),
        max_time_skew: MAX_TIME_SKEW,
        ticket_decryption_key: None,
        service_name: target_service_name,
        user: Some(CredentialsBuffers::try_from(credentials.clone()).unwrap()),
        client: None,
        authenticators_cache: HashSet::new(),
    };

    let mut client = CredSspClient::new(
        PUBLIC_KEY.to_vec(),
        credentials,
        CredSspMode::WithCredentials,
        ClientMode::Kerberos(client_config),
        target_name,
    )
    .unwrap();

    let mut server = CredSspServer::new(
        PUBLIC_KEY.to_vec(),
        CredentialsProxyImpl::new(&auth_identity),
        ServerMode::Kerberos(Box::new((server_config, server_properties))),
    )
    .unwrap();

    run_credssp(&mut client, &mut server, &auth_identity, &mut network_client);
}


--- File: tests/sspi/client_server/kerberos/kdc.rs ---
use std::collections::HashMap;
use std::hash::{Hash, Hasher};
use std::time::Duration as StdDuration;

use picky_asn1::date::GeneralizedTime;
use picky_asn1::restricted_string::IA5String;
use picky_asn1::wrapper::{
    Asn1SequenceOf, ExplicitContextTag0, ExplicitContextTag1, ExplicitContextTag10, ExplicitContextTag12,
    ExplicitContextTag2, ExplicitContextTag3, ExplicitContextTag4, ExplicitContextTag5, ExplicitContextTag6,
    ExplicitContextTag7, ExplicitContextTag9, IntegerAsn1, OctetStringAsn1, Optional,
};
use picky_krb::constants::error_codes::{KDC_ERR_PREAUTH_FAILED, KDC_ERR_PREAUTH_REQUIRED};
use picky_krb::constants::etypes::AES256_CTS_HMAC_SHA1_96;
use picky_krb::constants::key_usages::{
    AS_REP_ENC, TGS_REP_ENC_SESSION_KEY, TGS_REP_ENC_SUB_KEY, TGS_REQ_PA_DATA_AP_REQ_AUTHENTICATOR, TICKET_REP,
};
use picky_krb::constants::types::{
    AS_REP_MSG_TYPE, KRB_ERROR_MSG_TYPE, PA_ENC_TIMESTAMP, PA_ENC_TIMESTAMP_KEY_USAGE, PA_ETYPE_INFO2_TYPE,
    PA_TGS_REQ_TYPE, TGS_REP_MSG_TYPE,
};
use picky_krb::crypto::CipherSuite;
use picky_krb::data_types::{
    Authenticator, EncTicketPart, EncTicketPartInner, EncryptedData, EncryptionKey, EtypeInfo2Entry, KerberosFlags,
    KerberosStringAsn1, KerberosTime, LastReq, LastReqInner, Microseconds, PaData, PaEncTsEnc, PrincipalName, Realm,
    Ticket, TicketInner, TransitedEncoding,
};
use picky_krb::messages::{
    ApReq, ApReqInner, AsRep, AsReq, EncAsRepPart, EncKdcRepPart, EncTgsRepPart, KdcRep, KdcReq, KdcReqBody, KrbError,
    KrbErrorInner, TgsRep, TgsReq,
};
use rand::rngs::OsRng;
use rand::{Rng, RngCore};
use sspi::kerberos::KERBEROS_VERSION;
use time::{Duration, OffsetDateTime};

pub const MAX_TIME_SKEW: StdDuration = StdDuration::from_secs(3);
pub const KDC_URL: &str = "tcp://192.168.1.103:88";
pub const CLIENT_COMPUTER_NAME: &str = "DESKTOP-8F33RFH.example.com";

/// Represents user credentials in the internal KDC database.
pub struct PasswordCreds {
    /// User's password.
    pub password: Vec<u8>,
    /// Salt for deriving the encryption key.
    pub salt: String,
}

/// Represents user name in the internal KDC database.
///
/// We created a wrapper type because [PrincipalName] does not
/// implement the [Hash] trait.
#[derive(Debug, PartialEq, Eq, Clone)]
pub struct UserName(pub PrincipalName);

impl Hash for UserName {
    fn hash<H>(&self, state: &mut H)
    where
        H: Hasher,
    {
        self.0.name_type.0 .0.hash(state);
        self.0.name_string.0 .0.iter().for_each(|s| s.0.hash(state))
    }
}

/// Collection of validators of incoming Kerberos messages.
///
/// The user can provide customs validators to check messages generated by our Kerberos implementation.
pub struct Validators {
    /// Closure that validates the incoming AsReq message.
    pub as_req: Box<dyn Fn(&AsReq) + Send + Sync>,
    /// Closure that validates the incoming TgsReq message.
    pub tgs_req: Box<dyn Fn(&TgsReq) + Send + Sync>,
}

impl Default for Validators {
    fn default() -> Self {
        Self {
            as_req: Box::new(|_| {}),
            tgs_req: Box::new(|_| {}),
        }
    }
}

/// Simple mock of the KDC server.
///
/// We use it to test our Kerberos implementation.
/// This KDC implementation performs only small amount of all possible checks on
/// the incoming Kerberos messages: encryption keys + key usage number usage
/// and some mandatory fields like `pa-datas`.
/// All other validations like checking user/service names should be done separately. See [Validators] structure for more details.
#[derive(Default)]
pub struct KdcMock {
    /// Domain's Kerberos realm.
    realm: String,
    /// Represents Kerberos long-term keys.
    keys: HashMap<UserName, Vec<u8>>,
    /// Represents users credentials.
    users: HashMap<UserName, PasswordCreds>,
    /// Incoming Kerberos messages validators.
    validators: Validators,
}

impl KdcMock {
    /// Returns empty [KdcMock].
    ///
    /// Methods of the returned [KdcMock] should never be called. It can only be used for mocking in tests
    /// where KDC is not needed but there is a necessary to provide [NetworkClient] because of the API.
    pub fn empty() -> Self {
        Self::default()
    }

    /// Creates a new [KdcMock].
    pub fn new(
        realm: String,
        keys: HashMap<UserName, Vec<u8>>,
        users: HashMap<UserName, PasswordCreds>,
        validators: Validators,
    ) -> Self {
        Self {
            realm,
            keys,
            users,
            validators,
        }
    }

    fn make_err<const ERROR_CODE: u32>(sname: PrincipalName, realm: Realm, salt: Option<String>) -> KrbError {
        let current_date = OffsetDateTime::now_utc();
        // https://www.rfc-editor.org/rfc/rfc4120#section-5.2.4
        // Microseconds    ::= INTEGER (0..999999)
        let microseconds = current_date.microsecond().min(999_999);

        KrbError::from(KrbErrorInner {
            pvno: ExplicitContextTag0::from(IntegerAsn1(vec![KERBEROS_VERSION])),
            msg_type: ExplicitContextTag1::from(IntegerAsn1::from(vec![KRB_ERROR_MSG_TYPE])),
            ctime: Optional::from(None),
            cusec: Optional::from(None),
            stime: ExplicitContextTag4::from(KerberosTime::from(GeneralizedTime::from(current_date))),
            susec: ExplicitContextTag5::from(Microseconds::from(microseconds.to_be_bytes().to_vec())),
            error_code: ExplicitContextTag6::from(ERROR_CODE),
            crealm: Optional::from(None),
            cname: Optional::from(None),
            realm: ExplicitContextTag9::from(realm),
            sname: ExplicitContextTag10::from(sname),
            e_text: Optional::from(None),
            e_data: Optional::from(Some(ExplicitContextTag12::from(OctetStringAsn1::from(
                picky_asn1_der::to_vec(&Asn1SequenceOf::from(if let Some(salt) = salt {
                    vec![
                        PaData {
                            padata_type: ExplicitContextTag1::from(IntegerAsn1::from(PA_ETYPE_INFO2_TYPE.to_vec())),
                            padata_data: ExplicitContextTag2::from(OctetStringAsn1::from(
                                picky_asn1_der::to_vec(&Asn1SequenceOf::from(vec![EtypeInfo2Entry {
                                    etype: ExplicitContextTag0::from(IntegerAsn1::from(vec![
                                        AES256_CTS_HMAC_SHA1_96 as u8,
                                    ])),
                                    salt: Optional::from(Some(ExplicitContextTag1::from(KerberosStringAsn1::from(
                                        IA5String::from_string(salt).unwrap(),
                                    )))),
                                    s2kparams: Optional::from(None),
                                }]))
                                .unwrap(),
                            )),
                        },
                        PaData {
                            padata_type: ExplicitContextTag1::from(IntegerAsn1::from(PA_ENC_TIMESTAMP.to_vec())),
                            padata_data: ExplicitContextTag2::from(OctetStringAsn1::from(Vec::new())),
                        },
                    ]
                } else {
                    Vec::new()
                }))
                .unwrap(),
            )))),
        })
    }

    fn validate_timestamp(
        creds: &PasswordCreds,
        sname: PrincipalName,
        realm: Realm,
        pa_datas: &Asn1SequenceOf<PaData>,
    ) -> Result<Vec<u8>, KrbError> {
        macro_rules! err_preauth {
            (failed) => {
                Self::make_err::<{ KDC_ERR_PREAUTH_FAILED }>(sname.clone(), realm.clone(), Some(creds.salt.clone()))
            };
            (required) => {
                Self::make_err::<{ KDC_ERR_PREAUTH_REQUIRED }>(sname.clone(), realm.clone(), Some(creds.salt.clone()))
            };
        }

        let enc_data: EncryptedData = picky_asn1_der::from_bytes(
            &pa_datas
                .0
                .iter()
                .find(|pa_data| pa_data.padata_type.0 .0 == PA_ENC_TIMESTAMP)
                .ok_or_else(|| err_preauth!(required))?
                .padata_data
                .0
                 .0,
        )
        .map_err(|_| err_preauth!(failed))?;

        let cipher = CipherSuite::try_from(enc_data.etype.0 .0.as_slice())
            .map_err(|_| err_preauth!(failed))?
            .cipher();

        let key = cipher
            .generate_key_from_password(&creds.password, creds.salt.as_bytes())
            .unwrap();

        let timestamp: PaEncTsEnc = picky_asn1_der::from_bytes(
            &cipher
                .decrypt(&key, PA_ENC_TIMESTAMP_KEY_USAGE, &enc_data.cipher.0 .0)
                .map_err(|_| err_preauth!(failed))?,
        )
        .map_err(|_| err_preauth!(failed))?;

        let kdc_timestamp = OffsetDateTime::now_utc();
        let client_timestamp = OffsetDateTime::try_from(timestamp.patimestamp.0 .0)
            .map_err(|_| err_preauth!(failed))
            .map_err(|_| err_preauth!(failed))?;

        if client_timestamp > kdc_timestamp || kdc_timestamp - client_timestamp > MAX_TIME_SKEW {
            return Err(err_preauth!(failed));
        }

        Ok(key)
    }

    fn make_ticket(
        realm: KerberosStringAsn1,
        session_key: Vec<u8>,
        service_key: &[u8],
        kdc_options: KerberosFlags,
        sname: PrincipalName,
        cname: PrincipalName,
    ) -> Ticket {
        let auth_time = OffsetDateTime::now_utc();
        let end_time = auth_time + Duration::days(1);

        let ticket_enc_part = EncTicketPart::from(EncTicketPartInner {
            flags: ExplicitContextTag0::from(kdc_options.clone()),
            key: ExplicitContextTag1::from(EncryptionKey {
                key_type: ExplicitContextTag0::from(IntegerAsn1::from(vec![18])),
                key_value: ExplicitContextTag1::from(OctetStringAsn1::from(session_key)),
            }),
            crealm: ExplicitContextTag2::from(realm.clone()),
            cname: ExplicitContextTag3::from(cname),
            transited: ExplicitContextTag4::from(TransitedEncoding {
                // the client is unable to check these fields, so we can put any values we want
                tr_type: ExplicitContextTag0::from(IntegerAsn1::from(vec![0])),
                contents: ExplicitContextTag1::from(OctetStringAsn1::from(vec![1])),
            }),
            auth_time: ExplicitContextTag5::from(KerberosTime::from(GeneralizedTime::from(auth_time))),
            starttime: Optional::from(None),
            endtime: ExplicitContextTag7::from(KerberosTime::from(GeneralizedTime::from(end_time))),
            renew_till: Optional::from(None),
            caddr: Optional::from(None),
            authorization_data: Optional::from(None),
        });

        let ticket_enc_data = CipherSuite::Aes256CtsHmacSha196
            .cipher()
            .encrypt(
                service_key,
                TICKET_REP,
                &picky_asn1_der::to_vec(&ticket_enc_part).unwrap(),
            )
            .unwrap();

        Ticket::from(TicketInner {
            tkt_vno: ExplicitContextTag0::from(IntegerAsn1::from(vec![KERBEROS_VERSION])),
            realm: ExplicitContextTag1::from(realm),
            sname: ExplicitContextTag2::from(sname),
            enc_part: ExplicitContextTag3::from(EncryptedData {
                etype: ExplicitContextTag0::from(IntegerAsn1::from(vec![AES256_CTS_HMAC_SHA1_96 as u8])),
                kvno: Optional::from(None),
                cipher: ExplicitContextTag2::from(OctetStringAsn1::from(ticket_enc_data)),
            }),
        })
    }

    /// Performs AS exchange according to the RFC.
    ///
    /// https://www.rfc-editor.org/rfc/rfc4120#section-3.1
    pub fn as_exchange(&self, as_req: AsReq) -> Result<AsRep, KrbError> {
        (self.validators.as_req)(&as_req);

        let KdcReq {
            pvno: _,
            msg_type: _,
            padata,
            req_body,
        } = as_req.0;
        let KdcReqBody {
            kdc_options,
            cname,
            realm,
            sname,
            from: _,
            till: _,
            rtime: _,
            nonce: _,
            etype: _,
            addresses: _,
            enc_authorization_data: _,
            additional_tickets: _,
        } = req_body.0;

        let sname = sname.0.expect("sname must present in AsReq").0;
        let service_key = self
            .keys
            .get(&UserName(sname.clone()))
            .expect("service's key must present in KDC database");
        let realm = realm.0;
        let username = UserName(cname.0.expect("cname is missing in AsReq").0);
        let creds = self
            .users
            .get(&username)
            .expect("user's credentials is not found in KDC database");

        Self::validate_timestamp(
            creds,
            sname.clone(),
            realm.clone(),
            &padata
                .0
                .ok_or_else(|| {
                    Self::make_err::<{ KDC_ERR_PREAUTH_REQUIRED }>(sname.clone(), realm, Some(creds.salt.clone()))
                })?
                .0,
        )?;

        let cipher = CipherSuite::Aes256CtsHmacSha196.cipher();

        let mut rng = OsRng;
        let mut session_key = vec![0; cipher.key_size()];
        rng.fill_bytes(&mut session_key);

        let initial_key = cipher
            .generate_key_from_password(&creds.password, creds.salt.as_bytes())
            .unwrap();

        let auth_time = OffsetDateTime::now_utc();
        let end_time = auth_time + Duration::days(1);
        let realm = Realm::from(IA5String::from_string(self.realm.clone()).unwrap());

        let as_rep_enc_part = EncAsRepPart::from(EncKdcRepPart {
            key: ExplicitContextTag0::from(EncryptionKey {
                key_type: ExplicitContextTag0::from(IntegerAsn1::from(vec![AES256_CTS_HMAC_SHA1_96 as u8])),
                key_value: ExplicitContextTag1::from(OctetStringAsn1::from(session_key.to_vec())),
            }),
            last_req: ExplicitContextTag1::from(LastReq::from(vec![LastReqInner {
                lr_type: ExplicitContextTag0::from(IntegerAsn1::from(vec![0])),
                lr_value: ExplicitContextTag1::from(KerberosTime::from(GeneralizedTime::from(
                    auth_time - Duration::hours(1),
                ))),
            }])),
            nonce: ExplicitContextTag2::from(IntegerAsn1::from(rng.gen::<u32>().to_be_bytes().to_vec())),
            key_expiration: Optional::from(None),
            flags: ExplicitContextTag4::from(kdc_options.0.clone()),
            auth_time: ExplicitContextTag5::from(KerberosTime::from(GeneralizedTime::from(auth_time))),
            start_time: Optional::from(None),
            end_time: ExplicitContextTag7::from(KerberosTime::from(GeneralizedTime::from(end_time))),
            renew_till: Optional::from(None),
            srealm: ExplicitContextTag9::from(realm.clone()),
            sname: ExplicitContextTag10::from(sname.clone()),
            caadr: Optional::from(None),
            encrypted_pa_data: Optional::from(None),
        });
        let as_rep_enc_data = cipher
            .encrypt(
                &initial_key,
                AS_REP_ENC,
                &picky_asn1_der::to_vec(&as_rep_enc_part).unwrap(),
            )
            .unwrap();

        Ok(AsRep::from(KdcRep {
            pvno: ExplicitContextTag0::from(IntegerAsn1::from(vec![KERBEROS_VERSION])),
            msg_type: ExplicitContextTag1::from(IntegerAsn1::from(vec![AS_REP_MSG_TYPE])),
            padata: Optional::from(Some(ExplicitContextTag2::from(Asn1SequenceOf::from(vec![PaData {
                padata_type: ExplicitContextTag1::from(IntegerAsn1::from(PA_ETYPE_INFO2_TYPE.to_vec())),
                padata_data: ExplicitContextTag2::from(OctetStringAsn1::from(
                    picky_asn1_der::to_vec(&Asn1SequenceOf::from(vec![EtypeInfo2Entry {
                        etype: ExplicitContextTag0::from(IntegerAsn1::from(vec![AES256_CTS_HMAC_SHA1_96 as u8])),
                        salt: Optional::from(Some(ExplicitContextTag1::from(KerberosStringAsn1::from(
                            IA5String::from_string(creds.salt.clone()).unwrap(),
                        )))),
                        s2kparams: Optional::from(None),
                    }]))
                    .unwrap(),
                )),
            }])))),
            crealm: ExplicitContextTag3::from(realm.clone()),
            cname: ExplicitContextTag4::from(username.0.clone()),
            ticket: ExplicitContextTag5::from(Self::make_ticket(
                realm,
                session_key,
                service_key,
                kdc_options.0,
                sname,
                username.0,
            )),
            enc_part: ExplicitContextTag6::from(EncryptedData {
                etype: ExplicitContextTag0::from(IntegerAsn1::from(vec![AES256_CTS_HMAC_SHA1_96 as u8])),
                kvno: Optional::from(None),
                cipher: ExplicitContextTag2::from(OctetStringAsn1::from(as_rep_enc_data)),
            }),
        }))
    }

    fn tgs_preauth(
        &self,
        sname: PrincipalName,
        realm: Realm,
        pa_datas: &Asn1SequenceOf<PaData>,
    ) -> Result<(Vec<u8>, PrincipalName, i32), KrbError> {
        macro_rules! err_preauth {
            (failed) => {
                Self::make_err::<{ KDC_ERR_PREAUTH_FAILED }>(sname.clone(), realm.clone(), None)
            };
            (required) => {
                Self::make_err::<{ KDC_ERR_PREAUTH_REQUIRED }>(sname.clone(), realm.clone(), None)
            };
        }

        let ap_req: ApReq = picky_asn1_der::from_bytes(
            &pa_datas
                .0
                .iter()
                .find(|pa_data| pa_data.padata_type.0 .0 == PA_TGS_REQ_TYPE)
                .ok_or_else(|| err_preauth!(required))?
                .padata_data
                .0
                 .0,
        )
        .map_err(|_| err_preauth!(failed))?;

        let ApReqInner {
            pvno: _,
            msg_type: _,
            ap_options: _,
            ticket,
            authenticator,
        } = ap_req.0;
        let TicketInner {
            sname: ticket_sname,
            enc_part: ticket_enc_data,
            ..
        } = ticket.0 .0;

        let cipher = CipherSuite::try_from(ticket_enc_data.etype.0 .0.as_slice())
            .map_err(|_| err_preauth!(failed))?
            .cipher();

        let service_key = self
            .keys
            .get(&UserName(ticket_sname.0))
            .expect("service's key must present in KDC database");
        let ticket_enc_part: EncTicketPart = picky_asn1_der::from_bytes(
            &cipher
                .decrypt(service_key, TICKET_REP, &ticket_enc_data.cipher.0 .0)
                .expect("TGS REQ - TGT Ticket decryption should not fail"),
        )
        .expect("TGT Ticket enc part decoding should not fail");

        let EncTicketPartInner { key, cname, .. } = ticket_enc_part.0;
        let session_key = key.0.key_value.0 .0;

        let authenticator_enc_data = authenticator.0;
        let cipher = CipherSuite::try_from(authenticator_enc_data.etype.0 .0.as_slice())
            .map_err(|_| err_preauth!(failed))?
            .cipher();

        let authenticator: Authenticator = picky_asn1_der::from_bytes(
            &cipher
                .decrypt(
                    &session_key,
                    TGS_REQ_PA_DATA_AP_REQ_AUTHENTICATOR,
                    &authenticator_enc_data.cipher.0 .0,
                )
                .expect("TGS REQ - Authenticator decryption should no fail"),
        )
        .expect("Authenticator decoding should not fail");

        Ok(if let Some(key) = authenticator.0.subkey.0 {
            (key.0.key_value.0 .0, cname.0, TGS_REP_ENC_SUB_KEY)
        } else {
            (session_key, cname.0, TGS_REP_ENC_SESSION_KEY)
        })
    }

    /// Performs TGS exchange according to the RFC.
    ///
    /// https://www.rfc-editor.org/rfc/rfc4120#section-3.3
    pub fn tgs_exchange(&self, tgs_req: TgsReq) -> Result<TgsRep, KrbError> {
        (self.validators.tgs_req)(&tgs_req);

        let KdcReq {
            pvno: _,
            msg_type: _,
            padata,
            req_body,
        } = tgs_req.0;
        let KdcReqBody {
            kdc_options,
            cname: _,
            realm: _,
            sname,
            from: _,
            till: _,
            rtime: _,
            nonce: _,
            etype: _,
            addresses: _,
            enc_authorization_data: _,
            additional_tickets,
        } = req_body.0;

        let sname = sname.0.expect("sname must present in TgsReq").0;
        let realm = Realm::from(IA5String::from_string(self.realm.clone()).unwrap());
        let (initial_key, cname, tgs_rep_key_usage) = self.tgs_preauth(
            sname.clone(),
            realm.clone(),
            &padata
                .0
                .ok_or_else(|| Self::make_err::<{ KDC_ERR_PREAUTH_REQUIRED }>(sname.clone(), realm.clone(), None))?
                .0,
        )?;

        let ticket_enc_key = if let Some(tgt_ticket) = additional_tickets.0 {
            let TicketInner { sname, enc_part, .. } = tgt_ticket
                .0
                 .0
                .into_iter()
                .next()
                .expect("array of additional tickets must not be empty")
                .0;
            let key = self
                .keys
                .get(&UserName(sname.0))
                .expect("service's key must present in KDC database");
            let EncryptedData {
                etype,
                cipher: ticket_enc_data,
                kvno: _,
            } = enc_part.0;

            let cipher = CipherSuite::try_from(etype.0 .0.as_slice())
                .expect("ticket etype should be valid")
                .cipher();

            let ticket_enc_part: EncTicketPart =
                picky_asn1_der::from_bytes(&cipher.decrypt(key, TICKET_REP, &ticket_enc_data.0 .0).unwrap())
                    .expect("TGT Ticket enc part decoding should not fail");
            ticket_enc_part.0.key.0.key_value.0 .0
        } else {
            self.keys
                .get(&UserName(sname.clone()))
                .expect("service's key must present in KDC database")
                .to_vec()
        };

        let cipher = CipherSuite::Aes256CtsHmacSha196.cipher();

        let mut rng = OsRng;
        let mut session_key = vec![0; cipher.key_size()];
        rng.fill_bytes(&mut session_key);

        let auth_time = OffsetDateTime::now_utc();
        let end_time = auth_time + Duration::days(1);

        let tgs_rep_enc_part = EncTgsRepPart::from(EncKdcRepPart {
            key: ExplicitContextTag0::from(EncryptionKey {
                key_type: ExplicitContextTag0::from(IntegerAsn1::from(vec![AES256_CTS_HMAC_SHA1_96 as u8])),
                key_value: ExplicitContextTag1::from(OctetStringAsn1::from(session_key.to_vec())),
            }),
            last_req: ExplicitContextTag1::from(LastReq::from(vec![LastReqInner {
                lr_type: ExplicitContextTag0::from(IntegerAsn1::from(vec![0])),
                lr_value: ExplicitContextTag1::from(KerberosTime::from(GeneralizedTime::from(
                    auth_time - Duration::hours(1),
                ))),
            }])),
            nonce: ExplicitContextTag2::from(IntegerAsn1::from(rng.gen::<u32>().to_be_bytes().to_vec())),
            key_expiration: Optional::from(None),
            flags: ExplicitContextTag4::from(kdc_options.0.clone()),
            auth_time: ExplicitContextTag5::from(KerberosTime::from(GeneralizedTime::from(auth_time))),
            start_time: Optional::from(None),
            end_time: ExplicitContextTag7::from(KerberosTime::from(GeneralizedTime::from(end_time))),
            renew_till: Optional::from(None),
            srealm: ExplicitContextTag9::from(realm.clone()),
            sname: ExplicitContextTag10::from(sname.clone()),
            caadr: Optional::from(None),
            encrypted_pa_data: Optional::from(None),
        });
        let tgs_rep_enc_data = cipher
            .encrypt(
                &initial_key,
                tgs_rep_key_usage,
                &picky_asn1_der::to_vec(&tgs_rep_enc_part).unwrap(),
            )
            .unwrap();

        Ok(TgsRep::from(KdcRep {
            pvno: ExplicitContextTag0::from(IntegerAsn1::from(vec![KERBEROS_VERSION])),
            msg_type: ExplicitContextTag1::from(IntegerAsn1::from(vec![TGS_REP_MSG_TYPE])),
            padata: Optional::from(None),
            crealm: ExplicitContextTag3::from(realm.clone()),
            cname: ExplicitContextTag4::from(cname.clone()),
            ticket: ExplicitContextTag5::from(Self::make_ticket(
                realm,
                session_key,
                &ticket_enc_key,
                kdc_options.0,
                sname,
                cname,
            )),
            enc_part: ExplicitContextTag6::from(EncryptedData {
                etype: ExplicitContextTag0::from(IntegerAsn1::from(vec![AES256_CTS_HMAC_SHA1_96 as u8])),
                kvno: Optional::from(None),
                cipher: ExplicitContextTag2::from(OctetStringAsn1::from(tgs_rep_enc_data)),
            }),
        }))
    }
}


--- File: tests/sspi/client_server/kerberos/mod.rs ---
#![allow(clippy::result_large_err)]

pub mod kdc;
pub mod network_client;

use std::collections::{HashMap, HashSet};
use std::panic;

use picky_asn1::restricted_string::IA5String;
use picky_asn1::wrapper::{Asn1SequenceOf, ExplicitContextTag0, ExplicitContextTag1, IntegerAsn1};
use picky_krb::constants::types::{NT_PRINCIPAL, NT_SRV_INST};
use picky_krb::data_types::{KerberosStringAsn1, PrincipalName};
use picky_krb::gss_api::MechTypeList;
use sspi::credssp::SspiContext;
use sspi::kerberos::ServerProperties;
use sspi::network_client::NetworkClient;
use sspi::{
    AuthIdentity, BufferType, ClientRequestFlags, Credentials, CredentialsBuffers, DataRepresentation, Kerberos,
    KerberosConfig, SecurityBuffer, SecurityStatus, ServerRequestFlags, Sspi, SspiImpl, Username,
};
use url::Url;

use crate::client_server::kerberos::kdc::{
    KdcMock, PasswordCreds, UserName, Validators, CLIENT_COMPUTER_NAME, KDC_URL, MAX_TIME_SKEW,
};
use crate::client_server::kerberos::network_client::NetworkClientMock;
use crate::client_server::{test_encryption, test_rpc_request_encryption, test_stream_buffer_encryption};

/// Represents a Kerberos environment:
/// * user and services keys;
/// * user logon credentials;
/// * realm and target application service name;
///
/// It is used for simplifying tests environment preparation.
pub struct KrbEnvironment {
    pub keys: HashMap<UserName, Vec<u8>>,
    pub users: HashMap<UserName, PasswordCreds>,
    pub credentials: Credentials,
    pub realm: String,
    pub target_name: String,
    pub target_service_name: PrincipalName,
}

/// Initializes a Kerberos environment. It includes:
/// * User logon credentials (password-based).
/// * Kerberos services keys.
/// * Target machine name.
pub fn init_krb_environment() -> KrbEnvironment {
    let username = "pw13";
    let user_password = "qweQWE123!@#";
    let domain = "EXAMPLE";
    let realm = "EXAMPLE.COM";
    let mut salt = realm.to_string();
    salt.push_str(username);
    let krbtgt = "krbtgt";
    let termsrv = "TERMSRV";
    let target_machine_name = "DESKTOP-8F33RFH.example.com";
    let mut target_name = termsrv.to_string();
    target_name.push('/');
    target_name.push_str(target_machine_name);

    let tgt_service_key = vec![
        199, 133, 201, 239, 57, 139, 61, 128, 71, 236, 217, 130, 250, 148, 117, 193, 197, 86, 155, 11, 92, 124, 232,
        146, 3, 14, 158, 220, 113, 63, 110, 230,
    ];
    let application_service_key = vec![
        168, 29, 77, 196, 211, 88, 148, 180, 123, 188, 196, 182, 173, 30, 249, 191, 89, 35, 44, 56, 20, 217, 132, 131,
        89, 144, 33, 79, 16, 91, 126, 72,
    ];
    let keys = [
        (
            UserName(PrincipalName {
                name_type: ExplicitContextTag0::from(IntegerAsn1::from(vec![NT_SRV_INST])),
                name_string: ExplicitContextTag1::from(Asn1SequenceOf::from(vec![
                    KerberosStringAsn1::from(IA5String::from_string(krbtgt.into()).unwrap()),
                    KerberosStringAsn1::from(IA5String::from_string(domain.into()).unwrap()),
                ])),
            }),
            tgt_service_key.clone(),
        ),
        (
            UserName(PrincipalName {
                name_type: ExplicitContextTag0::from(IntegerAsn1::from(vec![NT_SRV_INST])),
                name_string: ExplicitContextTag1::from(Asn1SequenceOf::from(vec![
                    KerberosStringAsn1::from(IA5String::from_string(krbtgt.into()).unwrap()),
                    KerberosStringAsn1::from(IA5String::from_string(realm.to_string()).unwrap()),
                ])),
            }),
            tgt_service_key,
        ),
        (
            UserName(PrincipalName {
                name_type: ExplicitContextTag0::from(IntegerAsn1::from(vec![NT_SRV_INST])),
                name_string: ExplicitContextTag1::from(Asn1SequenceOf::from(vec![
                    KerberosStringAsn1::from(IA5String::from_string(termsrv.into()).unwrap()),
                    KerberosStringAsn1::from(IA5String::from_string(target_machine_name.into()).unwrap()),
                ])),
            }),
            application_service_key,
        ),
    ]
    .into_iter()
    .collect();
    let users = [(
        UserName(PrincipalName {
            name_type: ExplicitContextTag0::from(IntegerAsn1::from(vec![NT_PRINCIPAL])),
            name_string: ExplicitContextTag1::from(Asn1SequenceOf::from(vec![KerberosStringAsn1::from(
                IA5String::from_string(username.into()).unwrap(),
            )])),
        }),
        PasswordCreds {
            password: user_password.as_bytes().to_vec(),
            salt,
        },
    )]
    .into_iter()
    .collect();

    let credentials = Credentials::AuthIdentity(AuthIdentity {
        username: Username::new_down_level_logon_name(username, domain).unwrap(),
        password: user_password.to_owned().into(),
    });

    KrbEnvironment {
        keys,
        users,
        realm: realm.to_string(),
        credentials,
        target_name,
        target_service_name: PrincipalName {
            name_type: ExplicitContextTag0::from(IntegerAsn1::from(vec![NT_SRV_INST])),
            name_string: ExplicitContextTag1::from(Asn1SequenceOf::from(vec![
                KerberosStringAsn1::from(IA5String::from_string("TERMSRV".into()).unwrap()),
                KerberosStringAsn1::from(IA5String::from_string("DESKTOP-8F33RFH.example.com".into()).unwrap()),
            ])),
        },
    }
}

/// Does all preparations and calls the [initialize_security_context_impl] function
/// on the provided Kerberos context.
pub fn initialize_security_context(
    client: &mut SspiContext,
    credentials_handle: &mut Option<CredentialsBuffers>,
    flags: ClientRequestFlags,
    target_name: &str,
    in_token: Vec<u8>,
    network_client: &mut dyn NetworkClient,
) -> (SecurityStatus, Vec<u8>) {
    let mut input_token = [SecurityBuffer::new(in_token, BufferType::Token)];
    let mut output_token = vec![SecurityBuffer::new(Vec::with_capacity(1024), BufferType::Token)];

    let mut builder = client
        .initialize_security_context()
        .with_credentials_handle(credentials_handle)
        .with_context_requirements(flags)
        .with_target_data_representation(DataRepresentation::Native)
        .with_target_name(target_name)
        .with_input(&mut input_token)
        .with_output(&mut output_token);
    let result = client
        .initialize_security_context_impl(&mut builder)
        .expect("Kerberos initialize_security_context should not fail")
        .resolve_with_client(network_client)
        .expect("Kerberos initialize_security_context should not fail");

    (result.status, output_token.remove(0).buffer)
}

/// Does all preparations and calls the [accept_security_context] function
/// on the provided Kerberos context.
pub fn accept_security_context(
    server: &mut SspiContext,
    credentials_handle: &mut Option<CredentialsBuffers>,
    flags: ServerRequestFlags,
    in_token: Vec<u8>,
    network_client: &mut dyn NetworkClient,
) -> (SecurityStatus, Vec<u8>) {
    let mut input_token = [SecurityBuffer::new(in_token, BufferType::Token)];
    let mut output_token = vec![SecurityBuffer::new(Vec::with_capacity(1024), BufferType::Token)];

    let builder = server
        .accept_security_context()
        .with_credentials_handle(credentials_handle)
        .with_context_requirements(flags)
        .with_target_data_representation(DataRepresentation::Native)
        .with_input(&mut input_token)
        .with_output(&mut output_token);
    let result = server
        .accept_security_context_impl(builder)
        .expect("Kerberos accept_security_context should not fail")
        .resolve_with_client(network_client)
        .expect("Kerberos accept_security_context should not fail");

    (result.status, output_token.remove(0).buffer)
}

fn run_kerberos(
    client: &mut SspiContext,
    client_credentials_handle: &mut Option<CredentialsBuffers>,
    client_flags: ClientRequestFlags,
    target_name: &str,

    server: &mut SspiContext,
    server_credentials_handle: &mut Option<CredentialsBuffers>,
    server_flags: ServerRequestFlags,

    network_client: &mut dyn NetworkClient,
) {
    let mut client_in_token = Vec::new();

    for _ in 0..3 {
        let (client_status, token) = initialize_security_context(
            client,
            client_credentials_handle,
            client_flags,
            target_name,
            client_in_token,
            network_client,
        );

        let (_, token) =
            accept_security_context(server, server_credentials_handle, server_flags, token, network_client);
        client_in_token = token;

        if client_status == SecurityStatus::Ok {
            test_encryption(client, server);
            test_stream_buffer_encryption(client, server);
            test_rpc_request_encryption(client, server);
            return;
        }
    }

    panic!("Kerberos authentication should not exceed 3 steps");
}

#[test]
fn kerberos_auth() {
    let KrbEnvironment {
        realm,
        credentials,
        keys,
        users,
        target_name,
        target_service_name,
    } = init_krb_environment();

    let ticket_decryption_key = keys.get(&UserName(target_service_name.clone())).unwrap().clone();

    let kdc = KdcMock::new(
        realm,
        keys,
        users,
        Validators {
            as_req: Box::new(|_as_req| {
                // Nothing to validate in AsReq.
            }),
            tgs_req: Box::new(|tgs_req| {
                // Here, we should check that the Kerberos client does not negotiated Kerberos U2U auth and not enabled any unneeded flags.

                let kdc_options = tgs_req.0.req_body.kdc_options.0 .0.as_bytes();
                // enc-tkt-in-skey must be disabled.
                assert_eq!(kdc_options[4], 0x00, "some unneeded KDC options are enabled");

                let additional_tickets = tgs_req
                    .0
                    .req_body
                    .0
                    .additional_tickets
                    .0
                    .as_ref()
                    .map(|additional_tickets| additional_tickets.0 .0.as_slice());
                assert!(
                    matches!(additional_tickets, None | Some(&[])),
                    "TgsReq should not contain any additional tickets"
                );
            }),
        },
    );
    let mut network_client = NetworkClientMock { kdc };

    let client_config = KerberosConfig {
        kdc_url: Some(Url::parse("tcp://192.168.1.103:88").unwrap()),
        client_computer_name: Some("DESKTOP-I7E8EFA.example.com".into()),
    };
    let kerberos_client = Kerberos::new_client_from_config(client_config).unwrap();

    let server_config = KerberosConfig {
        kdc_url: Some(Url::parse("tcp://192.168.1.103:88").unwrap()),
        client_computer_name: Some("DESKTOP-8F33RFH.example.com".into()),
    };
    let server_properties = ServerProperties {
        mech_types: MechTypeList::from(Vec::new()),
        max_time_skew: MAX_TIME_SKEW,
        ticket_decryption_key: Some(ticket_decryption_key),
        service_name: target_service_name,
        user: None,
        client: None,
        authenticators_cache: HashSet::new(),
    };
    let kerberos_server = Kerberos::new_server_from_config(server_config, server_properties).unwrap();

    let credentials = CredentialsBuffers::try_from(credentials).unwrap();
    let mut client_credentials_handle = Some(credentials.clone());
    let mut server_credentials_handle = Some(credentials);

    let client_flags = ClientRequestFlags::MUTUAL_AUTH
        | ClientRequestFlags::INTEGRITY
        | ClientRequestFlags::SEQUENCE_DETECT
        | ClientRequestFlags::REPLAY_DETECT
        | ClientRequestFlags::CONFIDENTIALITY;
    let server_flags = ServerRequestFlags::MUTUAL_AUTH
        | ServerRequestFlags::INTEGRITY
        | ServerRequestFlags::SEQUENCE_DETECT
        | ServerRequestFlags::REPLAY_DETECT
        | ServerRequestFlags::CONFIDENTIALITY;

    run_kerberos(
        &mut SspiContext::Kerberos(kerberos_client),
        &mut client_credentials_handle,
        client_flags,
        &target_name,
        &mut SspiContext::Kerberos(kerberos_server),
        &mut server_credentials_handle,
        server_flags,
        &mut network_client,
    );
}

#[test]
fn kerberos_u2u_auth() {
    let KrbEnvironment {
        realm,
        credentials,
        keys,
        users,
        target_name,
        target_service_name,
    } = init_krb_environment();

    let kdc = KdcMock::new(
        realm,
        keys,
        users,
        Validators {
            as_req: Box::new(|_as_req| {
                // Nothing to validate in AsReq.
            }),
            tgs_req: Box::new(|tgs_req| {
                // Here, we should check that the Kerberos client successfully negotiated Kerberos U2U auth.

                let kdc_options = tgs_req.0.req_body.kdc_options.0 .0.as_bytes();
                // KDC options must have enc-tkt-in-skey enabled.
                assert_eq!(kdc_options[4], 0x08, "the enc-tkt-in-skey KDC option is not enabled");

                if let Some(tickets) = tgs_req.0.req_body.0.additional_tickets.0.as_ref() {
                    assert!(
                        !tickets.0 .0.is_empty(),
                        "TgsReq must have at least one additional ticket: TGT from the application service"
                    );
                } else {
                    panic!("TgsReq must have at least one additional ticket: TGT from the application service");
                }
            }),
        },
    );
    let mut network_client = NetworkClientMock { kdc };

    let client_config = KerberosConfig {
        kdc_url: Some(Url::parse(KDC_URL).unwrap()),
        client_computer_name: Some(CLIENT_COMPUTER_NAME.into()),
    };
    let kerberos_client = Kerberos::new_client_from_config(client_config).unwrap();

    let server_config = KerberosConfig {
        kdc_url: Some(Url::parse(KDC_URL).unwrap()),
        client_computer_name: Some(CLIENT_COMPUTER_NAME.into()),
    };
    let server_properties = ServerProperties {
        mech_types: MechTypeList::default(),
        max_time_skew: MAX_TIME_SKEW,
        ticket_decryption_key: None,
        service_name: target_service_name,
        user: None,
        client: None,
        authenticators_cache: HashSet::new(),
    };
    let kerberos_server = Kerberos::new_server_from_config(server_config, server_properties).unwrap();

    let credentials = CredentialsBuffers::try_from(credentials).unwrap();
    let mut client_credentials_handle = Some(credentials.clone());
    let mut server_credentials_handle = Some(credentials);

    let client_flags = ClientRequestFlags::MUTUAL_AUTH
        | ClientRequestFlags::INTEGRITY
        | ClientRequestFlags::USE_SESSION_KEY // Kerberos U2U auth
        | ClientRequestFlags::SEQUENCE_DETECT
        | ClientRequestFlags::REPLAY_DETECT
        | ClientRequestFlags::CONFIDENTIALITY;
    let server_flags = ServerRequestFlags::MUTUAL_AUTH
        | ServerRequestFlags::INTEGRITY
        | ServerRequestFlags::USE_SESSION_KEY // Kerberos U2U auth
        | ServerRequestFlags::SEQUENCE_DETECT
        | ServerRequestFlags::REPLAY_DETECT
        | ServerRequestFlags::CONFIDENTIALITY;

    run_kerberos(
        &mut SspiContext::Kerberos(kerberos_client),
        &mut client_credentials_handle,
        client_flags,
        &target_name,
        &mut SspiContext::Kerberos(kerberos_server),
        &mut server_credentials_handle,
        server_flags,
        &mut network_client,
    );
}


--- File: tests/sspi/client_server/kerberos/network_client.rs ---
use sspi::generator::NetworkRequest;
use sspi::network_client::NetworkClient;
use sspi::Result;

use crate::client_server::kerberos::kdc::KdcMock;

/// [NetworkClient] mock implementation.
///
/// Instead of sending Kerberos messages to the KDC service,
/// it redirects them to the KDC mock implementation.
pub struct NetworkClientMock {
    pub kdc: KdcMock,
}

impl NetworkClient for NetworkClientMock {
    fn send(&self, request: &NetworkRequest) -> Result<Vec<u8>> {
        let data = &request.data[4..];

        let response = if let Ok(as_req) = picky_asn1_der::from_bytes(data) {
            match self.kdc.as_exchange(as_req) {
                Ok(as_rep) => picky_asn1_der::to_vec(&as_rep)?,
                Err(krb_err) => picky_asn1_der::to_vec(&krb_err)?,
            }
        } else if let Ok(tgs_req) = picky_asn1_der::from_bytes(data) {
            match self.kdc.tgs_exchange(tgs_req) {
                Ok(tgs_rep) => picky_asn1_der::to_vec(&tgs_rep)?,
                Err(krb_err) => picky_asn1_der::to_vec(&krb_err)?,
            }
        } else {
            panic!("Invalid Kerberos message: {:?}", request.data);
        };

        let mut data = vec![0; 4 + response.len()];
        data[0..4].copy_from_slice(&u32::try_from(response.len()).unwrap().to_be_bytes());
        data[4..].copy_from_slice(&response);

        Ok(data)
    }
}


--- File: tests/sspi/client_server/mod.rs ---
#![cfg(feature = "network_client")] // The network_client feature is required for the client_server tests.

mod credssp;
mod kerberos;
mod ntlm;

use sspi::credssp::SspiContext;
use sspi::{EncryptionFlags, SecurityBufferFlags, SecurityBufferRef, Sspi};

fn test_encryption(client: &mut SspiContext, server: &mut SspiContext) {
    let plain_message = b"Devolutions/sspi-rs";

    let mut token = [0; 1024];
    let mut data = plain_message.to_vec();

    let mut message = vec![
        SecurityBufferRef::token_buf(token.as_mut_slice()),
        SecurityBufferRef::data_buf(data.as_mut_slice()),
    ];

    client
        .encrypt_message(EncryptionFlags::empty(), &mut message, 0)
        .unwrap();
    server.decrypt_message(&mut message, 0).unwrap();

    assert_eq!(plain_message, message[1].data());
}

fn test_stream_buffer_encryption(client: &mut SspiContext, server: &mut SspiContext) {
    // https://learn.microsoft.com/en-us/windows/win32/secauthn/sspi-kerberos-interoperability-with-gssapi

    let plain_message = b"Devolutions/sspi-rs";

    let mut token = [0; 1024];
    let mut data = plain_message.to_vec();
    let mut message = [
        SecurityBufferRef::token_buf(token.as_mut_slice()),
        SecurityBufferRef::data_buf(data.as_mut_slice()),
    ];

    client
        .encrypt_message(EncryptionFlags::empty(), &mut message, 0)
        .unwrap();

    let mut buffer = message[0].data().to_vec();
    buffer.extend_from_slice(message[1].data());

    let mut message = [
        SecurityBufferRef::stream_buf(&mut buffer),
        SecurityBufferRef::data_buf(&mut []),
    ];

    server.decrypt_message(&mut message, 0).unwrap();

    assert_eq!(message[1].data(), plain_message);
}

fn test_rpc_request_encryption(client: &mut SspiContext, server: &mut SspiContext) {
    // RPC header
    let header = [
        5, 0, 0, 3, 16, 0, 0, 0, 60, 1, 76, 0, 1, 0, 0, 0, 208, 0, 0, 0, 0, 0, 0, 0,
    ];
    // Unencrypted data in RPC Request
    let plaintext = [
        108, 0, 0, 0, 0, 0, 0, 0, 108, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 128, 84, 0, 0, 0, 96, 0, 0, 0, 0, 0, 0, 0, 20, 0,
        0, 0, 2, 0, 64, 0, 2, 0, 0, 0, 0, 0, 36, 0, 3, 0, 0, 0, 1, 5, 0, 0, 0, 0, 0, 5, 21, 0, 0, 0, 223, 243, 137, 88,
        86, 131, 83, 53, 105, 218, 109, 33, 80, 4, 0, 0, 0, 0, 20, 0, 2, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
        1, 1, 0, 0, 0, 0, 0, 5, 18, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 5, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 138, 227, 19, 113, 2, 244, 54, 113, 2, 64, 40, 0,
        96, 89, 120, 185, 79, 82, 223, 17, 139, 109, 131, 220, 222, 215, 32, 133, 1, 0, 0, 0, 51, 5, 113, 113, 186,
        190, 55, 73, 131, 25, 181, 219, 239, 156, 204, 54, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    // RPC security trailer header
    let trailer = [16, 6, 8, 0, 0, 0, 0, 0];

    let mut header_data = header.to_vec();
    let mut data = plaintext.to_vec();
    let mut trailer_data = trailer.to_vec();
    let mut token_data = vec![0; 76];
    let mut message = vec![
        SecurityBufferRef::data_buf(&mut header_data).with_flags(SecurityBufferFlags::SECBUFFER_READONLY_WITH_CHECKSUM),
        SecurityBufferRef::data_buf(&mut data),
        SecurityBufferRef::data_buf(&mut trailer_data)
            .with_flags(SecurityBufferFlags::SECBUFFER_READONLY_WITH_CHECKSUM),
        SecurityBufferRef::token_buf(&mut token_data),
    ];

    client
        .encrypt_message(EncryptionFlags::empty(), &mut message, 0)
        .unwrap();

    assert_eq!(header[..], message[0].data()[..]);
    assert_eq!(trailer[..], message[2].data()[..]);

    server.decrypt_message(&mut message, 0).unwrap();

    assert_eq!(header[..], message[0].data()[..]);
    assert_eq!(message[1].data(), plaintext);
    assert_eq!(trailer[..], message[2].data()[..]);
}


--- File: tests/sspi/client_server/ntlm.rs ---
use sspi::builders::{AcquireCredentialsHandle, WithoutCredentialUse};
use sspi::credssp::SspiContext;
use sspi::ntlm::NtlmConfig;
use sspi::{
    AcquireCredentialsHandleResult, AuthIdentity, BufferType, ClientRequestFlags, CredentialUse, Credentials,
    DataRepresentation, InitializeSecurityContextResult, Ntlm, Secret, SecurityBuffer, SecurityStatus,
    ServerRequestFlags, Sspi, Username,
};

use crate::client_server::{test_encryption, test_rpc_request_encryption, test_stream_buffer_encryption};

fn run_ntlm(config: NtlmConfig) {
    let credentials = Credentials::AuthIdentity(AuthIdentity {
        username: Username::parse("test_user").unwrap(),
        password: Secret::from("test_password".to_owned()),
    });
    let target_name = "TERMSRV/DESKTOP-8F33RFH.example.com";

    let mut client = SspiContext::Ntlm(Ntlm::with_config(config.clone()));
    let mut server = SspiContext::Ntlm(Ntlm::with_config(config));

    let builder = AcquireCredentialsHandle::<'_, _, _, WithoutCredentialUse>::new();
    let AcquireCredentialsHandleResult {
        credentials_handle: mut client_credentials_handle,
        ..
    } = builder
        .with_auth_data(&credentials)
        .with_credential_use(CredentialUse::Outbound)
        .execute(&mut client)
        .unwrap();

    let builder = AcquireCredentialsHandle::<'_, _, _, WithoutCredentialUse>::new();
    let AcquireCredentialsHandleResult {
        credentials_handle: mut server_credentials_handle,
        ..
    } = builder
        .with_auth_data(&credentials)
        .with_credential_use(CredentialUse::Inbound)
        .execute(&mut server)
        .unwrap();

    let mut input_token = [SecurityBuffer::new(Vec::new(), BufferType::Token)];
    let mut output_token = [SecurityBuffer::new(Vec::new(), BufferType::Token)];

    for _ in 0..3 {
        let mut builder = client
            .initialize_security_context()
            .with_credentials_handle(&mut client_credentials_handle)
            .with_context_requirements(
                ClientRequestFlags::MUTUAL_AUTH
                    | ClientRequestFlags::USE_SESSION_KEY
                    | ClientRequestFlags::INTEGRITY
                    | ClientRequestFlags::CONFIDENTIALITY,
            )
            .with_target_data_representation(DataRepresentation::Native)
            .with_target_name(target_name)
            .with_input(&mut input_token)
            .with_output(&mut output_token);
        let InitializeSecurityContextResult { status, .. } =
            client.initialize_security_context_sync(&mut builder).unwrap();

        input_token[0].buffer.clear();

        let builder = server
            .accept_security_context()
            .with_credentials_handle(&mut server_credentials_handle)
            .with_context_requirements(ServerRequestFlags::empty())
            .with_target_data_representation(DataRepresentation::Native)
            .with_input(&mut output_token)
            .with_output(&mut input_token);
        server.accept_security_context_sync(builder).unwrap();

        output_token[0].buffer.clear();

        if status == SecurityStatus::Ok {
            test_encryption(&mut client, &mut server);
            test_stream_buffer_encryption(&mut client, &mut server);
            test_rpc_request_encryption(&mut client, &mut server);
            return;
        }
    }

    panic!("NTLM authentication should not exceed 3 steps")
}

#[test]
fn ntlm_with_computer_name() {
    run_ntlm(NtlmConfig {
        client_computer_name: Some("DESKTOP-3D83IAN.example.com".to_owned()),
    });
}

#[test]
fn ntlm_without_computer_name() {
    run_ntlm(NtlmConfig {
        client_computer_name: None,
    });
}


--- File: tests/sspi/common.rs ---
use std::io;
use std::sync::LazyLock;

use sspi::{
    credssp, AcquireCredentialsHandleResult, AuthIdentity, BufferType, ClientRequestFlags, ContextNames, CredentialUse,
    DataRepresentation, EncryptionFlags, SecurityBuffer, SecurityBufferRef, SecurityStatus, ServerRequestFlags, Sspi,
    SspiEx, Username,
};
use time::OffsetDateTime;

pub static CREDENTIALS: LazyLock<AuthIdentity> = LazyLock::new(|| AuthIdentity {
    username: Username::new("Username", Some("Domain")).unwrap(),
    password: String::from("Password").into(),
});

const MESSAGE_TO_CLIENT: &[u8] = b"Hello, client!";

pub struct CredentialsProxyImpl<'a> {
    credentials: &'a AuthIdentity,
}

impl<'a> CredentialsProxyImpl<'a> {
    pub fn new(credentials: &'a AuthIdentity) -> Self {
        Self { credentials }
    }
}

impl credssp::CredentialsProxy for CredentialsProxyImpl<'_> {
    type AuthenticationData = AuthIdentity;

    fn auth_data_by_user(&mut self, username: &Username) -> io::Result<Self::AuthenticationData> {
        assert_eq!(username.account_name(), self.credentials.username.account_name());

        Ok(self.credentials.clone())
    }
}

pub fn create_client_credentials_handle<T>(
    client: &mut T,
    auth_data: Option<&T::AuthenticationData>,
) -> sspi::Result<T::CredentialsHandle>
where
    T: Sspi,
{
    let AcquireCredentialsHandleResult {
        credentials_handle,
        expiry,
    } = if let Some(auth_data) = auth_data {
        client
            .acquire_credentials_handle()
            .with_credential_use(CredentialUse::Outbound)
            .with_auth_data(auth_data)
            .execute(client)?
    } else {
        client
            .acquire_credentials_handle()
            .with_credential_use(CredentialUse::Outbound)
            .execute(client)?
    };

    if let Some(expiry) = expiry {
        let now = OffsetDateTime::now_utc();
        assert!(now < expiry);
    }

    Ok(credentials_handle)
}

pub fn create_server_credentials_handle<T>(server: &mut T) -> sspi::Result<T::CredentialsHandle>
where
    T: Sspi,
{
    let AcquireCredentialsHandleResult {
        credentials_handle,
        expiry,
    } = server
        .acquire_credentials_handle()
        .with_credential_use(CredentialUse::Inbound)
        .execute(server)?;
    if let Some(expiry) = expiry {
        let now = OffsetDateTime::now_utc();
        assert!(now < expiry);
    }

    Ok(credentials_handle)
}

pub fn process_authentication_without_complete<ClientSspi, ServerSspi>(
    client: &mut ClientSspi,
    mut client_creds_handle: ClientSspi::CredentialsHandle,
    server: &mut ServerSspi,
    mut server_creds_handle: ServerSspi::CredentialsHandle,
) -> sspi::Result<(SecurityStatus, SecurityStatus)>
where
    ClientSspi: Sspi,
    ServerSspi: Sspi,
{
    let mut server_output = Vec::new();
    let mut client_status;
    let mut server_status = SecurityStatus::ContinueNeeded;

    loop {
        let mut client_output = vec![SecurityBuffer::new(Vec::new(), BufferType::Token)];

        let mut builder = client
            .initialize_security_context()
            .with_credentials_handle(&mut client_creds_handle)
            .with_context_requirements(ClientRequestFlags::ALLOCATE_MEMORY | ClientRequestFlags::CONFIDENTIALITY)
            .with_target_data_representation(DataRepresentation::Native)
            .with_input(&mut server_output)
            .with_output(&mut client_output);

        let client_result = client
            .initialize_security_context_impl(&mut builder)?
            .resolve_to_result()?;
        client_status = client_result.status;

        if client_status != SecurityStatus::ContinueNeeded && server_status != SecurityStatus::ContinueNeeded {
            return Ok((client_status, server_status));
        }

        server_output = vec![SecurityBuffer::new(Vec::new(), BufferType::Token)];

        let builder = server
            .accept_security_context()
            .with_credentials_handle(&mut server_creds_handle)
            .with_context_requirements(ServerRequestFlags::ALLOCATE_MEMORY)
            .with_target_data_representation(DataRepresentation::Native)
            .with_input(&mut client_output)
            .with_output(&mut server_output);
        let server_result = server.accept_security_context_impl(builder)?.resolve_to_result()?;
        server_status = server_result.status;

        if client_status != SecurityStatus::ContinueNeeded && server_status != SecurityStatus::ContinueNeeded {
            return Ok((client_status, server_status));
        }
    }
}

pub fn try_complete_authentication<T>(server: &mut T, auth_server_status: SecurityStatus) -> sspi::Result<()>
where
    T: Sspi,
{
    if auth_server_status == SecurityStatus::CompleteNeeded || auth_server_status == SecurityStatus::CompleteAndContinue
    {
        let mut token = Vec::new();
        server.complete_auth_token(&mut token)?;
    }

    Ok(())
}

pub fn set_identity_and_try_complete_authentication<T, C>(
    server: &mut T,
    auth_server_status: SecurityStatus,
    credentials_proxy: &mut C,
) -> sspi::Result<()>
where
    T: Sspi + SspiEx,
    C: credssp::CredentialsProxy<AuthenticationData = T::AuthenticationData>,
{
    if auth_server_status == SecurityStatus::CompleteNeeded || auth_server_status == SecurityStatus::CompleteAndContinue
    {
        let ContextNames { username } = server.query_context_names()?;
        let auth_data = credentials_proxy.auth_data_by_user(&username)?;
        server.custom_set_auth_identity(auth_data).unwrap();

        let mut token = Vec::new();
        server.complete_auth_token(&mut token)?;
    }

    Ok(())
}

pub fn check_messages_encryption(client: &mut impl Sspi, server: &mut impl Sspi) -> sspi::Result<()> {
    let server_sizes = server.query_context_sizes()?;
    let sequence_number = 0;

    let mut token = vec![0; server_sizes.security_trailer as usize];
    let mut data = MESSAGE_TO_CLIENT.to_vec();
    let mut messages = [
        SecurityBufferRef::token_buf(token.as_mut_slice()),
        SecurityBufferRef::data_buf(data.as_mut_slice()),
    ];
    server.encrypt_message(EncryptionFlags::empty(), &mut messages, sequence_number)?;
    assert_ne!(MESSAGE_TO_CLIENT, messages[1].data());

    println!(
        "Message to client: {:x?}, encrypted message: {:x?}, token: {:x?}",
        MESSAGE_TO_CLIENT,
        messages[0].data(),
        messages[1].data()
    );

    let [mut token, mut data] = messages;

    let mut messages = vec![
        SecurityBufferRef::data_buf(data.take_data()),
        SecurityBufferRef::token_buf(token.take_data()),
    ];

    client.decrypt_message(&mut messages, sequence_number)?;

    assert_eq!(MESSAGE_TO_CLIENT, messages[0].data());

    Ok(())
}


--- File: tests/sspi/main.rs ---
mod client_server;
mod common;
mod ntlm;


--- File: tests/sspi/ntlm.rs ---
use sspi::Ntlm;

use crate::common::{
    check_messages_encryption, create_client_credentials_handle, create_server_credentials_handle,
    process_authentication_without_complete, set_identity_and_try_complete_authentication, try_complete_authentication,
    CredentialsProxyImpl, CREDENTIALS,
};

#[test]
fn successful_ntlm_authentication_with_client_auth_data() {
    let mut credentials_proxy = CredentialsProxyImpl::new(&CREDENTIALS);

    let mut client = Ntlm::new();
    let client_credentials_handle = create_client_credentials_handle(&mut client, Some(&*CREDENTIALS)).unwrap();

    let mut server = Ntlm::new();
    let server_credentials_handle = create_server_credentials_handle(&mut server).unwrap();

    let (client_status, server_status) = process_authentication_without_complete(
        &mut client,
        client_credentials_handle,
        &mut server,
        server_credentials_handle,
    )
    .unwrap();
    try_complete_authentication(&mut client, client_status).unwrap();
    set_identity_and_try_complete_authentication(&mut server, server_status, &mut credentials_proxy).unwrap();

    check_messages_encryption(&mut client, &mut server).unwrap();
}


--- File: tools/aadjoin/AADJoin.sln ---
﻿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.32407.337
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "AADJoin", "AADJoin\AADJoin.csproj", "{75FA134F-D957-4FA5-8215-5881F73267F6}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "UnitTests", "UnitTests\UnitTests.csproj", "{C8CC0BBA-909E-418A-9CCD-96087369FAC0}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{75FA134F-D957-4FA5-8215-5881F73267F6}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{75FA134F-D957-4FA5-8215-5881F73267F6}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{75FA134F-D957-4FA5-8215-5881F73267F6}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{75FA134F-D957-4FA5-8215-5881F73267F6}.Release|Any CPU.Build.0 = Release|Any CPU
		{C8CC0BBA-909E-418A-9CCD-96087369FAC0}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{C8CC0BBA-909E-418A-9CCD-96087369FAC0}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{C8CC0BBA-909E-418A-9CCD-96087369FAC0}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{C8CC0BBA-909E-418A-9CCD-96087369FAC0}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {D8FCDD3A-161B-4671-A938-4192019BC7A6}
	EndGlobalSection
EndGlobal


--- File: tools/aadjoin/AADJoin/AADJoin.csproj ---
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net6.0</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="CommandLineParser" Version="2.9.1" />
    <PackageReference Include="System.IdentityModel.Tokens.Jwt" Version="6.35.0" />
  </ItemGroup>

</Project>


--- File: tools/aadjoin/AADJoin/AzureAD.cs ---
﻿using AADJoin.Creds;
using AADJoin.Messages;
using AADJoin.Utils;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;

namespace AADJoin
{
    internal class AzureAD {
        /// <summary>
        /// Checks if the account associated with provided username exists and active
        /// </summary>
        /// <param name="username">Account username</param>
        /// <returns></returns>
        public static async Task CheckUsername(string username)
        {
            Console.WriteLine("Start {0} username checking...", username);
            var url = String.Format("https://login.microsoftonline.com/common/userrealm/{0}?api-version=1.0", username);

            var httpClient = new HttpClient();

            var response = await httpClient.GetAsync(url);
            var content = await response.Content.ReadAsStringAsync();

            if (response.StatusCode != HttpStatusCode.OK)
            {
                Console.WriteLine("Error. Status code: {0}. Body:", response.StatusCode);
                Console.WriteLine(content);
                Environment.Exit(1);
            }

            Console.WriteLine(content);
            Console.WriteLine("User exist and active");
        }

        /// <summary>
        /// Performs basic authorization in the Azure AD using account username and password.
        /// It's just account authorization and not related to any tenant.
        /// </summary>
        /// <param name="clientId">client id</param>
        /// <param name="user">Account credentials</param>
        /// <returns>AuthResponse object</returns>
        public static async Task<AuthResponse> AzureAdAuthorize(string clientId, UserCreds user)
        {
            Console.WriteLine("Start Azure AD authorization...");

            var url = "https://login.microsoftonline.com//common/oauth2/token";

            var httpClient = new HttpClient();

            var form = new Dictionary<string, string>();
            form.Add("grant_type", "password");
            form.Add("password", user.Password);
            form.Add("client_id", clientId);
            form.Add("username", user.Username);
            form.Add("resource", "https://graph.windows.net");
            form.Add("scope", "openid");

            var response = await httpClient.PostAsync(url, new FormUrlEncodedContent(form));
            var content = await response.Content.ReadAsStringAsync();

            if (response.StatusCode != HttpStatusCode.OK)
            {
                Console.WriteLine(string.Format("Error. Status code: {0}. Body:", response.StatusCode));
                Console.WriteLine(content);
                Environment.Exit(1);
            }

            Console.WriteLine(content);
            var authResponse = JsonSerializer.Deserialize<AuthResponse>(content);
            Console.WriteLine("Azure AD authorization succeeded!");

            return authResponse;
        }

        /// <summary>
        /// Performs user authorization in the tenant using previously obtained refresh token.
        /// </summary>
        /// <param name="clientId">client id</param>
        /// <param name="authResponse">AuthResponse object returned from the AzureADAuthorize method</param>
        /// <returns>TenantAuthResponse object</returns>
        public static async Task<TenantAuthResponse> AzureTenantAuthorize(string clientId, AuthResponse authResponse)
        {
            Console.WriteLine("Start Azure Tenant authorization...");

            var url = string.Format("https://login.microsoftonline.com/{0}/oauth2/token", authResponse.GetTenantId());

            var httpClient = new HttpClient();

            var form = new Dictionary<string, string>();
            form.Add("scope", "openid");
            form.Add("grant_type", "refresh_token");

            // https://github.com/Gerenios/AADInternals/blob/master/AccessToken.ps1#L1864
            // 01cb2876-7ebd-4aa4-9cc9-d28bd4d359a9 means urn:ms-drs:enterpriseregistration.windows.net
            // More UUIDs: https://www.rickvanrousselt.com/blog/azure-default-service-principals-reference-table/
            form.Add("resource", "01cb2876-7ebd-4aa4-9cc9-d28bd4d359a9");

            form.Add("client_id", clientId);
            form.Add("refresh_token", authResponse.refresh_token);

            var response = await httpClient.PostAsync(url, new FormUrlEncodedContent(form));
            var content = await response.Content.ReadAsStringAsync();

            if (response.StatusCode != HttpStatusCode.OK)
            {
                Console.WriteLine(string.Format("Error. Status code: {0}. Body:", response.StatusCode));
                Console.WriteLine(content);
                Environment.Exit(1);
            }

            Console.WriteLine(content);
            var tenantAuthResponse = TenantAuthResponse.FromString(content);
            Console.WriteLine("Azure Tenant authorization succeeded!");

            return tenantAuthResponse;
        }

        /// <summary>
        /// Joins new device to the Azure AD. Automatically creates new device key/certificate, and id. The device id is
        /// a randomly generated UUID. The private key password is the device id.
        /// Saves them in corresponding files:
        /// * `{device_id}.key` - the device private key; {device_id} is a password from the key;
        /// * `{random_id}.csr` - the device certificate request that has been used to obtain the device certificate;
        /// * `{device_id}.cer` - the device certificate;
        /// </summary>
        /// <param name="domain">Azure AD domain</param>
        /// <param name="tenantAuthResponse">TenantAuthResponse object returned from the AzureTenantAuthorize method</param>
        /// <returns>Device creds object</returns>
        public static async Task<DeviceCreds> JoinDevice(string domain, TenantAuthResponse tenantAuthResponse)
        {
            Console.WriteLine("Start device joining...");

            var url = "https://enterpriseregistration.windows.net/EnrollmentServer/device/?api-version=1.0";

            var httpClient = new HttpClient();
            httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", tenantAuthResponse.access_token);

            var deviceId = Guid.NewGuid();
            // minimal key size = 2048
            var deviceKey = new RSACng(2048);

            var joinDeviceRequest = new JoinDeviceRequest(domain, deviceKey, deviceId);

            var data = new StringContent(joinDeviceRequest.ToString());
            data.Headers.ContentType = new MediaTypeHeaderValue("application/json");

            var response = await httpClient.PostAsync(url, data);
            var content = await response.Content.ReadAsStringAsync();

            if (response.StatusCode != HttpStatusCode.OK)
            {
                Console.WriteLine(string.Format("Error. Status code: {0}. Body:", response.StatusCode));
                Console.WriteLine(content);
                Environment.Exit(1);
            }

            Console.WriteLine(content);
            var joinDeviceResponse = JoinDeviceResponse.FromString(content);

            var certificate = new X509Certificate(Convert.FromBase64String(joinDeviceResponse.Certificate.RawBody));
            var device = new DeviceCreds(deviceKey, certificate);

            Console.WriteLine("The device transport key password: {0}", device.Id);
            Console.WriteLine(
                "The device transport key (PKCS8) has been written into the file: {0}",
                CryptoUtils.RsaToPkcs8File(deviceKey, device.Id, device.Id)
            );

            Console.WriteLine(
                "The device certificate (.pfx) has been written into the file: {0}",
                CryptoUtils.PemCrtToPfxFile(joinDeviceResponse.Certificate.RawBody, deviceKey, device.Id, device.Id)
            );

            Console.WriteLine(
                "The device certificate (.cer) has been written into the file: {0}",
                CryptoUtils.PemCrtToFile(joinDeviceResponse.Certificate.RawBody, device.Id)
            );

            Console.WriteLine("Device joining succeeded!");

            return device;
        }

        /// <summary>
        /// Requests nonce from the Azure AD tenant.
        /// </summary>
        /// <param name="tenantId">Tenant UUID</param>
        /// <returns>Base64 encoded nonce</returns>
        private static async Task<string> RequestNonce(string tenantId)
        {
            Console.WriteLine("Start obtaining nonce...");

            var httpClient = new HttpClient();

            var url = string.Format("https://login.microsoftonline.com/{0}/oauth2/token", tenantId);

            var nonceForm = new Dictionary<string, string>();
            nonceForm.Add("grant_type", "srv_challenge");

            var nonceResponse = await httpClient.PostAsync(url, new FormUrlEncodedContent(nonceForm));
            var nonceContent = await nonceResponse.Content.ReadAsStringAsync();

            if (nonceResponse.StatusCode != HttpStatusCode.OK)
            {
                Console.WriteLine(string.Format("Error. Status code: {0}. Body:", nonceResponse.StatusCode));
                Console.WriteLine(nonceContent);
                Environment.Exit(1);
            }

            Console.WriteLine(nonceContent);

            var document = JsonDocument.Parse(nonceContent);
            var nonce = document.RootElement.GetProperty("Nonce");

            return nonce.ToString();
        }

        /// <summary>
        /// Obtains refresh and access token with the TGT.
        /// </summary>
        /// <param name="user">Account credentials</param>
        /// <param name="tenantId">Tenant id</param>
        /// <param name="nonce">Previously obtained nonce</param>
        /// <param name="device">Device creds (private key and certificate)</param>
        /// <returns>JSON response from AzureAD as string</returns>
        private static async Task<string> TokenWithTgt(
            UserCreds user,
            string tenantId,
            string nonce,
            DeviceCreds device
        )
        {
            Console.WriteLine("Start TokenWithTGT...");

            var httpClient = new HttpClient();

            var url = string.Format("https://login.microsoftonline.com/{0}/oauth2/token", tenantId);

            var certForm = new Dictionary<string, string>();
            certForm.Add("request", JwtUtils.GenerateFRequestJwt(
                nonce,
                device,
                user
            ));
            certForm.Add("grant_type", "urn:ietf:params:oauth:grant-type:jwt-bearer");
            certForm.Add("client_info", "1");
            certForm.Add("tgt", "true");
            certForm.Add("windows_api_version", "2.2");

            var response = await httpClient.PostAsync(url, new FormUrlEncodedContent(certForm));
            var content = await response.Content.ReadAsStringAsync();

            if (response.StatusCode != HttpStatusCode.OK)
            {
                Console.WriteLine(string.Format("Error. Status code: {0}. Body:", response.StatusCode));
                Console.WriteLine(content);

                Environment.Exit(1);
            }

            Console.WriteLine(content);
            return content;
        }

        /// <summary>
        /// Checks if the provided domain exists and active
        /// </summary>
        /// <param name="domain">AzureAD domain</param>
        /// <returns></returns>
        private static async Task CheckDomain(string domain)
        {
            var url = String.Format("https://login.microsoftonline.com/common/UserRealm/?user={0}&api-version=1.0&checkForMicrosoftAccount=false&fallback_domain={1}", domain, domain);

            var httpClient = new HttpClient();

            var response = await httpClient.GetAsync(url);
            var content = await response.Content.ReadAsStringAsync();

            if (response.StatusCode != HttpStatusCode.OK)
            {
                Console.WriteLine("Error. Status code: {0}. Body:", response.StatusCode);
                Console.WriteLine(content);
                Environment.Exit(1);
            }

            Console.WriteLine(content);
            Console.WriteLine("Domain exist and active");
        }

        /// <summary>
        /// Obtains client P2P certificates ans saves them into the corresponding files.
        /// </summary>
        /// <param name="user">Account credentials</param>
        /// <param name="tenantId">Tenant id</param>
        /// <param name="device">Device credentials (private key and certificate)</param>
        /// <returns></returns>
        public static async Task ObtainClientP2PCertificate(UserCreds user, string tenantId, DeviceCreds device)
        {
            Console.WriteLine("Start obtaining client P2P certificates...");

            await CheckDomain(user.Domain);

            var nonce = await RequestNonce(tenantId);
            Console.WriteLine("First nonce: {0}", nonce);

            var response = await TokenWithTgt(user, tenantId, nonce, device);

            var responseJson = JsonDocument.Parse(response);
            var refreshToken = responseJson.RootElement.GetProperty("refresh_token").ToString();
            var sessionKeyJwe = responseJson.RootElement.GetProperty("session_key_jwe").ToString();
            var sessionKey = CryptoUtils.DecryptSessionKeyFromJwe(sessionKeyJwe, device.Key);

            nonce = await RequestNonce(tenantId);
            Console.WriteLine("Second nonce: {0}", nonce);

            // randomly generated nonce
            // we can hard code it for our tool
            byte[] context = { 25, 152, 185, 126, 55, 118, 199, 221, 254, 108, 255, 202, 88, 128, 76, 218, 200, 157, 211, 63, 242, 37, 152, 198 };
            var contextBase64 = "GZi5fjd2x93+bP/KWIBM2sid0z/yJZjG";

            var signingKey = CryptoUtils.DeriveSigningKey(sessionKey, context);

            var certificateJwe = await RdpCertificate(
                nonce,
                contextBase64,
                tenantId,
                refreshToken,
                signingKey,
                user,
                device
            );

            var certificates = CryptoUtils.DecryptCeritficate(sessionKey, CryptoUtils.ExtractContextFromJwe(certificateJwe), certificateJwe);
            var id = string.Format("{0}_client_auth", device.Id);

            Console.WriteLine(
                "The client P2P certificate (.cer) has been written into the file: {0}",
                CryptoUtils.PemCrtToFile(certificates[0], id + "_p2p")
            );

            Console.WriteLine(
                "The client P2P CA certificate (.cer) has been written into the file: {0}",
                CryptoUtils.PemCrtToFile(certificates[1], id + "_p2p_ca")
            );

            Console.WriteLine("Finished obtaining client P2P certificates!");
        }

        private static async Task<string> RdpCertificate(
            string nonce,
            string context,
            string tenantId,
            string refreshToken,
            byte[] signingKey,
            UserCreds user,
            DeviceCreds device
        )
        {
            Console.WriteLine("Start RDP certificate obtaining...");

            var httpClient = new HttpClient();

            var url = string.Format("https://login.microsoftonline.com/{0}/oauth2/token", tenantId);

            var certForm = new Dictionary<string, string>();
            certForm.Add("request", JwtUtils.GenerateRdpCertificateRequestJwt(
                nonce,
                context,
                user.Username,
                refreshToken,
                signingKey,
                device.Key
            ));
            certForm.Add("grant_type", "urn:ietf:params:oauth:grant-type:jwt-bearer");
            certForm.Add("windows_api_version", "2.2");

            var response = await httpClient.PostAsync(url, new FormUrlEncodedContent(certForm));
            var content = await response.Content.ReadAsStringAsync();

            if (response.StatusCode != HttpStatusCode.OK)
            {
                Console.WriteLine(string.Format("Error. Status code: {0}. Body:", response.StatusCode));
                Console.WriteLine(content);

                Environment.Exit(1);
            }

            Console.WriteLine(content);
            return content;
        }

        /// <summary>
        /// Obtains P2P certificate for server autherization using device key and certificate. Saves certificates in the 
        /// corresponding files:
        /// * `{device_id}_server_auth_p2p.cer`
        /// * `{device_id}_server_auth_p2p_ca.cer`
        /// </summary>
        /// <param name="domain">AzureAD domain</param>
        /// <param name="tenantId">Tenant id</param>
        /// <param name="device">Device credentials</param>
        /// <returns></returns>
        public static async Task ObtainServerP2PCertificate(string domain, string tenantId, DeviceCreds device)
        {
            Console.WriteLine("Start obtaining server P2P certificates...");

            var url = string.Format("https://login.microsoftonline.com/{0}/oauth2/token", tenantId);

            var nonce = await RequestNonce(tenantId);

            var certForm = new Dictionary<string, string>();
            certForm.Add("request", JwtUtils.GenerateP2PRequestJwt(
                nonce,
                device,
                string.Format("tenjo.{0}", domain)
            ));
            certForm.Add("grant_type", "urn:ietf:params:oauth:grant-type:jwt-bearer");
            certForm.Add("windows_api_version", "2.0");

            var httpClient = new HttpClient();

            var response = await httpClient.PostAsync(url, new FormUrlEncodedContent(certForm));
            var content = await response.Content.ReadAsStringAsync();

            if (response.StatusCode != HttpStatusCode.OK)
            {
                Console.WriteLine(string.Format("Error. Status code: {0}. Body:", response.StatusCode));
                Console.WriteLine(content);

                Environment.Exit(1);
            }

            Console.WriteLine(content);
            var p2pCerificatesResponse = P2PCertificatesResponse.FromString(content);
            var id = string.Format("{0}_server_auth", device.Id);

            Console.WriteLine(
                "The server P2P certificate (.cer) has been written into the file: {0}",
                CryptoUtils.PemCrtToFile(p2pCerificatesResponse.x5c, id + "_p2p")
            );

            Console.WriteLine(
                "The server P2P CA certificate (.cer) has been written into the file: {0}",
                CryptoUtils.PemCrtToFile(p2pCerificatesResponse.x5c_ca, id + "_p2p_ca")
            );

            Console.WriteLine("Finished obtaining server P2P certificates!");
        }

        /// <summary>
        /// Obtains P2P certificates.
        /// </summary>
        /// <param name="deviceId">Device id</param>
        /// <param name="domain">Azure AD domain</param>
        /// <param name="tenantId">Azure AD tenant id</param>
        /// <param name="device">Device credentials (private key and certificate)</param>
        /// <returns></returns>
        public static async Task ObtainP2PCertificates(string deviceId, string domain, string tenantId, DeviceCreds device)
        {
            Console.WriteLine("Start obtaining device P2P certificates...");

            var httpClient = new HttpClient();

            var url = string.Format("https://login.microsoftonline.com/{0}/oauth2/token", tenantId);

            var nonceForm = new Dictionary<string, string>();
            nonceForm.Add("grant_type", "srv_challenge");

            var nonceResponse = await httpClient.PostAsync(url, new FormUrlEncodedContent(nonceForm));
            var nonceContent = await nonceResponse.Content.ReadAsStringAsync();

            if (nonceResponse.StatusCode != HttpStatusCode.OK)
            {
                Console.WriteLine(string.Format("Error. Status code: {0}. Body:", nonceResponse.StatusCode));
                Console.WriteLine(nonceContent);
                Environment.Exit(1);
            }

            Console.WriteLine(nonceContent);

            var document = JsonDocument.Parse(nonceContent);
            var nonce = document.RootElement.GetProperty("Nonce");

            var certForm = new Dictionary<string, string>();
            certForm.Add("request", JwtUtils.GenerateP2PRequestJwt(
                nonce.ToString(),
                device,
                string.Format("mypc.{0}", domain)
            ));
            certForm.Add("grant_type", "urn:ietf:params:oauth:grant-type:jwt-bearer");
            certForm.Add("windows_api_version", "2.0");

            var response = await httpClient.PostAsync(url, new FormUrlEncodedContent(certForm));
            var content = await response.Content.ReadAsStringAsync();

            if (response.StatusCode != HttpStatusCode.OK)
            {
                Console.WriteLine(string.Format("Error. Status code: {0}. Body:", response.StatusCode));
                Console.WriteLine(content);

                Environment.Exit(1);
            }

            Console.WriteLine(content);
            var p2pCerificatesResponse = P2PCertificatesResponse.FromString(content);

            Console.WriteLine(
                "The device P2P certificate (.cer) has been written into the file: {0}",
                CryptoUtils.PemCrtToFile(p2pCerificatesResponse.x5c, deviceId + "_p2p")
            );

            Console.WriteLine(
                "The device P2P CA certificate (.cer) has been written into the file: {0}",
                CryptoUtils.PemCrtToFile(p2pCerificatesResponse.x5c_ca, deviceId + "_p2p_ca")
            );

            Console.WriteLine("Finished obtaining device P2P certificates!");
        }
    }
}


--- File: tools/aadjoin/AADJoin/Creds/DeviceCreds.cs ---
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Threading.Tasks;

namespace AADJoin.Creds
{
    public class DeviceCreds
    {
        public string Id { get; set; }
        public RSA Key { get; set; }
        public X509Certificate Certificate { get; set; }

        public DeviceCreds(string id, RSA key, X509Certificate certificate)
        {
            Id = id;
            Key = key;
            Certificate = certificate;
        }

        public DeviceCreds(RSA key, X509Certificate certificate)
        {
            Console.WriteLine(certificate.Subject);
            Id = certificate.Subject.Split('=')[1];
            Key = key;
            Certificate = certificate;
        }

        public static DeviceCreds Empty()
        {
            return new DeviceCreds(null, null, null);
        }

        public static DeviceCreds FromPfx(string pfxPath, string password)
        {
            X509Certificate2 cert = new X509Certificate2(pfxPath, password, X509KeyStorageFlags.Exportable);

            return new DeviceCreds(
                cert.GetRSAPrivateKey(),
                new X509Certificate(Convert.FromHexString(cert.GetRawCertDataString()))
            );
        }
    }
}


--- File: tools/aadjoin/AADJoin/Creds/UserCreds.cs ---
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace AADJoin.Creds
{
    public class UserCreds
    {
        public string Username { get; set; }
        public string Password { get; set; }
        public string Domain { get; set; }

        public UserCreds(string username, string password, string domain)
        {
            if (username == null)
            {
                throw new ArgumentNullException(nameof(username));
            }

            if (password == null)
            {
                throw new ArgumentNullException(nameof(password));
            }

            if (domain == null)
            {
                throw new ArgumentNullException(nameof(domain));
            }

            Username = username;
            Password = password;
            Domain = domain;
        }
    }
}


--- File: tools/aadjoin/AADJoin/Messages/AuthResponse.cs ---
﻿using System;
using System.Text.Json;

namespace AADJoin.Messages
{
    public class AuthResponse
    {
        public string token_type { get; set; }
        public string scope { get; set; }
        public string expires_in { get; set; }
        public string ext_expires_in { get; set; }
        public string expires_on { get; set; }
        public string not_before { get; set; }
        public string resource { get; set; }
        public string access_token { get; set; }
        public string refresh_token { get; set; }
        public string id_token { get; set; }

        public static AuthResponse fromString(string authResponse)
        {
            return JsonSerializer.Deserialize<AuthResponse>(authResponse);
        }

        public string GetTenantId()
        {
            var payload = id_token.Split('.')[1];
            switch (payload.Length % 4)
            {
                case 2: payload += "=="; break;
                case 3: payload += "="; break;
            }

            var document = JsonDocument.Parse(Convert.FromBase64String(payload));
            var idToken = document.RootElement.GetProperty("tid");

            return idToken.GetString();
        }
    }
}


--- File: tools/aadjoin/AADJoin/Messages/JoinDeviceRequest.cs ---
﻿using System;
using System.Text.Json;
using System.Security.Cryptography.X509Certificates;
using System.Security.Cryptography;
using System.Text.Json.Serialization;
using AADJoin.Utils;

namespace AADJoin.Messages
{
    public class JoinDeviceRequest
    {
        public class Csr
        {
            [JsonInclude]
            public string Type { get; set; }
            [JsonInclude]
            public string Data { get; set; }

            public Csr(string type, string data)
            {
                Type = type;
                Data = data;
            }
        }

        public class Attrs
        {
            [JsonInclude]
            public string ReuseDevice { get; set; }
            [JsonInclude]
            public string ReturnClientSid { get; set; }
            [JsonInclude]
            public string SharedDevice { get; set; }

            public Attrs(bool reuse, bool returnClientSid, bool sharedDevice)
            {
                ReuseDevice = reuse.ToString();
                ReturnClientSid = returnClientSid.ToString();
                SharedDevice = sharedDevice.ToString();
            }
        }

        public string TransportKey { get; set; }
        public int JoinType { get; set; }
        public string DeviceDisplayName { get; set; }
        public string OSVersion { get; set; }
        [JsonInclude]
        public Csr CertificateRequest { get; set; }
        public string TargetDomain { get; set; }
        public string DeviceType { get; set; }
        [JsonInclude]
        public Attrs Attributes { get; set; }

        public JoinDeviceRequest(string domain, RSACng key, Guid deviceId)
        {
            byte[] rsaPubKeyExport = key.Key.Export(CngKeyBlobFormat.GenericPublicBlob);
            TransportKey = Convert.ToBase64String(rsaPubKeyExport);

            // https://github.com/Gerenios/AADInternals/blob/master/PRT_Utils.ps1#L101
            // 0 = Azure AD join
            // 4 = Azure AD registered
            // 6 = Azure AD hybrid join
            JoinType = 0;

            var now = DateTime.Now;
            DeviceDisplayName = string.Format(
                "Test Device {0}{1}{2} {3}{4}{5}",
                now.Year, now.Month, now.Day, now.Hour, now.Minute, now.Second
            );

            OSVersion = "10.0.22000.978";

            var csr = new CertificateRequest("CN=7E980AD9-B86D-4306-9425-9AC066FB014A", key, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
            var rawCsr = Convert.ToBase64String(csr.CreateSigningRequest());
            CertificateRequest = new Csr("pkcs10", rawCsr);

            Console.WriteLine("The device certificate request (CSR) has been written into the file: {0}", CryptoUtils.PemCsrToFile(rawCsr, deviceId));

            TargetDomain = domain;

            DeviceType = "Windows";

            Attributes = new Attrs(true, true, false);
        }

        public override string ToString()
        {
            return JsonSerializer.Serialize(this);
        }
    }
}


--- File: tools/aadjoin/AADJoin/Messages/JoinDeviceResponse.cs ---
﻿using System.Text.Json;
using System.Text.Json.Serialization;

namespace AADJoin.Messages
{
    public class JoinDeviceResponse
    {
        public class Cert
        {
            [JsonInclude]
            public string Thumbprint { get; set; }
            [JsonInclude]
            public string RawBody { get; set; }
        }

        public class Usr
        {
            [JsonInclude]
            public string Upn { get; set; }
        }

        public class MembershipChgs
        {
            [JsonInclude]
            public string LocalSID { get; set; }
            [JsonInclude]
            public string[] AddSIDs { get; set; }
        }

        public Cert Certificate { get; set; }
        public Usr User { get; set; }
        public MembershipChgs[] MembershipChanges { get; set; }

        public static JoinDeviceResponse FromString(string data)
        {
            return JsonSerializer.Deserialize<JoinDeviceResponse>(data);
        }
    }
}


--- File: tools/aadjoin/AADJoin/Messages/P2PCertificatesResponse.cs ---
﻿using System.Text.Json;

namespace AADJoin.Messages
{
    public class P2PCertificatesResponse
    {
        public string token_type { get; set; }
        public string expires_in { get; set; }
        public string ext_expires_in { get; set; }
        public string expires_on { get; set; }
        public string x5c { get; set; }
        public string cert_token_use { get; set; }
        public string x5c_ca { get; set; }
        public string resource { get; set; }

        public static P2PCertificatesResponse FromString(string data)
        {
            return JsonSerializer.Deserialize<P2PCertificatesResponse>(data);
        }
    }
}


--- File: tools/aadjoin/AADJoin/Messages/TenantAuthResponse.cs ---
﻿using System;
using System.Text.Json;

namespace AADJoin.Messages
{
    public class TenantAuthResponse
    {
        public string token_type { get; set; }
        public string scope { get; set; }
        public string expires_in { get; set; }
        public string ext_expires_in { get; set; }
        public string expires_on { get; set; }
        public string not_before { get; set; }
        public string resource { get; set; }
        public string access_token { get; set; }
        public string refresh_token { get; set; }
        public string id_token { get; set; }

        public static TenantAuthResponse FromString(string authResponse)
        {
            return JsonSerializer.Deserialize<TenantAuthResponse>(authResponse);
        }
    }
}


--- File: tools/aadjoin/AADJoin/Options.cs ---
﻿using CommandLine;

namespace AADJoin
{
    public class Options
    {
        [Option('j', "join-new-device", Required = false, HelpText = "Join new device to the Azure AD")]
        public bool JoinNewDevice { get; set; }

        [Option('c', "client-p2p-cert", Required = false, HelpText = "Obtain P2P certificate for the client authorization")]
        public bool ClientP2PCert { get; set; }

        [Option('s', "server-p2p-cert", Required = false, HelpText = "Obtain P2P certificate for the server authorization")]
        public bool ServerP2PCert { get; set; }

        [Option('d', "domain", Required = true, HelpText = "Azure AD domain")]
        public string Domain { get; set; }

        [Option('u', "username", Required = true, HelpText = "User Azure AD username in FQDN format")]
        public string Username { get; set; }

        [Option('p', "password", Required = true, HelpText = "User password")]
        public string Password { get; set; }

        [Option('e', "existing-device", Required = false, HelpText = "Path to the PFX file with the device key + certificate")]
        public string DevicePfx { get; set; }

        [Option('f', "pfx-key-password", Required = false, HelpText = "PFX file password")]
        public string PfxPassword { get; set; }
    }
}


--- File: tools/aadjoin/AADJoin/Program.cs ---
﻿using System;
using System.Threading.Tasks;
using System.Collections.Generic;
using CommandLine;
using AADJoin.Creds;

namespace AADJoin
{
    public class Program
    {
        static async Task Main(string[] args)
        {
            await Parser.Default.ParseArguments<Options>(args).WithParsedAsync(RunOptions);
        }

        static async Task RunOptions(Options opts)
        {
            var device = DeviceCreds.Empty();
            var user = new UserCreds(opts.Username, opts.Password, opts.Domain);

            // well-known client ids: https://github.com/Gerenios/AADInternals/blob/master/AccessToken_utils.ps1#L11
            // graph_api: 1b730954-1685-4b74-9bfd-dac224a7b894
            string clientId = "1b730954-1685-4b74-9bfd-dac224a7b894";

            await AzureAD.CheckUsername(opts.Username);
            var authResponse = await AzureAD.AzureAdAuthorize(clientId, user);

            if (opts.JoinNewDevice)
            {
                var tenantAuthResponse = await AzureAD.AzureTenantAuthorize(clientId, authResponse);
                device = await AzureAD.JoinDevice(opts.Domain, tenantAuthResponse);
            } else if (opts.DevicePfx != null)
            {
                Console.WriteLine("Trying to load device PFX file...");
                device = DeviceCreds.FromPfx(opts.DevicePfx, opts.PfxPassword);
            } else
            {
                Console.WriteLine("Error: No device information provided.");
                Environment.Exit(1);
            }

            if (opts.ServerP2PCert)
            {
                await AzureAD.ObtainServerP2PCertificate(user.Domain, authResponse.GetTenantId(), device);
            } else if (opts.ClientP2PCert)
            {
                await AzureAD.ObtainClientP2PCertificate(user, authResponse.GetTenantId(), device);
            } else
            {
                Console.WriteLine("Nothing left to do.");
            }
        }
    }
}


--- File: tools/aadjoin/AADJoin/Utils/CryptoUtils.cs ---
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Text.Json;

namespace AADJoin.Utils
{
    public class CryptoUtils
    {
        public static string PemCsrToFile(string rawCsr, Guid id)
        {
            return PemCsrToFile(rawCsr, id.ToString());
        }

        public static string PemCsrToFile(string rawCsr, string id)
        {
            var fileId = id + ".csr";

            string[] lines = { "-----BEGIN CERTIFICATE REQUEST-----", rawCsr, "-----END CERTIFICATE REQUEST-----" };
            File.WriteAllLines(fileId, lines);

            return fileId;
        }

        public static string PemCrtToFile(string rawCrt, Guid id)
        {
            return PemCrtToFile(rawCrt, id.ToString());
        }

        public static string PemCrtToFile(string rawCrt, string id)
        {
            var fileId = id + ".cer";

            string[] lines = { "-----BEGIN CERTIFICATE-----", rawCrt, "-----END CERTIFICATE-----" };
            File.WriteAllLines(fileId, lines);

            return fileId;
        }

        public static string RsaToPkcs8String(RSACng rsaKey, string password)
        {
            var bytes = rsaKey.ExportEncryptedPkcs8PrivateKey(
                password,
                new PbeParameters(PbeEncryptionAlgorithm.Aes256Cbc, HashAlgorithmName.SHA256, 15)
            );

            return Convert.ToBase64String(bytes);
        }

        public static string RsaToPkcs8File(RSACng rsaKey, string password, string id)
        {
            var fileId = id + ".key";

            var bytes = rsaKey.ExportEncryptedPkcs8PrivateKey(
                password,
                new PbeParameters(PbeEncryptionAlgorithm.Aes256Cbc, HashAlgorithmName.SHA256, 15)
            );
            string[] lines = {
                "-----BEGIN ENCRYPTED PRIVATE KEY-----",
                Convert.ToBase64String(bytes),
                "-----END ENCRYPTED PRIVATE KEY-----"
            };
            File.WriteAllLines(fileId, lines);

            return fileId;
        }

        public static string PemCrtToPfxFile(string rawCrt, RSA privateKey, string id, string password)
        {
            var fileId = id + ".pfx";

            X509Certificate2 cert = new X509Certificate2(Convert.FromBase64String(rawCrt));
            X509Certificate2 pfxCert = cert.CopyWithPrivateKey(privateKey);

            byte[] pkcs12 = pfxCert.Export(X509ContentType.Pfx, password);

            File.WriteAllBytes(fileId, pkcs12);

            return fileId;
        }

    public static RSA Pkcs8ToRsa(string password, string content)
        {
            var rsa = RSA.Create();

            int bytesRead = 0;
            ReadOnlySpan<char> passwordSpan = password.AsSpan();
            ReadOnlySpan<byte> contentSpan = Convert.FromBase64String(content);
            rsa.ImportEncryptedPkcs8PrivateKey(passwordSpan, contentSpan, out bytesRead);

            return rsa;
        }

        public static byte[] FromBase64(string payload)
        {
            var data = payload.Replace("_", "/").Replace("-","+");

            while (data.Length % 4 != 0)
            {
                data += '=';
            }

            return Convert.FromBase64String(data);
        }

        public static byte[] DecryptSessionKeyFromJwe(string jwe, RSA key)
        {
            Console.WriteLine(jwe);
            var parsedJwe = jwe.Split('.');
            var cipher = FromBase64(parsedJwe[1]);
            Console.WriteLine(cipher.Length);

            return key.Decrypt(cipher, RSAEncryptionPadding.OaepSHA1);
        }

        public static byte[] ExtractContextFromJwe(string jwe)
        {
            var document = JsonDocument.Parse(FromBase64(jwe.Split('.')[0]));
            return FromBase64(document.RootElement.GetProperty("ctx").ToString());
        }

        public static byte[] DeriveSigningKey(byte[] sessionKey, byte[] context)
        {
            byte[] label = Encoding.UTF8.GetBytes("AzureAD-SecureConversation");

            List<byte> computeValue = new List<byte>();
            computeValue.AddRange(new byte[] { 0x00, 0x00, 0x00, 0x01 });
            computeValue.AddRange(label);
            computeValue.Add(0x00);
            computeValue.AddRange(context);
            computeValue.AddRange(new byte[] { 0x00, 0x00, 0x01, 0x00 });

            HMACSHA256 hmac = new HMACSHA256(sessionKey);
            byte[] hmacOutput = hmac.ComputeHash(computeValue.ToArray());

            return hmacOutput;
        }

        public static string[] DecryptCeritficate(byte[] sessionKey, byte[] context, string jwe)
        {
            var parsedJwe = jwe.Split('.');
            var iv = FromBase64(parsedJwe[2]);
            var encData = FromBase64(parsedJwe[3]);
            var signingKey = DeriveSigningKey(sessionKey, context);

            var cryptoProvider = new AesCryptoServiceProvider();
            cryptoProvider.IV = iv;
            cryptoProvider.Key = signingKey;

            var buffer = new MemoryStream();
            var cryptoStream = new CryptoStream(buffer, cryptoProvider.CreateDecryptor(signingKey, iv), CryptoStreamMode.Write);

            cryptoStream.Write(encData, 0, encData.Count());
            cryptoStream.FlushFinalBlock();
            var decData = buffer.ToArray();

            cryptoStream.Dispose();
            cryptoProvider.Dispose();

            var document = JsonDocument.Parse(decData);
            var rdp = document.RootElement.GetProperty("x5c").ToString();
            var rdp_ca = document.RootElement.GetProperty("x5c_ca").ToString();

            return new[] { rdp, rdp_ca }; 
        }
    }
}


--- File: tools/aadjoin/AADJoin/Utils/JwtUtils.cs ---
﻿using System;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Cryptography.X509Certificates;
using System.Security.Cryptography;
using System.IO;
using System.Text;
using AADJoin.Creds;

namespace AADJoin.Utils
{
    public class JwtUtils
    {
        // The AAD cloud ap identifier. it will always be "38aa3b87-a06d-4817-b275–7a316988d93b"
        static string AadApIdentifier = "38aa3b87-a06d-4817-b275-7a316988d93b";

        public static string GenerateRdpCertificateRequestJwt(
            string nonce,
            string context,
            string username,
            string refreshToken,
            byte[] signingKey,
            RSA key
        )
        {
            var header = new JwtHeader();
            header.Add("alg", "HS256");
            header.Add("kdf_ver", "2");
            header.Add("ctx", context);

            var payload = new JwtPayload();
            payload.Add("iss", "aad:brokerplugin");
            payload.Add("grant_type", "refresh_token");
            payload.Add("aud", "login.microsoftonline.com");
            payload.Add("request_nonce", nonce);
            payload.Add("scope", "openid aza ugs");
            payload.Add("refresh_token", refreshToken);
            payload.Add("client_id", AadApIdentifier);
            payload.Add("cert_token_use", "user_cert");
            payload.Add("csr_type", "http://schemas.microsoft.com/windows/pki/2009/01/enrollment#PKCS10");

            var csr = new CertificateRequest(string.Format("CN = {0}", username), key, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
            var rawCsr = Convert.ToBase64String(csr.CreateSigningRequest());
            payload.Add("csr", rawCsr);

            payload.Add("win_ver", "10.0.22000.653");

            var dataToSign = string.Format("{0}.{1}", header.Base64UrlEncode(), payload.Base64UrlEncode());

            HMACSHA256 hmac = new HMACSHA256(signingKey);
            byte[] hmacOutput = hmac.ComputeHash(Encoding.UTF8.GetBytes(dataToSign));

            var finalJwt = string.Format("{0}.{1}", dataToSign, Convert.ToBase64String(hmacOutput).Split('=')[0]);
            Console.WriteLine(finalJwt);

            return finalJwt;
        }

        public static string GenerateFRequestJwt(string nonce, DeviceCreds device, UserCreds user)
        {
            var header = new JwtHeader();
            header.Add("alg", "RS256");
            header.Add("typ", "JWT");
            header.Add("x5c", Convert.ToBase64String(device.Certificate.Export(X509ContentType.Cert)));
            header.Add("kdf_ver", "2");

            var payload = new JwtPayload();
            payload.Add("client_id", AadApIdentifier);
            payload.Add("request_nonce", nonce);
            payload.Add("scope", "openid aza ugs");
            payload.Add("win_ver", "10.0.22000.653");
            payload.Add("grant_type", "password");
            payload.Add("username", user.Username);
            payload.Add("password", user.Password);

            var dataToSign = string.Format("{0}.{1}", header.Base64UrlEncode(), payload.Base64UrlEncode());

            var signature = device.Key.SignData(Encoding.ASCII.GetBytes(dataToSign), HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);

            var finalJwt = string.Format("{0}.{1}", dataToSign, Convert.ToBase64String(signature).Split('=')[0]);
            Console.WriteLine(finalJwt);

            return finalJwt;
        }

        public static string GenerateP2PRequestJwt(string nonce, DeviceCreds device, string dnsName)
        {
            var header = new JwtHeader();
            header.Add("alg", "RS256");
            header.Add("typ", "JWT");
            header.Add("x5c", Convert.ToBase64String(device.Certificate.Export(X509ContentType.Cert)));

            var payload = new JwtPayload();
            payload.Add("client_id", AadApIdentifier);
            payload.Add("request_nonce", nonce);
            payload.Add("win_ver", "10.0.18363.0");
            payload.Add("grant_type", "device_auth");
            payload.Add("cert_token_use", "device_cert");
            payload.Add("csr_type", "http://schemas.microsoft.com/windows/pki/2009/01/enrollment#PKCS10");

            var csr = new CertificateRequest(device.Certificate.Subject, device.Key, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);

            var rawCsr = Convert.ToBase64String(csr.CreateSigningRequest());
            payload.Add("csr", rawCsr);

            payload.Add("netbios_name", dnsName);
            payload.Add("dns_names", new string[] { dnsName });

            var dataToSign = string.Format("{0}.{1}", header.Base64UrlEncode(), payload.Base64UrlEncode());

            var signature = device.Key.SignData(Encoding.ASCII.GetBytes(dataToSign), HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);

            var finalJwt = string.Format("{0}.{1}", dataToSign, Convert.ToBase64String(signature).Split('=')[0]);
            Console.WriteLine(finalJwt);

            return finalJwt;
        }
    }
}


--- File: tools/aadjoin/README.md ---

# AADJoin

### Purpose of this tool

This tool simulates new device joining to the Azure Active Directory and device certificates obtaining.

It can obtain three types of certificates:

* the device certificate;
* the client certificate for the P2P authorization
* the server certificate for the P2P authorization

All generated keys, CSRs, and certificates will be saved in appropriate files. You will see paths to them in logs.

### How use it

```
AADJoin 1.0.0
Copyright (C) 2022 AADJoin

  -j, --join-new-device     Join new device to the Azure AD

  -c, --client-p2p-cert     Obtain P2P certificate for the client authorization

  -s, --server-p2p-cert     Obtain P2P certificate for the server authorization

  -d, --domain              Required. Azure AD domain

  -u, --username            Required. User Azure AD username in FQDN format

  -p, --password            Required. User password

  -e, --existing-device     Path to the PFX file with the device key + certificate

  -f, --pfx-key-password    PFX file password

  --help                    Display this help screen.

  --version                 Display version information.
```

*Attention: To run this tool you need .Net 6.0.8 runtime*

### Example

Create and join a new device to the AzureAD:

```bash
AADJoin.exe --join-new-device --domain dataans.com --username s10@dataans.com --password wwwWWW222@@@
```

The comman above will create a three files:

* `<device id>.key` - the device private key;
* `<random guid>.csr` - the certificate request that had been used for the device certificate generation;
* `<device id>.cer` - the device certificate;

My example:

```
03b8620d-12ff-48ee-b036-e1cf4c598609.key
007bfc57-2504-404c-99f4-6160d1bfe2cb.csr
03b8620d-12ff-48ee-b036-e1cf4c598609.cer
```

We can obtain the server P2P sertificate with the following command:

```bash
AADJoin.exe --existing-device 03b8620d-12ff-48ee-b036-e1cf4c598609.pfx --pfx-key-password 03b8620d-12ff-48ee-b036-e1cf4c598609 --domain dataans.com --username s10@dataans.com --password wwwWWW222@@@ --server-p2p-cert
```

The command above will create two files:

* `<device id>_server_auth_p2p.cer` - the P2P certificate for the server authentication;
* `<device id>_server_auth_p2p_ca.cer` - the P2P CA certificate of the obtained certificate;

We can obtain the client P2P sertificate with the following command:

```bash
AADJoin.exe --existing-device 03b8620d-12ff-48ee-b036-e1cf4c598609.pfx --pfx-key-password 03b8620d-12ff-48ee-b036-e1cf4c598609 --domain dataans.com --username s10@dataans.com --password wwwWWW222@@@ --client-p2p-cert
```

The command above will create two files:

* `<device id>_client_auth_p2p.cer` - the P2P certificate for the client authentication;
* `<device id>_client_auth_p2p_ca.cer` - the P2P CA certificate of the obtained certificate;

And here are files I had:

```
03b8620d-12ff-48ee-b036-e1cf4c598609_client_auth_p2p.cer
03b8620d-12ff-48ee-b036-e1cf4c598609_client_auth_p2p_ca.cer
03b8620d-12ff-48ee-b036-e1cf4c598609_server_auth_p2p.cer
03b8620d-12ff-48ee-b036-e1cf4c598609_server_auth_p2p_ca.cer
```


--- File: tools/aadjoin/UnitTests/UnitTest1.cs ---
using Microsoft.VisualStudio.TestTools.UnitTesting;
using AADJoin.Messages;
using System.Security.Cryptography;
using System;
using System.Text;
using AADJoin.Utils;
using System.Globalization;
using System.Numerics;
using System.Collections.Generic;
using System.Linq;
using AADJoin;
using System.Threading.Tasks;
using Newtonsoft.Json.Bson;
using Microsoft.IdentityModel.Tokens;
using System.IO;
using System.Security.Cryptography.X509Certificates;

namespace UnitTests
{
    [TestClass]
    public class UnitTest1
    {
        [TestMethod]
        public void TestTenantIdParsing()
        {
            var authResponse = AuthResponse.fromString("{\"token_type\":\"Bearer\",\"scope\":\"user_impersonation\",\"expires_in\":\"3958\",\"ext_expires_in\":\"3958\",\"expires_on\":\"1660206842\",\"not_before\":\"1660202583\",\"resource\":\"https://graph.windows.net\",\"access_token\":\"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6IjJaUXBKM1VwYmpBWVhZR2FYRUpsOGxWMFRPSSIsImtpZCI6IjJaUXBKM1VwYmpBWVhZR2FYRUpsOGxWMFRPSSJ9.eyJhdWQiOiJodHRwczovL2dyYXBoLndpbmRvd3MubmV0IiwiaXNzIjoiaHR0cHM6Ly9zdHMud2luZG93cy5uZXQvYTkyNTI0NDgtOWFiNy00OWIwLWJiNWMtZjJmOTIzYzg0NjcyLyIsImlhdCI6MTY2MDIwMjU4MywibmJmIjoxNjYwMjAyNTgzLCJleHAiOjE2NjAyMDY4NDIsImFjciI6IjEiLCJhaW8iOiJBU1FBMi84VEFBQUF4dHBFbTMvWnEwQlZPcnQ3M1BXazNYTjJzRHlrUGdRUjgvWENqLzA2OEpzPSIsImFtciI6WyJwd2QiXSwiYXBwaWQiOiIxYjczMDk1NC0xNjg1LTRiNzQtOWJmZC1kYWMyMjRhN2I4OTQiLCJhcHBpZGFjciI6IjAiLCJpcGFkZHIiOiIxOTQuNDQuNDUuMTIxIiwibmFtZSI6InM0Iiwib2lkIjoiZWE4YjhlODctNzM0OC00MzJhLWFlNTUtNGIyMjQ2MWE3NGJkIiwicHVpZCI6IjEwMDMyMDAyMUFFRDgzNjciLCJyaCI6IjAuQVhrQVNDUWxxYmVhc0VtN1hQTDVJOGhHY2dJQUFBQUFBQUFBd0FBQUFBQUFBQUNVQUkwLiIsInNjcCI6InVzZXJfaW1wZXJzb25hdGlvbiIsInN1YiI6ImRzeU5ZNUp3SzYxbU5PbTAwakdNOFgtak5VdS00X1BuMmRIQmxoMnc4QkkiLCJ0ZW5hbnRfcmVnaW9uX3Njb3BlIjoiRVUiLCJ0aWQiOiJhOTI1MjQ0OC05YWI3LTQ5YjAtYmI1Yy1mMmY5MjNjODQ2NzIiLCJ1bmlxdWVfbmFtZSI6InM0QGRhdGFhbnMuY29tIiwidXBuIjoiczRAZGF0YWFucy5jb20iLCJ1dGkiOiJyRTl4QVdjWnlrSzJVT0VQeEdGWUFBIiwidmVyIjoiMS4wIn0.Ma5odOE1Lnm0C_5aCPPLdyTISO-1wNhTjLcvgXl4D_1LyxeXSYnMv5H0D2_HNjntDWPqBWzpXbujCE3rwZYeoSlrBSC2N3Ua0T38ceOCxS7fwA70Th4dgpFITPHokintL26eLXnlwr7erOOO_1T8RGcj9RRolF5gI1ArnL4nXmBsKisQBjZuFqKUYZgMzqBbBtcxbRGy_NduaOx_NKwxE_c7Pmo4mS6YX22n4z4p1hakCXqk3UmGin3basWHRoiD32Z7vJyXX1KWkvv8MIVupVkurW8KAvRfx4asSAsQn7Ii2_JsItxLCDoFXY--6VFaB4mwdp6xKQWchb1BVZi0dA\",\"refresh_token\":\"0.AXkASCQlqbeasEm7XPL5I8hGclQJcxuFFnRLm_3awiSnuJSUAI0.AgABAAEAAAD--DLA3VO7QrddgJg7WevrAgDs_wQA9P-v1WHQotebkoyXd9fjaE78Ld2Esf6sLTg0AeeyRqOL7XekLSSdFiAncPZTwZYzG_E60e6DZYgrAhRxBt5QRgRLNtHDAJZ2h0tiXGdpSQsLvlXKWQEre1FeosL6KeAGPCCfphBX_1khW8tk-YIxXi_5kwUxZedbwPS3qA5VnQKvYvPMF9bQyHYUdk8AVfPsorcln4KTQdTaRpoGZCsdwTtat13jnOnfs6NSr7JV_l6U2ysCyZZDtS2Q327lGH8_MTwhf-rtxJe60T8dDFsPQhGPGXwYSKJoToLE3UXMIGcjMtkgsiPkku-XGDLvR4c2WlDYm4TwZUKQ5JUZvBk9jeFPLS2WCrdguK5pWKjZw02vLBu3eBxE7AesZXNew-bNvjyG65qBJRI_0du7z0NH5CaiqCeWmgc7bHejl3pkM6_WXhhBpj_OvnzwJFbPbmSW1_N24FaJiqralvPIyQqqBjkX1GTzHDLHONaGD5en2w2Z4m_4glTkko4z3IP3YGP_AN_WjdJ5NPrgBEYzAmlaMNJDEFejXPe2ifWjxucwqhVbPBu5_TcwJhuErx1adl4YQ_Pzq56BaP3Ybi6gNxdnnsqtcOPiDlMC5lv8BCIOT4kLW8bpksM1tqpxUrxHNk65C4qiHEVWABH8cpabmg\",\"id_token\":\"eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJhdWQiOiIxYjczMDk1NC0xNjg1LTRiNzQtOWJmZC1kYWMyMjRhN2I4OTQiLCJpc3MiOiJodHRwczovL3N0cy53aW5kb3dzLm5ldC9hOTI1MjQ0OC05YWI3LTQ5YjAtYmI1Yy1mMmY5MjNjODQ2NzIvIiwiaWF0IjoxNjYwMjAyNTgzLCJuYmYiOjE2NjAyMDI1ODMsImV4cCI6MTY2MDIwNjQ4MywiYW1yIjpbInB3ZCJdLCJpcGFkZHIiOiIxOTQuNDQuNDUuMTIxIiwibmFtZSI6InM0Iiwib2lkIjoiZWE4YjhlODctNzM0OC00MzJhLWFlNTUtNGIyMjQ2MWE3NGJkIiwicHVpZCI6IjEwMDMyMDAyMUFFRDgzNjciLCJyaCI6IjAuQVhrQVNDUWxxYmVhc0VtN1hQTDVJOGhHY2xRSmN4dUZGblJMbV8zYXdpU251SlNVQUkwLiIsInN1YiI6ImVzQzkwWWdfN3MyTVBXNTA0cE04UVp5Njl4ZGZPUVQxbExoQnZqYjdJRjgiLCJ0ZW5hbnRfcmVnaW9uX3Njb3BlIjoiRVUiLCJ0aWQiOiJhOTI1MjQ0OC05YWI3LTQ5YjAtYmI1Yy1mMmY5MjNjODQ2NzIiLCJ1bmlxdWVfbmFtZSI6InM0QGRhdGFhbnMuY29tIiwidXBuIjoiczRAZGF0YWFucy5jb20iLCJ2ZXIiOiIxLjAifQ.\"}");

            Assert.AreEqual("a9252448-9ab7-49b0-bb5c-f2f923c84672", authResponse.GetTenantId());
        }

        [TestMethod]
        public void TestP2PCertificatesResponseParsing()
        {
            var rawResponse = "{\"token_type\":\"x509\",\"expires_in\":\"86399\",\"ext_expires_in\":\"0\",\"expires_on\":\"1660480130\",\"x5c\":\"MIIDgDCCAmigAwIBAgIQYNQVBIdbLvF59KM1CaK9UzANBgkqhkiG9w0BAQsFADBNMUswSQYDVQQDHkIATQBTAC0ATwByAGcAYQBuAGkAegBhAHQAaQBvAG4ALQBQADIAUAAtAEEAYwBjAGUAcwBzACAAWwAyADAAMgAyAF0wHhcNMjIwODEzMTIyMzUwWhcNMjIwODE0MTIyODUwWjBlMTQwMgYKCZImiZPyLGQBGRYkYTkyNTI0NDgtOWFiNy00OWIwLWJiNWMtZjJmOTIzYzg0NjcyMS0wKwYDVQQDDCRkNzgyNTIyNS02YTAzLTQ1Y2YtOTAzOC01MGM2ODM0MWRmMWYwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDiw1YUnKRxOMMOdBOc2DXgqR6qUp+4+43AURHRrez+lHu3/vi5LtQJZlh1SVLJxIRSzPo7LAvbD3lFga9f5TX5lzVn+fNUR6YmQxSGhNwt6XM6O+aiW/gS0QnS8CpLVI1rBkqA1HomHGAu6IWsIWBv+7BKLP50XaHP9HZLHeisJPWQqUkeZD319io20MM/prPCFCtvA70SFaZrFSGCtTPUbDeU57YgX/68Nwx34djD40CEein3q1cyGYRcPdJpS0W38hPLl9w5l6NVyXid5zRm4DFnICf+bqgsCOryx/LLLmoecI2Km51uELP1xlCl8A1rzyyv6O9H1oGP6lHsB9INAgMBAAGjRDBCMA4GA1UdDwEB/wQEAwIFoDATBgNVHSUEDDAKBggrBgEFBQcDATAbBgkrBgEEAYI3FQoEDjAMMAoGCCsGAQUFBwMBMA0GCSqGSIb3DQEBCwUAA4IBAQBcRy7zmvoWE8SvRQh1QJJf3sPvnmP6FnWkd5rU0oQrqeYx7Y++l7C0Hpl600FcsxMaEDi65uiW80vUpCTOjTlgCZv57Z7Ra8nTm0jI4Y+EiszoA8FZxPTjFv0hQ/f92sbjCLgi7TN6EcO8i+eGeez9uCAuvk2dITZBobOgEaqschpt0gnEeGHqHq3rIOuNqsFoBSmS3niIPULgtGElbhCNtsuGlAAdMch0gaYw6U29I+ZAQ0XRPSA+8IuC6hZcv4+ij3ItAkay544NCN4rEzAXiuEtee6YlBPjCqG3s4Gb0ebVFdEvZQ7k4Bh0h8O+hqDgde63Ki8o2Yu0bTMH3hbP\",\"cert_token_use\":\"device_cert\",\"x5c_ca\":\"MIIDRTCCAi2gAwIBAgIQFjJo2vHWmoNDMmy1tdDXjjANBgkqhkiG9w0BAQsFADBNMUswSQYDVQQDHkIATQBTAC0ATwByAGcAYQBuAGkAegBhAHQAaQBvAG4ALQBQADIAUAAtAEEAYwBjAGUAcwBzACAAWwAyADAAMgAyAF0wHhcNMjIwODA4MDAwMDAwWhcNMjMwODA4MDAwMDAwWjBNMUswSQYDVQQDHkIATQBTAC0ATwByAGcAYQBuAGkAegBhAHQAaQBvAG4ALQBQADIAUAAtAEEAYwBjAGUAcwBzACAAWwAyADAAMgAyAF0wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDL5cI1sb5q4MzqePzFPJkD+cZILh1+pbTriwbSY7pwPNdEEVQ6Z1aBcdVxYUHXYX7eEDulwH+0CQNLw+RHtrajIBEEf3n1DgHPno54rBaCK6jGeDo8SdM03B6HzFnH2Z8zDbYog42jtMyLsGgo6eGpLpL2kHHTwPnkqcVKT5zDodqlHu6Cl7ZSYJlJMV0nqYsIEocEidw3QBwPM3Eb2ZUIU+aLg64GGoCfoXFnoXqMVRymZLyMXZaDfT4J3pFQl8f6yutqmBu6j7XDxIAEamkMxD1FWicOVwOZMK9BYTLgaXXGawlx8Nf//3QhCaCDSliWDw7OeONBp1BodWymqamRAgMBAAGjITAfMB0GA1UdDgQWBBQRWuiJpM68E5FnjQ1sbUpkoa9EJTANBgkqhkiG9w0BAQsFAAOCAQEAWKFD5lu244+UPfSTPpUOaePzs0ofuDjDhYzrx9dNPiOU1SOKfmwNXz2qgeaWaggc2/zEhpgJ5S7593HBHNT8LbKRmwlT9+4qO78B3JsN0hKzqChXV8rczS4rFylmoUJIpVNrip+CHDyP4VVynillduVYEQDt5bkkBovQjonlWPq+nMxZz+vvl7mGCSYeN2FhwiUWO4AaDv0NGSjR3YJ1mpeZa9uNw/pyr5iF1g0BfjmUIDgCBpof3ZEIxFMkzDhmscIOOtTRKPV8H2MP907boXn1oNeJhb7WeoEaW2iwYr8uEef82f8NFKvDIVnr2nhcfCSoo/7bF2hvLEXw432ouQ==\",\"resource\":\"urn:p2p_cert\"}";

            var p2pCertificatesResponse = P2PCertificatesResponse.FromString(rawResponse);

            Assert.AreEqual("x509", p2pCertificatesResponse.token_type);
            Assert.AreEqual("86399", p2pCertificatesResponse.expires_in);
            Assert.AreEqual("0", p2pCertificatesResponse.ext_expires_in);
            Assert.AreEqual(
                "MIIDgDCCAmigAwIBAgIQYNQVBIdbLvF59KM1CaK9UzANBgkqhkiG9w0BAQsFADBNMUswSQYDVQQDHkIATQBTAC0ATwByAGcAYQBuAGkAegBhAHQAaQBvAG4ALQBQADIAUAAtAEEAYwBjAGUAcwBzACAAWwAyADAAMgAyAF0wHhcNMjIwODEzMTIyMzUwWhcNMjIwODE0MTIyODUwWjBlMTQwMgYKCZImiZPyLGQBGRYkYTkyNTI0NDgtOWFiNy00OWIwLWJiNWMtZjJmOTIzYzg0NjcyMS0wKwYDVQQDDCRkNzgyNTIyNS02YTAzLTQ1Y2YtOTAzOC01MGM2ODM0MWRmMWYwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDiw1YUnKRxOMMOdBOc2DXgqR6qUp+4+43AURHRrez+lHu3/vi5LtQJZlh1SVLJxIRSzPo7LAvbD3lFga9f5TX5lzVn+fNUR6YmQxSGhNwt6XM6O+aiW/gS0QnS8CpLVI1rBkqA1HomHGAu6IWsIWBv+7BKLP50XaHP9HZLHeisJPWQqUkeZD319io20MM/prPCFCtvA70SFaZrFSGCtTPUbDeU57YgX/68Nwx34djD40CEein3q1cyGYRcPdJpS0W38hPLl9w5l6NVyXid5zRm4DFnICf+bqgsCOryx/LLLmoecI2Km51uELP1xlCl8A1rzyyv6O9H1oGP6lHsB9INAgMBAAGjRDBCMA4GA1UdDwEB/wQEAwIFoDATBgNVHSUEDDAKBggrBgEFBQcDATAbBgkrBgEEAYI3FQoEDjAMMAoGCCsGAQUFBwMBMA0GCSqGSIb3DQEBCwUAA4IBAQBcRy7zmvoWE8SvRQh1QJJf3sPvnmP6FnWkd5rU0oQrqeYx7Y++l7C0Hpl600FcsxMaEDi65uiW80vUpCTOjTlgCZv57Z7Ra8nTm0jI4Y+EiszoA8FZxPTjFv0hQ/f92sbjCLgi7TN6EcO8i+eGeez9uCAuvk2dITZBobOgEaqschpt0gnEeGHqHq3rIOuNqsFoBSmS3niIPULgtGElbhCNtsuGlAAdMch0gaYw6U29I+ZAQ0XRPSA+8IuC6hZcv4+ij3ItAkay544NCN4rEzAXiuEtee6YlBPjCqG3s4Gb0ebVFdEvZQ7k4Bh0h8O+hqDgde63Ki8o2Yu0bTMH3hbP",
                p2pCertificatesResponse.x5c
            );
            Assert.AreEqual("device_cert", p2pCertificatesResponse.cert_token_use);
            Assert.AreEqual(
                "MIIDRTCCAi2gAwIBAgIQFjJo2vHWmoNDMmy1tdDXjjANBgkqhkiG9w0BAQsFADBNMUswSQYDVQQDHkIATQBTAC0ATwByAGcAYQBuAGkAegBhAHQAaQBvAG4ALQBQADIAUAAtAEEAYwBjAGUAcwBzACAAWwAyADAAMgAyAF0wHhcNMjIwODA4MDAwMDAwWhcNMjMwODA4MDAwMDAwWjBNMUswSQYDVQQDHkIATQBTAC0ATwByAGcAYQBuAGkAegBhAHQAaQBvAG4ALQBQADIAUAAtAEEAYwBjAGUAcwBzACAAWwAyADAAMgAyAF0wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDL5cI1sb5q4MzqePzFPJkD+cZILh1+pbTriwbSY7pwPNdEEVQ6Z1aBcdVxYUHXYX7eEDulwH+0CQNLw+RHtrajIBEEf3n1DgHPno54rBaCK6jGeDo8SdM03B6HzFnH2Z8zDbYog42jtMyLsGgo6eGpLpL2kHHTwPnkqcVKT5zDodqlHu6Cl7ZSYJlJMV0nqYsIEocEidw3QBwPM3Eb2ZUIU+aLg64GGoCfoXFnoXqMVRymZLyMXZaDfT4J3pFQl8f6yutqmBu6j7XDxIAEamkMxD1FWicOVwOZMK9BYTLgaXXGawlx8Nf//3QhCaCDSliWDw7OeONBp1BodWymqamRAgMBAAGjITAfMB0GA1UdDgQWBBQRWuiJpM68E5FnjQ1sbUpkoa9EJTANBgkqhkiG9w0BAQsFAAOCAQEAWKFD5lu244+UPfSTPpUOaePzs0ofuDjDhYzrx9dNPiOU1SOKfmwNXz2qgeaWaggc2/zEhpgJ5S7593HBHNT8LbKRmwlT9+4qO78B3JsN0hKzqChXV8rczS4rFylmoUJIpVNrip+CHDyP4VVynillduVYEQDt5bkkBovQjonlWPq+nMxZz+vvl7mGCSYeN2FhwiUWO4AaDv0NGSjR3YJ1mpeZa9uNw/pyr5iF1g0BfjmUIDgCBpof3ZEIxFMkzDhmscIOOtTRKPV8H2MP907boXn1oNeJhb7WeoEaW2iwYr8uEef82f8NFKvDIVnr2nhcfCSoo/7bF2hvLEXw432ouQ==",
                p2pCertificatesResponse.x5c_ca
            );
            Assert.AreEqual(
                "urn:p2p_cert",
                p2pCertificatesResponse.resource
            );
        }

        [TestMethod]
        public void TestJoinDeviceResponseParsing()
        {
            var rawJoinDeviceResponse = "{\"Certificate\":{\"Thumbprint\":\"63663A9293FD6CB5F108B1435C78136C36B0407B\",\"RawBody\":\"MIID8jCCAtqgAwIBAgIQFaOoakv7w5ZOUX3Jgk2P8TANBgkqhkiG9w0BAQsFADB4MXYwEQYKCZImiZPyLGQBGRYDbmV0MBUGCgmSJomT8ixkARkWB3dpbmRvd3MwHQYDVQQDExZNUy1Pcmdhbml6YXRpb24tQWNjZXNzMCsGA1UECxMkODJkYmFjYTQtM2U4MS00NmNhLTljNzMtMDk1MGMxZWFjYTk3MB4XDTIyMDgxMjIxMDQ1M1oXDTMyMDgxMjIxMzQ1M1owLzEtMCsGA1UEAxMkYTgwZWM0YjctODA4Ny00N2VmLWJjODYtZmNmY2FiOWJmNWQ5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwwiKdRD944dG340IpqnREL+DXVbLeiYSATsOFEegVAOB6UXVDTZ3QEEM6So6BqT0wCpDav7RxCmFUhkB6MH7PVv3FwqnYwxXSLBfHH9fVZXUISqqu3s2Vi5PbG0whw+OAchFATb1+/ttwHP+nnhhLOo9SJmNoznJ/ho3MJVLzn3/NJdZL2UIEVNPL+lPI01Wja6miDTbdHtmuByqqOYJJlxh2PYfW7LKSoV/5ZX7OYczowrsfxjuJBBj6NKctUB92LaTxtcwRoGKVZ8ARBO2mBmMHacRbqm2tVAVp4sK9c2nmKnSsVyVPkKdY0xNDIBy+JutPs/yA+RBWZrb6DK7/QIDAQABo4HAMIG9MAwGA1UdEwEB/wQCMAAwFgYDVR0lAQH/BAwwCgYIKwYBBQUHAwIwIgYLKoZIhvcUAQWCHAIEEwSBELfEDqiHgO9HvIb8/Kub9dkwIgYLKoZIhvcUAQWCHAMEEwSBEIeOi+pIcypDrlVLIkYadL0wIgYLKoZIhvcUAQWCHAUEEwSBEEgkJam3mrBJu1zy+SPIRnIwFAYLKoZIhvcUAQWCHAgEBQSBAkVVMBMGCyqGSIb3FAEFghwHBAQEgQExMA0GCSqGSIb3DQEBCwUAA4IBAQCBiJ4r1FKrdn/iqfDsYLdr7TbIulLccwXZJz3pNlUN/9EeTY6sVrW7H2iLCLk9bVk2S9b8WGuC+gO+E6CRpOPwWHHXAhrGCoEdlRXaWSY0kDArhvdMR9xGJOTPO0m6q8nn1Z3G8EtwD8qIbgwPtE08zJ5ls6UKmDLk9jiKXH6vCgwtgI9WCxNTJYG9npHkK0C6chEa1QZlo3aRKhRPqAJ8B1kh1XRZigXKT8Rqt2YjD+SWjWOYWupAAylysQaJwW+gAIXRQJW3OVpeaP4ajQqpYV11VlVR8t/mIWL1PE+ONJqZc/YFBrT6E9wPYBJzjCMurTj8kHr8yXfZzjNQaGN8\"},\"User\":{\"Upn\":\"s4@dataans.com\"},\"MembershipChanges\":[{\"LocalSID\":\"S-1-5-32-544\",\"AddSIDs\":[\"S-1-12-1-161258645-1267993664-2068636298-1054913958\",\"S-1-12-1-1201544774-1151677024-232476811-374148655\",\"S-1-12-1-3935014535-1126855496-575362478-3178502726\"]}]}";

            var joinResponse = JoinDeviceResponse.FromString(rawJoinDeviceResponse);

            Assert.AreEqual("63663A9293FD6CB5F108B1435C78136C36B0407B", joinResponse.Certificate.Thumbprint);
            Assert.AreEqual(
                "MIID8jCCAtqgAwIBAgIQFaOoakv7w5ZOUX3Jgk2P8TANBgkqhkiG9w0BAQsFADB4MXYwEQYKCZImiZPyLGQBGRYDbmV0MBUGCgmSJomT8ixkARkWB3dpbmRvd3MwHQYDVQQDExZNUy1Pcmdhbml6YXRpb24tQWNjZXNzMCsGA1UECxMkODJkYmFjYTQtM2U4MS00NmNhLTljNzMtMDk1MGMxZWFjYTk3MB4XDTIyMDgxMjIxMDQ1M1oXDTMyMDgxMjIxMzQ1M1owLzEtMCsGA1UEAxMkYTgwZWM0YjctODA4Ny00N2VmLWJjODYtZmNmY2FiOWJmNWQ5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwwiKdRD944dG340IpqnREL+DXVbLeiYSATsOFEegVAOB6UXVDTZ3QEEM6So6BqT0wCpDav7RxCmFUhkB6MH7PVv3FwqnYwxXSLBfHH9fVZXUISqqu3s2Vi5PbG0whw+OAchFATb1+/ttwHP+nnhhLOo9SJmNoznJ/ho3MJVLzn3/NJdZL2UIEVNPL+lPI01Wja6miDTbdHtmuByqqOYJJlxh2PYfW7LKSoV/5ZX7OYczowrsfxjuJBBj6NKctUB92LaTxtcwRoGKVZ8ARBO2mBmMHacRbqm2tVAVp4sK9c2nmKnSsVyVPkKdY0xNDIBy+JutPs/yA+RBWZrb6DK7/QIDAQABo4HAMIG9MAwGA1UdEwEB/wQCMAAwFgYDVR0lAQH/BAwwCgYIKwYBBQUHAwIwIgYLKoZIhvcUAQWCHAIEEwSBELfEDqiHgO9HvIb8/Kub9dkwIgYLKoZIhvcUAQWCHAMEEwSBEIeOi+pIcypDrlVLIkYadL0wIgYLKoZIhvcUAQWCHAUEEwSBEEgkJam3mrBJu1zy+SPIRnIwFAYLKoZIhvcUAQWCHAgEBQSBAkVVMBMGCyqGSIb3FAEFghwHBAQEgQExMA0GCSqGSIb3DQEBCwUAA4IBAQCBiJ4r1FKrdn/iqfDsYLdr7TbIulLccwXZJz3pNlUN/9EeTY6sVrW7H2iLCLk9bVk2S9b8WGuC+gO+E6CRpOPwWHHXAhrGCoEdlRXaWSY0kDArhvdMR9xGJOTPO0m6q8nn1Z3G8EtwD8qIbgwPtE08zJ5ls6UKmDLk9jiKXH6vCgwtgI9WCxNTJYG9npHkK0C6chEa1QZlo3aRKhRPqAJ8B1kh1XRZigXKT8Rqt2YjD+SWjWOYWupAAylysQaJwW+gAIXRQJW3OVpeaP4ajQqpYV11VlVR8t/mIWL1PE+ONJqZc/YFBrT6E9wPYBJzjCMurTj8kHr8yXfZzjNQaGN8",
                joinResponse.Certificate.RawBody
            );
            Assert.AreEqual("s4@dataans.com", joinResponse.User.Upn);
            Assert.AreEqual("S-1-5-32-544", joinResponse.MembershipChanges[0].LocalSID);
            Assert.AreEqual("S-1-12-1-161258645-1267993664-2068636298-1054913958", joinResponse.MembershipChanges[0].AddSIDs[0]);
            Assert.AreEqual("S-1-12-1-1201544774-1151677024-232476811-374148655", joinResponse.MembershipChanges[0].AddSIDs[1]);
            Assert.AreEqual("S-1-12-1-3935014535-1126855496-575362478-3178502726", joinResponse.MembershipChanges[0].AddSIDs[2]);
        }

        [TestMethod]
        public void TestJwtSignature()
        {
            byte[] key = {37, 150, 246, 91, 244, 248, 131, 90, 221, 132, 103, 95, 89, 45, 99, 167, 229, 126, 64, 98, 54, 106, 164, 199, 58, 196, 255, 251, 3, 198, 189, 231, 255, 37, 235, 58, 145, 190, 222, 58, 16, 117, 188, 67, 38, 97, 255, 119, 125, 2, 200, 124, 15, 119, 242, 48, 145, 86, 2, 101, 131, 60, 14, 60, 21, 112, 93, 234, 148, 196, 107, 51, 36, 135, 255, 65, 128, 43, 11, 99, 66, 248, 147, 27, 140, 222, 27, 43, 24, 50, 204, 253, 161, 77, 211, 105, 220, 142, 171, 131, 101, 251, 206, 53, 197, 163, 84, 80, 180, 87, 64, 235, 155, 72, 52, 247, 151, 25, 14, 36, 140, 203, 186, 104, 21, 74, 40, 178, 176, 36, 215, 244, 106, 196, 120, 225, 107, 197, 34, 170, 202, 227, 6, 163, 27, 140, 124, 76, 246, 174, 179, 100, 164, 197, 64, 254, 63, 157, 220, 17, 112, 188, 145, 55, 131, 106, 147, 43, 100, 170, 192, 36, 142, 40, 196, 141, 144, 23, 183, 29, 22, 130, 239, 56, 53, 34, 210, 186, 61, 142, 156, 72, 144, 67, 228, 247, 38, 78, 127, 51, 225, 11, 79, 62, 116, 43, 129, 69, 30, 176, 138, 189, 127, 135, 109, 105, 198, 200, 92, 254, 242, 33, 166, 251, 38, 81, 100, 252, 220, 49, 29, 13, 208, 125, 229, 143, 165, 127, 141, 89, 76, 215, 58, 114, 101, 79, 81, 107, 174, 8, 103, 238, 228, 207, 208, 142};
            byte[] data = Encoding.ASCII.GetBytes("eyJhbGciOiJIUzI1NiIsICJrZGZfdmVyIjoyLCAiY3R4IjoiYVlKdEQ1NHZPN0h0R0dQMkp1Q0ZScnBQTk1kYUQ4SnYifQ.eyJpc3MiOiJhYWQ6YnJva2VycGx1Z2luIiwgImdyYW50X3R5cGUiOiJyZWZyZXNoX3Rva2VuIiwgImF1ZCI6ImxvZ2luLm1pY3Jvc29mdG9ubGluZS5jb20iLCAicmVxdWVzdF9ub25jZSI6IkF3QUJBQUVBQUFBQ0FPel9CQUQwX3h0TnRoZkFwS2NvR1o2V1lQMVVpYnZfLXlOMmd1SS1vc0c3VXB2QUV3UmVGUGo3QndSTGJobFZLQnIzaEhWeElQUkhwMmVEWVl0SWJfYVdZM1hwd0g0Z0FBIiwgInNjb3BlIjoib3BlbmlkIGF6YSB1Z3MiLCAicmVmcmVzaF90b2tlbiI6IjAuQVhrQVNDUWxxYmVhc0VtN1hQTDVJOGhHY29jN3FqaHRvQmRJc25WNk1XbUkyVHVVQUZFLkFnQUJBQUVBQUFELS1ETEEzVk83UXJkZGdKZzdXZXZyQWdEc193UUE5UDlqSlZZb0IwaDk4R2ZvQ3Q3WlplcXU2UzV6WEktdDFTSjc5WXZLcUxBSEdtSzVGZ3VwMllMVWEzYnZWd0hTUngycnBWbnYybEozWVQ1MEF1eEpnVTIxYlc3MEtPREVCUWVKb3VNdkNPZFNiTS0yb2tRbWlJWnBBcjlaYlc5RGItZjZVZkFwRXJKdUZQMFh3SUxSSmo1c0xDUWluOTY5VDd2aTVLMXIzMzFxLXJhY2hSV1cta2owTWFSVnEyZmFPNWdKZjdQTGE2YS1WTEZLSFVzVjM5UklkamxEZkdIQl9TSWdrSHBaZnEyZTJqRTlsQjJuVlVpUWdYZ1ZiS2l6ZXZkbGdqU3lacW1kOG54RmFuZVdVQWRLR1U0VjUyNy0tMHg3c2hrQmN0clhaZnlTaFVrSTllSEZYWFI3cUZHbzdqQ2tXZ1MwRXlfQk5mdTNlTHV2cWhQR3RmcWpzT1dJUGlScmRzSDVMQWFIM0RtbHFyRHZGOURKQkRQMENOaU10LXZXR2dwc2FIdUZqSW9yMGp6eXF0REdHRVVJbFVvdjFSbmtDVW9sajFyREVPZGY4dlhrSkwzQ2x6dTJQaVJEMFhQY25mVWRwTmlCc295WHYzMFplbHI0WFY4ZXN0NXdKREQ4aDJETGJwSXJabEV1dUZDREJpZW9IM3IwUERQT0RnWVFzeHdNVjMxR1BIUVlvbmItbVlJNjhMVW9Ya0VObXF3d2pSN1c3aTBxVnVreHRfU3dSS3dNem1udWNadC1pek9aTWlROXpUTFhwZnd0cXpfMWU5UC1oX3NPS0d5clluZWMtZEIzY043QWl1RlRBbmxpUVZsZWNuZkh6LWNjaGdGazhFa0tidzlLRDdCLUZTaGhmRHVOV1U1MzhFdlVadVphUXJrbnk4VzlZaGNMY1NjMEdKYlJyZDAxLWZEbWV3UEs4R3k0MjNZNmZFT01KLUlSYlhlajlaMG5OMi0zTFoycWVPZWZjWm84UXFXVDdseFNlMnNqVzlNU25DM2RMUFh6c2hjSzc0eUdBY09Wa3VEYTlpWWFlTGxBM0MwTmdLcTcxRHBNNnVjIiwgImNsaWVudF9pZCI6IjM4YWEzYjg3LWEwNmQtNDgxNy1iMjc1LTdhMzE2OTg4ZDkzYiIsICJjZXJ0X3Rva2VuX3VzZSI6InVzZXJfY2VydCIsICJjc3JfdHlwZSI6Imh0dHA6XC9cL3NjaGVtYXMubWljcm9zb2Z0LmNvbVwvd2luZG93c1wvcGtpXC8yMDA5XC8wMVwvZW5yb2xsbWVudCNQS0NTMTAiLCAiY3NyIjoiTUlJQ2JEQ0NBVlFDQVFBd0p6RWxNQ01HQTFVRUF4NGNBSE1BTndCQUFHUUFZUUIwQUdFQVlRQnVBSE1BTGdCakFHOEFiVENDQVNJd0RRWUpLb1pJaHZjTkFRRUJCUUFEZ2dFUEFEQ0NBUW9DZ2dFQkFLVmNmR0xTNmN4UlJwZzVvU1BYK1NUMU1kYkJIdXNTWnRcL1VNRkxqbVdDaDIwa2tTOFZVWVJjdTdrcDJFdllISjlPMis1Q2FJb3drbUp2aVNiRkdwUm45OWxKVktEYWFSY1o0WDk0VlZZOStuZzRvelVQejA2amtBR0VTVlwvM2JJQ0hsMUZ1NjZRc0NZVWtVb0I0UktNYlh6TzVKV1lzemFHWjBweVdWSE82XC9CU3RVZnVqSWUxbG5EcTVHNzl6MWU0dzk2TVBISTJcL05oNnNGc1VncWJwNGRmTW9UMklyYmloa1h4cURaeXNiS09BN2lvU2hcL3EwY1JyM2ZwcUZKczlnMWpLaGVWT29YWXQ4Z1JCb1pLaFFOWEtTQnJYUVhzQTFqTmoySmN0M3VGUjlRVkhxb0g2c2F4dnErdTV2dUZCSHNNSDBVa05GbStrWm81V0xRc3VaMENBd0VBQWFBQU1BMEdDU3FHU0liM0RRRUJDd1VBQTRJQkFRQit6aVpsYmcrWUFQYWs1Q3J2Z3RhSCttYzNCSUJOalhMV2FMNlwvUnFXOEJVSnBIclE5bGE0S2VlR2FcLytCZHJmbmlOTzdrOE85XC9qc0VkWXB1QSt5XC9tVkphRWNoT1JucUpwYUhUZ0JZMFJDMW5EXC9EVHBEXC9xZXFxd1lVSXdoZ2RidmxQQzF6VWJXWlVaUFB1d1AwYUNoUXNycldGWFVXRWg0NW5zRGN4SFl4VTRxcUI0WmQzbTduUHdhZThibGJjckk2YWNOZGtZNmRtaTkzQ29FaFlZdjA4ejlMQmIxQ3V4TzFPUndCQ2lNcDNFWkZyMVE5Sm9ZZW1NTjZFMVBWTnpISDQxMTlcL0IxWjhcL1I0NTB3UW5LY1wvdTN3K3ZYd0xXMjY2elhpXC84RWwrc2JCdk5kQ2VxQkpWUk9ZdkdFTDBCaHNIT2ZUUEtkbndvNHo4WU1MUExHSSIsICJ3aW5fdmVyIjoiMTAuMC4yMjAwMC42NTMifQ");

            HMACSHA256 hmac = new HMACSHA256(key);
            byte[] hash = hmac.ComputeHash(data);

            foreach (var b in hash)
            {
                Console.Write("{0} ", b);
            }
            Console.WriteLine();

            var base64Hash = Convert.ToBase64String(hash);
            Console.WriteLine(base64Hash);
            Console.WriteLine("AtxpdY3mOqjsWGTCsDNBKbKDTjQk-jAP7HHZZerX57E");

            Assert.AreEqual("AtxpdY3mOqjsWGTCsDNBKbKDTjQk-jAP7HHZZerX57E", base64Hash);
        }

    }
}


--- File: tools/aadjoin/UnitTests/UnitTests.csproj ---
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net6.0</TargetFramework>

    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="16.9.4" />
    <PackageReference Include="MSTest.TestAdapter" Version="2.2.3" />
    <PackageReference Include="MSTest.TestFramework" Version="2.2.3" />
    <PackageReference Include="coverlet.collector" Version="3.0.2" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\AADJoin\AADJoin.csproj" />
  </ItemGroup>

</Project>


--- File: tools/dpapi-cli-client/.gitignore ---
Cargo.lock


--- File: tools/dpapi-cli-client/Cargo.toml ---
[package]
name = "dpapi-cli-client"
version = "0.0.0"
edition = "2021"
publish = false

[dependencies]
xflags = "0.3"
tokio = { version = "1.43", features = ["rt-multi-thread"] }
url = "2.5"
reqwest = { version = "0.12", default-features = false, features = ["json", "rustls-tls-native-roots"] }

sspi = { path = "../..", features = ["network_client"] }
uuid = { version = "1.15", features = ["std"] }
dpapi.path = "../../crates/dpapi"
dpapi-transport.path = "../../crates/dpapi-transport"
dpapi-native-transport.path = "../../crates/dpapi-native-transport"
serde = { version = "1", features = ["derive"] }

tracing-subscriber = { version = "0.3", features = ["std", "fmt", "local-time", "env-filter"] }


--- File: tools/dpapi-cli-client/README.md ---
# DPAPI cli client

This is a simple DPAPI client for using the DPAPI. It can encrypt secrets or decrypt them using DPAPI. Run `dpapi-cli-client --help` for more information and usage manual.

**Note**: do not use this tool in production. The only purpose of this tool is to test the DPAPI implementation correctness.

--- File: tools/dpapi-cli-client/src/cli.rs ---
use std::path::PathBuf;

xflags::xflags! {
    /// DPAPI cli client. This app is used to encrypt/decrypt secrets using the DPAPI.
    cmd dpapi {
        /// Target server hostname.
        /// For example, win-956cqossjtf.tbt.com.
        required --server server: String

        /// Websocket proxy address.
        /// For example, ws://devolutions-gateway.tbt.com:7171/jet/fwd/tcp
        optional --proxy-address proxy_address: String

        /// The username to decrypt/encrypt the DPAPI blob.
        /// The username can be specified in FQDN (DOMAIN\username) or UPN (username@domain) format.
        required --username username: String

        /// User's password.
        required --password password: String

        /// Client's computer name. This parameter is optional.
        /// If not provided, the current computer name will be used.
        optional --computer-name computer_name: String

        /// Encrypt secret.
        /// This command simulates the `NCryptProtectSecret` function. The encrypted secret (DPAPI blob) will be printed to stdout.
        cmd encrypt {
            /// User's SID.
            required --sid sid: String

            /// Secret to encrypt.
            /// This parameter is optional. If not provided, the app will try to read the secret from stdin.
            optional --secret secret: String
        }

        cmd decrypt {
            /// Path to file that contains DPAPI blob.
            /// This parameter is optional. If not provided, the app will try to read the DPAPI blob from stdin.
            optional --file file: PathBuf
        }
    }
}


--- File: tools/dpapi-cli-client/src/logging.rs ---
use std::fs::OpenOptions;

use tracing_subscriber::prelude::*;
use tracing_subscriber::EnvFilter;

const DPAPI_LOG_PATH_ENV: &str = "DPAPI_LOG_PATH";

pub fn init_logging() {
    let path = if let Ok(path) = std::env::var(DPAPI_LOG_PATH_ENV) {
        path
    } else {
        eprintln!(
            "[DPAPI] {} environment variable is not set. Logging is disabled.",
            DPAPI_LOG_PATH_ENV
        );
        return;
    };

    let file = match OpenOptions::new().create(true).append(true).open(&path) {
        Ok(f) => f,
        Err(e) => {
            eprintln!("[DPAPI] Couldn't open log file: {e}. File path: {}", path);
            return;
        }
    };

    let fmt_layer = tracing_subscriber::fmt::layer()
        .pretty()
        .with_thread_names(true)
        .with_writer(file);

    tracing_subscriber::registry()
        .with(fmt_layer)
        .with(EnvFilter::from_env("DPAPI_LOG_LEVEL"))
        .init();
}


--- File: tools/dpapi-cli-client/src/main.rs ---
#![doc = include_str!("../README.md")]
#![warn(missing_docs)]
#![warn(clippy::large_futures)]

mod cli;
mod logging;
mod network_client;
mod session_token;

use std::fs;
use std::io::{stdin, stdout, Error, ErrorKind, Read, Result, Write};

use dpapi::{CryptProtectSecretArgs, CryptUnprotectSecretArgs};
use dpapi_native_transport::NativeTransport;
use dpapi_transport::ProxyOptions;
use url::Url;

use crate::cli::{Decrypt, Dpapi, DpapiCmd, Encrypt};

async fn run(data: Dpapi) -> Result<()> {
    logging::init_logging();

    sspi::install_default_crypto_provider_if_necessary()
        .map_err(|_| Error::other("failed to initialize default crypto provider"))?;

    let Dpapi {
        server,
        proxy_address,
        username,
        password,
        computer_name,
        subcommand,
    } = data;

    let proxy = proxy_address
        .as_ref()
        .map(|proxy| {
            Result::Ok(ProxyOptions {
                proxy: Url::parse(proxy).map_err(|err| {
                    Error::new(
                        ErrorKind::InvalidData,
                        format!("invalid proxy URL ({:?}): {:?}", proxy, err),
                    )
                })?,
                get_session_token: Box::new(session_token::get_session_token),
            })
        })
        .transpose()?;
    let mut network_client = network_client::SyncNetworkClient;

    match subcommand {
        DpapiCmd::Encrypt(Encrypt { sid, secret }) => {
            let secret = if let Some(secret) = secret {
                secret.into_bytes()
            } else {
                stdin().bytes().collect::<Result<Vec<_>>>()?
            };

            let blob = Box::pin(dpapi::n_crypt_protect_secret::<NativeTransport>(
                CryptProtectSecretArgs {
                    data: secret.into(),
                    sid,
                    root_key_id: None,
                    server: &server,
                    proxy,
                    username: &username,
                    password: password.into(),
                    client_computer_name: computer_name,
                    network_client: &mut network_client,
                    kerberos_config: None,
                },
            ))
            .await
            .unwrap();

            stdout().write_all(&blob)?;
        }
        DpapiCmd::Decrypt(Decrypt { file }) => {
            let blob = if let Some(file) = file {
                fs::read(file)?
            } else {
                stdin().bytes().collect::<Result<Vec<_>>>()?
            };

            let secret = Box::pin(dpapi::n_crypt_unprotect_secret::<NativeTransport>(
                CryptUnprotectSecretArgs {
                    blob: &blob,
                    server: &server,
                    proxy,
                    username: &username,
                    password: password.into(),
                    client_computer_name: computer_name,
                    network_client: &mut network_client,
                    kerberos_config: None,
                },
            ))
            .await
            .unwrap();

            stdout().write_all(secret.as_ref())?;
        }
    }

    Ok(())
}

#[tokio::main]
async fn main() -> Result<()> {
    match Dpapi::from_env() {
        Ok(flags) => run(flags).await,
        Err(err) => err.exit(),
    }
}


--- File: tools/dpapi-cli-client/src/network_client.rs ---
use std::future::Future;
use std::pin::Pin;

use sspi::network_client::reqwest_network_client::ReqwestNetworkClient;
use sspi::network_client::{AsyncNetworkClient, NetworkClient};
use sspi::{Error, ErrorKind, NetworkRequest, Result};

#[derive(Debug)]
pub struct SyncNetworkClient;

impl AsyncNetworkClient for SyncNetworkClient {
    fn send<'a>(&'a mut self, request: &'a NetworkRequest) -> Pin<Box<dyn Future<Output = Result<Vec<u8>>> + 'a>> {
        let request = request.clone();
        Box::pin(async move {
            tokio::task::spawn_blocking(move || ReqwestNetworkClient.send(&request))
                .await
                .map_err(|err| Error::new(ErrorKind::InternalError, err))?
        })
    }
}


--- File: tools/dpapi-cli-client/src/session_token.rs ---
use std::env;
use std::future::Future;
use std::io::{Error, Result};
use std::pin::Pin;

use reqwest::Client;
use serde::{Deserialize, Serialize};
use url::Url;
use uuid::Uuid;

#[derive(Serialize)]
struct ForwardRequest<'dst> {
    pub validity_duration: Option<u64>,
    pub dst_hst: &'dst str,
    pub jet_ap: Option<&'static str>,
    pub jet_aid: Option<Uuid>,
    pub jet_rec: bool,
}

#[derive(Deserialize)]
struct TokenResponse {
    token: String,
}

/// Obtains the session token from the [tokengen server](https://github.com/Devolutions/devolutions-gateway/tree/master/tools/tokengen).
///
/// Parameters:
/// * `session_id` - connection session id.
/// * `destination` - target RPC server address.
pub fn get_session_token(session_id: Uuid, destination: Url) -> Pin<Box<dyn Future<Output = Result<String>>>> {
    let connection_url = Url::parse(&env::var("DG_CONNECTION_URL").unwrap()).unwrap();

    Box::pin(async move {
        let TokenResponse { token } = Client::new()
            .post(connection_url)
            .json(&ForwardRequest {
                validity_duration: Some(60 * 60),
                dst_hst: destination.as_str(),
                jet_ap: Some("unknown"),
                jet_aid: Some(session_id),
                jet_rec: false,
            })
            .send()
            .await
            .map_err(Error::other)?
            .error_for_status()
            .map_err(Error::other)?
            .json()
            .await
            .map_err(Error::other)?;

        Ok(token)
    })
}


--- File: tools/wasm-testcompile/.cargo/config.toml ---
[build]
target = "wasm32-unknown-unknown"

[target.'cfg(target_arch = "wasm32")']
rustflags = "--cfg getrandom_backend=\"wasm_js\""


--- File: tools/wasm-testcompile/.gitignore ---
Cargo.lock


--- File: tools/wasm-testcompile/Cargo.toml ---
[package]
name = "wasm-testcompile"
version = "0.0.0"
license = "MIT/Apache-2.0"
edition = "2021"
publish = false

[lib]
crate-type = ["cdylib"]

[dependencies]
sspi = { path = "../.." }

whoami = "0.5"
wasm-bindgen = "0.2"

# Support for WASM.
# Note that currently, most of our dependencies are still depending on getrandom 0.2, but some already switched to 0.3.
# We avoid updating the packages in the workspace Cargo.lock, but we are following the evolution of the ecosystem for
# wasm-testcompile.
getrandom02 = { package = "getrandom", version = "0.2", default-features = false, features = ["js"] }
getrandom03 = { package = "getrandom", version = "0.3", default-features = false, features = ["wasm_js"] }
uuid = { version = "1.13", default-features = false, features = ["rng-getrandom"] }


--- File: tools/wasm-testcompile/check.ps1 ---
#!/bin/env pwsh

$ErrorActionPreference = "Stop"

Push-Location -Path $PSScriptRoot

try {
	cargo build -v

	if ($LastExitCode -ne 0) {
		throw "Compilation failed"
	}

	$undefinedSymbols = wasm2wat ./target/wasm32-unknown-unknown/debug/wasm_testcompile.wasm | Select-String -Pattern 'import "env"'

	if (-Not [string]::IsNullOrEmpty($undefinedSymbols)) {
		throw "Found undefined symbols in generated wasm file: $undefinedSymbols"
	}

	Write-Host "Looks WASM-compatible to me!"
} finally {
	Pop-Location
}


--- File: tools/wasm-testcompile/rust-toolchain.toml ---
[toolchain]
targets = ["wasm32-unknown-unknown"]
profile = "minimal"

--- File: tools/wasm-testcompile/src/lib.rs ---
use sspi::ntlm::NtlmConfig;
use sspi::{credssp, AuthIdentity, Credentials, Username};
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn credssp_client() {
    let identity = AuthIdentity {
        username: Username::parse("NETBIOSDMN\\AccountName").unwrap(),
        password: String::from("secret").into(),
    };

    let mut cred_ssp_client = credssp::CredSspClient::new(
        Vec::new(),
        Credentials::AuthIdentity(identity),
        credssp::CredSspMode::WithCredentials,
        credssp::ClientMode::Negotiate(sspi::NegotiateConfig {
            protocol_config: Box::<NtlmConfig>::default(),
            package_list: None,
            client_computer_name: "win2017".into(),
        }),
        String::new(),
    )
    .unwrap();

    let next_ts_request = credssp::TsRequest::default();

    let result = cred_ssp_client.process(next_ts_request).unwrap();

    std::hint::black_box(result);
}


